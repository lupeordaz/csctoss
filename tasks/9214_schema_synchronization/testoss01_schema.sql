--
-- PostgreSQL database dump
--

SET statement_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = off;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET escape_string_warning = off;

--
-- Name: carrier; Type: SCHEMA; Schema: -; Owner: carrier_owner
--

CREATE SCHEMA carrier;


ALTER SCHEMA carrier OWNER TO carrier_owner;

--
-- Name: csctoss; Type: SCHEMA; Schema: -; Owner: csctoss_owner
--

CREATE SCHEMA csctoss;


ALTER SCHEMA csctoss OWNER TO csctoss_owner;

--
-- Name: invoice; Type: SCHEMA; Schema: -; Owner: invoice_owner
--

CREATE SCHEMA invoice;


ALTER SCHEMA invoice OWNER TO invoice_owner;

--
-- Name: oss_sync; Type: SCHEMA; Schema: -; Owner: alert_writer
--

CREATE SCHEMA oss_sync;


ALTER SCHEMA oss_sync OWNER TO alert_writer;

--
-- Name: rt3; Type: SCHEMA; Schema: -; Owner: rt_user
--

CREATE SCHEMA rt3;


ALTER SCHEMA rt3 OWNER TO rt_user;

--
-- Name: rtnew; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA rtnew;


ALTER SCHEMA rtnew OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- Name: plpgsql_call_handler(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plpgsql_call_handler() RETURNS language_handler
    LANGUAGE c
    AS '/home/postgres/PGSQL/lib/plpgsql.so', 'plpgsql_call_handler';


ALTER FUNCTION public.plpgsql_call_handler() OWNER TO postgres;

--
-- Name: plpgsql; Type: PROCEDURAL LANGUAGE; Schema: public; Owner: postgres
--

CREATE TRUSTED PROCEDURAL LANGUAGE plpgsql HANDLER plpgsql_call_handler;


ALTER PROCEDURAL LANGUAGE plpgsql OWNER TO postgres;

--
-- Name: plsh_handler(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plsh_handler() RETURNS language_handler
    LANGUAGE c
    AS '/usr/local/INSTALL/postgresql-8.0.14/lib/pgplsh/pgplsh.so', 'plsh_handler';


ALTER FUNCTION public.plsh_handler() OWNER TO postgres;

--
-- Name: plsh_validator(oid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plsh_validator(oid) RETURNS void
    LANGUAGE c
    AS '/usr/local/INSTALL/postgresql-8.0.14/lib/pgplsh/pgplsh.so', 'plsh_validator';


ALTER FUNCTION public.plsh_validator(oid) OWNER TO postgres;

--
-- Name: plsh; Type: PROCEDURAL LANGUAGE; Schema: public; Owner: postgres
--

CREATE PROCEDURAL LANGUAGE plsh HANDLER plsh_handler VALIDATOR plsh_validator;


ALTER PROCEDURAL LANGUAGE plsh OWNER TO postgres;

SET search_path = csctoss, pg_catalog;

--
-- Name: billing_entity_structure_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE billing_entity_structure_retval AS (
	billing_entity_id integer,
	parent_billing_entity_id integer,
	master_billing_entity_id integer,
	level integer,
	name text
);


ALTER TYPE csctoss.billing_entity_structure_retval OWNER TO csctoss_owner;

--
-- Name: cancellation_info_and_perform_bulk_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE cancellation_info_and_perform_bulk_retval AS (
	billing_entity text,
	line_id integer,
	start_date date,
	model_number text,
	carrier text,
	esn_hex text,
	sn text,
	sales_order text,
	username text,
	acctstarttime timestamp without time zone,
	result text,
	msg text
);


ALTER TYPE csctoss.cancellation_info_and_perform_bulk_retval OWNER TO csctoss_owner;

--
-- Name: cancellation_info_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE cancellation_info_retval AS (
	billing_entity text,
	line_id integer,
	start_date date,
	model_number text,
	carrier text,
	esn_hex text,
	sn text,
	sales_order text,
	username text,
	acctstarttime text
);


ALTER TYPE csctoss.cancellation_info_retval OWNER TO csctoss_owner;

--
-- Name: check_missing_mrcs_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE check_missing_mrcs_retval AS (
	item_id integer,
	internal_number text,
	external_id integer,
	allowance_kb integer
);


ALTER TYPE csctoss.check_missing_mrcs_retval OWNER TO csctoss_owner;

--
-- Name: equipment_line_unique_identifier_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE equipment_line_unique_identifier_retval AS (
	line_id integer,
	line_assignment_start date,
	line_assignment_end date,
	billing_entity text,
	equipment_id integer,
	carrier text,
	equipment_type text,
	model_number1 text,
	radius_username text,
	ip_pool text,
	static_ip_address character varying(253),
	radius_billing_entity text,
	serial_number text,
	esn_hex text,
	esn_dec text,
	min text,
	mdn text,
	mac_address text,
	esn_hex1 text,
	esn_hex2 text,
	esn_dec1 text,
	esn_dec2 text,
	min1 text,
	min2 text,
	mdn1 text,
	mdn2 text
);


ALTER TYPE csctoss.equipment_line_unique_identifier_retval OWNER TO csctoss_owner;

--
-- Name: fetch_mrac_by_date_range_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE fetch_mrac_by_date_range_retval AS (
	master_radacctid bigint,
	line_id integer,
	line_label text,
	calling_station_id text,
	username text,
	esn_or_serial text,
	billing_entity_id integer,
	start_time text,
	stop_time text,
	framed_ip_address text,
	bytes_in bigint,
	bytes_out bigint,
	time_connected text,
	line_assignment_type text,
	location_label_type text,
	location_label text,
	address text,
	start_timestamp timestamp without time zone,
	stop_timestamp timestamp without time zone
);


ALTER TYPE csctoss.fetch_mrac_by_date_range_retval OWNER TO csctoss_owner;

--
-- Name: fetch_mrpa_by_date_range_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE fetch_mrpa_by_date_range_retval AS (
	master_radpostauth_id bigint,
	username character varying(64),
	pass character varying,
	reply character varying(32),
	authdate text,
	source_hostname character varying(64),
	callingstationid text,
	line_id integer
);


ALTER TYPE csctoss.fetch_mrpa_by_date_range_retval OWNER TO csctoss_owner;

--
-- Name: get_list_static_ip; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE get_list_static_ip AS (
	line_id integer,
	start_date date,
	end_date date,
	calling_station_id text,
	customer_name text,
	group_name text,
	pool_group_name text,
	service_group_name text
);


ALTER TYPE csctoss.get_list_static_ip OWNER TO csctoss_owner;

--
-- Name: get_usage_for_location_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE get_usage_for_location_retval AS (
	master_radacctid bigint,
	line_id integer,
	line_label text,
	calling_station_id text,
	username text,
	esn_or_serial text,
	billing_entity_id integer,
	start_time text,
	stop_time text,
	framed_ip_address text,
	bytes_in bigint,
	bytes_out bigint,
	time_connected text,
	line_assignment_type text,
	location_label_type text,
	location_label text,
	address text,
	start_timestamp timestamp without time zone,
	stop_timestamp timestamp without time zone
);


ALTER TYPE csctoss.get_usage_for_location_retval OWNER TO csctoss_owner;

--
-- Name: hourly_report_record_type; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE hourly_report_record_type AS (
	hour character varying,
	ar_count_spr integer,
	ne_count_spr integer,
	ss_count_spr integer,
	this_space text,
	ar_count_usc integer,
	ne_count_usc integer,
	ss_count_usc integer,
	ar_count_vzw integer,
	ne_count_vzw integer,
	ss_count_vzw integer
);


ALTER TYPE csctoss.hourly_report_record_type OWNER TO csctoss_owner;

--
-- Name: insert_update_location_labels_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE insert_update_location_labels_retval AS (
	result_code boolean,
	error_message text
);


ALTER TYPE csctoss.insert_update_location_labels_retval OWNER TO csctoss_owner;

--
-- Name: line_usage_daily_detail_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE line_usage_daily_detail_retval AS (
	master_radacctid bigint,
	username text,
	start_time timestamp without time zone,
	stop_time timestamp without time zone,
	framed_ip_address text,
	bytes_in bigint,
	bytes_out bigint,
	time_connected text,
	calling_station_id text,
	esn_or_serial text,
	location_label text,
	line_label text
);


ALTER TYPE csctoss.line_usage_daily_detail_retval OWNER TO csctoss_owner;

--
-- Name: my_type1; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE my_type1 AS (
	equip_id integer,
	rad_username text,
	uim_value text
);


ALTER TYPE csctoss.my_type1 OWNER TO csctoss_owner;

--
-- Name: my_type2; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE my_type2 AS (
	upd_equip_id integer,
	correct_min text,
	exist_min text,
	related_equip_id integer,
	related_min text
);


ALTER TYPE csctoss.my_type2 OWNER TO csctoss_owner;

--
-- Name: ops_api_activate_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE ops_api_activate_retval AS (
	result_code boolean,
	error_message text
);


ALTER TYPE csctoss.ops_api_activate_retval OWNER TO csctoss_owner;

--
-- Name: ops_api_assign_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE ops_api_assign_retval AS (
	result_code boolean,
	error_message text
);


ALTER TYPE csctoss.ops_api_assign_retval OWNER TO csctoss_owner;

--
-- Name: ops_api_assign_retval_2; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE ops_api_assign_retval_2 AS (
	result_code boolean,
	error_message text
);


ALTER TYPE csctoss.ops_api_assign_retval_2 OWNER TO csctoss_owner;

--
-- Name: ops_api_expire_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE ops_api_expire_retval AS (
	result_code boolean,
	error_message text
);


ALTER TYPE csctoss.ops_api_expire_retval OWNER TO csctoss_owner;

--
-- Name: ops_api_line_equipment_unique_ids_info_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE ops_api_line_equipment_unique_ids_info_retval AS (
	line_id integer,
	active text,
	line_assignment_type text,
	line_assignment_start date,
	line_assignment_end date,
	carrier text,
	billing_entity_id integer,
	billing_entity text,
	equipment_id integer,
	equipment_type text,
	model_number1 text,
	esn_hex text,
	esn_dec text,
	mac_address text,
	serial_number text,
	mdn text,
	min text,
	esn_hex1 text,
	esn_hex2 text,
	esn_dec1 text,
	esn_dec2 text,
	min1 text,
	min2 text,
	mdn1 text,
	mdn2 text,
	equipment_status text,
	ip_pool text,
	static_ip_address text,
	number_of_active_charges integer,
	radius_username text
);


ALTER TYPE csctoss.ops_api_line_equipment_unique_ids_info_retval OWNER TO csctoss_owner;

--
-- Name: ops_api_line_plan_product_info_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE ops_api_line_plan_product_info_retval AS (
	customer_name text,
	line_id integer,
	location text,
	line_label text,
	username text,
	notes text,
	active_flag boolean,
	plan_type text,
	plan_comment text,
	product_code text,
	start_date date,
	end_date date,
	length_days integer,
	prepaid_unit text,
	prepaid_allowance integer,
	prepaid_balance integer,
	model_description text,
	model_number text,
	equipment_type text,
	embedded_model text,
	esn_hex text,
	esn_dec text,
	mdn text,
	min text,
	serial_number text,
	mac_address text,
	esn_hex1 text,
	esn_dec1 text,
	mdn1 text,
	min1 text,
	esn_hex2 text,
	esn_dec2 text,
	mdn2 text,
	min2 text
);


ALTER TYPE csctoss.ops_api_line_plan_product_info_retval OWNER TO csctoss_owner;

--
-- Name: ops_api_modify_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE ops_api_modify_retval AS (
	result_code boolean,
	error_message text
);


ALTER TYPE csctoss.ops_api_modify_retval OWNER TO csctoss_owner;

--
-- Name: ops_api_restore_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE ops_api_restore_retval AS (
	result_code boolean,
	error_message text
);


ALTER TYPE csctoss.ops_api_restore_retval OWNER TO csctoss_owner;

--
-- Name: ops_api_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE ops_api_retval AS (
	result_code boolean,
	error_message text
);


ALTER TYPE csctoss.ops_api_retval OWNER TO csctoss_owner;

--
-- Name: ops_api_retval_boolean; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE ops_api_retval_boolean AS (
	result_code boolean
);


ALTER TYPE csctoss.ops_api_retval_boolean OWNER TO csctoss_owner;

--
-- Name: ops_api_suspend_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE ops_api_suspend_retval AS (
	result_code boolean,
	error_message text
);


ALTER TYPE csctoss.ops_api_suspend_retval OWNER TO csctoss_owner;

--
-- Name: ops_api_unique_ids_by_static_ip_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE ops_api_unique_ids_by_static_ip_retval AS (
	equipment_id integer,
	esn_hex text,
	esn_dec text,
	serial_number text,
	mac_address text,
	mdn text,
	min text
);


ALTER TYPE csctoss.ops_api_unique_ids_by_static_ip_retval OWNER TO csctoss_owner;

--
-- Name: ops_api_unique_ids_radius_info_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE ops_api_unique_ids_radius_info_retval AS (
	equipment_id integer,
	line_id integer,
	line_assignment_start date,
	line_assignment_end date,
	esn_hex text,
	esn_dec text,
	mac_address text,
	serial_number text,
	mdn text,
	min text,
	radius_username character varying(64),
	radius_group character varying(64),
	radius_attribute character varying(64)
);


ALTER TYPE csctoss.ops_api_unique_ids_radius_info_retval OWNER TO csctoss_owner;

--
-- Name: ops_change_static_ip_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE ops_change_static_ip_retval AS (
	result_code boolean,
	error_message text
);


ALTER TYPE csctoss.ops_change_static_ip_retval OWNER TO csctoss_owner;

--
-- Name: oss_rma_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE oss_rma_retval AS (
	billing_entity_id integer,
	old_equip_id integer,
	old_model text,
	old_sn text,
	old_username text,
	new_equip_id integer,
	new_model text,
	new_sn text,
	rma_so_num text,
	line_id integer,
	carrier text,
	username text,
	groupname text,
	message text
);


ALTER TYPE csctoss.oss_rma_retval OWNER TO csctoss_owner;

--
-- Name: oss_sync_ip_activity_fetch_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE oss_sync_ip_activity_fetch_retval AS (
	acctstarttime timestamp without time zone,
	acctstoptime timestamp without time zone,
	framedipaddress inet,
	class integer
);


ALTER TYPE csctoss.oss_sync_ip_activity_fetch_retval OWNER TO csctoss_owner;

--
-- Name: oss_sync_line_mrac_fetch_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE oss_sync_line_mrac_fetch_retval AS (
	master_radacctid bigint,
	class integer,
	acctstarttime timestamp without time zone,
	acctstoptime timestamp without time zone,
	framedipaddress inet
);


ALTER TYPE csctoss.oss_sync_line_mrac_fetch_retval OWNER TO csctoss_owner;

--
-- Name: perform_bulk_cancellation_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE perform_bulk_cancellation_retval AS (
	equipment_id integer,
	identifier text,
	result text,
	msg text
);


ALTER TYPE csctoss.perform_bulk_cancellation_retval OWNER TO csctoss_owner;

--
-- Name: plan_acct_dates_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE plan_acct_dates_retval AS (
	parent_company text,
	parent_company_id integer,
	billing_entity text,
	billing_entity_id integer,
	line_id integer,
	line_label text,
	plan_id integer,
	plan_start_date date,
	plan_end_date date,
	length_days integer,
	plan_accounting_date date,
	product_id integer,
	product_desc text
);


ALTER TYPE csctoss.plan_acct_dates_retval OWNER TO csctoss_owner;

--
-- Name: rad_all_attr_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE rad_all_attr_retval AS (
	source text,
	groupname text,
	attribute text,
	op text,
	valu text,
	priority integer
);


ALTER TYPE csctoss.rad_all_attr_retval OWNER TO csctoss_owner;

--
-- Name: rad_attrval_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE rad_attrval_retval AS (
	source text,
	attr text,
	op text,
	valu text
);


ALTER TYPE csctoss.rad_attrval_retval OWNER TO csctoss_owner;

--
-- Name: rma_device_info_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE rma_device_info_retval AS (
	model text,
	esn text,
	serial text
);


ALTER TYPE csctoss.rma_device_info_retval OWNER TO csctoss_owner;

--
-- Name: sprint_roaming_by_date_range_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE sprint_roaming_by_date_range_retval AS (
	username text,
	billing_entity_id integer,
	billing_entity_name text,
	line_id integer,
	equipment_id integer,
	esn_hex text,
	serial_number text,
	smrac_line_id text,
	acctstarttime timestamp without time zone,
	_3gpp2foreignagentaddress text,
	framedipaddress text
);


ALTER TYPE csctoss.sprint_roaming_by_date_range_retval OWNER TO csctoss_owner;

--
-- Name: static_ip_desc_type; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE static_ip_desc_type AS (
	id integer,
	static_ip text,
	carrier_id integer,
	carrier_name text,
	groupname character varying(64),
	billing_entity_id integer,
	billing_name text
);


ALTER TYPE csctoss.static_ip_desc_type OWNER TO csctoss_owner;

--
-- Name: static_ip_line_beid_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE static_ip_line_beid_retval AS (
	billing_entity_id integer,
	line_id integer,
	username text,
	static_ip text,
	sip_line_id integer
);


ALTER TYPE csctoss.static_ip_line_beid_retval OWNER TO csctoss_owner;

--
-- Name: string_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE string_retval AS (
	string_value text
);


ALTER TYPE csctoss.string_retval OWNER TO csctoss_owner;

--
-- Name: unique_id_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE unique_id_retval AS (
	line_id integer,
	equipment_id integer,
	radius_username text,
	uim_value text,
	uis_value text,
	uie_value text,
	message text
);


ALTER TYPE csctoss.unique_id_retval OWNER TO csctoss_owner;

--
-- Name: universal_get_limit_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE universal_get_limit_retval AS (
	term_expires date,
	time_expires integer,
	this_month date,
	available_time integer,
	time_consumption integer,
	user_registration integer,
	contract_plan integer
);


ALTER TYPE csctoss.universal_get_limit_retval OWNER TO csctoss_owner;

--
-- Name: update_line_label_all_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE update_line_label_all_retval AS (
	line_id integer,
	current_line_label text,
	correct_line_label text
);


ALTER TYPE csctoss.update_line_label_all_retval OWNER TO csctoss_owner;

--
-- Name: update_unique_identifier_value_retval; Type: TYPE; Schema: csctoss; Owner: csctoss_owner
--

CREATE TYPE update_unique_identifier_value_retval AS (
	result_code boolean,
	error_message text
);


ALTER TYPE csctoss.update_unique_identifier_value_retval OWNER TO csctoss_owner;

SET search_path = public, pg_catalog;

--
-- Name: dblink_pkey_results; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE dblink_pkey_results AS (
	"position" integer,
	colname text
);


ALTER TYPE public.dblink_pkey_results OWNER TO postgres;

SET search_path = csctoss, pg_catalog;

--
-- Name: add_new_username(text, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION add_new_username(text, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_username 		TEXT:=$1 ;
  par_staff_id		INTEGER:=$2;
  var_carrier 		TEXT;

BEGIN  

  SET client_min_messages TO NOTICE;

  PERFORM public.set_change_log_staff_id (par_staff_id);

  --determine carrier
  IF substr(par_username,11,4) in ('@tsp','@cn0') THEN
    RAISE NOTICE 'SPRINT' ;
    var_carrier = 'SPRINT' ;
  ELSIF substr(par_username,11,4) = '@vzw' THEN
    RAISE NOTICE 'VERIZON' ;
    var_carrier = 'VERIZON' ;
  ELSIF substr(par_username,11,4) = '@usc' THEN
    RAISE NOTICE 'USCC' ;
    var_carrier = 'USCC' ;
  ELSE 
    RAISE EXCEPTION 'UNRECOGNIZED CARRIER from given username (%). Check username for errors.' , par_username ;
  END IF;

  --insert into username
  INSERT INTO username 
  (username,billing_entity_id)
  VALUES 
  (par_username,'2') ;

  IF var_carrier = 'SPRINT' THEN
    INSERT INTO radcheck
    (username,attribute,op) 
    VALUES
    (par_username,'ClearText-Password',':=');
  END IF;

  IF var_carrier = 'VERIZON' THEN
    IF par_username like '%@vzw.net' THEN
      INSERT INTO radcheck
      (username,attribute,op) 
      VALUES
      (par_username,'ClearText-Password',':=') ;      
    ELSIF par_username like '%@vzw3g.com' THEN
      INSERT INTO radcheck
      (username,attribute,op,value) 
      VALUES
      (par_username,'Auth-Type',':=','Accept') ;
    ELSE
      RAISE EXCEPTION 'Cannot determine carrier realm from username (%)' , par_username ;
    END IF;
  END IF;

  IF var_carrier = 'USCC' THEN
  
    INSERT INTO radcheck
    (username,attribute,op,value) 
    VALUES
    (par_username,'ClearText-Password',':=','CP@11U$ers') ;

  ELSIF var_carrier = 'VERIZON' THEN
  
    INSERT INTO usergroup 
    (username,groupname,priority)
    VALUES 
    (par_username,'SERVICE-inventory',5000) ;

  ELSIF var_carrier = 'SPRINT' THEN
  
    INSERT INTO usergroup 
    (username,groupname,priority)
    VALUES 
    (par_username,'SERVICE-vzwretail_inventory_cnione',5000) ;

  ELSE
    RAISE EXCEPTION '[add_new_username(text,integer)] Error: Failed at inserting into usergroup table' ;
  END IF;


RETURN true;

  
END ;

$_$;


ALTER FUNCTION csctoss.add_new_username(text, integer) OWNER TO csctoss_owner;

--
-- Name: add_new_username_bulk(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION add_new_username_bulk(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
  par_staff_id		integer:=$1 ;
  uname			text[];
  result		text;
  list			text[] := '{5776937581@tsp17.sprintpcs.com,
					5776937588@tsp17.sprintpcs.com,
					5776937592@tsp17.sprintpcs.com,
					5776937594@tsp17.sprintpcs.com,
					5776937596@tsp17.sprintpcs.com,
					5776937599@tsp17.sprintpcs.com,
					5776937601@tsp17.sprintpcs.com,
					5776937603@tsp17.sprintpcs.com,
					5776937608@tsp17.sprintpcs.com,
					5776937610@tsp17.sprintpcs.com,
					5776937612@tsp17.sprintpcs.com,
					5776937614@tsp17.sprintpcs.com,
					5776937616@tsp17.sprintpcs.com,
					5776937618@tsp17.sprintpcs.com,
					5776937620@tsp17.sprintpcs.com,
					5776937622@tsp17.sprintpcs.com,
					5776937624@tsp17.sprintpcs.com,
					5776937626@tsp17.sprintpcs.com,
					5776937628@tsp17.sprintpcs.com,
					5776937630@tsp17.sprintpcs.com,
					5776937633@tsp17.sprintpcs.com}' ;
BEGIN  

  SET client_min_messages TO NOTICE;

  PERFORM public.set_change_log_staff_id (par_staff_id);

  FOR i in array_lower(list,1)..array_upper(list,1) 
   LOOP
	select * into result from add_new_username(list[i],261) ;	
        RAISE NOTICE 'result = %' , result ;
   END LOOP;


RETURN true;

  
END ;

$_$;


ALTER FUNCTION csctoss.add_new_username_bulk(integer) OWNER TO csctoss_owner;

--
-- Name: address_insert_ui(text, text, text, text, text, text, text, text, text, integer, text, character, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION address_insert_ui(text, text, text, text, text, text, text, text, text, integer, text, character, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
	param_line1				ALIAS FOR $1  ;
	param_line2				ALIAS FOR $2  ;
	param_line3				ALIAS FOR $3  ;
	param_line4				ALIAS FOR $4  ;
	param_city				ALIAS FOR $5  ;
	param_state_code		ALIAS FOR $6  ;
	param_postal_code		ALIAS FOR $7  ;
	param_latitude			ALIAS FOR $8  ;
	param_longitude			ALIAS FOR $9  ;
	param_related_id		ALIAS FOR $10 ;
	param_address_type		ALIAS FOR $11 ;
	param_insert_type		CHAR(1) := UPPER($12) ;
    param_location_label	ALIAS FOR $13 ;

	v_retval				BOOLEAN ;
BEGIN
	-- Call regular version with no location label type (14th parameter)
	v_retval := address_insert_ui(param_line1, param_line2, param_line3, param_line4,
								  param_city, param_state_code, param_postal_code,
								  param_latitude, param_longitude, param_related_id,
								  param_address_type, param_insert_type,
								  param_location_label, NULL) ;

	RETURN v_retval ;
END ;
$_$;


ALTER FUNCTION csctoss.address_insert_ui(text, text, text, text, text, text, text, text, text, integer, text, character, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION address_insert_ui(text, text, text, text, text, text, text, text, text, integer, text, character, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION address_insert_ui(text, text, text, text, text, text, text, text, text, integer, text, character, text) IS 'Wrapper to call Address UI Insert function when no location label type is specified.';


--
-- Name: address_insert_ui(text, text, text, text, text, text, text, text, text, integer, text, character, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION address_insert_ui(text, text, text, text, text, text, text, text, text, integer, text, character, text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
	param_line1				ALIAS FOR $1  ;
	param_line2				ALIAS FOR $2  ;
	param_line3				ALIAS FOR $3  ;
	param_line4				ALIAS FOR $4  ;
	param_city				ALIAS FOR $5  ;
	param_state_code		ALIAS FOR $6  ;
	param_postal_code		ALIAS FOR $7  ;
	param_latitude			ALIAS FOR $8  ;
	param_longitude			ALIAS FOR $9  ;
	param_related_id		ALIAS FOR $10 ;
	param_address_type		ALIAS FOR $11 ;
	param_insert_type		CHAR(1) := UPPER($12) ;
    param_location_label	ALIAS FOR $13 ;
	param_loc_label_type	text := UPPER($14) ;

	v_counter				INTEGER ;
	v_address_id			INTEGER ;
BEGIN
	-- Check required fields
	IF param_line1 IS NULL
	OR param_city IS NULL
	OR param_state_code IS NULL
	OR param_postal_code IS NULL THEN
		RETURN FALSE ;
	END IF ;

	-- Default to insert type to billing entity
	IF param_insert_type IS NULL THEN
		param_insert_type := 'B' ;
	END IF ;
	param_insert_type := UPPER(param_insert_type) ;

	-- Check for valid insert type
	IF param_insert_type NOT IN ('B','C') THEN
		RETURN FALSE ;
	END IF ;

	-- Validate address type
	SELECT COUNT(*)
	INTO   v_counter
	FROM   address_type
	WHERE  address_type = UPPER(param_address_type) ;

	-- If location supplied, validate insert type and
	-- address type
	IF  param_location_label IS NOT NULL THEN
		IF param_insert_type <> 'B' THEN
			RETURN FALSE ;
		END IF ;
		IF param_loc_label_type IS NOT NULL
		AND param_address_type = 'PHYSICAL' THEN
			RETURN FALSE ;
		END IF ;
	END IF ;

	-- Check to see if address exists
	SELECT address_id
	INTO   v_address_id
	FROM   address
	WHERE  UPPER(line1) = UPPER(param_line1)
	AND    UPPER(COALESCE(line2,'X')) = UPPER(COALESCE(param_line2,'X'))
	AND    UPPER(COALESCE(line3,'X')) = UPPER(COALESCE(param_line3,'X'))
	AND    UPPER(COALESCE(line4,'X')) = UPPER(COALESCE(param_line4,'X'))
	AND    UPPER(city) = UPPER(param_city)
	AND    UPPER(state_code) = UPPER(param_state_code)
	AND    UPPER(postal_code) = UPPER(param_postal_code)
	AND    UPPER(COALESCE(latitude,'X')) = UPPER(COALESCE(param_latitude,'X'))
	AND    UPPER(COALESCE(longitude,'X')) = UPPER(COALESCE(param_longitude,'X')) ;

	IF NOT FOUND THEN
		-- Create address record
		SELECT NEXTVAL('csctoss.address_address_id_seq') INTO v_address_id ;

		INSERT INTO address (
			address_id,
			line1,
			line2,
			line3,
			line4,
			city,
			state_code,
			postal_code,
			latitude,
			longitude)
		VALUES (
			v_address_id,
			param_line1,
			param_line2,
			param_line3,
			param_line4,
			param_city,
			param_state_code,
			param_postal_code,
			param_latitude,
			param_longitude) ;
	END IF ;

	-- Create appropriate linkage record
	IF param_insert_type = 'B' THEN
		INSERT INTO billing_entity_address (
			billing_entity_id,
			address_type,
			address_id)
		VALUES (
			param_related_id,
			UPPER(param_address_type),
			v_address_id) ;

		-- If location label is supplied, create location records
		-- for the new company
		IF param_location_label IS NOT NULL THEN
			IF param_loc_label_type IS NULL THEN
				INSERT INTO billing_entity_location_label (
					billing_entity_address_id,
					location_label_type,
					location_label)
				VALUES (
					v_address_id,
					'INTERNAL ASSIGNED',
					param_location_label) ;

				INSERT INTO billing_entity_location_label (
					billing_entity_address_id,
					location_label_type,
					location_label)
				VALUES (
					v_address_id,
					'MONITORING',
					param_location_label) ;

				INSERT INTO billing_entity_location_label (
					billing_entity_address_id,
					location_label_type,
					location_label)
				VALUES (
					v_address_id,
					'USER DEFINED',
					param_location_label) ;
			ELSE
				-- Label type was specified, create only one
				param_loc_label_type := UPPER(param_loc_label_type) ;
				INSERT INTO billing_entity_location_label (
					billing_entity_address_id,
					location_label_type,
					location_label)
				VALUES (
					v_address_id,
					param_loc_label_type,
					param_location_label) ;
			END IF ;
		END IF ;
	ELSIF param_insert_type = 'C' THEN
		INSERT INTO contact_address (
			contact_id,
			address_type,
			address_id)
		VALUES (
			param_related_id,
			UPPER(param_address_type),
			v_address_id) ;
	ELSE
		-- Invalid insert type, should never get here
		RETURN FALSE ;
	END IF ;

	RETURN TRUE ;
END ;
$_$;


ALTER FUNCTION csctoss.address_insert_ui(text, text, text, text, text, text, text, text, text, integer, text, character, text, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION address_insert_ui(text, text, text, text, text, text, text, text, text, integer, text, character, text, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION address_insert_ui(text, text, text, text, text, text, text, text, text, integer, text, character, text, text) IS 'Handle address inserts from the UI.';


--
-- Name: address_update_ui(integer, text, text, text, text, text, text, text, text, text, integer, text, character, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION address_update_ui(integer, text, text, text, text, text, text, text, text, text, integer, text, character, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
	param_address_id		ALIAS FOR $1  ;
	param_line1				ALIAS FOR $2  ;
	param_line2				ALIAS FOR $3  ;
	param_line3				ALIAS FOR $4  ;
	param_line4				ALIAS FOR $5  ;
	param_city				ALIAS FOR $6  ;
	param_state_code		TEXT			:= UPPER($7)  ;
	param_postal_code		TEXT			:= UPPER($8)  ;
	param_latitude			ALIAS FOR $9  ;
	param_longitude			ALIAS FOR $10 ;
	param_related_id		ALIAS FOR $11 ;
	param_address_type		ALIAS FOR $12 ;
	param_update_type		CHAR(1)			:= UPPER($13) ;
	param_location_label	ALIAS FOR $14 ;
	arrea_line				INTEGER[]		:= ARRAY[0] ;
	arrea_equip				INTEGER[]		:= ARRAY[0] ;
	arrea_type				TEXT[]			:= ARRAY['X'] ;
	arrea_addr				INTEGER[]		:= ARRAY[0] ;
	arrea_cont				INTEGER[]		:= ARRAY[0] ;
    arrea_start				TEXT[]  := ARRAY['X'] ;
    arrea_end				TEXT[]  := ARRAY['X'] ;
    arrea_ship				TEXT[]          := ARRAY['X'] ;
	arrea_ship_addr			INTEGER[]		:= ARRAY[0] ;
    arrea_inst_date			TEXT[]          := ARRAY['X'] ;
	arrea_inst_by			TEXT[]			:= ARRAY['X'] ;
	arrea_created			TIMESTAMPTZ[]	:= ARRAY['1900-01-01'::timestamp] ;
	arrea_modified			TIMESTAMPTZ[]	:= ARRAY['1900-01-01'::timestamp] ;
	arrea_notes				TEXT[]			:= ARRAY['X'] ;
	arrea_beid				INTEGER[]		:= ARRAY[0] ;
	v_eqas_pos				INTEGER			:= 2 ;
	v_lieq_row				line_equipment%ROWTYPE ;
	curs_lieq				CURSOR (le_addr_key INTEGER) IS
								SELECT line_id, equipment_id, start_date::TEXT AS start_date,
									   end_date::TEXT AS end_date, billing_entity_address_id,
									   ship_date::TEXT AS ship_date,
									   install_date::TEXT AS install_date, installed_by
								FROM   line_equipment
								WHERE  billing_entity_address_id = le_addr_key ;
	arrlo_addr				INTEGER[]		:= ARRAY[0] ;
	arrlo_type				TEXT[]			:= ARRAY['X'] ;
	arrlo_lab				TEXT[]			:= ARRAY['X'] ;
	arrlo_notes				TEXT[]			:= ARRAY['X'] ;
	v_loc_pos				INTEGER			:= 2 ;
	v_loc_row				billing_entity_location_label%ROWTYPE ;
	curs_loc				CURSOR (loc_addr_key INTEGER) IS
								SELECT *
								FROM   billing_entity_location_label
								WHERE  billing_entity_address_id = loc_addr_key ;
	v_counter				INTEGER ;
	v_loc_counter			INTEGER ;
	v_address_id			INTEGER ;
	v_location_label		TEXT ;
	v_sql					TEXT ;
	v_temp_start			TEXT ;
	v_temp_end				TEXT ;
	v_temp_ship				TEXT ;
	v_temp_install			TEXT ;
BEGIN
	-- Check required fields
	IF  param_line1			IS NULL
	 OR param_city			IS NULL
	 OR param_state_code	IS NULL
	 OR param_postal_code	IS NULL
	 OR param_address_type  IS NULL
	 OR param_update_type	IS NULL
    THEN
		RETURN FALSE ;
	END IF ;

	-- Check for valid insert type
	IF param_update_type NOT IN ('B','C') THEN
		RETURN FALSE ;
	END IF ;

	-- Validate address type
	SELECT COUNT(*)
	INTO   v_counter
	FROM   address_type
	WHERE  address_type = param_address_type ;

	IF v_counter = 0 THEN
		RETURN FALSE ;
	END IF ;

	-- If location label is specified, validate
	-- insert and address types
	IF param_location_label IS NOT NULL THEN
		IF param_update_type <> 'B'
		OR param_address_type <> 'PHYSICAL' THEN
			RETURN FALSE ;
		END IF ;
	END IF ;

	-- Check to see if there actually any changes.
	-- If not, simply exit with a success message
	SELECT COUNT(*)
    INTO   v_counter
    FROM   address
    WHERE  UPPER(line1) = UPPER(param_line1)
    AND    UPPER(COALESCE(line2,'X')) = UPPER(COALESCE(param_line2,'X'))
    AND    UPPER(COALESCE(line3,'X')) = UPPER(COALESCE(param_line3,'X'))
    AND    UPPER(COALESCE(line4,'X')) = UPPER(COALESCE(param_line4,'X'))
    AND    UPPER(city) = UPPER(param_city)
    AND    UPPER(state_code) = UPPER(param_state_code)
    AND    UPPER(postal_code) = UPPER(param_postal_code)
    AND    UPPER(COALESCE(latitude,'X')) = UPPER(COALESCE(param_latitude,'X'))
    AND    UPPER(COALESCE(longitude,'X')) = UPPER(COALESCE(param_longitude,'X'))
	AND    address_id = param_address_id ;

	IF v_counter = 1 THEN
		-- Check for just the location label changing
		SELECT COUNT(*)
		INTO   v_counter
		FROM   billing_entity_location_label
		WHERE  billing_entity_address_id = param_address_id
		AND    location_label_type = 'INTERNAL ASSIGNED'
		AND    location_label = param_location_label ;

		IF v_counter = 1 THEN
			-- No changes, just return TRUE and exit
			RETURN TRUE ;
		ELSE
			SELECT COUNT(*)
			INTO   v_counter
			FROM   billing_entity_location_label
			WHERE  billing_entity_address_id = param_address_id
			AND    location_label_type = 'INTERNAL ASSIGNED' ;

			IF v_counter = 1 THEN
				-- Label exists, update it
				UPDATE billing_entity_location_label
				SET    location_label = param_location_label
				WHERE  billing_entity_address_id = param_address_id
				AND    location_label_type = 'INTERNAL ASSIGNED' ;

				-- Now exit
				RETURN TRUE ;
			ELSE
				-- Create label record
				INSERT INTO billing_entity_location_label(billing_entity_address_id, location_label_type, location_label, notes)
				VALUES (param_address_id, 'INTERNAL ASSIGNED', param_location_label, NULL) ;

				-- Now exit
				RETURN TRUE ;
			END IF ;
		END IF ;
	END IF ;

	-- Check to see how many times the address is referenced
	SELECT COUNT(*)
	INTO   v_counter
	FROM   billing_entity_address
	WHERE  address_id = param_address_id ;

	SELECT COUNT(*) + v_counter
	INTO   v_counter
	FROM   contact_address
	WHERE  address_id = param_address_id ;

	IF v_counter = 0 THEN
		-- This should not occur if the address ID is valid
		RETURN FALSE ;
	END IF ;

	-- KKT
	-- TO DO:  Need to check if it's really changed before doing anything else
	IF v_counter = 1 THEN
		-- Update address record
		UPDATE address
		SET    line1		= param_line1,
			   line2		= param_line2,
			   line3		= param_line3,
			   line4		= param_line4,
			   city			= param_city,
			   state_code	= param_state_code,
			   postal_code	= param_postal_code,
			   latitude		= param_latitude,
			   longitude	= param_longitude
		WHERE  address_id = param_address_id ;

		-- Update or create internal location label if needed
		IF  param_location_label IS NOT NULL
		AND param_update_type = 'B'
		AND param_address_type = 'PHYSICAL' THEN
			SELECT COUNT(*)
			INTO   v_counter
			FROM   billing_entity_location_label
			WHERE  billing_entity_address_id = param_address_id
			AND    location_label_type = 'INTERNAL ASSIGNED' ;

			IF v_counter = 0 THEN
				-- Create internal label
				INSERT INTO billing_entity_location_label (
					billing_entity_address_id,
					location_label_type,
					location_label)
				VALUES (
					param_address_id,
					'INTERNAL ASSIGNED',
					param_location_label) ;
			ELSE
				-- Update existing label
				UPDATE billing_entity_location_label
				SET    location_label = param_location_label
				WHERE  billing_entity_address_id = param_address_id
				AND    location_label_type = 'INTERNAL ASSIGNED' ;
			END IF ;
		END IF ;
	ELSE
		-- Create address record
		SELECT NEXTVAL('csctoss.address_address_id_seq') INTO v_address_id ;

		INSERT INTO address (
			address_id,
			line1,
			line2,
			line3,
			line4,
			city,
			state_code,
			postal_code,
			latitude,
			longitude)
		VALUES (
			v_address_id,
			param_line1,
			param_line2,
			param_line3,
			param_line4,
			param_city,
			param_state_code,
			param_postal_code,
			param_latitude,
			param_longitude) ;

		-- Update appropriate linkage record
		v_counter     := 0 ;
		v_loc_counter := 0 ;
		IF param_update_type = 'B' THEN
			IF param_address_type = 'PHYSICAL' THEN
				-- check for equipment assignments
				SELECT COUNT(*)
				INTO   v_counter
				FROM   line_equipment lieq
				JOIN   billing_entity_address bead ON (bead.address_id = lieq.billing_entity_address_id)
				WHERE  lieq.billing_entity_address_id = param_address_id
				AND    bead.address_type = 'PHYSICAL' ;

				SELECT COUNT(*)
				INTO   v_loc_counter
				FROM   billing_entity_location_label bell
				       , billing_entity_address bead
				WHERE  bell.billing_entity_address_id = bead.address_id
				AND    bell.billing_entity_address_id = param_address_id
				AND    bead.billing_entity_id = param_related_id ;

				IF v_counter > 0 THEN
					-- worst hack ever
					-- if there are equipment assignments: save them, then delete them
					OPEN curs_lieq(param_address_id) ;
					LOOP
						FETCH curs_lieq INTO v_lieq_row ;
						EXIT WHEN NOT FOUND ;

						-- Use text variables for dates as date arrays have problems
						-- with NULL values
						v_temp_start   := v_lieq_row.start_date ;
						IF v_lieq_row.end_date IS NULL THEN
							v_temp_end := 'X' ;
						ELSE
							v_temp_end := v_lieq_row.end_date ;
						END IF ;
						IF v_lieq_row.ship_date IS NULL THEN
							v_temp_ship := 'X' ;
						ELSE
							v_temp_ship    := v_lieq_row.ship_date ;
						END IF ;
						IF v_lieq_row.install_date IS NULL THEN
							v_temp_install := 'X' ;
						ELSE
							v_temp_install := v_lieq_row.install_date ;
						END IF ;
						arrea_line		:= array_append(arrea_line, v_lieq_row.line_id) ;
						arrea_equip		:= array_append(arrea_equip, v_lieq_row.equipment_id) ;
						-- Use new address ID
						arrea_addr		:= array_append(arrea_addr, v_address_id) ;
						arrea_start		:= array_append(arrea_start, v_temp_start) ;
						arrea_end		:= array_append(arrea_end, v_temp_end) ;
						arrea_ship		:= array_append(arrea_ship, v_temp_ship) ;
						arrea_inst_date	:= array_append(arrea_inst_date, v_temp_install) ;
						arrea_inst_by	:= array_append(arrea_inst_by, v_lieq_row.installed_by) ;
						v_eqas_pos		:= v_eqas_pos + 1 ;
					END LOOP ;
					CLOSE curs_lieq ;

					DELETE FROM line_equipment WHERE billing_entity_address_id = param_address_id ;
				END IF ;

				IF v_loc_counter > 0 THEN
					-- same bad hack for locations
					OPEN curs_loc(param_address_id) ;
					LOOP
						FETCH curs_loc INTO v_loc_row ;
						EXIT WHEN NOT FOUND ;
						-- Use new address ID
						arrlo_addr		:= array_append(arrlo_addr, v_address_id) ;
						arrlo_type		:= array_append(arrlo_type, v_loc_row.location_label_type) ;
						arrlo_lab		:= array_append(arrlo_lab, v_loc_row.location_label) ;
						arrlo_notes		:= array_append(arrlo_notes, v_loc_row.notes) ;
						v_loc_pos := v_loc_pos + 1 ;
					END LOOP ;
					CLOSE curs_loc ;

					DELETE FROM billing_entity_location_label WHERE billing_entity_address_id = param_address_id ;
				END IF ;
			END IF ;

			UPDATE billing_entity_address
			SET    address_id = v_address_id
			WHERE  billing_entity_id = param_related_id
			AND    address_type      = param_address_type ;
		
			IF param_address_type = 'PHYSICAL' THEN
				IF v_counter > 0 THEN
					-- Re-create equipment assignments
					FOR i IN 2..v_eqas_pos-1 LOOP

						v_sql := 'INSERT INTO line_equipment (line_id ,equipment_id ,start_date ,end_date' ;
						v_sql := v_sql || ' ,billing_entity_address_id ,ship_date ,install_date ,installed_by)' ;
						v_sql := v_sql || ' VALUES(' ;
						v_sql := v_sql || arrea_line[i]::TEXT ;
						v_sql := v_sql || ', ' || arrea_equip[i]::TEXT ;
						v_sql := v_sql || ', \'' || arrea_start[i]::TEXT || '\'::DATE' ;
						IF arrea_end[i] = 'X' THEN
							v_sql := v_sql || ', null' ;
						ELSE
							v_sql := v_sql || ', \'' || arrea_end[i]::TEXT || '\'::DATE' ;
						END IF ;
						IF v_address_id IS NULL THEN
							v_sql := v_sql || ', null' ;
						ELSE
							v_sql := v_sql || ', ' || v_address_id::TEXT ;
						END IF ;
						IF arrea_ship[i] = 'X' THEN
							v_sql := v_sql || ', null' ;
						ELSE
							v_sql := v_sql || ', \'' || arrea_ship[i]::TEXT || '\'::DATE' ;
						END IF ;
						IF arrea_inst_date[i] = 'X' THEN
							v_sql := v_sql || ', null' ;
						ELSE
							v_sql := v_sql || ', \'' || arrea_inst_date[i]::TEXT || '\'::DATE' ;
						END IF ;
						IF arrea_inst_by[i] IS NULL THEN
							v_sql := v_sql || ', null )' ;
						ELSE
							v_sql := v_sql || ', \'' || arrea_inst_by[i] || '\' )' ;
						END IF ;

						EXECUTE v_sql ;
					END LOOP ;
				END IF ;

				IF v_loc_counter > 0 THEN
					-- Re-create location labels
					FOR j in 2..v_loc_pos-1 LOOP
						-- If location label is passed in, use the new value
						-- for the internal location label
						IF  arrlo_type[j] = 'INTERNAL ASSIGNED'
						AND param_location_label IS NOT NULL
						THEN
							v_location_label := param_location_label ;
						ELSE
							v_location_label := arrlo_lab[j] ;
						END IF ;

						INSERT INTO billing_entity_location_label(billing_entity_address_id
							,location_label_type
							,location_label
							,notes)
						VALUES (v_address_id
							,arrlo_type[j]
							,v_location_label
							,arrlo_notes[j]) ;
					END LOOP ;
				END IF ;

				-- Update Lines to match the new Physical Address
				UPDATE csctoss.line
				SET    billing_entity_address_id = v_address_id
				WHERE  billing_entity_id = param_related_id
				AND    billing_entity_address_id = param_address_id ;

				-- If a location label was supplied make sure there are
				-- are locations.  If not, create them
				IF param_location_label IS NOT NULL THEN
					IF v_loc_counter = 0 THEN
						-- There are no locations for this address, create them
						INSERT INTO billing_entity_location_label (
							billing_entity_address_id,
							location_label_type,
							location_label)
						VALUES (
							v_address_id,
							'INTERNAL ASSIGNED',
							param_location_label) ;

						INSERT INTO billing_entity_location_label (
							billing_entity_address_id,
							location_label_type,
							location_label)
						VALUES (
							v_address_id,
							'MONITORING',
							param_location_label) ;

						INSERT INTO billing_entity_location_label (
							billing_entity_address_id,
							location_label_type,
							location_label)
						VALUES (
							v_address_id,
							'USER DEFINED',
							param_location_label) ;
					ELSE
						-- Make sure the internal address exists
						SELECT COUNT(*)
						INTO   v_counter
						FROM   billing_entity_location_label
						WHERE  billing_entity_address_id = v_address_id
						AND    location_label_type = 'INTERNAL ASSIGNED' ;

						IF v_counter = 0 THEN
							INSERT INTO billing_entity_location_label (
								billing_entity_address_id,
								location_label_type,
								location_label)
							VALUES (
								v_address_id,
								'INTERNAL ASSIGNED',
								param_location_label) ;
						END IF ;
					END IF ;
				END IF ;

			END IF ; -- Physical check
		ELSIF param_update_type = 'C' THEN
			UPDATE contact_address
			SET    address_id = v_address_id
			WHERE  contact_id   = param_related_id
			AND    address_type = param_address_type ;
		END IF ;
	END IF ;

	RETURN TRUE ;
END ;
$_$;


ALTER FUNCTION csctoss.address_update_ui(integer, text, text, text, text, text, text, text, text, text, integer, text, character, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION address_update_ui(integer, text, text, text, text, text, text, text, text, text, integer, text, character, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION address_update_ui(integer, text, text, text, text, text, text, text, text, text, integer, text, character, text) IS 'Handle address updates from the UI.';


--
-- Name: alert_admin_reset_new(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION alert_admin_reset_new(integer) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_top_n                        integer := $1 ;

  var_sql                          text ;
  var_ss_sql			   text ;
  var_model_number1                text ;
  var_serial_number                text ;
  var_esn_hex                      text ;
  var_return                       text ;
  var_signal_strength              text ;
  
  spr_sig_str                      integer;
  usc_sig_str                      integer;

  rec_usage                        record ;
  rec_kount                        record ;
  line_id_curr			   integer;
  hoststring                       text;
  var_sig_str                      record;


BEGIN

  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT 'SPRINT LINES Top 20 Admin-Reset' ;
  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT '' ;

  RETURN NEXT 'USERNAME                          S/N             MODEL              TERMCAUSE   COUNT SIGNAL STRENGTH' ;
  RETURN NEXT '--------------------------------- --------------- ------------------ ----------- ----- ----------------' ;

  -- dynamically build the sql statement
  var_sql := 'SELECT username
                    ,acctterminatecause
                    ,class::integer as line_id
                    ,count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''Admin-Reset''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%sprint%''
            GROUP BY 1,2,3
            ORDER BY 4 DESC
               LIMIT ' || par_top_n ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_usage IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(username              text
                                        ,acctterminatecause    text
                                        ,line_id               integer
                                        ,kount                 integer)
  LOOP

    -- for each row returned get the oss data and return the complete record
    SELECT emod.model_number1
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'SERIAL NUMBER'),'NULL')
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'ESN HEX'),'NULL')
      INTO var_model_number1
          ,var_serial_number
          ,var_esn_hex
      FROM csctoss.line_equipment lieq
      JOIN csctoss.equipment equp ON (lieq.equipment_id = equp.equipment_id)
      JOIN csctoss.equipment_model emod ON (equp.equipment_model_id = emod.equipment_model_id)
     WHERE lieq.line_id = rec_usage.line_id
       AND lieq.end_date IS NULL;
       
    line_id_curr := rec_usage.line_id;
   
    --build query to pull signal strength  

    /*
    var_ss_sql:='select min(rssi)
		from portal.unit_status
		where line_id ='||line_id_curr||'
		and date::date = current_date-1';

    --old jbilling server
    --hoststring:='hostaddr=10.17.70.21 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    --new jbilling server
    hoststring:='hostaddr=10.17.70.25 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    select * into var_sig_str from  public.dblink(hoststring,var_ss_sql)
    AS sig_str_row(ss varchar);

    RAISE NOTICE 'var_sig_str.ss: %', var_sig_str.ss;

    IF var_sig_str.ss IS NULL 
    THEN 
       var_sig_str.ss := 'Not Found';
    END IF;
    */

    SELECT cellsignal INTO var_signal_strength FROM csctoss.soup_cellsignal
    WHERE esn = var_esn_hex ORDER BY timestamp DESC LIMIT 1;

    RAISE NOTICE 'var_signal_strength: %', var_signal_strength;

    IF var_signal_strength IS NULL 
    THEN 
       var_signal_strength := 'Not Found';
    END IF;

    -- build and return the record
    var_return := RPAD(rec_usage.username,33,' ')           ||' '||
                  RPAD(var_serial_number,15,' ')            ||' '||
                  RPAD(var_model_number1,18,' ')            ||' '||
                  RPAD(rec_usage.acctterminatecause,11,' ') ||' '||
                  RPAD(rec_usage.kount::text,5,' ')         ||' '||
                  LPAD(var_signal_strength,10,' ');    
    
    RAISE NOTICE 'var_return: %', var_return; 
   
    RETURN NEXT var_return ;
  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- return a total count
  var_sql := 'SELECT count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''Admin-Reset''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%sprint%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'SPRINT TOTAL Admin-Reset: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  RETURN NEXT '' ;

  -- return a unique count
  var_sql := 'SELECT count(distinct(username))
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''Admin-Reset''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%sprint%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'SPRINT # UNIQUE DEVICES WITH Admin-Reset: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  RETURN NEXT '' ;

  -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC 

  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT 'USCC LINES Top 20 Admin-Reset' ;
  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT '' ;
  RETURN NEXT 'USERNAME                          S/N             MODEL              TERMCAUSE   COUNT SIGNAL STRENGTH ' ;
  RETURN NEXT '--------------------------------- --------------- ------------------ ----------- ----- ---------------' ;

  -- dynamically build the sql statement
  var_sql := 'SELECT username
                    ,acctterminatecause
                    ,class::integer as line_id
                    ,count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''Admin-Reset''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%uscc%''
            GROUP BY 1,2,3
            ORDER BY 4 DESC
               LIMIT ' || par_top_n ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_usage IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(username              text
                                        ,acctterminatecause    text
                                        ,line_id               integer
                                        ,kount                 integer)
  LOOP

    -- for each row returned get the oss data and return the complete record
    SELECT emod.model_number1
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'SERIAL NUMBER'),'NULL')
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'ESN HEX'),'NULL')
      INTO var_model_number1
          ,var_serial_number
          ,var_esn_hex
      FROM csctoss.line_equipment lieq
      JOIN csctoss.equipment equp ON (lieq.equipment_id = equp.equipment_id)
      JOIN csctoss.equipment_model emod ON (equp.equipment_model_id = emod.equipment_model_id)
     WHERE lieq.line_id = rec_usage.line_id
       AND lieq.end_date IS NULL;

    line_id_curr := rec_usage.line_id;

    --build query to pull signal strength

    /*
    var_ss_sql:='select min(rssi)
                from portal.unit_status
                where line_id ='||line_id_curr||'
                and date::date = current_date-1';


    --old jbilling server
    --hoststring:='hostaddr=10.17.70.21 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    --new jbilling server
    hoststring:='hostaddr=10.17.70.25 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    select * into var_sig_str from  public.dblink(hoststring,var_ss_sql)
    AS sig_str_row(ss varchar);

    RAISE NOTICE 'var_sig_str.ss: %', var_sig_str.ss;

    IF var_sig_str.ss IS NULL
    THEN
       var_sig_str.ss := 'Not Found';
    END IF;
    */

    SELECT cellsignal INTO var_signal_strength FROM csctoss.soup_cellsignal
    WHERE esn = var_esn_hex ORDER BY timestamp DESC LIMIT 1;

    RAISE NOTICE 'var_signal_strength: %', var_signal_strength;

    IF var_signal_strength IS NULL 
    THEN 
       var_signal_strength := 'Not Found';
    END IF;

    -- build and return the record
    var_return := RPAD(rec_usage.username,33,' ')           ||' '||
                  RPAD(var_serial_number,15,' ')            ||' '||
                  RPAD(var_model_number1,18,' ')            ||' '||
                  RPAD(rec_usage.acctterminatecause,11,' ') ||' '||
                  RPAD(rec_usage.kount::text,5,' ')         ||' '||
                  LPAD(var_signal_strength,10,' ');


    RETURN NEXT var_return ;

  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- return a total count
  var_sql := 'SELECT count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''Admin-Reset''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%uscc%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'USCC TOTAL Admin-Reset: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- return a unique count
  var_sql := 'SELECT count(distinct(username))
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''Admin-Reset''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%uscc%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'USCC # UNIQUE DEVICES WITH Admin-Reset: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  RETURN NEXT '' ;


  -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW 

  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT 'Verizon LINES Top 20 Admin-Reset' ;
  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT '' ;
  RETURN NEXT 'USERNAME                          S/N             MODEL              TERMCAUSE   COUNT SIGNAL STRENGTH ' ;
  RETURN NEXT '--------------------------------- --------------- ------------------ ----------- ----- ---------------' ;

  -- dynamically build the sql statement
  var_sql := 'SELECT username
                    ,acctterminatecause
                    ,class::integer as line_id
                    ,count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''Admin-Reset''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%vzw%''
            GROUP BY 1,2,3
            ORDER BY 4 DESC
               LIMIT '||par_top_n ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_usage IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(username              text
                                        ,acctterminatecause    text
                                        ,line_id               integer
                                        ,kount                 integer)
  LOOP

    -- for each row returned get the oss data and return the complete record
    SELECT emod.model_number1
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'SERIAL NUMBER'),'NULL')
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'ESN HEX'),'NULL')
      INTO var_model_number1
          ,var_serial_number
          ,var_esn_hex
      FROM csctoss.line_equipment lieq
      JOIN csctoss.equipment equp ON (lieq.equipment_id = equp.equipment_id)
      JOIN csctoss.equipment_model emod ON (equp.equipment_model_id = emod.equipment_model_id)
     WHERE lieq.line_id = rec_usage.line_id
       AND lieq.end_date IS NULL;

    line_id_curr := rec_usage.line_id;

    --build query to pull signal strength

    /*
    var_ss_sql:='select min(rssi)
                from portal.unit_status
                where line_id ='||line_id_curr||'
                and date::date = current_date-1';


    --old jbilling server
    --hoststring:='hostaddr=10.17.70.21 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    --new jbilling server
    hoststring:='hostaddr=10.17.70.25 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    select * into var_sig_str from  public.dblink(hoststring,var_ss_sql)
    AS sig_str_row(ss varchar);

    RAISE NOTICE 'var_sig_str.ss: %', var_sig_str.ss;

    IF var_sig_str.ss IS NULL
    THEN
       var_sig_str.ss := 'Not Found';
    END IF;
    */

    SELECT cellsignal INTO var_signal_strength FROM csctoss.soup_cellsignal
    WHERE esn = var_esn_hex ORDER BY timestamp DESC LIMIT 1;

    RAISE NOTICE 'var_signal_strength: %', var_signal_strength;

    IF var_signal_strength IS NULL 
    THEN 
       var_signal_strength := 'Not Found';
    END IF;

    -- build and return the record
    var_return := RPAD(rec_usage.username,33,' ')           ||' '||
                  RPAD(var_serial_number,15,' ')            ||' '||
                  RPAD(var_model_number1,18,' ')            ||' '||
                  RPAD(rec_usage.acctterminatecause,11,' ') ||' '||
                  RPAD(rec_usage.kount::text,5,' ')         ||' '||
                  LPAD(var_signal_strength,10,' ');


    RETURN NEXT var_return ;

  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- return a total count
  var_sql := 'SELECT count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''Admin-Reset''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%vzw%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'Verizon TOTAL Admin-Reset: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- return a unique count
  var_sql := 'SELECT count(distinct(username))
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''Admin-Reset''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%vzw%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'Verizon # UNIQUE DEVICES WITH Admin-Reset: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  RETURN NEXT '' ;


  RETURN ;
  
END ;
$_$;


ALTER FUNCTION csctoss.alert_admin_reset_new(integer) OWNER TO csctoss_owner;

--
-- Name: alert_nas_error_new(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION alert_nas_error_new(integer) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_top_n                        integer := $1 ;

  var_sql                          text ;
  var_model_number1                text ;
  var_serial_number                text ;
  var_esn_hex                      text ;
  var_return                       text ;
  var_signal_strength              text ;

  rec_usage                        record ;
  rec_kount                        record ;
  
  line_id_curr                     integer;
  hoststring                       text;
  var_sig_str                      record;
  var_ss_sql			   text;  

BEGIN

  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT 'SPRINT LINES Top 20 NAS-Error' ;
  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT '' ;

  RETURN NEXT 'USERNAME                          S/N             MODEL              TERMCAUSE  COUNT SIGNAL STRENGTH' ;
  RETURN NEXT '--------------------------------- --------------- ------------------ ---------- ----- ---------------' ;

  -- dynamically build the sql statement
  var_sql := 'SELECT username
                    ,acctterminatecause
                    ,class::integer as line_id
                    ,count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''NAS-Error''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%sprint%''
            GROUP BY 1,2,3
            ORDER BY 4 DESC
               LIMIT ' || par_top_n ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_usage IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(username              text
                                        ,acctterminatecause    text
                                        ,line_id               integer
                                        ,kount                 integer)
  LOOP

    -- for each row returned get the oss data and return the complete record
    SELECT emod.model_number1
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'SERIAL NUMBER'),'NULL')
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'ESN HEX'),'NULL')
      INTO var_model_number1
          ,var_serial_number
          ,var_esn_hex
      FROM csctoss.line_equipment lieq
      JOIN csctoss.equipment equp ON (lieq.equipment_id = equp.equipment_id)
      JOIN csctoss.equipment_model emod ON (equp.equipment_model_id = emod.equipment_model_id)
     WHERE lieq.line_id = rec_usage.line_id
       AND lieq.end_date IS NULL;

    line_id_curr := rec_usage.line_id;

    --build query to pull signal strength

    /*
    var_ss_sql:='select min(rssi)
                from portal.unit_status
                where line_id ='||line_id_curr||'
                and date::date = current_date-1';
    --old jbilling server
    --hoststring:='hostaddr=10.17.70.21 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    --new jbilling server
    hoststring:='hostaddr=10.17.70.25 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    select * into var_sig_str from  public.dblink(hoststring,var_ss_sql)
    AS sig_str_row(ss varchar);

    RAISE NOTICE 'var_sig_str.ss: %', var_sig_str.ss;

    IF var_sig_str.ss IS NULL
    THEN
       var_sig_str.ss := 'Not Found';
    END IF;
    */

    SELECT cellsignal INTO var_signal_strength FROM csctoss.soup_cellsignal
    WHERE esn = var_esn_hex ORDER BY timestamp DESC LIMIT 1;

    RAISE NOTICE 'var_signal_strength: %', var_signal_strength;

    IF var_signal_strength IS NULL 
    THEN 
       var_signal_strength := 'Not Found';
    END IF;

    -- build and return the record
    var_return := RPAD(rec_usage.username,33,' ')           ||' '||
                  RPAD(var_serial_number,15,' ')            ||' '||
                  RPAD(var_model_number1,18,' ')            ||' '||
                  RPAD(rec_usage.acctterminatecause,10,' ') ||' '||
                  RPAD(rec_usage.kount::text,5,' ')         ||' '||
		  LPAD(var_signal_strength,15,' ');

    RETURN NEXT var_return ;

  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- return a total count
  var_sql := 'SELECT count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''NAS-Error''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%sprint%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'SPRINT TOTAL NAS-Error: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  RETURN NEXT '' ;

  -- return a unique count
  var_sql := 'SELECT count(distinct(username))
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''NAS-Error''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%sprint%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'SPRINT # UNIQUE DEVICES WITH NAS-Error: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  RETURN NEXT '' ;

  -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC 

  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT 'USCC LINES Top 20 NAS-Error' ;
  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT '' ;
  RETURN NEXT 'USERNAME                          S/N             MODEL              TERMCAUSE  COUNT SIGNAL STRENGTH' ;
  RETURN NEXT '--------------------------------- --------------- ------------------ ---------- ----- ---------------' ;

  -- dynamically build the sql statement
  var_sql := 'SELECT username
                    ,acctterminatecause
                    ,class::integer as line_id
                    ,count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''NAS-Error''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%uscc%''
            GROUP BY 1,2,3
            ORDER BY 4 DESC
               LIMIT '||par_top_n ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_usage IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(username              text
                                        ,acctterminatecause    text
                                        ,line_id               integer
                                        ,kount                 integer)
  LOOP

    -- for each row returned get the oss data and return the complete record
    SELECT emod.model_number1
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'SERIAL NUMBER'),'NULL')
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'ESN HEX'),'NULL')
      INTO var_model_number1
          ,var_serial_number
          ,var_esn_hex
      FROM csctoss.line_equipment lieq
      JOIN csctoss.equipment equp ON (lieq.equipment_id = equp.equipment_id)
      JOIN csctoss.equipment_model emod ON (equp.equipment_model_id = emod.equipment_model_id)
     WHERE lieq.line_id = rec_usage.line_id
       AND lieq.end_date IS NULL;

    line_id_curr := rec_usage.line_id;

    --build query to pull signal strength

    /*
    var_ss_sql:='select min(rssi)
                from portal.unit_status
                where line_id ='||line_id_curr||'
                and date::date = current_date-1';

    --old jbilling server
    --hoststring:='hostaddr=10.17.70.21 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    --new jbilling server
    hoststring:='hostaddr=10.17.70.25 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    select * into var_sig_str from  public.dblink(hoststring,var_ss_sql)
    AS sig_str_row(ss varchar);

    RAISE NOTICE 'var_sig_str.ss: %', var_sig_str.ss;

    IF var_sig_str.ss IS NULL
    THEN
       var_sig_str.ss := 'Not Found';
    END IF;
    */

    SELECT cellsignal INTO var_signal_strength FROM csctoss.soup_cellsignal
    WHERE esn = var_esn_hex ORDER BY timestamp DESC LIMIT 1;

    RAISE NOTICE 'var_signal_strength: %', var_signal_strength;

    IF var_signal_strength IS NULL 
    THEN 
       var_signal_strength := 'Not Found';
    END IF;

    -- build and return the record
    var_return := RPAD(rec_usage.username,33,' ')           ||' '||
                  RPAD(var_serial_number,15,' ')            ||' '||
                  RPAD(var_model_number1,18,' ')            ||' '||
                  RPAD(rec_usage.acctterminatecause,10,' ') ||' '||
                  RPAD(rec_usage.kount::text,5,' ') 	    ||' '||
		  LPAD(var_signal_strength,15,' ');

    RETURN NEXT var_return ;

  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- return a total count
  var_sql := 'SELECT count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''NAS-Error''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%uscc%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'USCC TOTAL NAS-Error: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- return a unique count
  var_sql := 'SELECT count(distinct(username))
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''NAS-Error''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%uscc%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'USCC # UNIQUE DEVICES WITH NAS-Error: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  RETURN NEXT '' ;


  -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW 

  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT 'Verizon LINES Top 20 NAS-Error' ;
  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT '' ;
  RETURN NEXT 'USERNAME                          S/N             MODEL              TERMCAUSE  COUNT SIGNAL STRENGTH' ;
  RETURN NEXT '--------------------------------- --------------- ------------------ ---------- ----- ---------------' ;

  -- dynamically build the sql statement
  var_sql := 'SELECT username
                    ,acctterminatecause
                    ,class::integer as line_id
                    ,count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''NAS-Error''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%vzw%''
            GROUP BY 1,2,3
            ORDER BY 4 DESC
               LIMIT '||par_top_n ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_usage IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(username              text
                                        ,acctterminatecause    text
                                        ,line_id               integer
                                        ,kount                 integer)
  LOOP

    -- for each row returned get the oss data and return the complete record
    SELECT emod.model_number1
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'SERIAL NUMBER'),'NULL')
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'ESN HEX'),'NULL')
      INTO var_model_number1
          ,var_serial_number
          ,var_esn_hex
      FROM csctoss.line_equipment lieq
      JOIN csctoss.equipment equp ON (lieq.equipment_id = equp.equipment_id)
      JOIN csctoss.equipment_model emod ON (equp.equipment_model_id = emod.equipment_model_id)
     WHERE lieq.line_id = rec_usage.line_id
       AND lieq.end_date IS NULL;


    line_id_curr:=rec_usage.line_id;

    --build query to pull signal strength

    /*
    var_ss_sql:='select min(rssi)
                from portal.unit_status
                where line_id ='||line_id_curr||'
                and date::date = current_date-1';

    --old jbilling server
    --hoststring:='hostaddr=10.17.70.21 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    --new jbilling server
    hoststring:='hostaddr=10.17.70.25 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    select * into var_sig_str from  public.dblink(hoststring,var_ss_sql)
    AS sig_str_row(ss varchar);

    RAISE NOTICE 'var_sig_str.ss: %', var_sig_str.ss;

    IF var_sig_str.ss IS NULL
    THEN
       var_sig_str.ss := 'Not Found';
    END IF;
    */

    SELECT cellsignal INTO var_signal_strength FROM csctoss.soup_cellsignal
    WHERE esn = var_esn_hex ORDER BY timestamp DESC LIMIT 1;

    RAISE NOTICE 'var_signal_strength: %', var_signal_strength;

    IF var_signal_strength IS NULL 
    THEN 
       var_signal_strength := 'Not Found';
    END IF;

    -- build and return the record
    var_return := RPAD(rec_usage.username,33,' ')           ||' '||
                  RPAD(var_serial_number,15,' ')            ||' '||
                  RPAD(var_model_number1,18,' ')            ||' '||
                  RPAD(rec_usage.acctterminatecause,10,' ') ||' '||
                  RPAD(rec_usage.kount::text,5,' ') 	    ||' '||
		  LPAD(var_signal_strength,15,' ');

    RETURN NEXT var_return ;

  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- return a total count
  var_sql := 'SELECT count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''NAS-Error''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%vzw%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'Verizon TOTAL NAS-Error: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- return a unique count
  var_sql := 'SELECT count(distinct(username))
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctterminatecause = ''NAS-Error''
                 AND acctstarttime::date = current_date-1
                 AND username LIKE ''%vzw%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'Verizon # UNIQUE DEVICES WITH NAS-Error: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  RETURN NEXT '' ;


  RETURN ;
  
END ;
$_$;


ALTER FUNCTION csctoss.alert_nas_error_new(integer) OWNER TO csctoss_owner;

--
-- Name: alert_short_session_new(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION alert_short_session_new(integer) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_top_n                        integer := $1 ;

  var_sql                          text ;
  var_model_number1                text ;
  var_serial_number                text ;
  var_esn_hex                      text ;
  var_return                       text ;
  var_signal_strength              text ;

  rec_usage                        record ;
  rec_kount                        record ;

  line_id_curr                     integer;
  hoststring                       text;
  var_sig_str                      record;
  var_ss_sql			   text;

BEGIN

  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT 'SPRINT LINES Top 20 Short Session' ;
  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT '' ;

  RETURN NEXT 'USERNAME                          S/N             MODEL              # SHORT SESSIONS SIGNAL STRENGTH' ;
  RETURN NEXT '--------------------------------- --------------- ------------------ ---------------- ---------------' ;

  -- dynamically build the sql statement
  var_sql := 'SELECT username
                    ,class::integer as line_id
                    ,count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctsessiontime IS NOT NULL
                 AND acctsessiontime <= 1
                 AND acctstarttime::date = current_date-1
                 AND class IS NOT NULL
                 AND username LIKE ''%sprint%''
            GROUP BY 1,2
            ORDER BY 3 DESC
               LIMIT '||par_top_n ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_usage IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(username              text
                                        ,line_id               integer
                                        ,kount                 integer)
  LOOP

    -- for each row returned get the oss data and return the complete record
    SELECT emod.model_number1
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'SERIAL NUMBER'),'NULL')
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'ESN HEX'),'NULL')
      INTO var_model_number1
          ,var_serial_number
          ,var_esn_hex
      FROM csctoss.line_equipment lieq
      JOIN csctoss.equipment equp ON (lieq.equipment_id = equp.equipment_id)
      JOIN csctoss.equipment_model emod ON (equp.equipment_model_id = emod.equipment_model_id)
     WHERE lieq.line_id = rec_usage.line_id
       AND lieq.end_date IS NULL;

    IF var_model_number1 IS NULL THEN var_model_number1 := 'UNKNOWN' ; END IF ;
    IF var_serial_number IS NULL THEN var_serial_number := 'UNKNOWN' ; END IF ;

    line_id_curr := rec_usage.line_id;

    --build query to pull signal strength

    /*
    var_ss_sql:='select min(rssi)
                from portal.unit_status
                where line_id ='||line_id_curr||'
                and date::date = current_date-1';

    --old jbilling server
    --hoststring:='hostaddr=10.17.70.21 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    --new jbilling server
    hoststring:='hostaddr=10.17.70.25 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    select * into var_sig_str from  public.dblink(hoststring,var_ss_sql)
    AS sig_str_row(ss varchar);

    RAISE NOTICE 'var_sig_str.ss: %', var_sig_str.ss;

    IF var_sig_str.ss IS NULL
    THEN
       var_sig_str.ss := 'Not Found';
    END IF;
    */

    SELECT cellsignal INTO var_signal_strength FROM csctoss.soup_cellsignal
    WHERE esn = var_esn_hex ORDER BY timestamp DESC LIMIT 1;

    RAISE NOTICE 'var_signal_strength: %', var_signal_strength;

    IF var_signal_strength IS NULL 
    THEN 
       var_signal_strength := 'Not Found';
    END IF;

    -- build and return the record
    var_return := RPAD(rec_usage.username,33,' ')           ||' '||
                  RPAD(var_serial_number,15,' ')            ||' '||
                  RPAD(var_model_number1,18,' ')            ||' '||
                  RPAD(rec_usage.kount::text,16,' ') 	    ||' '||
		  LPAD(var_signal_strength,10,' ');

    RETURN NEXT var_return ;

  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- return a total count
  var_sql := 'SELECT count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctsessiontime IS NOT NULL
                 AND acctsessiontime <= 1
                 AND acctstarttime::date = current_date-1
                 AND class IS NOT NULL
                 AND username LIKE ''%sprint%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'SPRINT TOTAL Short Sessions: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  RETURN NEXT '' ;

    -- return a unique count
  var_sql := 'SELECT count(distinct(username))
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctsessiontime IS NOT NULL
                 AND acctsessiontime <= 1
                 AND acctstarttime::date = current_date-1
                 AND class IS NOT NULL
                 AND username LIKE ''%sprint%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'SPRINT # UNIQUE DEVICES WITH Short Session: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  RETURN NEXT '' ;

  -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC -- USCC 

  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT 'USCC LINES Top 20 Short Session' ;
  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT '' ;
  RETURN NEXT 'USERNAME                          S/N             MODEL              # SHORT SESSIONS SIGNAL STRENGTH' ;
  RETURN NEXT '--------------------------------- --------------- ------------------ ---------------- ---------------' ;

  -- dynamically build the sql statement
  var_sql := 'SELECT username
                    ,class::integer as line_id
                    ,count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctsessiontime IS NOT NULL
                 AND acctsessiontime <= 1
                 AND acctstarttime::date = current_date-1
                 AND class IS NOT NULL
                 AND username LIKE ''%uscc%''
            GROUP BY 1,2
            ORDER BY 3 DESC
               LIMIT '||par_top_n ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_usage IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(username              text
                                        ,line_id               integer
                                        ,kount                 integer)
  LOOP

    -- for each row returned get the oss data and return the complete record
    SELECT emod.model_number1
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'SERIAL NUMBER'),'NULL')
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'ESN HEX'),'NULL')
      INTO var_model_number1
          ,var_serial_number
          ,var_esn_hex
      FROM csctoss.line_equipment lieq
      JOIN csctoss.equipment equp ON (lieq.equipment_id = equp.equipment_id)
      JOIN csctoss.equipment_model emod ON (equp.equipment_model_id = emod.equipment_model_id)
     WHERE lieq.line_id = rec_usage.line_id
       AND lieq.end_date IS NULL;

    IF var_model_number1 IS NULL THEN var_model_number1 := 'UNKNOWN' ; END IF ;
    IF var_serial_number IS NULL THEN var_serial_number := 'UNKNOWN' ; END IF ;

     line_id_curr:=rec_usage.line_id;

    --build query to pull signal strength

    /*
    var_ss_sql:='select min(rssi)
                from portal.unit_status
                where line_id ='||line_id_curr||'
                and date::date = current_date-1';

    --old jbilling server
    --hoststring:='hostaddr=10.17.70.21 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    --new jbilling server
    hoststring:='hostaddr=10.17.70.25 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    select * into var_sig_str from  public.dblink(hoststring,var_ss_sql)
    AS sig_str_row(ss varchar);

    RAISE NOTICE 'var_sig_str.ss: %', var_sig_str.ss;

    IF var_sig_str.ss IS NULL
    THEN
       var_sig_str.ss := 'Not Found';
    END IF;
    */

    SELECT cellsignal INTO var_signal_strength FROM csctoss.soup_cellsignal
    WHERE esn = var_esn_hex ORDER BY timestamp DESC LIMIT 1;

    RAISE NOTICE 'var_signal_strength: %', var_signal_strength;

    IF var_signal_strength IS NULL 
    THEN 
       var_signal_strength := 'Not Found';
    END IF;

    -- build and return the record
    var_return := RPAD(rec_usage.username,33,' ')           ||' '||
                  RPAD(var_serial_number,15,' ')            ||' '||
                  RPAD(var_model_number1,18,' ')            ||' '||
                  RPAD(rec_usage.kount::text,16,' ') 	    ||' '||
		  LPAD(var_signal_strength,10,' ');

    RETURN NEXT var_return ;

  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- return a total count
  var_sql := 'SELECT count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctsessiontime IS NOT NULL
                 AND acctsessiontime <= 1
                 AND acctstarttime::date = current_date-1
                 AND class IS NOT NULL
                 AND username LIKE ''%uscc%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'USCC TOTAL Short Sessions: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- return a unique count
  var_sql := 'SELECT count(distinct(username))
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctsessiontime IS NOT NULL
                 AND acctsessiontime <= 1
                 AND acctstarttime::date = current_date-1
                 AND class IS NOT NULL
                 AND username LIKE ''%uscc%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'USCC # UNIQUE DEVICES WITH Short Session: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW -- VZW 

  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT 'Verizon LINES Top 20 Short Session' ;
  RETURN NEXT '-----------------------------------------' ;
  RETURN NEXT '' ;
  RETURN NEXT 'USERNAME                          S/N             MODEL              # SHORT SESSIONS SIGNAL STRENGTH' ;
  RETURN NEXT '--------------------------------- --------------- ------------------ ---------------- ---------------' ;

  -- dynamically build the sql statement
  var_sql := 'SELECT username
                    ,class::integer as line_id
                    ,count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctsessiontime IS NOT NULL
                 AND acctsessiontime <= 1
                 AND acctstarttime::date = current_date-1
                 AND class IS NOT NULL
                 AND username LIKE ''%vzw%''
            GROUP BY 1,2
            ORDER BY 3 DESC
               LIMIT '||par_top_n ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_usage IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(username              text
                                        ,line_id               integer
                                        ,kount                 integer)
  LOOP

    -- for each row returned get the oss data and return the complete record
    SELECT emod.model_number1
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'SERIAL NUMBER'),'NULL')
          ,COALESCE((select value from csctoss.unique_identifier where equipment_id = equp.equipment_id and unique_identifier_type = 'ESN HEX'),'NULL')
      INTO var_model_number1
          ,var_serial_number
          ,var_esn_hex
      FROM csctoss.line_equipment lieq
      JOIN csctoss.equipment equp ON (lieq.equipment_id = equp.equipment_id)
      JOIN csctoss.equipment_model emod ON (equp.equipment_model_id = emod.equipment_model_id)
     WHERE lieq.line_id = rec_usage.line_id
       AND lieq.end_date IS NULL;

    IF var_model_number1 IS NULL THEN var_model_number1 := 'UNKNOWN' ; END IF ;
    IF var_serial_number IS NULL THEN var_serial_number := 'UNKNOWN' ; END IF ;

     line_id_curr:=rec_usage.line_id;

    --build query to pull signal strength

    /*
    var_ss_sql:='select min(rssi)
                from portal.unit_status
                where line_id ='||line_id_curr||'
                and date::date = current_date-1';

    --old jbilling server
    --hoststring:='hostaddr=10.17.70.21 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    --new jbilling server
    hoststring:='hostaddr=10.17.70.25 port=5440 dbname=jbilling user=oss_writer password=wr1t3r';

    select * into var_sig_str from  public.dblink(hoststring,var_ss_sql)
    AS sig_str_row(ss varchar);

    RAISE NOTICE 'var_sig_str.ss: %', var_sig_str.ss;

    IF var_sig_str.ss IS NULL
    THEN
       var_sig_str.ss := 'Not Found';
    END IF;
    */

    SELECT cellsignal INTO var_signal_strength FROM csctoss.soup_cellsignal
    WHERE esn = var_esn_hex ORDER BY timestamp DESC LIMIT 1;

    RAISE NOTICE 'var_signal_strength: %', var_signal_strength;

    IF var_signal_strength IS NULL 
    THEN 
       var_signal_strength := 'Not Found';
    END IF;

    -- build and return the record
    var_return := RPAD(rec_usage.username,33,' ')           ||' '||
                  RPAD(var_serial_number,15,' ')            ||' '||
                  RPAD(var_model_number1,18,' ')            ||' '||
                  RPAD(rec_usage.kount::text,16,' ') 	    ||' '||
		  LPAD(var_signal_strength,10,' ');

    RETURN NEXT var_return ;

  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- return a total count
  var_sql := 'SELECT count(*)
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctsessiontime IS NOT NULL
                 AND acctsessiontime <= 1
                 AND acctstarttime::date = current_date-1
                 AND class IS NOT NULL
                 AND username LIKE ''%vzw%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'Verizon TOTAL Short Sessions: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;

  -- return a blank line
  RETURN NEXT '' ;

  -- return a unique count
  var_sql := 'SELECT count(distinct(username))
                FROM master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
               WHERE acctsessiontime IS NOT NULL
                 AND acctsessiontime <= 1
                 AND acctstarttime::date = current_date-1
                 AND class IS NOT NULL
                 AND username LIKE ''%vzw%''' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR rec_kount IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(kount integer)
  LOOP
    var_return := 'Verizon # UNIQUE DEVICES WITH Short Session: '||rec_kount.kount::text ;
    RETURN NEXT var_return ;
  END LOOP ;


  RETURN ;
  
END ;
$_$;


ALTER FUNCTION csctoss.alert_short_session_new(integer) OWNER TO csctoss_owner;

--
-- Name: alert_usage_daily(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION alert_usage_daily() RETURNS text
    LANGUAGE plpgsql
    AS $_$
 DECLARE
 
	--v_thresh			DECIMAL := $1;
	v_err_flag			BOOLEAN := FALSE;
	v_query				TEXT;
	v_refcursor			REFCURSOR;
	o_ret_val			TEXT :='';
	--vr_line_usage_day		csctoss.line_usage_day%ROWTYPE;
	vr_line_usage_day		RECORD;
	v_counter			INTEGER :=0;
	v_update_counter		INTEGER :=0;
	v_insert_counter		INTEGER :=0;
	o_ret_val_upd			TEXT :='';
	o_ret_val_ins			TEXT :='';
BEGIN


	--remove records that are older than ten days
	DELETE FROM csctoss.alerts
        WHERE alert_id = (SELECT alert_id
                          FROM csctoss.alerts
                          WHERE alert_type_id = 1
                          AND timestamp < (current_date - '10 day'::INTERVAL)
                          );


	
	SELECT COUNT(*)
	INTO v_counter 
	FROM (SELECT * 
			   FROM ( select line_id,usage_date,product.product_code,product.product_id,pt.base_mb,(pt.base_mb *.25) as qtr_of_base
					,((COALESCE(acctinputoctets_utc,0) + COALESCE(acctoutputoctets_utc,0))/1024::float/1024::float) as usage
					,now() 
				  from csctoss.line_usage_day JOIN plan using (line_id) JOIN product using (product_id) JOIN product_overage_threshold pt using (product_id)
				  where usage_date = current_date-'1 day'::interval
				  )ss 
			   WHERE  usage > qtr_of_base)AS sss;

		 
	IF v_counter = 0 THEN
		--RAISE EXCEPTION 'No lines found that have exceeded their threshold' ;
		RETURN 'No lines found that have exceeded their threshold' ;
		v_err_flag := TRUE ;
	END IF;

	IF NOT v_err_flag THEN
		v_query = 'SELECT * 
			   FROM ( select line_id,usage_date,product.product_code,product.product_id,pt.base_mb,(pt.base_mb *.25) as qtr_of_base
					,((COALESCE(acctinputoctets_utc,0) + COALESCE(acctoutputoctets_utc,0))/1024::float/1024::float) as usage
					,now() 
				  from csctoss.line_usage_day JOIN plan using (line_id) JOIN product using (product_id) JOIN product_overage_threshold pt using (product_id)
				  where usage_date = current_date- '|| ''''||'1 day'||''''||'::interval
				  )ss 
			   WHERE  usage > qtr_of_base';

		v_update_counter = 0;
		v_insert_counter = 0;

		OPEN v_refcursor FOR EXECUTE v_query;
		LOOP
			FETCH v_refcursor INTO vr_line_usage_day ; 
			IF NOT FOUND THEN
				EXIT;
			ELSE
				SELECT COUNT(*)
				INTO v_counter 
				FROM csctoss.alerts
				WHERE line_id = vr_line_usage_day.line_id
				--AND usage_date = vr_line_usage_day.usage_date
				AND alert_type_id = 1; --use 1 because this is the value for all usage daily alerts
				
				IF v_counter = 1
				THEN
				
					 UPDATE csctoss.alerts
					   SET  
						usage_mb=trunc(vr_line_usage_day.usage::decimal,2), 
						alert_message='Line '||vr_line_usage_day.line_id||' used '||trunc(vr_line_usage_day.usage::decimal,2)||' mb of data on '|| vr_line_usage_day.usage_date||'',
						"timestamp"= now()
					 WHERE line_id = vr_line_usage_day.line_id;
					 --o_ret_val := 'Function complete: Rows updated' ;
					 
					 v_update_counter= v_update_counter + 1;
				 ELSE 

					 IF v_counter = 0
					 THEN
						 INSERT INTO csctoss.alerts(
						  	    alert_id, line_id, usage_mb, alert_message, priority_id, alert_type_id, 
						 	    "timestamp",alert_active)
						 VALUES (DEFAULT, vr_line_usage_day.line_id,trunc(vr_line_usage_day.usage::decimal,2) , 'Line '||vr_line_usage_day.line_id||' used '||trunc(vr_line_usage_day.usage::decimal,2)||' mb of data on '|| vr_line_usage_day.usage_date||'', 2, 1,
							    now(),'TRUE');
						--o_ret_val := 'Function complete:Rows inserted' ;
						 v_insert_counter = v_insert_counter + 1;
					 END IF;
				END IF;
			   END IF;
		 END LOOP;
	END IF;
	
	IF v_update_counter = 0
	THEN
		o_ret_val_upd = '0 lines updated\n';
	ELSE 
		o_ret_val_upd = ''||v_update_counter||' lines updated\n';
	END IF;

	IF v_insert_counter = 0
	THEN
		o_ret_val_ins = ' 0 lines inserted';
	ELSE 
		o_ret_val_ins = ' '||v_insert_counter||' lines inserted';
	END IF;

	o_ret_val = o_ret_val_upd || o_ret_val_ins;
	
	RETURN o_ret_val ;
END ;$_$;


ALTER FUNCTION csctoss.alert_usage_daily() OWNER TO csctoss_owner;

--
-- Name: api_bent_owned(integer, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION api_bent_owned(integer, text) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_billing_entity_id integer := $1 ;
  par_identifier        text    := $2 ;

  var_equipment_id      integer ;
  var_line_id           integer ;

BEGIN

  -- check the username table for radius_username owned by billing_entity_id
  PERFORM * 
     FROM csctoss.username 
    WHERE billing_entity_id = par_billing_entity_id
      AND username = par_identifier ;

  IF FOUND THEN RETURN TRUE ; END IF ;

  -- check the line table for line_id, calling_station_id and radius_username
  PERFORM *
     FROM csctoss.line
    WHERE active_flag
      AND start_date <= current_date
      AND COALESCE(end_date,'2999-12-31') > current_date
      AND ( billing_entity_id = par_billing_entity_id
          OR EXISTS (select true 
                       from billing_entity 
                      where billing_entity_id = line.billing_entity_id 
                        and parent_billing_entity_id = par_billing_entity_id)
          )
      AND ( (line_id::text      = par_identifier)
          OR
            (calling_station_id = par_identifier)
          OR 
            (radius_username    = par_identifier) 
          ) ;

  IF FOUND THEN RETURN TRUE ; END IF ;

  -- check unique_identifier table, need to make association via line_equipment so grab equipment_id
  SELECT equipment_id
    INTO var_equipment_id
    FROM csctoss.unique_identifier
   WHERE value = par_identifier
   LIMIT 1 ;

  IF NOT FOUND THEN RETURN FALSE ; END IF ;

  -- get the active line for this equipment_id
  SELECT line_id
    INTO var_line_id
    FROM csctoss.line_equipment
   WHERE equipment_id = var_equipment_id
     AND current_date BETWEEN start_date AND COALESCE(end_date,'2999-12-31') ;

  IF NOT FOUND THEN RETURN FALSE ; END IF ;

  -- finally check the line table for given line_id and billing_entity_id association
  PERFORM *
     FROM csctoss.line
    WHERE line_id = var_line_id
      AND active_flag
      AND start_date <= current_date
      AND COALESCE(end_date,'2999-12-31') > current_date
      AND ( billing_entity_id = par_billing_entity_id
          OR EXISTS (select true 
                       from billing_entity 
                      where billing_entity_id = line.billing_entity_id
                        and parent_billing_entity_id = par_billing_entity_id)
          ) ;

  IF FOUND THEN RETURN TRUE ; END IF ;

  RETURN FALSE ;

END ;

$_$;


ALTER FUNCTION csctoss.api_bent_owned(integer, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION api_bent_owned(integer, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION api_bent_owned(integer, text) IS 'Takes in a billing entity id and some identifier, and determines if that identifier is owned by the billing entity.';


--
-- Name: api_get_ip_for_unique_id(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION api_get_ip_for_unique_id(text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_value                    text := $1 ;

  var_equipment_id             integer ;
  var_calling_station_id       text ;
  var_username                 text ;
  var_ip_address               text ;

BEGIN

  -- derive the username
  SELECT username
    INTO var_username
    FROM csctoss.username unam
    JOIN csctoss.unique_identifier uniq ON (SUBSTR(unam.username,1,10) = uniq.value)
   WHERE unique_identifier_type IN ('MDN','MIN')
     AND equipment_id = (SELECT equipment_id
                           FROM csctoss.unique_identifier
                          WHERE value = par_value
                          LIMIT 1) ;

  IF NOT FOUND THEN
    RETURN 'ERROR: Cannot derive Username from Unique Identifier %.', par_value ;
  END IF ;

  -- check radreply for Framed-IP-Address attribute
  SELECT value
    INTO var_ip_address
    FROM csctoss.radreply
   WHERE attribute = 'Framed-IP-Address'
     AND username = var_username ;

  IF FOUND THEN
    RETURN var_ip_address ;
  ELSE

    -- last resort grab ip address from master_radacct for active session - null stop
    SELECT *
      INTO var_ip_address
      FROM public.dblink((select * from csctoss.fetch_csctlog_conn())
                        ,'SELECT host(framedipaddress)::text
                            FROM csctlog.master_radacct
                           WHERE username = '||quote_literal(var_username)||'
                             AND acctstoptime IS NULL
                             AND acctstarttime > current_timestamp - INTERVAL ''25 hours''
                        ORDER BY 1 DESC
                           LIMIT 1')
        AS rec_type(framedipaddress text) ;

    IF FOUND THEN
      RETURN var_ip_address ;
    ELSE
      RETURN 'ERROR: No matching IP Address for unique identifier '||par_value||'.' ;
    END IF ;

  END IF ;

END ;

$_$;


ALTER FUNCTION csctoss.api_get_ip_for_unique_id(text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION api_get_ip_for_unique_id(text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION api_get_ip_for_unique_id(text) IS 'Takes in a unique identifier and returns the static ip (radreply) or assigned ip (master_radacct).';


--
-- Name: api_get_mac_for_unique_id(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION api_get_mac_for_unique_id(text) RETURNS text
    LANGUAGE sql STABLE
    AS $_$
  SELECT uniq1.value
    FROM csctoss.unique_identifier uniq1
    JOIN csctoss.unique_identifier uniq2 USING (equipment_id)
   WHERE uniq1.unique_identifier_type = 'MAC ADDRESS'
     AND uniq2.value = $1
   LIMIT 1 ;
$_$;


ALTER FUNCTION csctoss.api_get_mac_for_unique_id(text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION api_get_mac_for_unique_id(text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION api_get_mac_for_unique_id(text) IS 'Takes in a unique identifier and returns mac address if it exists.';


--
-- Name: api_get_radius_username_for_unique_id(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION api_get_radius_username_for_unique_id(text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_value                    text := $1 ;

  var_equipment_id             integer ;
  var_calling_station_id       text ;
  var_username                 text ;

BEGIN

  -- first check to see if value is MIN
  SELECT equipment_id
    INTO var_equipment_id
    FROM csctoss.unique_identifier
   WHERE unique_identifier_type = 'MIN'
     AND value = par_value ;

  IF FOUND THEN
    var_calling_station_id = par_value ;
  ELSE 

    -- derive the MIN
    SELECT value
      INTO var_calling_station_id
      FROM csctoss.unique_identifier
     WHERE unique_identifier_type IN ('MDN','MIN')
       AND equipment_id = (SELECT equipment_id
                             FROM csctoss.unique_identifier
                            WHERE value = par_value
                            LIMIT 1)
     LIMIT 1 ;

      IF NOT FOUND THEN
        RETURN 'ERROR: Unique Identifier '||par_value||' does not have a valid corresponding MDN or MIN.' ;
      END IF ;

  END IF ;

  -- lookup the username based on calling_station_id variable
  SELECT username
    INTO var_username
    FROM csctoss.username
   WHERE SUBSTR(username,1,10) = var_calling_station_id ;

  IF FOUND THEN
    RETURN var_username ;
  ELSE
    RETURN 'ERROR: Calling Station ID '||var_calling_station_id||' does not have a valid username record.' ;
  END IF ;

END ;

$_$;


ALTER FUNCTION csctoss.api_get_radius_username_for_unique_id(text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION api_get_radius_username_for_unique_id(text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION api_get_radius_username_for_unique_id(text) IS 'Takes in a unique identifier and returns the Radius username';


--
-- Name: api_get_sn_for_unique_id(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION api_get_sn_for_unique_id(text) RETURNS text
    LANGUAGE sql STABLE
    AS $_$
  SELECT uniq1.value
    FROM csctoss.unique_identifier uniq1
    JOIN csctoss.unique_identifier uniq2 USING (equipment_id)
   WHERE uniq1.unique_identifier_type = 'SERIAL NUMBER'
     AND uniq2.value = $1
   LIMIT 1 ;
$_$;


ALTER FUNCTION csctoss.api_get_sn_for_unique_id(text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION api_get_sn_for_unique_id(text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION api_get_sn_for_unique_id(text) IS 'Takes in a unique identifier and returns serial number if it exists.';


--
-- Name: api_radius_attribute_reset(integer, integer, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION api_radius_attribute_reset(integer, integer, integer) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE

  par_line_id             integer := $1 ;
  par_plan_id             integer := $2 ;
  par_product_id          integer := $3 ;
  v_retval                BOOLEAN ;

BEGIN
  v_retval := reinstate_usergroup(par_line_id, par_plan_id, par_product_id);

  v_retval := get_radreply_minutes(par_line_id);

  RETURN v_retval;
END;
$_$;


ALTER FUNCTION csctoss.api_radius_attribute_reset(integer, integer, integer) OWNER TO csctoss_owner;

--
-- Name: FUNCTION api_radius_attribute_reset(integer, integer, integer); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION api_radius_attribute_reset(integer, integer, integer) IS 'API function with simply calls reinstate_usergroup(...) and get_radreply_minutes(...) in succession.';


--
-- Name: api_translate_unique_id(text, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION api_translate_unique_id(text, text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_type_in                  text := $1 ;
  par_value_in                 text := $2 ;
  par_type_out                 text := $3 ;

  var_equipment_id             integer ;
  var_retval                   text ;

  --var_calling_station_id       text ;
  --var_username                 text ;

BEGIN

  -- validate in and out types
  IF NOT EXISTS (select true from csctoss.unique_identifier_type where unique_identifier_type = par_type_in) AND
     par_type_in NOT IN ('RADIUS USERNAME','CSID') THEN
    RETURN 'ERROR: Input Unique Identifier Type '||par_type_in||' does not exist.' ;
  ELSIF NOT EXISTS (select true from csctoss.unique_identifier_type where unique_identifier_type = par_type_out) AND
     par_type_out NOT IN ('RADIUS USERNAME','CSID') THEN
    RETURN 'ERROR: Output Unique Identifier Type '||par_type_out||' does not exist.' ;
  ELSIF par_type_in = par_type_out THEN
    RETURN 'ERROR: Input and Output Unique Identifier Type cannot be the same.' ;
  END IF ;

  -- determine the equipment id
  IF par_type_in = 'CSID' THEN
    SELECT lieq.equipment_id
      INTO var_equipment_id
      FROM csctoss.line
      JOIN csctoss.line_equipment lieq USING (line_id)
     WHERE line.active_flag
       AND line.calling_station_id = par_value_in
       AND lieq.end_date IS NULL
  ORDER BY lieq.start_date DESC
     LIMIT 1 ;
  ELSIF par_type_in = 'RADIUS USERNAME' THEN
    SELECT lieq.equipment_id
      INTO var_equipment_id
      FROM csctoss.line
      JOIN csctoss.line_equipment lieq USING (line_id)
     WHERE line.radius_username = par_value_in
       AND lieq.end_date IS NULL
  ORDER BY lieq.start_date DESC
     LIMIT 1 ;
  ELSE
    SELECT equipment_id
      INTO var_equipment_id
      FROM csctoss.unique_identifier
     WHERE unique_identifier_type = par_type_in
       AND value = par_value_in ;
  END IF ;

RAISE NOTICE 'EQID: %', var_equipment_id ;

  IF var_equipment_id IS NULL THEN
    RETURN 'ERROR: Unable to determine Equipment ID for '||par_type_in||' '||par_value_in||'.' ;
  END IF ;

  -- lookup the reqested value
  IF par_type_in = 'CSID' and par_type_out = 'RADIUS USERNAME' THEN

    SELECT line.radius_username
      INTO var_retval
      FROM csctoss.line
      JOIN csctoss.line_equipment lieq USING (line_id)
     WHERE line.active_flag
       AND lieq.equipment_id = var_equipment_id
       AND lieq.end_date IS NULL
       AND line.calling_station_id = par_value_in
  ORDER BY lieq.start_date DESC
     LIMIT 1 ; 

  ELSIF par_type_in = 'RADIUS USERNAME' AND par_type_out = 'CSID' THEN
    SELECT line.calling_station_id
      INTO var_retval
      FROM csctoss.line
      JOIN csctoss.line_equipment lieq USING (line_id)
     WHERE line.active_flag
       AND lieq.equipment_id = var_equipment_id
       AND lieq.end_date IS NULL
       AND line.radius_username = par_value_in
  ORDER BY lieq.start_date DESC
     LIMIT 1 ;

  ELSIF par_type_out IN ('CSID','RADIUS USERNAME') THEN
    SELECT CASE WHEN par_type_out = 'CSID' 
                THEN line.calling_station_id
                ELSE line.radius_username END
      INTO var_retval
      FROM csctoss.line
      JOIN csctoss.line_equipment lieq USING (line_id)
     WHERE line.active_flag
       AND lieq.equipment_id = var_equipment_id
       AND lieq.end_date IS NULL
  ORDER BY lieq.start_date DESC
     LIMIT 1 ;

  ELSIF par_type_in IN ('CSID','RADIUS USERNAME') THEN
    SELECT uniq.value
      INTO var_retval
      FROM csctoss.line
      JOIN csctoss.line_equipment lieq USING (line_id)
      JOIN csctoss.unique_identifier uniq USING (equipment_id)
     WHERE line.active_flag
       AND lieq.equipment_id = var_equipment_id
       AND lieq.end_date IS NULL
       AND uniq.unique_identifier_type = par_type_out
  ORDER BY lieq.start_date DESC
     LIMIT 1 ;

  ELSE -- everything available from unique identifier

    SELECT uniq2.value
      INTO var_retval
      FROM csctoss.unique_identifier uniq1
      JOIN csctoss.unique_identifier uniq2 USING (equipment_id)
     WHERE uniq1.unique_identifier_type = par_type_in
       AND uniq1.value = par_value_in
       AND uniq2.unique_identifier_type = par_type_out ;
  END IF ;

  -- if null then return error message otherwise return value
  IF var_retval IS NULL THEN
    var_retval := 'ERROR: '||par_type_in||' '||par_value_in||' does not have a corresponding '||par_type_out||'.' ;
  END IF ;

  RETURN var_retval ;

END ;

$_$;


ALTER FUNCTION csctoss.api_translate_unique_id(text, text, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION api_translate_unique_id(text, text, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION api_translate_unique_id(text, text, text) IS 'Accepts a unique id type and valuE and returns requested type and value.';


--
-- Name: attribute_type_updater(text, character); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION attribute_type_updater(text, character) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_primary_key	text    := $1 ;
  par_change_type	char(1) := $2 ;

  var_sql		text ;

  sysparm_rec		record ;
  attribute_type_rec	record ;

BEGIN

  -- dynamically build sql statement based on change type and execute
  IF par_change_type = 'D' THEN

    -- build string for deletes
    var_sql := 'DELETE FROM attribute_type WHERE attribute_type = '||quote_literal(par_primary_key)||'' ;
  
  ELSE

    SELECT INTO attribute_type_rec * FROM csctoss.attribute_type WHERE attribute_type = par_primary_key ;
    IF NOT FOUND THEN RETURN FALSE ; END IF ;

    -- build string for inserts
    IF par_change_type = 'I' THEN
      var_sql := 'INSERT INTO attribute_type
                            ( attribute_type
                            , description )
                 VALUES (' || quote_literal(attribute_type_rec.attribute_type) || ','
                           || quote_literal(attribute_type_rec.description) || ')' ;

    -- build string for updates
    ELSIF par_change_type = 'U' THEN
      var_sql := 'UPDATE attribute_type
                     SET description     = ' || quote_literal(attribute_type_rec.description) || '
                   WHERE attribute_type  = ' || quote_literal(attribute_type_rec.attribute_type) ;
    END IF ;

  END IF ;

  -- now loop through appropriate rows again in system_parameter table performing the actual statement
  FOR sysparm_rec IN SELECT hostname, ip_address
                       FROM csctoss.system_parameter
                      WHERE repl_flag = TRUE
  LOOP

    BEGIN

      PERFORM public.dblink_exec(sysparm_rec.hostname, var_sql, TRUE) ;

    EXCEPTION WHEN OTHERS THEN PERFORM csctoss.replication_failure_insert
                                             (sysparm_rec.hostname
                                             ,sysparm_rec.ip_address
                                             ,'attribute_type'
                                             ,par_primary_key
                                             ,par_change_type
                                             ,var_sql) ;
    END ;

  END LOOP ;

  RETURN TRUE ;

END;
$_$;


ALTER FUNCTION csctoss.attribute_type_updater(text, character) OWNER TO slony;

--
-- Name: FUNCTION attribute_type_updater(text, character); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION attribute_type_updater(text, character) IS 'Updater based function to replicate attribute_type data changes from change_log.';


--
-- Name: attribute_updater(text, character); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION attribute_updater(text, character) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_primary_key       text    := $1 ;
  par_change_type       char(1) := $2 ;

  var_sql               text ;

  sysparm_rec		record ;
  attribute_rec		record ;

BEGIN

  -- dynamically build sql statement based on change type and execute
  IF par_change_type = 'D' THEN

    -- build string for deletes
      var_sql := 'delete from attribute where attribute = '||quote_literal(par_primary_key)||'' ;

  ELSE

    SELECT INTO attribute_rec * FROM csctoss.attribute WHERE attribute = par_primary_key ;
    IF NOT FOUND THEN RETURN FALSE ; END IF ;

    -- build string for inserts
    IF par_change_type = 'I' THEN

      var_sql := 'INSERT INTO attribute
                            ( attribute
                            , attribute_type
                            , description )
                 VALUES (' || quote_literal(attribute_rec.attribute) || ','
                           || quote_literal(attribute_rec.attribute_type) || ','
                           || CASE WHEN attribute_rec.description IS NULL THEN quote_literal('') 
                                   ELSE quote_literal(attribute_rec.description) END || ')' ;

    -- build string for updates
    ELSIF par_change_type = 'U' THEN
      var_sql := 'UPDATE attribute
                     SET attribute_type = ' || quote_literal(attribute_rec.attribute_type) || '
                        ,description    = ' || CASE WHEN attribute_rec.description IS NULL THEN quote_literal('') 
                                                    ELSE quote_literal(attribute_rec.description) END || '
                   WHERE attribute      = ' || quote_literal(attribute_rec.attribute) ;


    END IF ;

  END IF ;

  -- now loop through appropriate rows again in system_parameter table performing the actual statement
  FOR sysparm_rec IN SELECT hostname, ip_address
                       FROM csctoss.system_parameter
                      WHERE repl_flag = TRUE
  LOOP

    BEGIN

      PERFORM public.dblink_exec(sysparm_rec.hostname, var_sql, TRUE) ;

    EXCEPTION WHEN OTHERS THEN PERFORM csctoss.replication_failure_insert
                                             (sysparm_rec.hostname
                                             ,sysparm_rec.ip_address
                                             ,'attribute'
                                             ,par_primary_key
                                             ,par_change_type
                                             ,var_sql) ;
    END ;

  END LOOP ;

  RETURN TRUE ;

END;
$_$;


ALTER FUNCTION csctoss.attribute_updater(text, character) OWNER TO slony;

--
-- Name: FUNCTION attribute_updater(text, character); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION attribute_updater(text, character) IS 'Updater based function to replicate attribute data changes from change_log.';


--
-- Name: billing_entity_structure(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION billing_entity_structure() RETURNS SETOF billing_entity_structure_retval
    LANGUAGE plpgsql
    AS $$
DECLARE
	v_children		REFCURSOR ;
	vr_parents		billing_entity_structure_retval ;
	vr_children		billing_entity_structure_retval ;
BEGIN
	FOR vr_parents IN
		SELECT billing_entity_id, parent_billing_entity_id,
		       billing_entity_id AS master_billing_entity_id, 1, name
		FROM   billing_entity
		WHERE  parent_billing_entity_id IS NULL
	LOOP
		-- return current record
		RETURN next vr_parents ;

		-- get decendents
		OPEN v_children FOR
		SELECT billing_entity_id,
		       vr_parents.billing_entity_id AS parent_billing_entity_id,
		       vr_parents.billing_entity_id AS master_billing_entity_id,
		       2 AS level,
		       name
		FROM   billing_entity
		WHERE  parent_billing_entity_id = vr_parents.billing_entity_id ;

		FOR vr_children IN
			SELECT * FROM expand_be_children (v_children, 2, vr_parents.billing_entity_id, vr_parents.billing_entity_id)
		LOOP
			RETURN NEXT vr_children ;
		END LOOP ;

		CLOSE v_children ;
	END LOOP ;

	RETURN ;
END ;
$$;


ALTER FUNCTION csctoss.billing_entity_structure() OWNER TO csctoss_owner;

--
-- Name: FUNCTION billing_entity_structure(); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION billing_entity_structure() IS 'Retrieve child companies for any given billing entity, recursively';


--
-- Name: billing_entity_timezone(integer, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION billing_entity_timezone(integer, text) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    par_parent_billing_entity_id        integer := $1 ;   
    par_preferred_timezone              text    := $2 ;
    var_preferred_timezone              text ;

BEGIN
    IF par_parent_billing_entity_id > 0 THEN
       SELECT preferred_timezone 
         INTO var_preferred_timezone
         FROM billing_entity
        WHERE billing_entity_id = par_parent_billing_entity_id ;
       IF var_preferred_timezone != par_preferred_timezone THEN
          RAISE EXCEPTION 'Child Billing Entity cannot have a different preferred_timezone than Parent Billing Entity.' ;
       END IF ;
    END IF ;
    
    RETURN TRUE ;
END;

$_$;


ALTER FUNCTION csctoss.billing_entity_timezone(integer, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION billing_entity_timezone(integer, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION billing_entity_timezone(integer, text) IS 'Check constraint function for parent_billing_entity_id and child_billing_entity having different preferred_timezone';


--
-- Name: bp_billing_charge_date_window(integer, date, date); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION bp_billing_charge_date_window(integer, date, date) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_bp_master_billing_plan_id int  := $1 ;
  par_bchg_start_date           date := $2 ;
  par_bchg_end_date             date := $3 ;

  var_bpln_start_date           date ;
  var_bpln_end_date             date ;

  var_message                   text ;

BEGIN

  -- check if parms are null
  IF par_bchg_start_date IS NULL AND par_bchg_end_date IS NULL THEN
    RETURN TRUE ;
  ELSIF par_bchg_start_date IS NOT NULL AND par_bchg_end_date IS NULL THEN
    RAISE EXCEPTION 'If Billing Charge start date entered, then Billing Charge end date required.' ;
  ELSIF par_bchg_start_date IS NULL AND par_bchg_end_date IS NOT NULL THEN
    RAISE EXCEPTION 'If Billing Charge end date entered, then Billing Charge start date required.' ;
  ELSIF par_bchg_start_date > par_bchg_end_date THEN
    RAISE EXCEPTION 'Start date must occur before end date.' ;
  END IF ;

  -- get data for comparisons
  SELECT INTO var_bpln_start_date, var_bpln_end_date
              start_date, end_date
         FROM csctoss.bp_master_billing_plan bpln
        WHERE bp_master_billing_plan_id = par_bp_master_billing_plan_id ;

  IF NOT FOUND THEN 
    RAISE EXCEPTION 'Master Billing Plan ID % appears invalid.', par_bp_master_billing_plan_id ;
  END IF ;

  -- first compare start_date to start date
  IF par_bchg_start_date < var_bpln_start_date THEN
    var_message := 'Billing Charge start date ('
                  ||par_bchg_start_date::text
                  ||') cannot occur before Master Billing Plan start date ('
                  ||var_bpln_start_date::text
                  ||')' ;

    RAISE EXCEPTION '%', var_message ;

  END IF ;
 
  -- next compare start_date to end date
  IF par_bchg_start_date > var_bpln_end_date THEN
    var_message := 'Billing Charge start date ('
                  ||par_bchg_start_date::text
                  ||') cannot occur after Master Billing Plan end date ('
                  ||var_bpln_end_date::text
                  ||')' ;

    RAISE EXCEPTION '%', var_message ;

  END IF ;

  -- next compare end date to start date
  IF par_bchg_end_date < var_bpln_start_date THEN
    var_message := 'Billing Charge end date ('
                  ||par_bchg_end_date::text
                  ||') cannot occur before Master Billing Plan start date ('
                  ||var_bpln_start_date::text
                  ||')' ;
    
    RAISE EXCEPTION '%', var_message ;

  END IF ;

  -- finally compare end date to end date
  IF par_bchg_end_date > var_bpln_end_date THEN
    var_message := 'Billing Charge end date ('
                  ||par_bchg_end_date::text
                  ||') cannot occur after Master Billing Plan end date ('
                  ||var_bpln_end_date::text
                  ||')' ;
    
    RAISE EXCEPTION '%', var_message ;

  END IF ;

  RETURN TRUE ;

END ;

$_$;


ALTER FUNCTION csctoss.bp_billing_charge_date_window(integer, date, date) OWNER TO csctoss_owner;

--
-- Name: FUNCTION bp_billing_charge_date_window(integer, date, date); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION bp_billing_charge_date_window(integer, date, date) IS 'Check constraint function guaranteeing that billing charge dates fall within associated master billing plan dates.';


--
-- Name: bp_billing_charge_discount_date_window(integer, date, date); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION bp_billing_charge_discount_date_window(integer, date, date) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_bp_billing_charge_id      int  := $1 ;
  par_discount_start_date       date := $2 ;
  par_discount_end_date         date := $3 ;

  rec_bp_info                   record ;

  var_message                   text ;

BEGIN

  -- check if parms are null
  IF par_discount_start_date IS NULL AND par_discount_end_date IS NULL THEN
    RETURN TRUE ;
  ELSIF par_discount_start_date IS NOT NULL AND par_discount_end_date IS NULL THEN
    RAISE EXCEPTION 'If Discount start date entered, then Discount end date required.' ;
  ELSIF par_discount_start_date IS NULL AND par_discount_end_date IS NOT NULL THEN
    RAISE EXCEPTION 'If Discount end date entered, then Discount start date required.' ;
  ELSIF par_discount_start_date > par_discount_end_date THEN
    RAISE EXCEPTION 'Start date cannot occur before end date' ;
  END IF ;

  -- get data for comparisons
  SELECT INTO rec_bp_info
              bchg.start_date AS bchg_start_date
             ,bchg.end_date AS bchg_end_date
             ,bpln.start_date AS bpln_start_date
             ,bpln.end_date AS bpln_end_date
         FROM csctoss.bp_billing_charge bchg
         JOIN csctoss.bp_master_billing_plan bpln using (bp_master_billing_plan_id)
        WHERE bchg.bp_billing_charge_id = par_bp_billing_charge_id ;

  IF NOT FOUND THEN RETURN TRUE ; END IF ;

  -- first compare start_date to start dates
  IF par_discount_start_date < COALESCE(rec_bp_info.bchg_start_date, rec_bp_info.bpln_start_date) THEN
    var_message := 'Discount start date '
                  ||par_discount_start_date::text
                  ||' cannot occur before Billing Charge start date ('
                  ||COALESCE(rec_bp_info.bchg_start_date::text,'NULL')
                  ||') or Master Billing Plan start date ('
                  ||rec_bp_info.bpln_start_date::text
                  ||')' ;

    RAISE EXCEPTION '%', var_message ;

  END IF ;
 
  -- next compare start_date to end dates
  IF par_discount_start_date > COALESCE(rec_bp_info.bchg_end_date, rec_bp_info.bpln_end_date) THEN
    var_message := 'Discount start date '
                  ||par_discount_start_date::text
                  ||' cannot occur after Billing Charge end date ('
                  ||COALESCE(rec_bp_info.bchg_end_date::text,'NULL')
                  ||') or Master Billing Plan end date ('
                  ||rec_bp_info.bpln_end_date::text
                  ||')' ;

    RAISE EXCEPTION '%', var_message ;

  END IF ;

  -- next compare end date to start dates
  IF par_discount_end_date < COALESCE(rec_bp_info.bchg_start_date, rec_bp_info.bpln_start_date) THEN
    var_message := 'Discount end date '
                  ||par_discount_end_date::text
                  ||' cannot occur before Billing Charge start date ('
                  ||COALESCE(rec_bp_info.bchg_start_date::text,'NULL')
                  ||') or Master Billing Plan start date ('
                  ||rec_bp_info.bpln_start_date::text
                  ||')' ;
    
    RAISE EXCEPTION '%', var_message ;

  END IF ;

  -- finally compare end date to end dates
  IF par_discount_end_date > COALESCE(rec_bp_info.bchg_end_date, rec_bp_info.bpln_end_date) THEN
    var_message := 'Discount end date '
                  ||par_discount_end_date::text
                  ||' cannot occur after Billing Charge end date ('
                  ||COALESCE(rec_bp_info.bchg_end_date::text,'NULL')
                  ||') or Master Billing Plan end date ('
                  ||rec_bp_info.bpln_end_date::text
                  ||')' ;
    
    RAISE EXCEPTION '%', var_message ;

  END IF ;

  RETURN TRUE ;

END ;

$_$;


ALTER FUNCTION csctoss.bp_billing_charge_discount_date_window(integer, date, date) OWNER TO csctoss_owner;

--
-- Name: FUNCTION bp_billing_charge_discount_date_window(integer, date, date); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION bp_billing_charge_discount_date_window(integer, date, date) IS 'Check constraint function guaranteeing that billing charge discount dates fall within associated billing charge dates, or if null, master billing plan dates.';


--
-- Name: bp_billing_charge_discount_insert(integer, text, double precision, text, integer, date, date); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION bp_billing_charge_discount_insert(integer, text, double precision, text, integer, date, date) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE

  par_bp_billing_charge_id	int	:= $1 ;
  par_bp_billing_discount_type	text	:= $2 ;
  par_discount_amount		float8	:= $3 ;
  par_description		text	:= $4 ;
  par_process_order		int	:= $5 ;
  par_start_date		date	:= $6 ;
  par_end_date			date	:= $7 ;

  var_columns			text ;
  var_values			text ;
  var_process_order		int ;
  var_max_process_order		int ;

  var_record			record ;

BEGIN

  -- check all parameters, might as well validate here before they fail on constraints
  IF $1 IS NULL OR $2 IS NULL OR $3 IS NULL OR $4 IS NULL THEN
    RAISE EXCEPTION 'Required parameter missing. Please consult usage for function bp_billing_charge_discount_insert().' ;
  END IF ;

  IF par_process_order IS NOT NULL AND par_process_order < 1 THEN
    RAISE EXCEPTION 'Process Order must be greater than 0. You entered %.', par_process_order ;
  END IF ;

  IF (par_start_date IS NOT NULL AND par_end_date IS NULL) OR (par_start_date IS NULL AND par_end_date IS NOT NULL) THEN
    RAISE EXCEPTION 'If Start Date or End Date passed then both dates are required.' ;
  END IF ;

  -- set the staff id if null
  IF public.get_change_log_staff_id() = -1 THEN
    PERFORM public.set_change_log_staff_id(1) ;
  END IF ;

  -- begin constructing the insert statement
  var_columns := 'INSERT INTO csctoss.bp_billing_charge_discount 
                             (bp_billing_charge_id,bp_billing_discount_type,discount_amount,description' ;

  var_values  := 'VALUES  ('||par_bp_billing_charge_id||','''
                            ||par_bp_billing_discount_type||''','
                            ||par_discount_amount||','''
                            ||par_description||''',' ;

  -- evaluate the start and end dates
  IF par_start_date IS NOT NULL THEN
    var_columns := var_columns||',start_date' ;
    var_values  := var_values||''''||par_start_date||''',' ;
  END IF ;

  IF par_end_date IS NOT NULL THEN
    var_columns := var_columns||',end_date' ;
    var_values  := var_values||''''||par_end_date||''',' ;
  END IF ;

  var_columns := var_columns||',process_order)' ;

  -- see if any records exist for this billing charge id
  PERFORM *
     FROM csctoss.bp_billing_charge_discount
    WHERE bp_billing_charge_id = par_bp_billing_charge_id ;

  -- if no rows exist then insert the record and exit
  IF NOT FOUND THEN
    IF par_process_order IS NOT NULL THEN
      var_process_order := par_process_order ;
    ELSE
      var_process_order := 1 ;
    END IF ;

    var_values := var_values||var_process_order||')' ;
    EXECUTE var_columns||' '||var_values ;

  ELSE

    -- rows exist for this billing charge, so get the max process order
    SELECT INTO var_max_process_order MAX(process_order)
           FROM csctoss.bp_billing_charge_discount
          WHERE bp_billing_charge_id = par_bp_billing_charge_id ;

    IF par_process_order IS NULL OR par_process_order > var_max_process_order THEN

      var_process_order := var_max_process_order + 1 ;
      var_values := var_values||var_process_order||')' ;

    ELSE

      -- one or more rows exist with higher process order than new record, so increment each by 1 and update
      FOR var_record IN SELECT bp_billing_charge_discount_id, process_order
                          FROM csctoss.bp_billing_charge_discount
                         WHERE bp_billing_charge_id = par_bp_billing_charge_id
                           AND process_order >= par_process_order LOOP

        UPDATE csctoss.bp_billing_charge_discount
           SET process_order = var_record.process_order + 1
         WHERE bp_billing_charge_discount_id = var_record.bp_billing_charge_discount_id ;

      END LOOP ;

      -- append sql to insert the new record with passed in process_order
      var_values  := var_values||par_process_order||')' ;

    END IF ;

    -- perform the insert
    EXECUTE var_columns||' '||var_values ;

  END IF ;

  RETURN TRUE ;

END ;

$_$;


ALTER FUNCTION csctoss.bp_billing_charge_discount_insert(integer, text, double precision, text, integer, date, date) OWNER TO csctoss_owner;

--
-- Name: FUNCTION bp_billing_charge_discount_insert(integer, text, double precision, text, integer, date, date); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION bp_billing_charge_discount_insert(integer, text, double precision, text, integer, date, date) IS 'Inserts record into bp_billing_charge_discount table. Checks parameter validity and appropriately orders process_order based on input.';


--
-- Name: bp_billing_charge_onetime_dates_required(text, date, date); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION bp_billing_charge_onetime_dates_required(text, date, date) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
BEGIN
  -- check to see if either date is null or if dates are not same
  IF $1 = 'ONE-TIME' THEN
    IF $2 IS NULL THEN
      RAISE EXCEPTION 'If the charge type is ONE-TIME, then a start date is required.' ;
    ELSIF $3 IS NULL THEN
      RAISE EXCEPTION 'If the charge type is ONE-TIME, then an end date is required.' ;
    ELSIF $2 <> $3 THEN
      RAISE EXCEPTION 'If the charge type is ONE-TIME, then the start date and end date must be the same.' ;
    END IF ;
  END IF ;

  RETURN TRUE ;
END ;

$_$;


ALTER FUNCTION csctoss.bp_billing_charge_onetime_dates_required(text, date, date) OWNER TO csctoss_owner;

--
-- Name: FUNCTION bp_billing_charge_onetime_dates_required(text, date, date); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION bp_billing_charge_onetime_dates_required(text, date, date) IS 'Check constraint function for ONE-TIME charges requiring start_date, end_date, and that dates are equal.';


--
-- Name: bp_billing_charge_pre_update_delete(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION bp_billing_charge_pre_update_delete() RETURNS "trigger"
    LANGUAGE plpgsql
    AS $$
DECLARE
  var_failure   boolean := FALSE ;
BEGIN

  -- if updating and bp_billing_charge_type unchanged then exit
  IF TG_OP = 'UPDATE' THEN
    IF NEW.bp_billing_charge_type = OLD.bp_billing_charge_type THEN
      RETURN NEW ;
    END IF ;
  END IF ;

  -- search for rows with each type for associated table
  IF OLD.bp_billing_charge_type = 'ONE-TIME' THEN
    SELECT INTO var_failure COUNT(*) > 0
           FROM csctoss.bp_billing_charge_onetime
          WHERE bp_billing_charge_id = OLD.bp_billing_charge_id ;

  ELSIF OLD.bp_billing_charge_type = 'STATIC' THEN
    SELECT INTO var_failure COUNT(*) > 0
           FROM csctoss.bp_billing_charge_static
          WHERE bp_billing_charge_id = OLD.bp_billing_charge_id ;

  ELSIF OLD.bp_billing_charge_type = 'USAGE' THEN
    SELECT INTO var_failure COUNT(*) > 0
           FROM csctoss.bp_billing_charge_usage
          WHERE bp_billing_charge_id = OLD.bp_billing_charge_id ;

  END IF ;

  -- if violation, raise exception and message, otherwise return appropriately
  IF var_failure THEN
    RAISE EXCEPTION 'Cannot % Charge Type for bp_billing_charge_id %. Child records exist.', TG_OP, OLD.bp_billing_charge_id ;
  ELSIF TG_OP = 'DELETE' THEN
    RETURN OLD ;
  ELSE
    RETURN NEW ;
  END IF ;

END;
$$;


ALTER FUNCTION csctoss.bp_billing_charge_pre_update_delete() OWNER TO csctoss_owner;

--
-- Name: FUNCTION bp_billing_charge_pre_update_delete(); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION bp_billing_charge_pre_update_delete() IS 'Trigger function to prevent update or delete of a billing charge type if child records exist for that type.';


--
-- Name: bp_billing_charge_usage_pre_insert_update(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION bp_billing_charge_usage_pre_insert_update() RETURNS "trigger"
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN

  -- if per_session true, verify cost_per_unit exists and greater than zero
  IF NEW.per_session = TRUE AND (NEW.cost_per_unit IS NULL OR NEW.cost_per_unit <= 0) THEN
    RAISE EXCEPTION 'If per session true, then cost per unit must be greater than zero.' ;
  END IF ;

  -- if per_session true, verify that associated records do not exist in bp_usage_allotment
  IF NEW.per_session = TRUE THEN
    PERFORM *
       FROM csctoss.bp_usage_allotment
      WHERE bp_billing_charge_usage_id = NEW.bp_billing_charge_usage_id
      LIMIT 1 ;
    IF FOUND THEN
      RAISE EXCEPTION 'Associated records exist in bp_usage_allotment table. Cannot update per_session flag to TRUE.' ;
    END IF ;
  END IF ;

  RETURN NEW ;

END ;
$$;


ALTER FUNCTION csctoss.bp_billing_charge_usage_pre_insert_update() OWNER TO csctoss_owner;

--
-- Name: FUNCTION bp_billing_charge_usage_pre_insert_update(); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION bp_billing_charge_usage_pre_insert_update() IS 'Constraint trigger function preventing update of per session flag to TRUE if associated records exist in bp_usage_allotment table.';


--
-- Name: bp_billing_equipment_assignment_pre_insert(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION bp_billing_equipment_assignment_pre_insert() RETURNS "trigger"
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  var_max_end_date      csctoss.bp_billing_equipment_assignment.end_date%TYPE ;
BEGIN
  -- start date can never be later than end date
  IF NEW.end_date IS NOT NULL AND NEW.start_date > NEW.end_date THEN
    RAISE EXCEPTION 'Billing assignment start date cannot be later than end date' ;
  END IF ;

  -- only 1 row per bp_billing_charge_id and equipment_id with null end date
  IF NEW.end_date IS NULL AND (SELECT count(*) > 0
                                 FROM csctoss.bp_billing_equipment_assignment
                                WHERE equipment_id = NEW.equipment_id
                                  AND bp_billing_charge_id = NEW.bp_billing_charge_id
                                  AND end_date IS NULL) THEN

      RAISE EXCEPTION 'Equipment ID % already has a Billing Charge ID % and Billing Assignment with NULL end date', NEW.equipment_id, NEW.bp_billing_charge_id ;

  END IF ;
  
  -- get max end date for this equipment assignment for comparisons
  SELECT INTO var_max_end_date MAX(end_date)
         FROM bp_billing_equipment_assignment
        WHERE equipment_id = NEW.equipment_id
          AND end_date IS NOT NULL ;
  
  IF NOT FOUND THEN RETURN NEW ; END IF ;

  -- make sure new start date does not fall between existing assignment
  IF (SELECT count(*) > 0 FROM csctoss.bp_billing_equipment_assignment 
       WHERE NEW.start_date BETWEEN start_date AND end_date
         AND equipment_id = NEW.equipment_id
         AND bp_billing_charge_id = NEW.bp_billing_charge_id) THEN

    RAISE EXCEPTION 'New start date for Equipment ID % falls between existing assignment', NEW.equipment_id ;

  -- make sure new end date does not fall between existing assignment
  ELSIF NEW.end_date IS NOT NULL AND (SELECT count(*) > 0
                                        FROM csctoss.bp_billing_equipment_assignment
                                       WHERE NEW.end_date BETWEEN start_date AND end_date
                                         AND equipment_id = NEW.equipment_id
                                         AND bp_billing_charge_id = NEW.bp_billing_charge_id) THEN

    RAISE EXCEPTION 'New billing assignment end date for Equipment ID % falls between existing billing assignment', NEW.equipment_id ;

  END IF ;

  RETURN NEW ;

END ;
$$;


ALTER FUNCTION csctoss.bp_billing_equipment_assignment_pre_insert() OWNER TO csctoss_owner;

--
-- Name: bp_billing_equipment_assignment_pre_update(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION bp_billing_equipment_assignment_pre_update() RETURNS "trigger"
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  -- don't alow equipment_id updates - too many conditions to check
  IF NEW.equipment_id <> OLD.equipment_id THEN
    RAISE EXCEPTION 'Cannot update billing assignment equipment_id. Please delete or end date this billing equipment assignment.' ;
  END IF ;

  -- start date can never be before end date
  IF NEW.end_date IS NOT NULL AND NEW.start_date > NEW.end_date THEN
    RAISE EXCEPTION 'Billing assignment start date cannot be later than end date' ;
  END IF ;

  -- only 1 row per  bp_billing_charge_id and equipment_id with null end date
  IF NEW.end_date IS NULL AND  (SELECT count(*) > 0
                                  FROM csctoss.bp_billing_equipment_assignment
                                 WHERE equipment_id = NEW.equipment_id
                                   AND bp_billing_charge_id = NEW.bp_billing_charge_id
                                   AND end_date IS NULL
                                   AND bp_billing_equipment_assignment_id <> NEW.bp_billing_equipment_assignment_id) THEN

      RAISE EXCEPTION 'Equipment ID % already has a billing assignment with NULL end date', NEW.equipment_id ;

  END IF ;

  -- if start date changing verify new value valid
  IF NEW.start_date <> OLD.start_date THEN

    -- verify new start date does not fall between existing assignment
    IF (SELECT count(*) > 0
          FROM csctoss.bp_billing_equipment_assignment
         WHERE NEW.start_date BETWEEN start_date AND end_date
           AND equipment_id = NEW.equipment_id
           AND bp_billing_equipment_assignment_id <> NEW.bp_billing_equipment_assignment_id) THEN

      RAISE EXCEPTION 'New billing assignment start date for Equipment ID % falls between existing billing assignment', NEW.equipment_id ;

    END IF ;

  END IF ;

  -- if end date changing verify new value valid
  IF NEW.end_date IS NOT NULL AND NEW.end_date <> OLD.end_date THEN

    -- verify new end date does not fall between existing assignment
    IF (SELECT count(*) > 0
          FROM csctoss.bp_billing_equipment_assignment
         WHERE NEW.end_date BETWEEN start_date AND end_date
           AND equipment_id = NEW.equipment_id
           AND bp_billing_equipment_assignment_id <> NEW.bp_billing_equipment_assignment_id) THEN

      RAISE EXCEPTION 'New billing assignment end date for Equipment ID % falls between billing existing assignment', NEW.equipment_id ;

    END IF ;

  END IF ;

  RETURN NEW ;

END ;
$$;


ALTER FUNCTION csctoss.bp_billing_equipment_assignment_pre_update() OWNER TO csctoss_owner;

--
-- Name: bp_billing_period_pre_insert_update(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION bp_billing_period_pre_insert_update() RETURNS "trigger"
    LANGUAGE plpgsql
    AS $$

DECLARE

  rec_bp_billing_period         record ;
  var_message                   text ;

BEGIN

  SELECT INTO rec_bp_billing_period *
         FROM csctoss.bp_billing_period
        WHERE bp_billing_calendar_id = NEW.bp_billing_calendar_id
          AND ( (NEW.start_date BETWEEN start_date AND end_date) OR
                (NEW.end_date BETWEEN start_date AND end_date) ) ;

  IF FOUND THEN
    var_message := 'Billing Period Overlap Error for Billing Calendar '
                  ||rec_bp_billing_period.bp_billing_calendar_id::text
                  ||'. New start date / end date '
                  ||NEW.start_date::text||' / '||NEW.end_date::text
                  ||' conflicts with existing Billing Period start date / end date '
                  ||rec_bp_billing_period.start_date::text||' / '||rec_bp_billing_period.end_date ;

    RAISE EXCEPTION '%', var_message ;

  ELSE
    RETURN NEW ;
  END IF ;

END;
$$;


ALTER FUNCTION csctoss.bp_billing_period_pre_insert_update() OWNER TO csctoss_owner;

--
-- Name: FUNCTION bp_billing_period_pre_insert_update(); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION bp_billing_period_pre_insert_update() IS 'Trigger function to prevent billing period overlapping dates within the same billing calendar.';


--
-- Name: bp_check_billing_charge_id(text, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION bp_check_billing_charge_id(text, integer) RETURNS boolean
    LANGUAGE sql STABLE
    AS $_$
  SELECT COUNT(*) > 0
    FROM csctoss.bp_billing_charge
   WHERE bp_billing_charge_type = $1 
     AND bp_billing_charge_id = $2 ;
$_$;


ALTER FUNCTION csctoss.bp_check_billing_charge_id(text, integer) OWNER TO csctoss_owner;

--
-- Name: FUNCTION bp_check_billing_charge_id(text, integer); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION bp_check_billing_charge_id(text, integer) IS 'Constraint fuunction to verify appropriate bp_billing_charge_id for given table.';


--
-- Name: bp_check_charge_frequency(date, date, integer, integer, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION bp_check_charge_frequency(date, date, integer, integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_charge_start_date		ALIAS FOR $1 ;
	v_charge_end_date		ALIAS FOR $2 ;
	v_calendar_id			ALIAS FOR $3 ;
	v_period_id				ALIAS FOR $4 ;
	v_frequency				ALIAS FOR $5 ;
	v_counter				INTEGER := 0 ;
	vr_calendar				RECORD ;
	v_retval				BOOLEAN := FALSE ;
BEGIN
	-- Charges occuring every period are always charged
	IF v_frequency = 1 THEN
		RETURN TRUE ;
	END IF ;

	-- Prevent any division by zero errors
	IF v_frequency = 0 THEN
		RETURN FALSE ;
	END IF ;

	-- Iterate through periods and check for charge
	FOR vr_calendar IN
		SELECT bipe.bp_billing_period_id
		FROM   bp_billing_calendar cal,
			   bp_billing_period bipe
		WHERE  cal.bp_billing_calendar_id = bipe.bp_billing_calendar_id
		AND    cal.bp_billing_calendar_id = v_calendar_id
		AND    bipe.start_date BETWEEN v_charge_start_date AND v_charge_end_date
		ORDER BY bipe.start_date
	LOOP
		v_counter := v_counter + 1 ;
		
		IF vr_calendar.bp_billing_period_id = v_period_id THEN
			IF v_counter = 1 THEN
				-- always charge the first period
				v_retval := TRUE ;
			ELSE
				-- check using modulus operator
				-- use count minus one since the first period always gets
				-- charged
				IF ((v_counter - 1) % v_frequency) = 0 THEN
					v_retval := TRUE ;
				END IF ;
			END IF ;
		END IF ;
	END LOOP ;

	RETURN v_retval ;
END ;
$_$;


ALTER FUNCTION csctoss.bp_check_charge_frequency(date, date, integer, integer, integer) OWNER TO csctoss_owner;

--
-- Name: FUNCTION bp_check_charge_frequency(date, date, integer, integer, integer); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION bp_check_charge_frequency(date, date, integer, integer, integer) IS 'Check a charge, based on its frequency, against the current billing period to see if it should be charged';


--
-- Name: bp_cost_per_unit_ck(text, double precision, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION bp_cost_per_unit_ck(text, double precision, integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_table_name                        text             := $1 ;
  par_cost_per_unit                     double precision := $2 ;
  par_bp_billing_charge_usage_id        int              := $3 ;

  var_cost_per_unit                     double precision ;
  var_message                           text ;

BEGIN

  var_message := 'Billing Charge Usage Id '||par_bp_billing_charge_usage_id::text||' assigns cost per unit of ' ;

  -- check to see if bp_billing_charge_usage has cost per unit assigned at parent level
  IF par_table_name = 'bp_aggregate_usage_plan' AND par_cost_per_unit IS NOT NULL THEN
    SELECT INTO var_cost_per_unit cost_per_unit
           FROM csctoss.bp_billing_charge_usage
          WHERE bp_billing_charge_usage_id = par_bp_billing_charge_usage_id
            AND cost_per_unit IS NOT NULL ;

    IF FOUND THEN
      var_message := var_message||var_cost_per_unit::text||' at Billing Charge Usage level.' ;
      RAISE EXCEPTION '%', var_message ;
    END IF ;

  -- check to see if bp_aggregate_usage_plan has cost per unit assigned at child level
  ELSIF par_table_name = 'bp_billing_charge_usage' AND par_cost_per_unit IS NOT NULL THEN
    SELECT INTO var_cost_per_unit cost_per_unit
           FROM csctoss.bp_aggregate_usage_plan
          WHERE bp_billing_charge_usage_id = par_bp_billing_charge_usage_id
            AND cost_per_unit IS NOT NULL ;

    IF FOUND THEN
      var_message := var_message||var_cost_per_unit::text||' at Aggregate Usage Plan level.' ;
      RAISE EXCEPTION '%', var_message ;
    END IF ;

  END IF ;

  RETURN TRUE ;
END ;

$_$;


ALTER FUNCTION csctoss.bp_cost_per_unit_ck(text, double precision, integer) OWNER TO csctoss_owner;

--
-- Name: FUNCTION bp_cost_per_unit_ck(text, double precision, integer); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION bp_cost_per_unit_ck(text, double precision, integer) IS 'Check constraint function governing cost per unit precedence. Value in table bp_aggregate_usage_plan trumps value in bp_billing_charge_usage.';


--
-- Name: bp_usage_allotment_bp_billing_charge_usage_ck(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION bp_usage_allotment_bp_billing_charge_usage_ck(integer) RETURNS boolean
    LANGUAGE sql STABLE
    AS $_$
  SELECT NOT per_session
    FROM csctoss.bp_billing_charge_usage
   WHERE bp_billing_charge_usage_id = $1 ;
$_$;


ALTER FUNCTION csctoss.bp_usage_allotment_bp_billing_charge_usage_ck(integer) OWNER TO csctoss_owner;

--
-- Name: FUNCTION bp_usage_allotment_bp_billing_charge_usage_ck(integer); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION bp_usage_allotment_bp_billing_charge_usage_ck(integer) IS 'Constraint function preventing rows based on bp_billing_charge_usage_ied where the per_session flag is true.';


--
-- Name: calc_charged_minutes(interval); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION calc_charged_minutes(interval) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  i_interval          INTERVAL := $1 ;
  v_seconds           INTEGER  := 0 ;
  v_minutes_charged   INTEGER  := 0 ;

BEGIN

  v_seconds :=  EXTRACT(EPOCH FROM i_interval) ;
  v_minutes_charged :=  TRUNC((v_seconds/60),0) ;

  IF v_seconds % 60 > 0 THEN
    v_minutes_charged := v_minutes_charged + 1 ;
  END IF ;

  RETURN v_minutes_charged ;

END ;
$_$;


ALTER FUNCTION csctoss.calc_charged_minutes(interval) OWNER TO csctoss_owner;

--
-- Name: FUNCTION calc_charged_minutes(interval); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION calc_charged_minutes(interval) IS 'Calculates total minutes, round up, for an interval';


--
-- Name: calc_charged_minutes(bigint); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION calc_charged_minutes(bigint) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  i_seconds           BIGINT  := $1 ;
  v_minutes_charged   INTEGER := 0 ;

BEGIN

  v_minutes_charged :=  TRUNC((i_seconds/60),0) ;
  IF i_seconds % 60 > 0 THEN
    v_minutes_charged := v_minutes_charged + 1 ;
  END IF ;

  RETURN v_minutes_charged ;

END ;
$_$;


ALTER FUNCTION csctoss.calc_charged_minutes(bigint) OWNER TO csctoss_owner;

--
-- Name: FUNCTION calc_charged_minutes(bigint); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION calc_charged_minutes(bigint) IS 'Calculates total minutes, round up, for a bigint';


--
-- Name: calc_charged_prepaid_plan(integer, integer, integer, timestamp with time zone); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION calc_charged_prepaid_plan(integer, integer, integer, timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
	par_line_id						integer := $1 ;
	par_used_seconds				integer := $2 ;
	par_master_radacctid			integer := $3 ;
	par_acctstarttime				timestamptz := $4 ;
	const_comment					text := 'Parser prepaid charge'; 

	var_plan_id						integer ;
	var_prepaid_balance				integer ;
	var_used_minutes				int ;
	var_time_remaining				int ;
	var_current_plan_log_id			int ;
	var_radius_username				text ;
	var_groupname_session_timeout	integer ;
	var_return						text ;
	var_plan_log_update				BOOLEAN := TRUE ;
	var_product_id					integer ;
	var_billing_entity_id			integer ;
	var_service_groupname			text ;
	var_expired_groupname			text ;
	var_current_groupname			text ;
	crec							RECORD ;
	var_start_new_plan				BOOLEAN := FALSE ;
BEGIN
	-- Get plan_id for the line
	SELECT current_plan_id,
			billing_entity_id 
	INTO   var_plan_id,
			var_billing_entity_id 
	FROM   line
	WHERE  line_id = par_line_id ;

	IF NOT FOUND OR var_plan_id IS NULL THEN
		RETURN FALSE; 
	END IF ;
	 
	-- Validate used seconds, if var_used_minutes is less than zero do nothing.
	var_used_minutes := (ceil(par_used_seconds / 60.0))::int ;

	IF (var_used_minutes <= 0) THEN
		RETURN FALSE ;
	END IF ;

	-- Select prepaid_balance from plan
	SELECT pl.prepaid_balance,
			pl.product_id
	INTO   var_prepaid_balance,
			var_product_id
	FROM   plan pl
	WHERE  pl.plan_id  = var_plan_id
	AND    pl.line_id  = par_line_id ;

	-- If prepaid balance is NULL then assign zero to var_prepaid_balance.
	IF var_prepaid_balance IS NULL THEN
		var_prepaid_balance := 0 ;
	END IF ;

	-- When time remaining is more than session time.
	IF var_prepaid_balance >= var_used_minutes THEN
		var_time_remaining := var_prepaid_balance - var_used_minutes ;
	     
		UPDATE plan
		SET    prepaid_balance = var_time_remaining
		WHERE  plan_id = var_plan_id
		AND    line_id = par_line_id ;
	    
		-- Update correct log record, get current_value_sequence
		var_current_plan_log_id = currval('plan_log_plan_log_id_seq') ;

		-- Update plan_log set login_date = now() for the plan_log_id.
		UPDATE plan_log 
		SET    comment = const_comment,
			   login_date = now()
		WHERE  plan_log_id = var_current_plan_log_id ;

	-- When time remaining is less than session time.
	ELSE
		BEGIN
			FOR crec IN
				SELECT *
				FROM   plan
				WHERE  line_id = par_line_id
				AND    plan_id >= var_plan_id
				ORDER BY plan_id  
			LOOP
				var_plan_log_update     := TRUE ;
				IF crec.prepaid_balance IS NULL THEN
					crec.prepaid_balance := 0 ;
				END IF ;

				IF crec.prepaid_balance <= var_used_minutes THEN
					var_time_remaining := var_used_minutes - crec.prepaid_balance ;
	                
					var_used_minutes   := var_time_remaining ;
	               
					-- KKT: Added update to end_date when minutes exhausted
					UPDATE plan
					SET    prepaid_balance = 0,
						   end_date = now()::DATE
					WHERE  plan_id = crec.plan_id
					AND    line_id = crec.line_id ;

					-- KKT: Mark if we will start a new plan on the next iteration through the loop
					var_start_new_plan := TRUE ;

					BEGIN
						-- Update correct log record, get current_value_sequence             
						var_current_plan_log_id = currval('plan_log_plan_log_id_seq') ;
					EXCEPTION
						WHEN OTHERS THEN
							var_plan_log_update     := FALSE ;
							var_current_plan_log_id := nextval('plan_log_plan_log_id_seq') ;
					END ;
	        
					IF var_current_plan_log_id IS NOT NULL AND var_plan_log_update = TRUE THEN          
						-- Update plan_log set login_date = now() for the plan_log_id.
						UPDATE plan_log 
						SET    comment    = const_comment,
							   login_date = now()
						WHERE  plan_log_id = var_current_plan_log_id ;
					END IF ;

					UPDATE LINE 
					SET    current_plan_id = crec.plan_id
					WHERE  line_id         = crec.line_id ;

				ELSIF crec.prepaid_balance >= var_used_minutes THEN
					var_time_remaining := var_used_minutes - crec.prepaid_balance ;
 
					var_used_minutes   := var_time_remaining ;
					var_time_remaining := var_time_remaining * -1 ;

					-- KKT: If we are starting a new plan, update the start date as well
					IF var_start_new_plan THEN
						UPDATE plan
						SET    prepaid_balance = var_time_remaining,
							   start_date = now()::DATE
						WHERE  plan_id = crec.plan_id
						AND    line_id = crec.line_id ;

						var_start_new_plan := FALSE ;
					ELSE
						UPDATE plan
						SET    prepaid_balance = var_time_remaining
						WHERE  plan_id = crec.plan_id
						AND    line_id = crec.line_id ;
					END IF ;

					BEGIN
						-- Update correct log record, get current_value_sequence             
						var_current_plan_log_id = currval('plan_log_plan_log_id_seq') ;
					EXCEPTION
					WHEN OTHERS THEN
						var_plan_log_update     := FALSE ;
						var_current_plan_log_id := nextval('plan_log_plan_log_id_seq') ;
					END ;
	      
					IF var_current_plan_log_id IS NOT NULL AND var_plan_log_update = TRUE THEN          
						-- Update plan_log set login_date = now() for the plan_log_id.
						UPDATE plan_log 
						SET    comment     = const_comment,
							   login_date  = now()
						WHERE  plan_log_id = var_current_plan_log_id ;
					END IF ;

					UPDATE LINE 
					SET    current_plan_id = crec.plan_id
					WHERE  line_id         = crec.line_id ;
				END IF ;

				var_plan_id    := crec.plan_id ;
				var_product_id := crec.product_id ;

				IF var_used_minutes <= 0 THEN
					EXIT ;
				END IF ;
			END LOOP ;
		END ;

		IF var_used_minutes > 0 THEN
			INSERT INTO throw_away_minutes (line_id, plan_id, throw_away_min)
			VALUES (par_line_id,var_plan_id,var_used_minutes) ;
		END IF ;
	END IF ;

	-- Get Radius username for the line_id passed to the function
	SELECT username
	INTO   var_radius_username
	FROM   radreply
	WHERE  attribute = 'Class'
	AND    value     = par_line_id; 

	SELECT SUM(pl.prepaid_balance)
	INTO   var_time_remaining            
	FROM   plan pl
	WHERE  pl.line_id  = par_line_id ;

	-- usergroup logic here
	SELECT service_groupname, expired_groupname
	INTO   var_service_groupname, var_expired_groupname
	FROM   billing_entity_product
	WHERE  product_id = var_product_id
	AND    (billing_entity_id = var_billing_entity_id
			OR billing_entity_id = (SELECT parent_billing_entity_id
									FROM billing_entity
									WHERE billing_entity_id = var_billing_entity_id)
		   ) ;

	SELECT groupname 
	INTO   var_current_groupname
	FROM   usergroup 
	WHERE  username = var_radius_username
	AND    UPPER(groupname) like '%SERVICE%' ;

	-- IF EXPIRING, 0 MINUTES
	IF var_time_remaining <= 0 THEN
		IF var_current_groupname = var_service_groupname THEN
			UPDATE usergroup
			SET    groupname = var_expired_groupname
			WHERE  username  = var_radius_username ;
		ELSIF var_current_groupname = var_expired_groupname THEN
			NULL ; -- do nothing
		ELSE
			INSERT INTO usergroup_error_log (line_id, plan_id, username, error_message)
			VALUES (par_line_id,var_plan_id,var_radius_username, 
					'The current groupname for this usergroup record = '||var_current_groupname||', Does not match either the service or expired group') ;
		END IF ;
	END IF ;

	IF var_time_remaining > 0 THEN
		-- IF ACTIVATING, MEANING THEY EXTENDED AND BOUGHT A NEW PLAN
		IF var_current_groupname = var_expired_groupname THEN
			UPDATE usergroup
			SET    groupname = var_service_groupname
			WHERE  username  = var_radius_username ;
		ELSIF var_current_groupname = var_service_groupname THEN
			NULL ; -- do nothing
		ELSE
			INSERT INTO usergroup_error_log (line_id, plan_id, username, error_message)
			VALUES (par_line_id,var_plan_id,var_radius_username, 
					'The current groupname for this usergroup record = '||var_current_groupname||', Does not match either the service or expired group') ;
		END IF ;
	END IF ;

	-- determine the appropriate action for Session-Timeout
	SELECT DISTINCT rgrp.value::int
	INTO   var_groupname_session_timeout
	FROM   csctoss.usergroup ugrp
	JOIN   radgroupreply rgrp USING (groupname)
	WHERE  ugrp.username = var_radius_username
	AND    rgrp.attribute = 'Session-Timeout' ;

	IF NOT FOUND THEN 
		var_groupname_session_timeout := 86400 ;
	END IF  ;

	-- Convert to seconds because its stored as seconds in radgroupreply table.
	var_time_remaining := var_time_remaining * 60 ;

	IF var_groupname_session_timeout > var_time_remaining THEN
		IF var_time_remaining < 0 THEN
			var_time_remaining := var_time_remaining * -1 ;
		END IF ;
	    
		IF var_time_remaining <= 0 THEN
			DELETE FROM csctoss.radreply WHERE username = var_radius_username and attribute = 'Session-Timeout' ;
		ELSE
			UPDATE csctoss.radreply
			SET    value     = var_time_remaining
			WHERE  username  = var_radius_username
			AND    attribute = 'Session-Timeout' ;

			-- if the record doesn't exist then insert it
			IF NOT FOUND THEN
				INSERT INTO csctoss.radreply (username,attribute,op,value)
				VALUES (var_radius_username, 'Session-Timeout', '=', var_time_remaining) ;
			END IF ;
		END IF ;
	ELSE
		DELETE FROM csctoss.radreply WHERE username = var_radius_username and attribute = 'Session-Timeout' ;
		IF NOT FOUND THEN
			NULL ;
		END IF ;
	END IF ;

	-- This portion of the code should not be run in production as this will kill the nas and takes time to come back
	-- Best way is to write in some kind of table and call the function later.
	-- Right now commenting out would be the best option.
	/*   IF var_time_remaining <= 0 THEN
	       -- this device has exhausted all it's prepaid time
	       -- so we need to disconnect it from the nas by calling
	       -- the public.packet_of_disconnect(text) function
	      FOR var_return IN SELECT * FROM public.packet_of_disconnect(var_radius_username) ;
	      LOOP
	         RETURN NEXT var_return ;
	         IF var_return like '%SUCCESS%' THEN
	            RETURN TRUE;
	            EXIT;
	         ELSIF var_return like '%RC1: ERROR%' THEN
	            RETURN FALSE;
	            EXIT;
	         END IF;
	      END LOOP;
	    END IF;
	*/
	-- NOW, YOU'LL NEED TO WRITE SOME RETURN LOGIC OR A RETURN SET HERE
	-- BECAUSE THE PACKET_OF_DISCONNECT RETURNS A SET OF TEST
	-- GREG CAN TELL YOU WHAT HE WANTS YOU TO DO WITH ANY EXCEPTION HANDLING
	-- CHECK FOR THE WORD "SUCCESS", IF SUCCESS THEN DO NOTHING OTHERWISE RETURN THE ERROR CODES RC1, ETC

	-- Mark Radius accounting record as "processed"
	UPDATE master_radacct 
	SET    processed_flag   = TRUE 
	WHERE  master_radacctid = par_master_radacctid;

	RETURN TRUE;

END;
$_$;


ALTER FUNCTION csctoss.calc_charged_prepaid_plan(integer, integer, integer, timestamp with time zone) OWNER TO csctoss_owner;

--
-- Name: calculate_uptime_percent(text, date, date); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION calculate_uptime_percent(text, date, date) RETURNS numeric
    LANGUAGE sql STABLE
    AS $_$

  SELECT *
    FROM public.dblink((select * from csctoss.fetch_csctlog_conn())
                      ,'SELECT ROUND(((1-(SUM(acctsessiontime) / 
                                    (EXTRACT(epoch from COALESCE('||quote_literal($3::text)||', current_date)) -
                                     EXTRACT(epoch from COALESCE('||quote_literal($2::text)||', current_date-30))))) * 100)::numeric, 2)
                                FROM csctlog.master_radacct 
                               WHERE username = '||quote_literal($1)||'
                                 AND acctstarttime >= COALESCE('||quote_literal($2::text)||', current_date-30)
                                 AND acctstoptime < COALESCE('||quote_literal($3::text)||', current_date)
                                 AND acctstoptime IS NOT NULL
                                 AND acctsessiontime > 59
                            GROUP BY username')
      AS rec_type(percentage numeric) ;

$_$;


ALTER FUNCTION csctoss.calculate_uptime_percent(text, date, date) OWNER TO csctoss_owner;

--
-- Name: FUNCTION calculate_uptime_percent(text, date, date); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION calculate_uptime_percent(text, date, date) IS 'Calculates the uptime percent for customer primary services as one minus the uptime percent for Contour Networks secondary service.';


--
-- Name: cancellation_info(text, text[]); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION cancellation_info(text, text[]) RETURNS SETOF cancellation_info_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
  par_type		TEXT:=$1 ;
  par_values		ALIAS FOR $2 ;
  var_rec		RECORD;
  var_type		TEXT;
  test			TEXT;
  var_esn_hex		TEXT;
  var_sn		TEXT;
  var_mdn		TEXT;
  var_min		TEXT;
  var_username		TEXT;
  var_line_id		INTEGER;
  var_end_date		DATE;
  var_start_date	DATE;
  var_carrier		TEXT;
  var_model		TEXT;
  var_dblink_sql	TEXT;
  var_so		TEXT;
  var_company		TEXT;
  var_last_connection   TEXT;
  var_return		cancellation_info_retval ;
  
BEGIN
  set client_min_messages to NOTICE;

  IF par_type = 'esn_hex' THEN
    var_type = 'ESN HEX' ;
  END IF;

  IF par_type = 'sn' THEN
    var_type = 'SERIAL NUMBER' ;  
  END IF;

  FOR var_rec IN SELECT equipment_id 
		 FROM   unique_identifier
		 WHERE  1=1
		 AND    unique_identifier_type = var_type 
		 AND    value = ANY(par_values) 
  LOOP

    RAISE NOTICE 'equipment_id: %' , var_rec.equipment_id ;

    --get esn hex
    SELECT 
     value 
    INTO
     var_esn_hex
    FROM unique_identifier 
    WHERE unique_identifier_type = 'ESN HEX' 
    AND equipment_id = var_rec.equipment_id ;

    RAISE NOTICE 'esn_hex: %', var_esn_hex ;
    
    --get sn
    SELECT 
     value 
    INTO
     var_sn
    FROM unique_identifier 
    WHERE unique_identifier_type = 'SERIAL NUMBER' 
    AND equipment_id = var_rec.equipment_id ;				--add checks for null and put store some text in var

    RAISE NOTICE 'serial_number: %' , var_sn ; 

    --get mdn
    SELECT 
     value 
    INTO
     var_mdn
    FROM unique_identifier 
    WHERE unique_identifier_type = 'MDN' 
    AND equipment_id = var_rec.equipment_id ;

    RAISE NOTICE 'var_mdn: %' , var_mdn ;
    
    --get min
    SELECT 
     value 
    INTO
     var_min
    FROM unique_identifier 
    WHERE unique_identifier_type = 'MIN' 
    AND equipment_id = var_rec.equipment_id ;

    RAISE NOTICE 'var_min: %' , var_min ;

    --get username
    SELECT
     username
    INTO
     var_username
    FROM username
    WHERE (substr(username,1,10) = var_mdn OR substr(username,1,10) = var_min) ;

    RAISE NOTICE 'var_username: %' , var_username ;

    IF var_username IS NULL THEN
      RAISE EXCEPTION 'username not found in username table [equipment_id = %]' , var_rec.equipment_id ;
    END IF; 

    --check line
    SELECT 
     line_id, start_date
    INTO
     var_line_id, var_start_date
    FROM  line_equipment
    WHERE end_date is null
    AND   equipment_id = var_rec.equipment_id ;

    RAISE NOTICE 'active line_id: %' , var_line_id ;
    RAISE NOTICE 'start_date: %' , var_start_Date ;

    --also check for inactive line or null start date?
    IF var_line_id IS NULL THEN
    --no active line - get last line assignment
      SELECT 
       line_id,start_date
      INTO
       var_line_id,var_start_date
      FROM line_equipment
      WHERE 1=1
      AND equipment_id = var_rec.equipment_id 
      AND end_date = (select max(end_date) from line_equipment where equipment_id = var_rec.equipment_id) ;

      RAISE NOTICE 'line_id: %' , var_line_id ;
      RAISE NOTICE 'start_date: %' , var_start_Date ;
    END IF; -- end check if line_id is null

    --get carrier
    IF substr(var_username,11,4) ~ '@usc' THEN
      var_carrier = 'USCC';
    END IF;

    IF substr(var_username,11,4) ~ '@vzw' THEN
      var_carrier = 'VERIZON';
    END IF;
 
    IF substr(var_username,11,4) ~ '@tsp' THEN
      var_carrier = 'SPRINT';
    END IF;

    IF substr(var_username,11,4) ~ '@cn0' THEN
      var_carrier = 'SPRINT';
    END IF;

    IF var_carrier IS NULL THEN
      SELECT 
       carrier
      INTO
       var_carrier
      FROM  equipment_model
      WHERE equipment_model_id = (SELECT equipment_model_id FROM equipment WHERE equipment_id = var_rec.equipment_id) ;
    END IF;

    RAISE NOTICE 'carrier: %' , var_carrier ;

    --get model
    SELECT
     model_number1
    INTO
     var_model
    FROM equipment_model
    WHERE equipment_model_id = (SELECT equipment_model_id FROM equipment WHERE equipment_id = var_rec.equipment_id) ;

    RAISE NOTICE 'model: %' , var_model ;
/*
    SELECT
     max(acctstarttime)
    INTO
     var_last_connection
    FROM  master_radacct
    WHERE username = var_username ;

    RAISE NOTICE 'last_connection : %' , var_last_connection ;
*/    
    --get SO from Jbilling
    --var_dblink_sql := 'SELECT public_number FROM purchase_order WHERE id = (select order_id from prov_line WHERE esn_hex = '''||var_esn_hex||''' AND line_id = '''||var_line_id||''')'  ;
    var_dblink_sql := 'SELECT public_number FROM purchase_order WHERE id = (SELECT order_id FROM prov_line WHERE esn_hex = '||quote_literal(var_esn_hex)||
		      ' AND line_id = '||quote_literal(var_line_id)||
		      ' AND start_date = '||quote_literal(var_start_date)||')'  ;


    SELECT public_number INTO var_so FROM public.dblink(fetch_jbilling_conn(), var_dblink_sql) AS rec_type (public_number text) ;
    RAISE NOTICE 'sales_order: %', var_so ; 


    --get company name from Jbilling
    var_dblink_sql := 'SELECT organization_name FROM contact WHERE user_id = (SELECT user_id FROM purchase_order WHERE deleted = 0 AND public_number = '||quote_literal(var_so)||')'  ;

    SELECT b_entity INTO var_company FROM public.dblink(fetch_jbilling_conn(), var_dblink_sql) AS rec_type (b_entity text) ;
    RAISE NOTICE 'company: %', var_company ; 
    

    --get last connection from radius server
    SELECT * INTO var_last_connection FROM get_last_connection_by_username(var_username) ;

    var_return.billing_entity 	= var_company ;
    var_return.line_id 		= var_line_id;
    var_return.start_date 	= var_start_date;
    var_return.model_number	= var_model;
    var_return.carrier		= var_carrier;
    var_return.esn_hex		= var_esn_hex;
    var_return.sn		= var_sn;
    var_return.sales_order	= var_so;
    var_return.username		= var_username;
    var_return.acctstarttime	= var_last_connection;
    
    RETURN NEXT var_return;
    
  END LOOP;  

RETURN;

  
END ;

$_$;


ALTER FUNCTION csctoss.cancellation_info(text, text[]) OWNER TO csctoss_owner;

--
-- Name: cancellation_info_and_perform_bulk(text, text[], integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION cancellation_info_and_perform_bulk(text, text[], integer) RETURNS SETOF cancellation_info_and_perform_bulk_retval
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
  par_type		TEXT:=$1 ;
  par_values		ALIAS FOR $2 ;
  par_staff_id		INTEGER:=$3 ;
  var_rec		RECORD;
  var_type		TEXT;
  test			TEXT;
  var_esn_hex		TEXT;
  var_sn		TEXT;
  var_mdn		TEXT;
  var_min		TEXT;
  var_username		TEXT;
  var_line_id		INTEGER;
  var_end_date		DATE;
  var_start_date	DATE;
  var_carrier		TEXT;
  var_model		TEXT;
  var_dblink_sql	TEXT;
  var_so		TEXT;
  var_company		TEXT;
  var_last_connection   TEXT;
  var_return		cancellation_info_and_perform_bulk_retval ;
  --
  var_expire_result	TEXT;
  var_expire_msg	TEXT;
  
BEGIN
  set client_min_messages to NOTICE;

  IF par_type = 'esn_hex' THEN
    var_type = 'ESN HEX' ;
  END IF;

  IF par_type = 'sn' THEN
    var_type = 'SERIAL NUMBER' ;  
  END IF;

  FOR var_rec IN SELECT equipment_id 
		 FROM   unique_identifier
		 WHERE  1=1
		 AND    unique_identifier_type = var_type 
		 AND    value = ANY(par_values) 
  LOOP

    RAISE NOTICE 'equipment_id: %' , var_rec.equipment_id ;

    --get esn hex
    SELECT 
     value 
    INTO
     var_esn_hex
    FROM unique_identifier 
    WHERE unique_identifier_type = 'ESN HEX' 
    AND equipment_id = var_rec.equipment_id ;

    RAISE NOTICE 'esn_hex: %', var_esn_hex ;
    
    --get sn
    SELECT 
     value 
    INTO
     var_sn
    FROM unique_identifier 
    WHERE unique_identifier_type = 'SERIAL NUMBER' 
    AND equipment_id = var_rec.equipment_id ;				--add checks for null and put store some text in var

    RAISE NOTICE 'serial_number: %' , var_sn ; 

    --get mdn
    SELECT 
     value 
    INTO
     var_mdn
    FROM unique_identifier 
    WHERE unique_identifier_type = 'MDN' 
    AND equipment_id = var_rec.equipment_id ;

    RAISE NOTICE 'var_mdn: %' , var_mdn ;
    
    --get min
    SELECT 
     value 
    INTO
     var_min
    FROM unique_identifier 
    WHERE unique_identifier_type = 'MIN' 
    AND equipment_id = var_rec.equipment_id ;

    RAISE NOTICE 'var_min: %' , var_min ;

    --get username
    SELECT
     username
    INTO
     var_username
    FROM username
    WHERE (substr(username,1,10) = var_mdn OR substr(username,1,10) = var_min) ;

    RAISE NOTICE 'var_username: %' , var_username ;

    IF var_username IS NULL THEN
      RAISE EXCEPTION 'username not found in username table [equipment_id = %]' , var_rec.equipment_id ;
    END IF; 

    --check line
    SELECT 
     line_id, start_date
    INTO
     var_line_id, var_start_date
    FROM  line_equipment
    WHERE end_date is null
    AND   equipment_id = var_rec.equipment_id ;

    RAISE NOTICE 'active line_id: %' , var_line_id ;
    RAISE NOTICE 'start_date: %' , var_start_Date ;

    --also check for inactive line or null start date?
    IF var_line_id IS NULL THEN
    --no active line - get last line assignment
      SELECT 
       line_id,start_date
      INTO
       var_line_id,var_start_date
      FROM line_equipment
      WHERE 1=1
      AND equipment_id = var_rec.equipment_id 
      AND end_date = (select max(end_date) from line_equipment where equipment_id = var_rec.equipment_id) ;

      RAISE NOTICE 'line_id: %' , var_line_id ;
      RAISE NOTICE 'start_date: %' , var_start_Date ;
    END IF; -- end check if line_id is null

    --get carrier
    IF substr(var_username,11,4) ~ '@usc' THEN
      var_carrier = 'USCC';
    END IF;

    IF substr(var_username,11,4) ~ '@vzw' THEN
      var_carrier = 'VERIZON';
    END IF;
 
    IF substr(var_username,11,4) ~ '@tsp' THEN
      var_carrier = 'SPRINT';
    END IF;

    IF substr(var_username,11,4) ~ '@cn0' THEN
      var_carrier = 'SPRINT';
    END IF;

    IF var_carrier IS NULL THEN
      SELECT 
       carrier
      INTO
       var_carrier
      FROM  equipment_model
      WHERE equipment_model_id = (SELECT equipment_model_id FROM equipment WHERE equipment_id = var_rec.equipment_id) ;
    END IF;

    RAISE NOTICE 'carrier: %' , var_carrier ;

    --get model
    SELECT
     model_number1
    INTO
     var_model
    FROM equipment_model
    WHERE equipment_model_id = (SELECT equipment_model_id FROM equipment WHERE equipment_id = var_rec.equipment_id) ;

    RAISE NOTICE 'model: %' , var_model ;
/*
    SELECT
     max(acctstarttime)
    INTO
     var_last_connection
    FROM  master_radacct
    WHERE username = var_username ;

    RAISE NOTICE 'last_connection : %' , var_last_connection ;
*/    
    --get SO from Jbilling
    --var_dblink_sql := 'SELECT public_number FROM purchase_order WHERE id = (select order_id from prov_line WHERE esn_hex = '''||var_esn_hex||''' AND line_id = '''||var_line_id||''')'  ;
    var_dblink_sql := 'SELECT public_number FROM purchase_order WHERE id = (select order_id from prov_line WHERE esn_hex = '''||var_esn_hex||''' AND line_id = '''||var_line_id||''' and archived is null )'  ;

    SELECT public_number INTO var_so FROM public.dblink(fetch_jbilling_conn(), var_dblink_sql) AS rec_type (public_number text) ;

    RAISE NOTICE 'sales_order: %', var_so ; 


    --get company name from Jbilling
    var_dblink_sql := 'SELECT organization_name FROM contact WHERE user_id = (SELECT user_id FROM purchase_order WHERE deleted = 0 AND public_number = '''||var_so||''')'  ;

    SELECT b_entity INTO var_company FROM public.dblink(fetch_jbilling_conn(), var_dblink_sql) AS rec_type (b_entity text) ;

    RAISE NOTICE 'company: %', var_company ; 
    

    --get last connection from radius server
    --var_dblink_sql := 'SELECT max(acctstarttime) FROM master_radacct WHERE username = '''||var_username||''''  ;

    --var_dblink_sql := 'SELECT max(acctstarttime) FROM master_radacct WHERE username = '||quote_literal(var_username)  ;
    --SELECT acctstarttime INTO var_last_connection FROM public.dblink(fetch_csctlog_conn(), var_dblink_sql) AS rec_type (acctstarttime timestamp) ;
    
    --var_last_connection = '2015-01-01'::timestamp ;
    var_last_connection = null ;

    --RAISE NOTICE 'last connection: %', var_last_connection ; 

    var_return.billing_entity 	= var_company ;
    var_return.line_id 		= var_line_id;
    var_return.start_date 	= var_start_date;
    var_return.model_number	= var_model;
    var_return.carrier		= var_carrier;
    var_return.esn_hex		= var_esn_hex;
    var_return.sn		= var_sn;
    var_return.sales_order	= var_so;
    var_return.username		= var_username;
    var_return.acctstarttime	= var_last_connection;
   
    --perform cancellation
    IF var_esn_hex IS NOT NULL THEN

      SELECT * INTO var_expire_result, var_expire_msg FROM csctoss.ops_api_expire_bulk(var_esn_hex,par_staff_id) ; 

      var_return.result = var_expire_result ;
      var_return.msg = var_expire_msg ;
 
    ELSE  
      var_return.result = 'FAIL' ;
      var_return.msg = 'NO ESN_HEX FOUND TO PASS TO ops_api_expire_bulk(text)' ;    
    END IF;

    
    RETURN NEXT var_return;
    
  END LOOP;  

RETURN;

  
END ;

$_$;


ALTER FUNCTION csctoss.cancellation_info_and_perform_bulk(text, text[], integer) OWNER TO csctoss_owner;

--
-- Name: change_username(text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION change_username(text, text) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
  var_old_username text := $1;
  var_new_username text := $2;

  var_row record;
  var_affected_rows integer;
  var_affected_statistics text := '[Affected rows] => ';

BEGIN

  SELECT * INTO var_row FROM csctoss.username WHERE username = var_old_username;
  if NOT FOUND THEN
    return next 'Source username does not exist. username=' || var_old_username;
    return;
  end if;

  SELECT * INTO var_row FROM csctoss.username WHERE username = var_new_username;
  IF FOUND THEN
    return next 'Destination username exists already. username=' || var_new_username;
    return;
  end if;

  UPDATE csctoss.username SET username = var_new_username WHERE username = var_old_username;
  GET DIAGNOSTICS var_affected_rows = ROW_COUNT;
  var_affected_statistics := var_affected_statistics || 'username=' || var_affected_rows;

  UPDATE csctoss.usergroup SET username = var_new_username WHERE username = var_old_username;
  GET DIAGNOSTICS var_affected_rows = ROW_COUNT;
  var_affected_statistics := var_affected_statistics || 'usergroup=' || var_affected_rows;

  UPDATE csctoss.radcheck SET username = var_new_username WHERE username = var_old_username;
  GET DIAGNOSTICS var_affected_rows = ROW_COUNT;
  var_affected_statistics := var_affected_statistics || 'radcheck=' || var_affected_rows;

  UPDATE csctoss.radreply SET username = var_new_username WHERE username = var_old_username;
  GET DIAGNOSTICS var_affected_rows = ROW_COUNT;
  var_affected_statistics := var_affected_statistics || 'radreply=' || var_affected_rows;

  UPDATE csctoss.line SET radius_username = var_new_username WHERE radius_username = var_old_username;
  GET DIAGNOSTICS var_affected_rows = ROW_COUNT;
  var_affected_statistics := var_affected_statistics || 'line=' || var_affected_rows;

  return next var_affected_statistics;
  RETURN NEXT 'SUCCESS';
  RETURN;

END ;

$_$;


ALTER FUNCTION csctoss.change_username(text, text) OWNER TO csctoss_owner;

--
-- Name: check_jbilling_mrc_allowance(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION check_jbilling_mrc_allowance() RETURNS SETOF check_missing_mrcs_retval
    LANGUAGE plpgsql
    AS $$

DECLARE
	
  var_return			check_missing_mrcs_retval ;
  v_rec				RECORD;

BEGIN

  SET client_min_messages TO notice ;

  --NOTE: excluding two MRC fees by item_ids (7700,5700)
  --IF new fees are created and given a name like MRC-, then we will have to

  --SELECT * FROM public.dblink(fetch_jbilling_conn(),' SELECT internal_number FROM public.item WHERE internal_number ~ ''MRC-[0-9]'' AND deleted = 0 ORDER BY 1') as rec_type (internal_number text) 
   
  FOR v_rec IN 
  SELECT 
   id,internal_number,external_id,allowance_kb 
  FROM public.dblink(fetch_jbilling_conn(),'SELECT
					     id,internal_number,external_id,allowance_kb
				            FROM  public.item
					    WHERE internal_number ~ ''MRC-[0-9]'' 
					    AND deleted = 0 
					    AND allowance_kb is null ORDER BY 1 ') as rec_type (id integer,internal_number text,external_id integer,allowance_kb integer) 
  LOOP
    var_return.item_id = v_rec.id ;
    var_return.internal_number = v_rec.internal_number ;
    var_return.external_id = v_rec.external_id ;
    var_return.allowance_kb = v_rec.allowance_kb ;

    RETURN NEXT var_return ;

  END LOOP;
  
  RETURN ;

END;
$$;


ALTER FUNCTION csctoss.check_jbilling_mrc_allowance() OWNER TO csctoss_owner;

--
-- Name: check_missing_mrcs(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION check_missing_mrcs() RETURNS SETOF check_missing_mrcs_retval
    LANGUAGE plpgsql
    AS $$

DECLARE

  v_rec				RECORD;
  var_found_item_oss		TEXT;
  var_oss_missing_item		TEXT;	
  var_return			check_missing_mrcs_retval ;

BEGIN

  SET client_min_messages TO notice ;

  --NOTE: excluding two MRC fees by item_ids (7700,5700)
  --IF new fees are created and given a name like MRC-, then we will have to

  FOR v_rec IN SELECT * FROM public.dblink(fetch_jbilling_conn(),' SELECT internal_number FROM public.item WHERE internal_number ~ ''MRC-[0-9]'' AND deleted = 0 ORDER BY 1') as rec_type (internal_number text) 

  LOOP
  
    --RAISE NOTICE 'processing item %' , v_rec.internal_number ;

    --check OSS for item/product 
    
    SELECT product_code
    INTO   var_found_item_oss
    FROM   csctoss.product
    WHERE  1=1
    AND    product_code = v_rec.internal_number ;

    IF var_found_item_oss IS NULL THEN
      var_oss_missing_item = v_rec.internal_number ;   
      --RAISE NOTICE '***MISSING ITEM % ', var_oss_missing_item ; 
   
      SELECT id,internal_number,external_id,allowance_kb INTO var_return.item_id,var_return.internal_number,var_return.external_id,var_return.allowance_kb 
      FROM public.dblink(fetch_jbilling_conn(),'SELECT
						  id,internal_number,external_id,allowance_kb
						 FROM  public.item
						 WHERE item.internal_number  = '|| quote_literal(v_rec.internal_number)) as rec_type (id integer,internal_number text,external_id integer,allowance_kb integer) ;
      RETURN NEXT var_return ;
    END IF;     
  END LOOP;
    
  RETURN ;

END;
$$;


ALTER FUNCTION csctoss.check_missing_mrcs() OWNER TO csctoss_owner;

--
-- Name: check_send_email(integer, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION check_send_email(integer, boolean) RETURNS boolean
    LANGUAGE sql STABLE
    AS $_$
  SELECT EXISTS (SELECT contact_id
                   FROM csctoss.contact
                  WHERE contact_id = $1
                    AND ( COALESCE(notification_email, email_address) IS NOT NULL OR $2 = FALSE)) ;
$_$;


ALTER FUNCTION csctoss.check_send_email(integer, boolean) OWNER TO csctoss_owner;

--
-- Name: FUNCTION check_send_email(integer, boolean); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION check_send_email(integer, boolean) IS 'Constraint function to guarantee the alert contact has email_address if send_email flag set to true.';


--
-- Name: check_send_text_to_phone(integer, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION check_send_text_to_phone(integer, boolean) RETURNS boolean
    LANGUAGE sql STABLE
    AS $_$
  SELECT EXISTS (SELECT contact_id
                   FROM csctoss.contact
                  WHERE contact_id = $1
                    AND (notification_phone IS NOT NULL OR $2 = FALSE)) ;
$_$;


ALTER FUNCTION csctoss.check_send_text_to_phone(integer, boolean) OWNER TO csctoss_owner;

--
-- Name: FUNCTION check_send_text_to_phone(integer, boolean); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION check_send_text_to_phone(integer, boolean) IS 'Constraint function to guarantee the alert contact has notification_phone if send_text_to_phone set to true.';


--
-- Name: contact_insert_ui(integer, text, text, text, text, text, text, text, boolean, text, text, integer, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION contact_insert_ui(integer, text, text, text, text, text, text, text, boolean, text, text, integer, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
    param_billing_entity_id			ALIAS FOR $1  ;
    param_family_name				ALIAS FOR $2  ;
    param_given_name				ALIAS FOR $3  ;
    param_title						ALIAS FOR $4  ;
    param_email_address				ALIAS FOR $5  ;
	param_phone_number				ALIAS FOR $6  ;
	param_alternate_phone_number	ALIAS FOR $7  ;
	param_fax_number				ALIAS FOR $8  ;
	param_send_product_info			ALIAS FOR $9  ;
	param_contact_level				ALIAS FOR $10 ;
	param_contact_type				ALIAS FOR $11 ;
	param_address_id				ALIAS FOR $12 ;
	param_address_type				ALIAS FOR $13 ;

	v_counter				INTEGER ;
	v_contact_id			INTEGER ;
BEGIN
	-- Check required fields
	IF param_billing_entity_id IS NULL
	OR param_family_name IS NULL
	OR param_given_name IS NULL
	OR param_phone_number IS NULL
	OR param_contact_level IS NULL
	OR param_contact_type IS NULL THEN
		RETURN FALSE ;
	END IF ;

	-- Validate address_id, if supplied
	IF param_address_id IS NOT NULL THEN
		SELECT COUNT(*)
		INTO   v_counter
		FROM   address
		WHERE  address_id = param_address_id;

		IF v_counter = 0 THEN
			RETURN FALSE ;
		END IF ;
	END IF ;

	-- Validate contact_level
	SELECT COUNT(*)
	INTO   v_counter
	FROM   contact_level
	WHERE  contact_level = param_contact_level ;

	IF v_counter = 0 THEN
		RETURN FALSE ;
	END IF ;

	-- Validate contact_type
	SELECT COUNT(*)
	INTO   v_counter
	FROM   contact_type
	WHERE  contact_type = param_contact_type ;

	IF v_counter = 0 THEN
		RETURN FALSE ;
	END IF ;

	-- Create contact record
	SELECT NEXTVAL('csctoss.contact_contact_id_seq') INTO v_contact_id ;

	INSERT INTO contact (
		contact_id,
		billing_entity_id,
		family_name,
		given_name,
		title,
		email_address,
		phone_number,
		alternate_phone_number,
		fax_number,
		send_product_info,
		contact_level,
		contact_type)
	VALUES (
		v_contact_id,
		param_billing_entity_id,
		param_family_name,
		param_given_name,
		param_title,
		param_email_address,
		param_phone_number,
		param_alternate_phone_number,
		param_fax_number,
		param_send_product_info,
		param_contact_level,
		param_contact_type) ;

	-- Create address linkage record if address_id was passed in
	IF param_address_id IS NOT NULL THEN
		INSERT INTO contact_address (
			contact_id,
			address_type,
			address_id)
		VALUES (
			v_contact_id,
			UPPER(param_address_type),
			param_address_id) ;
	END IF ;

	RETURN TRUE ;
END ;
$_$;


ALTER FUNCTION csctoss.contact_insert_ui(integer, text, text, text, text, text, text, text, boolean, text, text, integer, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION contact_insert_ui(integer, text, text, text, text, text, text, text, boolean, text, text, integer, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION contact_insert_ui(integer, text, text, text, text, text, text, text, boolean, text, text, integer, text) IS 'Handle contact inserts from the UI.';


--
-- Name: contact_insert_ui(integer, text, text, text, text, text, text, text, boolean, text, text, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION contact_insert_ui(integer, text, text, text, text, text, text, text, boolean, text, text, text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
	param_billing_entity_id			ALIAS FOR $1  ;
	param_family_name				ALIAS FOR $2  ;
	param_given_name				ALIAS FOR $3  ;
	param_title						ALIAS FOR $4  ;
	param_email_address				ALIAS FOR $5  ;
	param_phone_number				ALIAS FOR $6  ;
	param_alternate_phone_number	ALIAS FOR $7  ;
	param_fax_number				ALIAS FOR $8  ;
	param_send_product_info			ALIAS FOR $9  ;
	param_contact_level				ALIAS FOR $10 ;
	param_contact_type				ALIAS FOR $11 ;
	param_address_id				ALIAS FOR $12 ;
	param_address_type				ALIAS FOR $13 ;

	v_address_id					INTEGER ;
	v_result						BOOLEAN := FALSE;
BEGIN
	-- This is an overloaded version of the primary function to allow for
	-- differences in passing null values from Java
	--
	-- Please do not use this version if it is not necessary

	IF param_address_id = 'NULL'
	OR param_address_id = 'null' THEN
		SELECT contact_insert_ui (param_billing_entity_id, param_family_name,
					param_given_name, param_title, param_email_address,
					param_phone_number, param_alternate_phone_number,
					param_fax_number, param_send_product_info,
					param_contact_level, param_contact_type,
					NULL, param_address_type)
		INTO   v_result ;
	ELSE
		SELECT contact_insert_ui (param_billing_entity_id, param_family_name,
					param_given_name, param_title, param_email_address,
					param_phone_number, param_alternate_phone_number,
					param_fax_number, param_send_product_info,
					param_contact_level, param_contact_type,
					param_address_id::INTEGER, param_address_type)
		INTO   v_result ;
	END IF ;

	RETURN v_result ;
END ;
$_$;


ALTER FUNCTION csctoss.contact_insert_ui(integer, text, text, text, text, text, text, text, boolean, text, text, text, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION contact_insert_ui(integer, text, text, text, text, text, text, text, boolean, text, text, text, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION contact_insert_ui(integer, text, text, text, text, text, text, text, boolean, text, text, text, text) IS 'Handle contact inserts from the UI that require a string for a NULL address_id.  This is an overloaded version of the original function.';


--
-- Name: create_insert_statement(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION create_insert_statement(text) RETURNS SETOF text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
    param_username    ALIAS FOR $1;
    var_sql           text;
BEGIN
/*
  SELECT dblink_build_sql_insert INTO var_sql FROM dblink_build_sql_insert('username', '1', 1, '{"4047837961@vzw3g.com"}', '{"4047837961@vzw3g.com"}'); RETURN NEXT var_sql || ';';
  SELECT dblink_build_sql_insert INTO var_sql FROM dblink_build_sql_insert('usergroup', '1', 1, array((SELECT id FROM usergroup WHERE username = '4047837961@vzw3g.com')), array((SELECT id FROM usergroup WHERE username = '4047837961@vzw3g.com'))); RETURN NEXT var_sql || ';';
  SELECT dblink_build_sql_insert INTO var_sql FROM dblink_build_sql_insert('radcheck', '1', 1, array((SELECT id FROM radcheck WHERE username = '4047837961@vzw3g.com')), array((SELECT id FROM radcheck WHERE username = '4047837961@vzw3g.com'))); RETURN NEXT var_sql || ';';
  SELECT dblink_build_sql_insert INTO var_sql FROM dblink_build_sql_insert('radreply', '1', 1, array((SELECT id FROM radreply WHERE username = '4047837961@vzw3g.com')), array((SELECT id FROM radreply WHERE username = '4047837961@vzw3g.com'))); RETURN NEXT var_sql || ';';
*/

--  SELECT dblink_build_sql_insert INTO var_sql FROM dblink_build_sql_insert('username', '1', 1, (SELECT array[param_username]), (SELECT array[param_username])); RETURN NEXT var_sql || ';';
--  SELECT dblink_build_sql_insert INTO var_sql FROM dblink_build_sql_insert('usergroup', '1', 1, (SELECT array((SELECT id FROM usergroup WHERE username = param_username ORDER BY id LIMIT 1))), (SELECT array((SELECT id FROM usergroup WHERE username = param_username ORDER BY id LIMIT 1)))); RETURN NEXT var_sql || ';';
--  SELECT dblink_build_sql_insert INTO var_sql FROM dblink_build_sql_insert('radcheck', '1', 1, (SELECT array((SELECT id FROM radcheck WHERE username = param_username))), (SELECT array((SELECT id FROM radcheck WHERE username = param_username)))); RETURN NEXT var_sql || ';';
--  SELECT dblink_build_sql_insert INTO var_sql FROM dblink_build_sql_insert('radreply', '1', 1, (SELECT array((SELECT id FROM radreply WHERE username = param_username ORDER BY id LIMIT 1))), (SELECT array((SELECT id FROM radreply WHERE username = param_username ORDER BY id LIMIT 1)))); RETURN NEXT var_sql || ';';
--  SELECT dblink_build_sql_insert INTO var_sql FROM dblink_build_sql_insert('radreply', '1', 1, (SELECT array((SELECT id FROM radreply WHERE username = param_username AND attribute = 'Framed-IP-Address'))), (SELECT array((SELECT id FROM radreply WHERE username = param_username AND attribute = 'Framed-IP-Address')))); RETURN NEXT var_sql || ';';
  SELECT dblink_build_sql_insert INTO var_sql FROM dblink_build_sql_insert('radreply', '1', 1, (SELECT array((SELECT id FROM radreply WHERE username = param_username AND attribute = 'Class'))), (SELECT array((SELECT id FROM radreply WHERE username = param_username AND attribute = 'Class')))); RETURN NEXT var_sql || ';';

  RETURN;
END;
$_$;


ALTER FUNCTION csctoss.create_insert_statement(text) OWNER TO csctoss_owner;

--
-- Name: date_range_overlap(date, date, date, date); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION date_range_overlap(date, date, date, date) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_range1_start		ALIAS FOR $1 ;
	v_range1_end		ALIAS FOR $2 ;
	v_range2_start		ALIAS FOR $3 ;
	v_range2_end		ALIAS FOR $4 ;
	v_retval			BOOLEAN := FALSE ;
BEGIN
	IF v_range2_start BETWEEN v_range1_start AND v_range1_end THEN
		v_retval := TRUE ;
	END IF ;
	IF v_range2_end BETWEEN v_range1_start AND v_range1_end THEN
		v_retval := TRUE ;
	END IF ;
	IF v_range1_start BETWEEN v_range2_start AND v_range2_end THEN
		v_retval := TRUE ;
	END IF ;
	IF v_range1_end BETWEEN v_range2_start AND v_range2_end THEN
		v_retval := TRUE ;
	END IF ;

	RETURN v_retval ;
END ;
$_$;


ALTER FUNCTION csctoss.date_range_overlap(date, date, date, date) OWNER TO csctoss_owner;

--
-- Name: FUNCTION date_range_overlap(date, date, date, date); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION date_range_overlap(date, date, date, date) IS 'Check for overlap between two date ranges';


--
-- Name: delete_broadcast_message(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION delete_broadcast_message(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
 DECLARE 
 
       par_broadcast_id                       integer := $1;
       var_broadcast_message_group_id         integer;
       var_return                             text;
       
 BEGIN 
 
       IF par_broadcast_id IS NULL THEN 
 
          RAISE EXCEPTION 'ERROR: par_broadcast_id is Null.';
           
       ELSE 

          SELECT broadcast_message_group_id
          INTO var_broadcast_message_group_id
          FROM broadcast_message_data
          WHERE broadcast_id = par_broadcast_id;
        
           IF var_broadcast_message_group_id IS NULL THEN 
 
             var_return := 'Broadcast_message_group_id is Null. Hence no data to be deleted from broadcast_message_group.';
             --RETURN var_return;
                    
          ELSE 
       
             DELETE FROM broadcast_message_group 
             WHERE broadcast_message_group_id = var_broadcast_message_group_id ;
          
                IF NOT FOUND THEN 
 
                    RAISE EXCEPTION 'Delete Failed for Broadcast_Message_Group.';
                  
                END IF;

          END IF;

          DELETE FROM broadcast_message_data
          WHERE broadcast_id = par_broadcast_id ;
            
             IF NOT FOUND THEN 
 
                RAISE EXCEPTION 'Delete Failed for Broadcast_Message_Data.';
                  
              END IF;

      END IF;

   var_return := 'Deleted the required data.';
   RETURN var_return;           

END;
$_$;


ALTER FUNCTION csctoss.delete_broadcast_message(integer) OWNER TO csctoss_owner;

--
-- Name: device_purge(text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION device_purge(text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
 DECLARE 
 
       par_esn_hex            text := $1;
       par_carrier            text := $2; 
       var_equipment_id       integer; 
       var_return             text;
       var_temp_username      text;
       var_username           text;
       
 BEGIN 
 
          PERFORM public.set_change_log_staff_id(3);
      
       IF par_esn_hex = '' AND par_carrier = '' THEN 

           RAISE EXCEPTION 'Input values ESN HEX and Carrier are Null.';
       
       ELSIF par_esn_hex = '' THEN 

           RAISE EXCEPTION 'Input ESN HEX is Null. Please enter a value.';

       ELSIF par_carrier = '' THEN 

           RAISE EXCEPTION 'Input Carrier Value is Null. Please enter a value.';
 
       END IF;

    -- Retrieve Equipment_ID using ESN HEX 

       SELECT equipment_id INTO var_equipment_id
       FROM unique_identifier 
       WHERE unique_identifier_type = 'ESN HEX'
       AND value = par_esn_hex;

       IF var_equipment_id IS NULL THEN 

           var_return := 'No matching ESN HEX.'; 
           RETURN var_return;

       ELSE 

         IF ( par_carrier = 'SPRINT') THEN 

            -- Retrieve Username value from MDN as carrier is SPRINT
          
              SELECT value INTO var_temp_username
              FROM unique_identifier
              WHERE equipment_id = var_equipment_id
              AND unique_identifier_type = 'MDN'; 

         ELSIF ( par_carrier = 'VERIZON') THEN 

            -- Retrieve Username value from MIN as carrier is Verizon

              SELECT value INTO var_temp_username
              FROM unique_identifier
              WHERE equipment_id = var_equipment_id
              AND unique_identifier_type = 'MIN'; 

         ELSIF ( par_carrier = 'USCC') THEN 
 
             -- Retrieve Username value from MIN as carrier is USCC

              SELECT value INTO var_temp_username
              FROM unique_identifier 
              WHERE equipment_id = var_equipment_id
              AND unique_identifier_type = 'MIN'; 

         ELSE 

              var_return := 'Unknown Carrier.';
              RETURN var_return; 

         END IF;
       
        --Retrive username from username table 

          SELECT username INTO var_username
          FROM username
          WHERE username LIKE var_temp_username || '@%'; 
           

         -- Delete the required details from unique_identifier, username, radreply, usergroup, radcheck tables. 

            DELETE FROM radreply WHERE username = var_username;

            DELETE FROM radcheck WHERE username = var_username;
 
            DELETE FROM usergroup WHERE username = var_username;

            UPDATE line SET radius_username = NULL WHERE radius_username = var_username;

            DELETE FROM username WHERE username = var_username;

            DELETE FROM unique_identifier WHERE equipment_id = var_equipment_id; 

            var_return := 'All the inforamtion for the device has been purged.';

            RETURN var_return; 

       END IF;

END;
$_$;


ALTER FUNCTION csctoss.device_purge(text, text) OWNER TO csctoss_owner;

--
-- Name: dgo_ops_api_line_plan_product_info(text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION dgo_ops_api_line_plan_product_info(text, text) RETURNS SETOF ops_api_line_plan_product_info_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_type                    text      := $1;
  par_value                   text      := $2;
  var_equipment_id            integer;
  var_line_id                 integer;
  var_equipment_type          text;
  var_serial_number           text;
  var_esn_hex                 text;
  var_esn_dec                 text;
  var_min                     text;
  var_mdn                     text;
  var_mac_address             text;
  var_uniqid_row              RECORD;
  v_query                     text;
  var_billing_entity_id       integer;
  var_return_row              ops_api_line_plan_product_info_retval%ROWTYPE;

BEGIN
    RAISE NOTICE 'Entering Function';

  IF LENGTH(TRIM(COALESCE(par_value, ''))) = 0  AND par_type = '' THEN

      RAISE EXCEPTION 'Input Values Are Null.';

  ELSIF par_type = '' THEN

     RAISE EXCEPTION 'Input type is null. Please enter either Unique_Identifier or Line_ID or Username or Static IP Address or Billing_Entity_ID.';


  ELSIF par_value = '' THEN

      RAISE EXCEPTION 'Input value is null. Please enter values for either Unique_Identifier or Line_ID or Username or Static IP Address or Billing_Entity_ID.';

 END IF;
      -- Validate parameters.
   IF par_type = 'Unique_Identifier' THEN

          v_query := 'SELECT ui.equipment_id AS equipment_id,
                           eq.equipment_type AS equipment_type,
                           lieq.line_id AS line_id
                    FROM unique_identifier ui
                    JOIN equipment eq ON(ui.equipment_id = eq.equipment_id)
                    JOIN line_equipment lieq ON (ui.equipment_id = lieq.equipment_id)
                    WHERE ui.unique_identifier_type IN (''ESN HEX'', ''ESN DEC'', ''MDN'', ''MIN'', ''SERIAL NUMBER'', ''MAC ADDRESS'',
                                                                            ''ESN HEX1'', ''ESN HEX2'', ''ESN DEC1'', ''ESN DEC2'', ''MIN1'', ''MIN2'', ''MDN1'', ''MDN2'')
                    AND ui.value LIKE ' ||quote_literal(par_value||'%')|| 'GROUP BY  ui.equipment_id, eq.equipment_type, lieq.line_id LIMIT 100';

         ELSIF par_type = 'Line_ID' THEN

          var_line_id := (par_value)::integer;

            v_query :=  'SELECT  line.line_id AS line_id,
                                 lieq.equipment_id AS equipment_id,
                                 eq.equipment_type AS equipment_type
                         FROM line
                         JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
                         JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
                         WHERE 1=1 
                           AND lieq.end_date is null
                           AND line.line_id = '||(var_line_id)||'';

          ELSIF par_type = 'Username' THEN

            v_query := 'SELECT line.line_id AS line_id,
                                   lieq.equipment_id AS equipment_id,
                                   eq.equipment_type AS equipment_type
                        FROM line
                        JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
                        JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
                        WHERE line.radius_username LIKE '||quote_literal(par_value||'%')||'LIMIT 100';

          ELSIF par_type = 'Static IP Address' THEN

        v_query := 'SELECT line.line_id AS line_id,
                           lieq.equipment_id AS equipment_id,
                           eq.equipment_type AS equipment_type
                    FROM radreply
                    JOIN line ON (radreply.username = line.radius_username)
                    JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
                    JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
                    WHERE radreply.attribute::text = ''Framed-IP-Address''::text
                    AND radreply.value = '||quote_literal(par_value);


          ELSIF par_type = 'Billing_Entity_ID' THEN

          var_billing_entity_id := (par_value)::integer;

            v_query :=  'SELECT  line.line_id AS line_id,
                                 lieq.equipment_id AS equipment_id,
                                 eq.equipment_type AS equipment_type
                     FROM line
                     JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
                     JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
                     WHERE line.billing_entity_id = '||(var_billing_entity_id)||'LIMIT 100';
 END IF;

     FOR var_uniqid_row IN EXECUTE v_query

       LOOP

             var_equipment_id := var_uniqid_row.equipment_id ;
             var_line_id := var_uniqid_row.line_id;
             var_equipment_type := var_uniqid_row.equipment_type;

-- Retrieve Serial Number and Mac Address for the obtained Equipment_Id Value. These are unique for all types of equipments.

     SELECT uid1.value INTO var_serial_number FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'SERIAL NUMBER'::text;

     SELECT uid1.value INTO var_mac_address FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MAC ADDRESS'::text;

   IF var_equipment_type = 'ROUTER' THEN

      -- Get all unique_identifier values for a Router

      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;

      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;

      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text;

      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;

    ELSIF var_equipment_type = 'CARD' THEN

      -- Get the unique_identifiers for the equipment type Card.

      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;

      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;

      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text;

      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;

    ELSIF var_equipment_type = 'MODULE' THEN

      -- Get the unique_identifiers for the equipment_type Module.

      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;

      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;

      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text;

      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;

    END IF;

   FOR var_return_row IN
     SELECT
           CASE
               WHEN line.billing_entity_id IS NOT NULL THEN
                   ( SELECT billing_entity.name
                     FROM billing_entity
                     WHERE billing_entity.billing_entity_id = line.billing_entity_id)
               ELSE NULL::text
           END AS customer_name, line.line_id,
           CASE
               WHEN line.billing_entity_address_id IS NOT NULL THEN
                    (SELECT  locn.location_label
                     FROM billing_entity_location_label locn
                     WHERE locn.billing_entity_address_id = line.billing_entity_address_id
                     AND locn.location_label_type = 'USER DEFINED')
               ELSE NULL::text
            END AS location, line.line_label, line.radius_username, line.notes, --line.active_flag,
            CASE
                WHEN lieq.end_date IS NULL THEN 'TRUE'::text
                WHEN lieq.end_date IS NOT NULL THEN 'FALSE'::text
                ELSE 'N/A'::text
            END AS active_flag,
            pt.plan_type_desc AS plan_type, plan.comment AS plan_comment, prd.product_code,
            plan.start_date, plan.end_date, plan.length_days, plan.prepaid_unit,
            plan.prepaid_allowance, plan.prepaid_balance, eqm.model_description AS model,
            eqm.model_number1 AS model_number, eq.equipment_type,
           (SELECT eqm1.model_number1 FROM equipment_model eqm1
            WHERE eqm1.equipment_model_id = eqm.embedded_equipment_model_id) AS Embedded_Model,
            var_esn_hex, var_esn_dec, var_mdn, var_min, var_serial_number, var_mac_address
    FROM line
    LEFT JOIN plan ON (line.line_id = plan.line_id)
    LEFT JOIN plan_type pt ON (plan.plan_type_id = pt.plan_type_id)
    LEFT JOIN product prd ON ( plan.product_id = prd.product_id)
    JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
    JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
    JOIN equipment_model eqm ON ( eq.equipment_model_id = eqm.equipment_model_id)
    WHERE line.line_id = var_line_id
    --AND lieq.end_date IS NULL
    AND eq.equipment_id = var_equipment_id

    LOOP

         RETURN NEXT var_return_row;

    END LOOP;

  IF ( var_equipment_type = 'MULTI_NETWORK ROUTER') THEN

   FOR var_return_row IN

      SELECT
           CASE
               WHEN line.billing_entity_id IS NOT NULL THEN
                   ( SELECT billing_entity.name
                     FROM billing_entity
                     WHERE billing_entity.billing_entity_id = line.billing_entity_id)
               ELSE NULL::text
           END AS customer_name, line.line_id,
           CASE
               WHEN line.billing_entity_address_id IS NOT NULL THEN
                    (SELECT  locn.location_label
                     FROM billing_entity_location_label locn
                     WHERE locn.billing_entity_address_id = line.billing_entity_address_id
                     AND locn.location_label_type = 'USER DEFINED')
               ELSE NULL::text
            END AS location, line.line_label, line.radius_username, line.notes, --line.active_flag,
            CASE
                WHEN lieq.end_date IS NULL THEN 'TRUE'::text
                WHEN lieq.end_date IS NOT NULL THEN 'FALSE'::text
                ELSE 'N/A'::text
            END AS active_flag,
            pt.plan_type_desc AS plan_type, plan.comment AS plan_comment, prd.product_code,
            plan.start_date, plan.end_date, plan.length_days, plan.prepaid_unit,
            plan.prepaid_allowance, plan.prepaid_balance, eqm.model_description AS model,
            eqm.model_number1 AS model_number, eq.equipment_type,
           (SELECT eqm1.model_number1 FROM equipment_model eqm1
            WHERE eqm1.equipment_model_id = eqm.embedded_equipment_model_id) AS Embedded_Model,
            var_esn_hex, var_esn_dec, var_mdn, var_min, var_serial_number, var_mac_address
          ,(SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN HEX1'::text) AS esn_hex1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN DEC1'::text) AS esn_dec1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MDN1'::text) AS mdn1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MIN1'::text) AS min1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN HEX2'::text) AS esn_hex2,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN DEC2'::text) AS esn_dec2,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MDN2'::text) AS mdn2,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MIN2'::text) AS min2
    FROM line
    LEFT JOIN plan ON (line.line_id = plan.line_id)
    LEFT JOIN plan_type pt ON (plan.plan_type_id = pt.plan_type_id)
    LEFT JOIN product prd ON ( plan.product_id = prd.product_id)
    JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
    JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
    JOIN equipment_model eqm ON ( eq.equipment_model_id = eqm.equipment_model_id)
    WHERE line.line_id = var_line_id
    AND eq.equipment_id = var_equipment_id

    LOOP

         RETURN NEXT var_return_row;

    END LOOP;


END IF;

 END LOOP;

  RAISE NOTICE 'Finished Function.';

    RETURN;
END ;
$_$;


ALTER FUNCTION csctoss.dgo_ops_api_line_plan_product_info(text, text) OWNER TO csctoss_owner;

--
-- Name: dgo_update_usergroup_ip_func(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION dgo_update_usergroup_ip_func() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
v_count                 integer;
v_num_affected          integer;
v_return_text           text;
v_failure_text          text;
v_static_ip             text;
v_static_ip_old         text;
v_radreply_delete_cnt   integer;
v_line_id               integer;
v_static_ip_id_old      integer;
v_static_ip_id          integer;
v_billing_entity_id     integer;

c_rec                   record;
c_sql                   text;
v_header1               text;
v_header2               text;
v_breakout              boolean;
v_carrier               text;

BEGIN

     RAISE NOTICE ' START USERNAME UPDATE PROCESSING';
     c_sql:='SELECT username,usergroup
             FROM  dgo_username_list
             WHERE 1=1
             order by username
--             limit 5
             '
             ;

v_header1:='                                                                          USERGRP  RR/ROWS  OLD IP        NEW IP           RR';

v_header2:='      USERNAME                      USERGROUP                     LINE    UPDTD?   DELTED   UNASSGND      ASSIGNED       INSERT?' ;
RETURN NEXT ' -------------------------------------------------------------------------------------';
RETURN NEXT '                     BEGIN PROCESSING OF USERGROUP/VRF UPDATE';
RETURN NEXT ' -------------------------------------------------------------------------------------';
RETURN NEXT '';
RETURN NEXT v_header1;
RETURN NEXT v_header2;

FOR c_rec IN execute c_sql
  LOOP
    BEGIN
        v_count:=0;
        v_line_id:=null;
        v_return_text:=null;
        v_static_ip_id_old:=null;
        v_static_ip_id:=null;
        v_static_ip:=null;
        v_static_ip_old:=null;
        v_return_text:=rpad(c_rec.username,32)||'  ';
        v_return_text:=v_return_text||rpad(c_rec.usergroup,30)||'  ';
--
        v_carrier:=
             (
             CASE
                when  c_rec.username like '%sprint%' then 'SPRINT'
                when  c_rec.username like '%vzw%' then 'VZW'
                when  c_rec.username like '%uscc%' then 'USCC'
                else
                   'UNKNOWN'
             END  ) ;

        v_failure_text:='No username match in line table-- ';
        select count(*) INTO v_count
        FROM line
        where 1=1
          and radius_username=c_rec.username;
        IF v_count = 1 THEN
            select line_id,billing_entity_id into v_line_id,v_billing_entity_id
            from line
            where 1=1
              and radius_username=c_rec.username;
        ELSE
            select 1/0;
        END IF;

        v_failure_text:='Currently assigned a public IP Address -- ';
        select count(*) into v_count
        from static_ip_pool
        where 1=1
          and line_id = v_line_id
          and groupname like '%public%';
        IF v_count <> 0 THEN
            select 1/0;
        END IF;
        v_failure_text:=' Current usergroup for username has no match in usergroup table.';
        SELECT count(*) INTO v_count
        FROM usergroup ug
        WHERE 1=1
          AND c_rec.username = ug.username
          AND priority=50000;
        IF v_count = 0 THEN
           select 1/0;
        END IF;
        v_failure_text:='No entry in radcheck for this username.';
        select count(*) into v_count
        from radcheck rc
        where 1=1
          and rc.username = c_rec.username;
        IF v_count <> 1 THEN
            select 1/0;
        END IF;

        select count(*) into v_radreply_delete_cnt
        from radreply
        where 1=1
          and username=c_rec.username
          and attribute='Framed-IP-Address';
--
--
        SELECT count(*) INTO v_count
        FROM static_ip_pool
        WHERE 1=1
          AND line_id=v_line_id;
        IF v_count = 0 THEN
            v_static_ip_old:='N/A';
        ELSE
            SELECT id,static_ip into v_static_ip_id_old,v_static_ip_old
            FROM static_ip_pool
            WHERE 1=1
              AND line_id=v_line_id;
        END IF;
          v_breakout:=false;
          EXCEPTION
              when others THEN
              RETURN NEXT v_return_text;
              RETURN NEXT '   FAILURE -- '|| v_failure_text;
              v_breakout:=true;
        END;
        BEGIN
          if not v_breakout THEN
--
           v_failure_text:='Deleting rows from radreply';
           delete from radreply
           where 1=1
             and  username=c_rec.username
             and attribute='Framed-IP-Address';
            GET DIAGNOSTICS v_num_affected = ROW_COUNT;
            IF v_num_affected <> v_radreply_delete_cnt THEN
                select 1/0;
            END IF;
--                         begin modifications
           v_failure_text:='Setting old IP to unassigned in static_ip_pool';
           IF v_static_ip_old <> 'N/A' THEN
               UPDATE static_ip_pool SET is_assigned = false, line_id=null
               WHERE 1=1
                  AND line_id=v_line_id;
               GET DIAGNOSTICS v_num_affected = ROW_COUNT;
               IF v_num_affected = 0 THEN
                   select 1/0;
               END IF;
           END IF;
--
           v_failure_text:='Failed to update usergroup table with new usergroup for username ';
           UPDATE usergroup  SET groupname = c_rec.usergroup
           WHERE username = c_rec.username;
           GET DIAGNOSTICS v_num_affected = ROW_COUNT;
           IF v_num_affected = 0 THEN
               select 1/0;
           END IF;
--
          v_failure_text:='Call to ops_api_static_ip_assign failed';
        v_static_ip:=(ops_api_static_ip_assign(v_carrier, c_rec.usergroup,c_rec.username,v_line_id, v_billing_entity_id));
--
        v_return_text:=v_return_text||lpad(v_line_id,5);
        v_return_text:=v_return_text|| '     Y   ';
        v_return_text:=v_return_text||'      '||v_radreply_delete_cnt;
        v_return_text:=v_return_text|| '    '||rpad(v_static_ip_old, 14);
        v_return_text:=v_return_text|| '   '||rpad(v_static_ip, 14);
        v_return_text:=v_return_text|| '  Y';
        RETURN NEXT v_return_text;
--        raise notice ' End processing for : %',c_rec.username;
--        raise notice ' -------------------------------------------------------------------------------------';
       END IF;
       EXCEPTION
          when others THEN
          RETURN NEXT v_return_text;
          v_failure_text:='   --FAILURE-- '||v_failure_text;
          RETURN NEXT v_failure_text;
       END;
--
  END LOOP;
--RETURN NEXT 'xxx';
 RETURN;
END;

  $$;


ALTER FUNCTION csctoss.dgo_update_usergroup_ip_func() OWNER TO csctoss_owner;

--
-- Name: emod_credential_pre_insert_update(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION emod_credential_pre_insert_update() RETURNS "trigger"
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  IF (SELECT COUNT(*) >= 1
        FROM csctoss.equipment_model_credential
       WHERE equipment_model_id = NEW.equipment_model_id
         AND credential_set <> NEW.credential_set
         AND preferred_set
         AND NEW.preferred_set) THEN
    RAISE EXCEPTION 'Equipment Model ID % already has a preferred set of credentials.', NEW.equipment_model_id ;
  END IF ;
  RETURN NEW ;
END ;
$$;


ALTER FUNCTION csctoss.emod_credential_pre_insert_update() OWNER TO csctoss_owner;

--
-- Name: equipment_credential_populate(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION equipment_credential_populate() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE

  var_equipment_id          integer ;
  var_password              text ;
  var_sql                   text ;

  rec_cred                  record ;
  rec_exec                  record ;

BEGIN

  PERFORM public.set_change_log_staff_id(3) ;

  -- driving cursor to grab all data at once for new equipment
  FOR rec_cred IN SELECT equp.equipment_id
                        ,emcr.equipment_model_id
                        ,emcr.credential_set
                        ,emcr.preferred_set
                        ,emcr.username
                        ,emcr.password
                        ,emcr.derived
                    FROM csctoss.equipment equp
                    JOIN csctoss.equipment_model_credential emcr USING (equipment_model_id)
                   WHERE NOT EXISTS (select equipment_id
                                       from csctoss.equipment_credential
                                      where equipment_id = equp.equipment_id)
                ORDER BY equp.equipment_id
                        ,emcr.credential_set
  LOOP

    -- if the value is derived then dynamically retrieve using sql statement provided in password field
    IF rec_cred.derived THEN
      var_password := NULL ;
      var_sql := rec_cred.password||rec_cred.equipment_id ;
      FOR rec_exec IN EXECUTE var_sql LOOP
        var_password := rec_exec.password ;
      END LOOP ;
    ELSE
      var_password := rec_cred.password ;
    END IF ;

    -- if password is null, report it for logging
    IF var_password IS NULL THEN
      RETURN NEXT 'NOTICE: Equipment ID '||rec_cred.equipment_id::text||' Credential Set '||rec_cred.credential_set::text||' password is NULL.' ;
    END IF ;

   -- perform the insert
    INSERT INTO csctoss.equipment_credential
               (equipment_id
               ,credential_set
               ,preferred_set
               ,username
               ,password)
        VALUES (rec_cred.equipment_id
               ,rec_cred.credential_set
               ,rec_cred.preferred_set
               ,rec_cred.username
               ,var_password) ;

  END LOOP ;

  -- take a pass through table with null passwords and try to backfill
  FOR rec_cred IN SELECT ecrd.equipment_credential_id
                        ,ecrd.equipment_id
                        ,ecrd.credential_set
                        ,ecrd.username
                        ,emcr.password
                        ,emcr.derived
                    FROM csctoss.equipment_credential ecrd
                    JOIN csctoss.equipment equp USING (equipment_id)
                    JOIN csctoss.equipment_model_credential emcr ON 
                        (equp.equipment_model_id = emcr.equipment_model_id AND ecrd.credential_set = emcr.credential_set)
                   WHERE ecrd.password IS NULL
                ORDER BY ecrd.equipment_id
                        ,ecrd.credential_set
  LOOP

    -- if the value is derived then dynamically retrieve using sql statement provided in password field
    IF rec_cred.derived THEN
      var_password := NULL ;
      var_sql := rec_cred.password||rec_cred.equipment_id ;
      FOR rec_exec IN EXECUTE var_sql LOOP
        var_password := rec_exec.password ;
      END LOOP ;
    ELSE
      var_password := rec_cred.password ;
    END IF ;

    -- if password is null, do nothing, otherwise update
    IF var_password IS NOT NULL THEN
      UPDATE csctoss.equipment_credential
         SET password = var_password
       WHERE equipment_credential_id = rec_cred.equipment_credential_id ;
    END IF ;

  END LOOP ;

  RETURN NEXT 'SUCCESS' ;
  RETURN ;

END ;

$$;


ALTER FUNCTION csctoss.equipment_credential_populate() OWNER TO csctoss_owner;

--
-- Name: equipment_credential_pre_insert_update(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION equipment_credential_pre_insert_update() RETURNS "trigger"
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  IF (SELECT COUNT(*) >= 1
        FROM csctoss.equipment_credential
       WHERE equipment_id = NEW.equipment_id
         AND preferred_set
         AND equipment_credential_id <> NEW.equipment_credential_id) AND NEW.preferred_set THEN

    RAISE EXCEPTION 'Equipment ID % already has a preferred set of credentials.', NEW.equipment_id ;
  END IF ;
  RETURN NEW ;
END ;
$$;


ALTER FUNCTION csctoss.equipment_credential_pre_insert_update() OWNER TO csctoss_owner;

--
-- Name: esn_dec_to_esn_hex(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION esn_dec_to_esn_hex(text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
  var_front     text ;
  var_back      text ;
  var_length	integer ;
  var_return	text ;
BEGIN

  -- check parm, split the decimal value, trim any leading zeros
  var_length := length($1) ;
  IF var_length <> 11 THEN
    RAISE EXCEPTION 'ESN DEC must be 11 characters. % is only % characters', $1, var_length ;
  END IF ;

  var_front := ltrim(substr($1,1,3),'0') ;
  var_back  := ltrim(substr($1,4,8),'0') ;

  -- convert to hex, set to upper, put back together and return
  var_front := upper(to_hex(var_front::int)) ;
  var_back  := upper(to_hex(var_back::int)) ;

  RETURN var_front||var_back ;

END ;
$_$;


ALTER FUNCTION csctoss.esn_dec_to_esn_hex(text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION esn_dec_to_esn_hex(text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION esn_dec_to_esn_hex(text) IS 'Simple function to convert ESN DEC to ESN HEX according to USCC encoding rules.';


--
-- Name: esn_hex_to_esn_dec(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION esn_hex_to_esn_dec(text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
  var_front     text ;
  var_back      text ;
  var_length	integer ;
  v_return	record ;
BEGIN

  -- get the decimal value for the first 2 hex characters
  FOR v_return IN EXECUTE 'select x''' || substr($1,1,2) || '''::int::text AS value' LOOP
    var_front := v_return.value ;
  END LOOP ;

  -- get the decimal value for the remaining hex characters
  FOR v_return IN EXECUTE 'select x''' || substr($1,3) || '''::int::text AS value' LOOP
    var_back := v_return.value ;
  END LOOP ;

  -- check length and pad as necessary
  WHILE length(var_front) < 3 LOOP
    var_front := '0'||var_front ;
  END LOOP ;
  WHILE length(var_back) < 8 LOOP
    var_back := '0'||var_back ;
  END LOOP ;

  var_length := length(var_front||var_back) ;
  IF var_length != 11 THEN
    RAISE EXCEPTION 'ESN DEC converted to % digits. Must be 11 digits.', var_length ;
  END IF ;

  RETURN var_front || var_back ;

END ;
$_$;


ALTER FUNCTION csctoss.esn_hex_to_esn_dec(text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION esn_hex_to_esn_dec(text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION esn_hex_to_esn_dec(text) IS 'Simple function to convert ESN HEX to ESN DEC according to USCC encoding rules.';


--
-- Name: expand_be_children(refcursor, integer, integer, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION expand_be_children(refcursor, integer, integer, integer) RETURNS SETOF billing_entity_structure_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
	i_children		REFCURSOR	:= $1 ;
	i_level			INTEGER		:= $2 ;
	i_beid			INTEGER		:= $3 ;
	i_master_beid		INTEGER		:= $4 ;
	be_rec			BILLING_ENTITY_STRUCTURE_RETVAL ;
	rc_children		REFCURSOR ;
	vr_children		BILLING_ENTITY_STRUCTURE_RETVAL ;
	v_level			INTEGER 	:= 0 ;
	v_counter		INTEGER		:= 0 ;
BEGIN
	IF i_level > 10 THEN
		RAISE EXCEPTION 'Child company recursion level exceeded' ;
	END IF ;

	LOOP
		FETCH i_children INTO be_rec ;

		IF NOT FOUND THEN
			EXIT ;
		END IF ;

		SELECT COUNT(*)
		INTO   v_counter
		FROM   billing_entity
		WHERE  parent_billing_entity_id = be_rec.billing_entity_id ;

		IF v_counter > 0 THEN
			-- This company has children
			v_level := i_level + 1 ;

			OPEN rc_children FOR
			SELECT billing_entity_id AS my_beid,
			       parent_billing_entity_id AS my_parent,
			       i_master_beid AS my_master,
			       v_level AS my_level,
			       name AS my_name
			FROM   billing_entity
			WHERE  parent_billing_entity_id = be_rec.billing_entity_id ;

			FOR vr_children IN
			SELECT *
			FROM   expand_be_children (rc_children,
						   v_level,
						   be_rec.billing_entity_id,
						   i_master_beid )
			LOOP
				RETURN NEXT vr_children ;
			END LOOP ;

			CLOSE rc_children ;
		END IF ;

		RETURN NEXT be_rec ;
	END LOOP ;

	RETURN ;
END ;
$_$;


ALTER FUNCTION csctoss.expand_be_children(refcursor, integer, integer, integer) OWNER TO csctoss_owner;

--
-- Name: FUNCTION expand_be_children(refcursor, integer, integer, integer); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION expand_be_children(refcursor, integer, integer, integer) IS 'Retrieve child companies for any given billing entity, recursively';


--
-- Name: fetch_csctlog_conn(); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION fetch_csctlog_conn() RETURNS text
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
  var_conn_string    text ;
BEGIN
  SELECT 'hostaddr='||ip_address||
            ' port='||repl_port||
          ' dbname='||repl_target_db||
            ' user='||repl_target_username||
        ' password='||repl_target_password
    INTO var_conn_string
    FROM csctoss.system_parameter
   WHERE hostname = 'CSCTLOG' ;
  RETURN COALESCE(var_conn_string,'ERROR retrieving connection information for CSCTLOG.') ;
END ;
$$;


ALTER FUNCTION csctoss.fetch_csctlog_conn() OWNER TO slony;

--
-- Name: FUNCTION fetch_csctlog_conn(); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION fetch_csctlog_conn() IS 'Returns a string of connection information for the csctlog database based on entry in system_parameter table.';


--
-- Name: fetch_csctmon_conn(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION fetch_csctmon_conn() RETURNS text
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
  var_conn_string    text ;
BEGIN
  SELECT 'hostaddr='||ip_address||
            ' port='||repl_port||
          ' dbname='||repl_target_db||
            ' user='||repl_target_username||
        ' password='||repl_target_password
    INTO var_conn_string
    FROM csctoss.system_parameter
   WHERE hostname = 'CSCTMON' ;
  RETURN COALESCE(var_conn_string,'ERROR retrieving connection information for CSCTOSS.') ;
END ;
$$;


ALTER FUNCTION csctoss.fetch_csctmon_conn() OWNER TO csctoss_owner;

--
-- Name: FUNCTION fetch_csctmon_conn(); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION fetch_csctmon_conn() IS 'Returns a string of connection information for the csctmon database based on entry in system_parameter table.';


--
-- Name: fetch_csctoss_conn(); Type: FUNCTION; Schema: csctoss; Owner: postgres
--

CREATE FUNCTION fetch_csctoss_conn() RETURNS text
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
  var_conn_string    text ;
BEGIN
  SELECT 'hostaddr='||ip_address||
            ' port='||repl_port||
          ' dbname='||repl_target_db||
            ' user='||repl_target_username||
        ' password='||repl_target_password
    INTO var_conn_string
    FROM csctlog.system_parameter
   WHERE hostname = 'CSCTOSS' ;
  RETURN COALESCE(var_conn_string,'ERROR retrieving connection information for CSCTOSS.') ;
END ;
$$;


ALTER FUNCTION csctoss.fetch_csctoss_conn() OWNER TO postgres;

--
-- Name: FUNCTION fetch_csctoss_conn(); Type: COMMENT; Schema: csctoss; Owner: postgres
--

COMMENT ON FUNCTION fetch_csctoss_conn() IS 'Returns a string of connection information for the csctoss database based on entry in system_parameter table.';


--
-- Name: fetch_ip_for_line_id(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION fetch_ip_for_line_id(integer) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_line_id                   integer := $1 ;
  var_return                    text := '' ;

BEGIN

  IF par_line_id IS NULL THEN
    RETURN var_return ;
  END IF ;

  -- execute query to log database over dblink
  SELECT *
    INTO var_return
    FROM public.dblink((select * from csctoss.fetch_csctlog_conn())
                      ,'select framedipaddress
                          from csctlog.master_radacct
                         where class = '||quote_literal(par_line_id::varchar)||'
                           and acctstoptime is null
                           and acctstarttime > current_timestamp - interval ''1 day''
                      order by master_radacctid desc
                         limit 1')
      AS rec_type(framedipaddress text) ;

  RETURN COALESCE(var_return,'') ;

END ;
$_$;


ALTER FUNCTION csctoss.fetch_ip_for_line_id(integer) OWNER TO csctoss_owner;

--
-- Name: FUNCTION fetch_ip_for_line_id(integer); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION fetch_ip_for_line_id(integer) IS 'Returns mrac.framedipaddress for currently connected session for given line_id.';


--
-- Name: fetch_jbilling_conn(); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION fetch_jbilling_conn() RETURNS text
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
  var_conn_string    text ;
BEGIN
  SELECT 'hostaddr='||ip_address||
            ' port='||repl_port||
          ' dbname='||repl_target_db||
            ' user='||repl_target_username||
        ' password='||repl_target_password
    INTO var_conn_string
    FROM csctoss.system_parameter
   WHERE hostname = 'JBILLING' ;
  RETURN COALESCE(var_conn_string,'ERROR retrieving connection information for JBilling.') ;
END ;
$$;


ALTER FUNCTION csctoss.fetch_jbilling_conn() OWNER TO slony;

--
-- Name: FUNCTION fetch_jbilling_conn(); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION fetch_jbilling_conn() IS 'Returns a string of connection information for the JBilling database based on entry in system_parameter table.';


--
-- Name: fetch_max_ip_address(text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION fetch_max_ip_address(text, text) RETURNS inet
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_table_name	text := $1 ;
  par_partial_ip	text := $2 ;

  var_sql		text ;
  var_max_ip_address	text ;

  cur_dynsql		refcursor ;

BEGIN

  -- verify parameters
  IF LOWER(par_table_name) NOT IN ('radcheck','radgroupcheck','radgroupreply','radreply') THEN
    RAISE EXCEPTION 'Table % invalid. Table must be radcheck, radgroupcheck, radgroupreply or radreply', par_table_name ;
  ELSIF par_partial_ip = '' THEN 
    RAISE EXCEPTION 'Partial IP cannot be empty' ;
  ELSIF par_partial_ip NOT LIKE '%.%' THEN
    RAISE EXCEPTION 'Partial IP must have at least one dot (.)' ;
  END IF ;

  -- build sql statement, open cursor, fetch, close cursor
  var_sql := ' select value::inet from '||par_table_name||
             ' where value like '''||par_partial_ip||'%'''||
             ' order by value desc limit 1 ; ' ;

  OPEN cur_dynsql FOR EXECUTE var_sql ;
    FETCH cur_dynsql INTO var_max_ip_address ;
  CLOSE cur_dynsql ;

  -- evaluate and return results
  IF var_max_ip_address IS NULL THEN
    RAISE EXCEPTION 'No entries found in % table for partial ip %', par_table_name, par_partial_ip ;
  END IF ;

  RETURN var_max_ip_address ;

END ;

$_$;


ALTER FUNCTION csctoss.fetch_max_ip_address(text, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION fetch_max_ip_address(text, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION fetch_max_ip_address(text, text) IS 'Simple function to fetch the highest value for a partial ip address from given table passed as parameter.';


--
-- Name: fetch_mrac_by_date_range(integer, date, date); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION fetch_mrac_by_date_range(integer, date, date) RETURNS SETOF fetch_mrac_by_date_range_retval
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_line_id               integer := $1 ;
  par_start_date            date    := $2 ;
  par_end_date              date    := $3 ;

  var_preferred_timezone    text ;
  var_equipment_id          integer ;

  -------------------------------------------
  -- return record parameters fetched once --
  -------------------------------------------
  var_line_label                text ;
  var_calling_station_id        text ;
  var_line_radius_username      text ;
  var_esn_or_serial             text ;
  var_billing_entity_id         integer ;
  var_billing_entity_address_id integer ;
  var_line_assignment_type      text ;
  var_location_label_type       text ;
  var_location_label            text ;
  var_address                   text ;

  ------------------------------------
  -- totals returned as last record --
  ------------------------------------
  var_tot_bytes_in              bigint := 0 ;
  var_tot_bytes_out             bigint := 0 ;
  var_tot_seconds_connected     bigint := 0 ;
  var_tot_time_connected        text ;
  
  var_sql                       text ;
  var_return                    fetch_mrac_by_date_range_retval ;

BEGIN

  -- validate parameters
  IF par_line_id IS NULL OR par_start_date IS NULL OR par_end_date IS NULL THEN
    RAISE EXCEPTION 'Line ID, Start Date and End Date are required parameters.' ;
  ELSIF par_end_date < par_start_date THEN
    RAISE EXCEPTION 'Start Date must be before or equal to End Date.' ;
  ELSIF (SELECT COUNT(*)
           FROM csctoss.line
          WHERE line_id = par_line_id) = 0 THEN
    RAISE EXCEPTION 'Line ID % does not exist.', par_line_id ;
  END IF ;

  -- add a day to the end date to avoid at time zone in where clause which kills performance
  par_end_date := par_end_date + interval '1 day' ;

  -- fetch all line and billing_entity data once
  SELECT line.line_label
        ,COALESCE(line.calling_station_id,SUBSTR(line.radius_username,1,10))
        ,line.radius_username
        ,line.line_assignment_type
        ,bent.billing_entity_id
        ,line.billing_entity_address_id
        ,bent.preferred_timezone
    INTO var_line_label
        ,var_calling_station_id
        ,var_line_radius_username
        ,var_line_assignment_type
        ,var_billing_entity_id
        ,var_billing_entity_address_id
        ,var_preferred_timezone
    FROM csctoss.line
    JOIN csctoss.billing_entity bent USING (billing_entity_id)
   WHERE line.line_id = par_line_id ;

  -- get the address and location information once
  SELECT addr.line1||' '||CASE WHEN addr.line2 IS NULL THEN '' ELSE addr.line2||' ' END
                        ||CASE WHEN addr.line3 IS NULL THEN '' ELSE addr.line3||' ' END
                        ||CASE WHEN addr.line4 IS NULL THEN '' ELSE addr.line4||' ' END
                        ||addr.city||', '||addr.state_code||' '||postal_code
        ,ball.location_label_type
        ,ball.location_label
    INTO var_address
        ,var_location_label_type
        ,var_location_label
    FROM csctoss.address addr
    JOIN csctoss.billing_entity_location_label ball ON (addr.address_id = ball.billing_entity_address_id)
   WHERE addr.address_id = var_billing_entity_address_id ;

  -- get the esn or serial number once
  SELECT uniq.value
    INTO var_esn_or_serial
    FROM csctoss.line_equipment lieq
    JOIN csctoss.unique_identifier uniq USING (equipment_id)
    JOIN csctoss.equipment equp USING (equipment_id)
   WHERE lieq.line_id = par_line_id
     AND lieq.end_date IS NULL
     AND equp.equipment_type IN ('CARD','MODULE', 'ROUTER')
     AND uniq.unique_identifier_type = CASE WHEN equp.equipment_type = 'ROUTER'
                                            THEN 'SERIAL NUMBER'
                                            ELSE 'ESN DEC'
                                       END
ORDER BY lieq.start_date DESC
   LIMIT 1 ;

  IF var_esn_or_serial IS NULL THEN
    var_esn_or_serial := 'NOT FOUND' ;
  END IF ;

  -- dynamically build the sql statement
  var_sql := 'SELECT master_radacctid
                    ,'||quote_literal(par_line_id::varchar)||'
                    ,'||quote_literal(var_line_label)||'
                    ,'||quote_literal(var_calling_station_id)||'
                    ,username
                    ,'||quote_literal(var_esn_or_serial)||'
                    ,'||var_billing_entity_id||'
                    ,acctstarttime at time zone '||quote_literal(var_preferred_timezone)||'::text as start_time
                    ,acctstoptime at time zone '||quote_literal(var_preferred_timezone)||'::text as stop_time
                    ,framedipaddress
                    ,acctinputoctets as bytes_in
                    ,acctoutputoctets as bytes_out
                    ,normalize_epoch((EXTRACT(EPOCH FROM acctstoptime) - 
                                      EXTRACT(EPOCH FROM acctstarttime))::bigint,''HOUR'')::text AS time_connected
                    ,'||quote_literal(var_line_assignment_type)||'
                    ,'||quote_literal(var_location_label_type)||'
                    ,'||quote_literal(var_location_label)||'
                    ,'||quote_literal(var_address)||'
                    ,acctstarttime::timestamp as start_timestamp
                    ,acctstoptime::timestamp as stop_timestamp
                FROM csctlog.master_radacct
               WHERE acctstoptime IS NOT NULL
                 AND class = '||quote_literal(par_line_id::varchar)||'
                 AND acctstoptime >= '||quote_literal(par_start_date)||'
                 AND acctstoptime <= '||quote_literal(par_end_date)||'
            ORDER BY acctstarttime' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR var_return IN SELECT *
                      FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                        AS      rec_type(master_radacctid      bigint
                                        ,line_id               integer
                                        ,line_label            text
                                        ,calling_station_id    text
                                        ,username              text
                                        ,esn_or_serial         text
                                        ,billing_entity_id     integer
                                        ,start_time            text
                                        ,stop_time             text
                                        ,framed_ip_address     text
                                        ,bytes_in              bigint
                                        ,bytes_out             bigint
                                        ,time_connected        text
                                        ,line_assignment_type  text
                                        ,location_label_type   text
                                        ,location_label        text
                                        ,address               text
                                        ,start_timestamp       timestamp
                                        ,stop_timestamp        timestamp)
  LOOP
    var_tot_bytes_in          := var_tot_bytes_in + var_return.bytes_in ;
    var_tot_bytes_out         := var_tot_bytes_out + var_return.bytes_out ;
    var_tot_seconds_connected := var_tot_seconds_connected + 
                                (EXTRACT(EPOCH FROM var_return.stop_timestamp) -
                                 EXTRACT(EPOCH FROM var_return.start_timestamp))::bigint ;
    RETURN NEXT var_return ;
  END LOOP ;

  -- transform seconds to string
  var_tot_time_connected := normalize_epoch(var_tot_seconds_connected,'HOUR')::text ;

  RAISE NOTICE 'TOT BYTES IN  : %', var_tot_bytes_in ;
  RAISE NOTICE 'TOT BYTES OUT : %', var_tot_bytes_out ;
  RAISE NOTICE 'TOT TIME CONN : %', var_tot_time_connected ;

  -- build and return the totals row
  var_return := ROW(0
                   ,par_line_id::varchar
                   ,var_line_label
                   ,var_calling_station_id
                   ,var_line_radius_username
                   ,var_esn_or_serial
                   ,var_billing_entity_id
                   ,null
                   ,null
                   ,null
                   ,var_tot_bytes_in
                   ,var_tot_bytes_out
                   ,var_tot_time_connected
                   ,var_line_assignment_type
                   ,var_location_label_type
                   ,var_location_label
                   ,var_address
                   ,null
                   ,null) ;

  RETURN NEXT var_return ;
  RETURN ;

END ;
$_$;


ALTER FUNCTION csctoss.fetch_mrac_by_date_range(integer, date, date) OWNER TO csctoss_owner;

--
-- Name: FUNCTION fetch_mrac_by_date_range(integer, date, date); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION fetch_mrac_by_date_range(integer, date, date) IS 'Retrieves detailed accounting records and line information for a single device. Last record returns totals.';


--
-- Name: fetch_mrpa_by_date_range(integer, date, date); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION fetch_mrpa_by_date_range(integer, date, date) RETURNS SETOF fetch_mrpa_by_date_range_retval
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_line_id                   integer := $1 ;
  par_start_date                date    := $2 ;
  par_end_date                  date    := $3 ;

  var_radius_username           varchar(64) ;
  var_preferred_timezone        text ;

  var_sql                       text ;
  var_return                    fetch_mrpa_by_date_range_retval ;

BEGIN

  -- validate parameters
  IF par_line_id IS NULL OR par_start_date IS NULL OR par_end_date IS NULL THEN
    RAISE EXCEPTION 'Line ID, Start Date and End Date are required parameters.' ;
  ELSIF par_end_date < par_start_date THEN
    RAISE EXCEPTION 'Start Date must be before or equal to End Date.' ;
  ELSIF (SELECT COUNT(*)
           FROM csctoss.line
          WHERE line_id = par_line_id) = 0 THEN
    RAISE EXCEPTION 'Line ID % does not exist.', par_line_id ;
  END IF ;

  -- get the username and preferred timezone
  SELECT radius_username, preferred_timezone
    INTO var_radius_username, var_preferred_timezone
    FROM csctoss.line
    JOIN csctoss.billing_entity USING (billing_entity_id)
   WHERE line.line_id = par_line_id ;

  IF var_radius_username IS NULL THEN
    RAISE EXCEPTION 'Line ID % Radius Username is null.', par_line_id ;
  ELSIF var_preferred_timezone IS NULL THEN
    RAISE EXCEPTION 'Line ID % Preferred Timezone is null.', par_line_id ;
  END IF ;

RAISE NOTICE 'Radius Username: % - Timezone: %', var_radius_username, var_preferred_timezone ;

  -- add a day to the end date to avoid at time zone in where clause which kills performance
  par_end_date := par_end_date + interval '1 day' ;

  -- dynamically build the sql statement
  var_sql := 'SELECT master_radpostauth_id
                    ,username
                    ,pass
                    ,reply
                    ,substr((authdate at time zone '||quote_literal(var_preferred_timezone)||')::text,1,19)
                    ,source_hostname
                    ,username as callingstationid
                    ,'||par_line_id||'
                FROM csctlog.master_radpostauth
               WHERE username = '||quote_literal(var_radius_username)||'
                 AND authdate >= '||quote_literal(par_start_date)||'
                 AND authdate <= '||quote_literal(par_end_date)||'
            ORDER BY authdate desc
               LIMIT 100' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  FOR var_return IN SELECT *
                      FROM public.dblink((select * from csctoss.fetch_csctlog_conn())
                                         ,var_sql)
                              AS rec_type(master_radpostauth_id   bigint
                                         ,username                varchar(64)
                                         ,pass                    varchar
                                         ,reply                   varchar(32)
                                         ,authdate                text
                                         ,source_hostname         varchar(64)
                                         ,callingstationid        text
                                         ,line_id                 integer)
  LOOP
    RETURN NEXT var_return ;
  END LOOP ;

  RETURN ;

END ;
$_$;


ALTER FUNCTION csctoss.fetch_mrpa_by_date_range(integer, date, date) OWNER TO csctoss_owner;

--
-- Name: FUNCTION fetch_mrpa_by_date_range(integer, date, date); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION fetch_mrpa_by_date_range(integer, date, date) IS 'Retrieves authentications from master_radpostauth for a device given the line id and a date range.';


--
-- Name: fetch_portal_conn(); Type: FUNCTION; Schema: csctoss; Owner: postgres
--

CREATE FUNCTION fetch_portal_conn() RETURNS text
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
  var_conn_string    text ;
BEGIN
  SELECT 'hostaddr='||ip_address||
            ' port='||repl_port||
          ' dbname='||repl_target_db||
            ' user='||repl_target_username||
        ' password='||repl_target_password
    INTO var_conn_string
    FROM csctoss.system_parameter
   WHERE hostname = 'portal' ;
  RETURN COALESCE(var_conn_string,'ERROR retrieving connection information for portal.') ;
END ;
$$;


ALTER FUNCTION csctoss.fetch_portal_conn() OWNER TO postgres;

--
-- Name: FUNCTION fetch_portal_conn(); Type: COMMENT; Schema: csctoss; Owner: postgres
--

COMMENT ON FUNCTION fetch_portal_conn() IS 'Returns a string of connection information for the portal database based on entry in system_parameter table.';


--
-- Name: firmware_gmu_loader(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION firmware_gmu_loader() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE

  rec_firm             record ;
  rec_error            record ;

BEGIN

  PERFORM * FROM public.set_change_log_staff_id(3) ;

  -- first verify the interface job executed
  IF NOT (SELECT TRUE FROM csctoss.firmware_gmu WHERE firmware_gmu_id = -1) THEN
    RETURN NEXT 'ERROR: Table firmware_gmu is empty or incomplete.' ;
    RETURN ;  
  END IF ;

  -- backfill equipment_id based on ESN HEX
  UPDATE csctoss.firmware_gmu
     SET equipment_id =
        (select equipment_id
           from unique_identifier
          where unique_identifier_type = 'ESN HEX'
            and value = firmware_gmu.value)
   WHERE unique_identifier_type = 'ESN HEX'
     AND equipment_id is null ;

  -- backfill equipment_id based on serial number
  UPDATE csctoss.firmware_gmu
     SET equipment_id =
        (select equipment_id
           from unique_identifier
          where unique_identifier_type = 'SERIAL NUMBER'
            and value = firmware_gmu.value)
   WHERE unique_identifier_type = 'SERIAL NUMBER'
     AND equipment_id IS NULL ;

  -- backfill equipment_model_id based on equipment_id
  UPDATE csctoss.firmware_gmu
     SET equipment_model_id = equipment.equipment_model_id
    FROM csctoss.equipment
   WHERE firmware_gmu.equipment_id is not null
     AND firmware_gmu.equipment_id = equipment.equipment_id ;

  -- go through entries and mark as error where equipment_id null
  UPDATE csctoss.firmware_gmu
     SET status = 'ERROR'
        ,error  = 'GMU '||vendor_name||' '||unique_identifier_type||' '||value||' Unmatached OSS Equipment ID.'
   WHERE firmware_gmu_id > 0
     AND equipment_id IS NULL ;

  -- now go through distinct models and firmware and reconcile entries in equipment_firmware table
  INSERT INTO csctoss.equipment_firmware (equipment_model_id, firmware_version)
       SELECT DISTINCT equipment_model_id, firmware_version
         FROM csctoss.firmware_gmu
        WHERE equipment_model_id IS NOT NULL 
          AND firmware_version IS NOT NULL
          AND status <> 'ERROR'
       EXCEPT
       SELECT DISTINCT equipment_model_id, firmware_version
         FROM csctoss.equipment_firmware ;

  -- update new or changed equipment_firmware_id in equipment table
  FOR rec_firm IN SELECT equp.equipment_id
                        ,efrm.equipment_firmware_id as efrm_firm_id
                        ,equp.equipment_firmware_id as equp_firm_id
                    FROM csctoss.equipment equp
                    JOIN csctoss.firmware_gmu frmg ON (frmg.equipment_id = equp.equipment_id)
                    JOIN csctoss.equipment_firmware efrm ON (frmg.equipment_model_id = efrm.equipment_model_id
                                                        AND frmg.firmware_version = efrm.firmware_version)
                   WHERE frmg.equipment_id IS NOT NULL
                     AND frmg.equipment_model_id IS NOT NULL
                     AND frmg.firmware_version IS NOT NULL
  LOOP

    -- if equipment_firmware_id null or disagrees with gmu data then update it
    IF rec_firm.equp_firm_id IS NULL OR rec_firm.efrm_firm_id <> rec_firm.equp_firm_id THEN
      UPDATE csctoss.equipment
         SET equipment_firmware_id = rec_firm.efrm_firm_id
       WHERE equipment_id = rec_firm.equipment_id ;
    END IF ;

  END LOOP ;

  -- return all the errors
  FOR rec_error IN SELECT COALESCE(error,'EMPTY STRING') as err_msg
                     FROM csctoss.firmware_gmu
                    WHERE status = 'ERROR'
                 ORDER BY firmware_gmu_id
  LOOP
    RETURN NEXT rec_error.err_msg ;
  END LOOP ;

  RETURN NEXT 'SUCCESS' ;
  RETURN ;

END ;

$$;


ALTER FUNCTION csctoss.firmware_gmu_loader() OWNER TO csctoss_owner;

--
-- Name: FUNCTION firmware_gmu_loader(); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION firmware_gmu_loader() IS 'Daily function to process GMU firmware data by adding new and updating existing equipment.';


--
-- Name: firmware_soup_loader(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION firmware_soup_loader() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE

  rec_firm             record ;
  rec_error            record ;

BEGIN

  PERFORM * FROM public.set_change_log_staff_id(3) ;

  -- first verify the interface job executed
  IF NOT (SELECT TRUE FROM csctoss.firmware_soup WHERE did = -1) THEN
    RETURN NEXT 'ERROR: Table firmware_soup is empty or incomplete.' ;
    RETURN ;  
  END IF ;

  -- backfill equipment_id based on serial number
  UPDATE csctoss.firmware_soup
     SET equipment_id =
        (select equipment_id
           from unique_identifier
          where unique_identifier_type = 'SERIAL NUMBER'
            and value = firmware_soup.serial)
   WHERE equipment_id IS NULL ;

  -- backfill equipment_id based on FULL mac address
  UPDATE csctoss.firmware_soup
     SET equipment_id =
        (select equipment_id
           from unique_identifier
          where unique_identifier_type = 'MAC ADDRESS'
            and value = firmware_soup.eui)
   WHERE equipment_id is null ;

  -- backfill equipment_id based on partial (last 6 chars) of mac address
  UPDATE csctoss.firmware_soup
     SET equipment_id =
        (select equipment_id
           from unique_identifier
          where unique_identifier_type = 'MAC ADDRESS'
            and value = substr(eui,7,6))
   WHERE equipment_id is null ;

  -- backfill equipment_model_id based on equipment_id
  UPDATE csctoss.firmware_soup
     SET equipment_model_id = equipment.equipment_model_id
    FROM csctoss.equipment
   WHERE firmware_soup.equipment_id is not null
     AND firmware_soup.equipment_id = equipment.equipment_id ;

  -- backfill model_number2 based on equipment_model_id
  UPDATE csctoss.firmware_soup
     SET model_number2 = equipment_model.model_number2
    FROM csctoss.equipment_model
   WHERE firmware_soup.equipment_model_id is not null
     AND firmware_soup.equipment_model_id = equipment_model.equipment_model_id ;

  -- go through entries and mark as error where equipment_id null
  UPDATE csctoss.firmware_soup
     SET status = 'ERROR'
        ,error  = 'SOUP MAC '||eui||' / SN '||COALESCE(serial,'NULL')||' Unmatched OSS Equipment ID.'
   WHERE did > 0
     AND equipment_id IS NULL ;

  -- go through entries and mark as error where soup equipment_model <> oss equipment_model
  UPDATE csctoss.firmware_soup
     SET status = 'ERROR'
        ,error  = 'OSS Eqid '||equipment_id::text||' Model ('||model_number2||') !=  SOUP Model ('||model||').'
   WHERE did > 0
     AND model IS NOT NULL
     AND model_number2 IS NOT NULL
     AND model <> model_number2 ;

  -- make a pass through ERRORs where models disagree and try to reconcile based on 'CS' difference
  -- if the basic model numbers agrees then just assume the shorthand version is correct
  FOR rec_firm IN SELECT *
                    FROM csctoss.firmware_soup
                   WHERE status = 'ERROR'
                     AND model IS NOT NULL
                     AND model_number2 IS NOT NULL
                     AND model <> model_number2
                     AND substr(model_number2,1,length(model)) = model
  LOOP
    UPDATE csctoss.firmware_soup
       SET model_number2 = model
          ,status        = 'SCRUB'
          ,error         = 'CORRECTED: '||error
     WHERE did           = rec_firm.did ; 
  END LOOP ;

  -- finally backfill the corrected equipment_model_id for SCRUB records and proceed
  UPDATE csctoss.firmware_soup
     SET equipment_model_id = equipment_model.equipment_model_id
    FROM csctoss.equipment_model
   WHERE status = 'SCRUB'
     AND firmware_soup.model_number2 = equipment_model.model_number2 ;
 
  -- now go through distinct models and firmware and reconcile entries in equipment_firmware table
  INSERT INTO csctoss.equipment_firmware (equipment_model_id, firmware_version)
       SELECT DISTINCT equipment_model_id, firmware
         FROM csctoss.firmware_soup
        WHERE equipment_model_id IS NOT NULL 
          AND firmware IS NOT NULL
          AND status <> 'ERROR'
       EXCEPT
       SELECT DISTINCT equipment_model_id, firmware_version
         FROM csctoss.equipment_firmware ;

  -- update new or changed equipment_firmware_id in equipment table
  FOR rec_firm IN SELECT equp.equipment_id
                        ,efrm.equipment_firmware_id as efrm_firm_id
                        ,equp.equipment_firmware_id as equp_firm_id
                    FROM csctoss.equipment equp
                    JOIN csctoss.firmware_soup frms ON (frms.equipment_id = equp.equipment_id)
                    JOIN csctoss.equipment_firmware efrm ON (frms.equipment_model_id = efrm.equipment_model_id
                                                        AND frms.firmware = efrm.firmware_version)
                   WHERE frms.equipment_id IS NOT NULL
                     AND frms.equipment_model_id IS NOT NULL
                     AND frms.firmware IS NOT NULL
  LOOP

    -- if equipment_firmware_id null or disagrees with soup data then update it
    IF rec_firm.equp_firm_id IS NULL OR rec_firm.efrm_firm_id <> rec_firm.equp_firm_id THEN
      UPDATE csctoss.equipment
         SET equipment_firmware_id = rec_firm.efrm_firm_id
       WHERE equipment_id = rec_firm.equipment_id ;
    END IF ;

  END LOOP ;

  -- return all the errors
  FOR rec_error IN SELECT COALESCE(error,'EMPTY STRING') as err_msg
                     FROM csctoss.firmware_soup
                    WHERE status = 'ERROR'
                 ORDER BY error
  LOOP
    RETURN NEXT rec_error.err_msg ;
  END LOOP ;

  RETURN NEXT 'SUCCESS' ;
  RETURN ;

END ;

$$;


ALTER FUNCTION csctoss.firmware_soup_loader() OWNER TO csctoss_owner;

--
-- Name: FUNCTION firmware_soup_loader(); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION firmware_soup_loader() IS 'Daily function to process SOUP firmware data by adding new and updating existing equipment.';


--
-- Name: fix_class_value_vzw(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION fix_class_value_vzw() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE

  rec_usernames      record ;
  var_sql            text ;
  var_affected_count int ;

BEGIN

  PERFORM public.set_change_log_staff_id(3) ;

  -- query master_radacct for the fourth successful login
  FOR rec_usernames IN
      SELECT rr.username AS username, rr.value AS class
      FROM public.dblink((SELECT * FROM csctoss.fetch_csctlog_conn()),
                         'SELECT DISTINCT username
                          FROM csctlog.master_radacct
                          WHERE 1 = 1
                          AND substring(username from ''@.*$'') = ''@vzw3g.com''
                          AND ((class !~* ''[0-9].*'') OR (class = ''0'') OR (class IS NULL))
                         ')
           AS mradacct (username text)
      JOIN radreply rr ON (mradacct.username = rr.username)
      WHERE rr.attribute = 'Class'
  LOOP

      var_sql := 'UPDATE csctlog.master_radacct SET class = ' || quote_literal(rec_usernames.class) ||
        ' WHERE username = ' || quote_literal(rec_usernames.username) ||
        ' AND   ((class !~* ''[0-9].*'') OR (class = ''0'') OR (class IS NULL))' ;
      PERFORM dblink_exec((SELECT * FROM csctoss.fetch_csctlog_conn()), var_sql ) ;

      GET DIAGNOSTICS var_affected_count = ROW_COUNT ;
      RETURN NEXT rec_usernames.username || ',' || rec_usernames.class || ' UPDCNT=> ' || var_affected_count ;

  END LOOP ;

  RETURN NEXT 'SUCCESS' ;
  RETURN ;

END ;
$_$;


ALTER FUNCTION csctoss.fix_class_value_vzw() OWNER TO csctoss_owner;

--
-- Name: FUNCTION fix_class_value_vzw(); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION fix_class_value_vzw() IS 'Function to fix incorrect class values.';


--
-- Name: fix_line_plans(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION fix_line_plans() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE

   var_row		RECORD;
   var_line_id		integer :=0;

   var_end_date 	date ;
   var_length_days  	integer :=0;
   var_plan_type_id	integer :=0;
   var_timestamp	timestamp;
   var_notes		varchar;
   var_external_id	integer;

BEGIN

--length days from product
--plan_type_id - ??????
--comment - SO from notes in line *
--create_timestamptimestamp from line *
--product id - external_id from jbilling
--3 for jalbert
--line_id
--start_date from line *
--end_date from line *
--accounting_start_date - timestamp from above

set client_min_messages to NOTICE;

FOR var_row IN select l.line_id,l.date_created,l.notes,l.end_date 
		from line l
		left outer join plan p on (l.line_id = p.line_id)
		where 1=1
		and  p.line_id is null
		order by l.start_date
		--limit 5

LOOP
   var_line_id = var_row.line_id;
   var_timestamp = var_row.date_created;
   var_notes = var_row.notes;
   var_end_date = var_row.end_date;

  --  RAISE INFO 'lineid=%', var_line_id;
--RAISE NOTICE 'lineid=%', var_line_id;
--RAISE WARNING 'lineid=%', var_line_id;

   select row.external_id into var_external_id from public.dblink('hostaddr=10.17.70.25 port=5440 dbname=jbilling user=jbilling password=wrub5N4b',
	'select i.external_id
	from prov_line pl,item i
	where 1=1
	and pl.item_id = i.id
	and pl.line_id = '|| var_line_id)
   as row (external_id integer);

  -- RAISE INFO 'exId=%', var_external_id;
--RAISE NOTICE 'exId=%', var_external_id;
--RAISE WARNING 'exId=%', var_external_id;

  IF var_external_id IS NULL THEN
    RAISE NOTICE 'Null returned for external_id for line_id=%', var_line_id;
         
  ELSE 

    SELECT
      length_days,
      plan_type_id
    INTO
      var_length_days,
      var_plan_type_id
    FROM product
    WHERE product_id = var_external_id;

    RAISE INFO 'length_days=%', var_length_days;
    RAISE NOTICE 'length_days=%', var_length_days;
    RAISE WARNING 'length_days=%', var_length_days;

	   
    INSERT INTO plan 
     (length_days,plan_type_id,comment,create_timestamp,product_id,staff_id,line_id,start_date,end_date,accounting_start_date)
    VALUES
     (var_length_days,var_plan_type_id,var_notes,var_timestamp,var_external_id,3,var_line_id,var_timestamp::date,var_end_date,var_timestamp::date);

   END IF;


END LOOP;

RETURN true;

  
END ;

$$;


ALTER FUNCTION csctoss.fix_line_plans() OWNER TO csctoss_owner;

--
-- Name: fix_radius_settings(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION fix_radius_settings(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
/*
  par_username 		TEXT:=$1 ;
  par_staff_id		INTEGER:=$2;
  var_carrier 		TEXT;
*/

  par_staff_id		INTEGER:=$1 ;
  var_row		RECORD;
  var_username		TEXT;
  var_equipment_id	INTEGER;
  var_mdn		TEXT;
  var_carrier		TEXT;
BEGIN  

  SET client_min_messages TO NOTICE;

  PERFORM public.set_change_log_staff_id (par_staff_id);

  FOR var_row IN select ui.equipment_id,ui.value as hex,ui2.value as mdn,u.username
		from unique_identifier ui
		left outer join unique_identifier ui2 on (ui.equipment_id = ui2.equipment_id and ui2.unique_identifier_type = 'MDN')
		left outer join username u on (substr(u.username,1,10) = ui2.value)
		--join line_equipment le on le.equipment_id = ui.equipment_id
		where 1=1
		--and le.end_date is null
		and not exists (select true from line_equipment where equipment_id = ui.equipment_id  and end_date is null)
		-- to find two active routers :
		--and not exists (select true from line_equipment where equipment_id = ui.equipment_id  and end_date is null)
		--
		and ui.value in
		('A10000157E3AC2',
		'A10000157E5CF7',
		'A10000157E5D57',
		'A10000157ECB5B',
		'A10000157ECAF8',
		'A10000157EC97D',
		'A1000009429744',
		'A10000094222CF',
		'A100000941D483',
		'A1000009414D26',
		'A100000941E67F',
		'F616A1D3',
		'A100000941E4F9',
		'A100000941AB28',
		'A100000941AA89',
		'A10000157EBCED',
		'A10000157E3ABA',
		'A10000157E3B43',
		'A100000941F0C3',
		'A100001578C925',
		'A1000009426633',
		'A1000009408859',
		'A1000009422270',
		'A1000009465FFD',
		'A10000094223FA',
		'A10000094223CC',
		'A1000009465FFC',
		'A1000009407DDA',
		'F616A20E',
		'A100000941E44F',
		'A10000157E5CF3',
		'A100000941E610',
		'A100000943EA76',
		'A100000941E40D',
		'A100000941E45C',
		'A100000942659F',
		'A1000009426323',
		'A100000942247A',
		'A10000094263CC',
		'A1000009429A98',
		'A100000941A9DE',
		'A1000009422299',
		'A100000941CD9A',
		'A100000943EA77',
		'A100000941E41A',
		'A100000941D362',
		'A1000009407DE1',
		'A100000943C2FE',
		'A1000009426073',
		'A10000094264D5',
		'A10000157E356D',
		'A10000157ED033',
		'A1000015771A2A',
		'A10000157ED2D1',
		'A1000009409ED7',
		'A10000157E3A58',
		'A100000943EBE7',
		'A1000009426246',
		'A100000942DC15',
		'A100000941F022',
		'A100000941E510',
		'A10000157EE728',
		'A100000941CDCE',
		'A100000941E359',
		'A1000009408897',
		'A10000094226F7',
		'A100000941E67B',
		'A100000941AAF6',
		'A100000941D216',
		'A1000009420BCE',
		'A100000943EF72',
		'A10000157EBCBA',
		'A10000157D16BF',
		'A100000941E3E1',
		'A1000009433279',
		'A1000009410298',
		'A10000157ECBD6',
		'A10000157EBB9F',
		'A100001578C848',
		'A100001578C794',
		'A10000157ED04E',
		'A10000157EBB1C',
		'A1000015771E08',
		'A1000015771A38',
		'A10000157E3B7A',
		'A100001578C7CD',
		'A100001578C833',
		'A100001578C9AA',
		'A1000015771E40',
		'A100001578C80D',
		'A100001578C91E',
		'A100001578C82A',
		'A100001578C786'
		)
		order by 1

  LOOP

    --RAISE NOTICE '** PROCESSING e_id = %, hex = %, username = %' , var_row.equipment_id,var_row.hex,var_row.username ;

  RAISE NOTICE '** PROCESSING %', var_row.username ;  

  --determine carrier
  IF substr(var_row.username,11,4) in ('@tsp','@cn0') THEN
    RAISE NOTICE 'SPRINT' ;
    var_carrier = 'SPRINT' ;
  ELSIF substr(var_row.username,11,4) = '@vzw' THEN
    RAISE NOTICE 'VERIZON' ;
    var_carrier = 'VERIZON' ;
  ELSE
    var_carrier = 'UNKNOWN' ; 
    RAISE EXCEPTION 'UNRECOGNIZED CARRIER from given username (%). Check username for errors.' , var_row.username ;
  END IF;

  DELETE FROM radcheck WHERE username = var_row.username ;

  --insert into radcheck
  IF var_carrier = 'SPRINT' THEN
    DELETE FROM radcheck WHERE username = var_row.username ;
    
    INSERT INTO radcheck
    (username,attribute,op) 
    VALUES
    (var_row.username,'ClearText-Password',':=');
  END IF;

  IF var_carrier = 'VERIZON' THEN
    IF var_row.username like '%@vzw.net' THEN
      INSERT INTO radcheck
      (username,attribute,op) 
      VALUES
      (var_row.username,'ClearText-Password',':=') ;      
    ELSIF var_row.username like '%@vzw3g.com' THEN
      INSERT INTO radcheck
      (username,attribute,op,value) 
      VALUES
      (var_row.username,'Auth-Type',':=','Accept') ;
    ELSE
      RAISE EXCEPTION 'Cannot determine carrier realm from username (%)' , var_row.username ;
    END IF;
  END IF;


  --insert into usergroup

  DELETE FROM usergroup WHERE username = var_row.username ;

  INSERT INTO usergroup 
  (username,groupname,priority)
  VALUES 
  (var_row.username,'SERVICE-inventory',5000) ;


  --delete from radreply

  DELETE FROM radreply WHERE username = var_row.username ;

  RAISE NOTICE '***** COMPLETED %', var_row.username ;

END LOOP;

RETURN true;
 
END ;

$_$;


ALTER FUNCTION csctoss.fix_radius_settings(integer) OWNER TO csctoss_owner;

--
-- Name: fix_radius_settings_uscc(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION fix_radius_settings_uscc(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_staff_id		INTEGER:=$1 ;
  var_row		RECORD;
  var_username		TEXT;
  var_equipment_id	INTEGER;
  var_mdn		TEXT;
  var_carrier		TEXT;
  
BEGIN  

  SET client_min_messages TO NOTICE;

  PERFORM public.set_change_log_staff_id (par_staff_id);

  FOR var_row IN select ui.equipment_id,ui.value as hex,ui2.value as mdn,u.username
		from unique_identifier ui
		left outer join unique_identifier ui2 on (ui.equipment_id = ui2.equipment_id and ui2.unique_identifier_type = 'MIN')
		left outer join username u on (substr(u.username,1,10) = ui2.value)
		--join line_equipment le on le.equipment_id = ui.equipment_id
		where 1=1
		--and le.end_date is null
		and not exists (select true from line_equipment where equipment_id = ui.equipment_id  and end_date is null)
		-- to find two active routers :
		--and not exists (select true from line_equipment where equipment_id = ui.equipment_id  and end_date is null)
		--
		and ui.value in
		('F615C285',
'F615D77D',
'F616EC5B',
'F616F08E',
'F6160350',
'F6158B00',
'F616FBD5',
'F616EED2',
'F616EAAD',
'F61782B5',
'F615C892',
'F6158943',
'F615F93C',
'F615D734',
'F615C730',
'F615D88F',
'F615FD33',
'F616EB56',
'F616F8EA',
'F615C850',
'F615C704',
'F611C1DC',
'F615C84A',
'F616F8DA',
'F61588B8',
'F615F8C4',
'F616003D',
'F616EC4A',
'F615C73A',
'F616F988',
'F614C450',
'F615C6FA',
'F616EB55',
'F615CA5A',
'F615C5A8',
'F615C852',
'F616ECF6',
'F615F8A2',
'F616EA38',
'F616002B',
'F615F8A2',
'F615D629',
'F616EA26',
'F615F8A2',
'F616EDD3',
'F615D653',
'F615FC06',
'F616ED44',
'F615F8A2'
)
order by 2

  LOOP

    --RAISE NOTICE '** PROCESSING e_id = %, hex = %, username = %' , var_row.equipment_id,var_row.hex,var_row.username ;

  RAISE NOTICE '** PROCESSING %', var_row.username ;  

  --determine carrier
  IF substr(var_row.username,11,4) in ('@tsp','@cn0') THEN
    RAISE NOTICE 'SPRINT' ;
    var_carrier = 'SPRINT' ;
  ELSIF substr(var_row.username,11,4) = '@vzw' THEN
    RAISE NOTICE 'VERIZON' ;
    var_carrier = 'VERIZON' ;
  ELSIF substr(var_row.username,11,4) = '@usc' THEN
    RAISE NOTICE 'USCC' ;
    var_carrier = 'USCC' ;
  ELSE 
    RAISE EXCEPTION 'UNRECOGNIZED CARRIER from given username (%). Check username for errors.' , var_row.username ;
  END IF;

  DELETE FROM radcheck WHERE username = var_row.username ;

  --insert into radcheck
  IF var_carrier = 'SPRINT' THEN
    DELETE FROM radcheck WHERE username = var_row.username ;
    
    INSERT INTO radcheck
    (username,attribute,op) 
    VALUES
    (var_row.username,'ClearText-Password',':=');
  END IF;

  IF var_carrier = 'VERIZON' THEN
    IF var_row.username like '%@vzw.net' THEN
      INSERT INTO radcheck
      (username,attribute,op) 
      VALUES
      (var_row.username,'ClearText-Password',':=') ;      
    ELSIF var_row.username like '%@vzw3g.com' THEN
      INSERT INTO radcheck
      (username,attribute,op,value) 
      VALUES
      (var_row.username,'Auth-Type',':=','Accept') ;
    ELSE
      RAISE EXCEPTION 'Cannot determine carrier realm from username (%)' , var_row.username ;
    END IF;
  END IF;

  IF var_carrier = 'USCC' THEN

    DELETE FROM radcheck WHERE username = var_row.username ;
    
    INSERT INTO radcheck
    (username,attribute,op,value) 
    VALUES
    (var_row.username,'ClearText-Password',':=','CP@11U$ers') ;
  END IF;


  --insert into usergroup

  DELETE FROM usergroup WHERE username = var_row.username ;

  INSERT INTO usergroup 
  (username,groupname,priority)
  VALUES 
  (var_row.username,'SERVICE-inventory',5000) ;


  --delete from radreply

  DELETE FROM radreply WHERE username = var_row.username ;

  RAISE NOTICE '***** COMPLETED %', var_row.username ;

END LOOP;

RETURN true;
 
END ;

$_$;


ALTER FUNCTION csctoss.fix_radius_settings_uscc(integer) OWNER TO csctoss_owner;

--
-- Name: fix_radius_settings_vzw(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION fix_radius_settings_vzw(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
/*
  par_username 		TEXT:=$1 ;
  par_staff_id		INTEGER:=$2;
  var_carrier 		TEXT;
*/

  par_staff_id		INTEGER:=$1 ;
  var_row		RECORD;
  var_username		TEXT;
  var_equipment_id	INTEGER;
  var_mdn		TEXT;
  var_carrier		TEXT;
BEGIN  

  SET client_min_messages TO NOTICE;

  PERFORM public.set_change_log_staff_id (par_staff_id);

  FOR var_row IN select ui.equipment_id,ui.value as hex,ui2.value as mdn,u.username
		from unique_identifier ui
		left outer join unique_identifier ui2 on (ui.equipment_id = ui2.equipment_id and ui2.unique_identifier_type = 'MDN')
		left outer join username u on (substr(u.username,1,10) = ui2.value)
		--join line_equipment le on le.equipment_id = ui.equipment_id
		where 1=1
		--and le.end_date is null
		and not exists (select true from line_equipment where equipment_id = ui.equipment_id  and end_date is null)
		-- to find two active routers :
		--and  exists (select true from line_equipment where equipment_id = ui.equipment_id  and end_date is null)
		--
		and ui.value in
		('F611C1DC',
			'A100001574CBBD',
			'A1000012C25A77',
			'A1000012C21855',
			'A1000036983F4A',
			'A10000369C1A7E',
			'A1000036981F3B',
			'A10000157EA502',
			'A1000036981D4C',
			'A1000012C2046E',
			'A100001578A7BF',
			'A1000036985382',
			'A1000036981E50',
			'A100001578B466',
			'A100001578B1F2',
			'A10000157A1900',
			'A1000012C2293A',
			'A1000012C24C35',
			'A10000157F1799',
			'A10000157F1766',
			'A1000036981D13',
			'A1000036983F66',
			'A1000012C22CA9',
			'A1000012C21FAD',
			'A10000157E3E36',
			'A1000012C20668',
			'A10000157E3AC2')
		order by 1

  LOOP

    --RAISE NOTICE '** PROCESSING e_id = %, hex = %, username = %' , var_row.equipment_id,var_row.hex,var_row.username ;

  RAISE NOTICE '** PROCESSING %', var_row.username ;  

  --determine carrier
  IF substr(var_row.username,11,4) in ('@tsp','@cn0') THEN
    RAISE NOTICE 'SPRINT' ;
    var_carrier = 'SPRINT' ;
  ELSIF substr(var_row.username,11,4) = '@vzw' THEN
    RAISE NOTICE 'VERIZON' ;
    var_carrier = 'VERIZON' ;
  ELSE
    var_carrier = 'UNKNOWN' ; 
    RAISE EXCEPTION 'UNRECOGNIZED CARRIER from given username (%). Check username for errors.' , var_row.username ;
  END IF;

  

  --insert into radcheck
  IF var_carrier = 'SPRINT' THEN
    DELETE FROM radcheck WHERE username = var_row.username ;
    
    INSERT INTO radcheck
    (username,attribute,op) 
    VALUES
    (var_row.username,'ClearText-Password',':=');
  END IF;

  IF var_carrier = 'VERIZON' THEN
    IF var_row.username like '%@vzw.net' THEN
      DELETE FROM radcheck WHERE username = var_row.username ;
      
      INSERT INTO radcheck
      (username,attribute,op) 
      VALUES
      (var_row.username,'ClearText-Password',':=') ;      
    ELSIF var_row.username like '%@vzw3g.com' THEN
    
      DELETE FROM radcheck WHERE username = var_row.username ;
    
      INSERT INTO radcheck
      (username,attribute,op,value) 
      VALUES
      (var_row.username,'Auth-Type',':=','Accept') ;
    ELSE
      RAISE EXCEPTION 'Cannot determine carrier realm from username (%)' , var_row.username ;
    END IF;
  END IF;


  --insert into usergroup

  DELETE FROM usergroup WHERE username = var_row.username ;

  INSERT INTO usergroup 
  (username,groupname,priority)
  VALUES 
  (var_row.username,'SERVICE-inventory',5000) ;


  --delete from radreply

  DELETE FROM radreply WHERE username = var_row.username ;

  RAISE NOTICE '***** COMPLETED %', var_row.username ;



END LOOP;

RETURN true;
 
END ;

$_$;


ALTER FUNCTION csctoss.fix_radius_settings_vzw(integer) OWNER TO csctoss_owner;

--
-- Name: fix_username_func(text, text, text, integer, integer, integer, integer, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION fix_username_func(text, text, text, integer, integer, integer, integer, integer) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
declare
in_old_username   text:=$1;
in_new_username   text:=$2;
in_staff_login    text:=$3;
in_username_cnt   integer:=$4;
in_radcheck_cnt   integer:=$5;
in_radreply_cnt   integer:=$6;
in_usergroup_cnt  integer:=$7;
in_line_cnt       integer:=$8;

v_staff_id        integer;
v_result          integer;
v_tab             text;
v_fail_ind        integer;
v_in_count        integer;
begin

    set client_min_messages=NOTICE;
    
    RAISE NOTICE 'Start of DB Username Update Function';

    select * into v_staff_id from staff where staff_login_name= in_staff_login;
 
    select * into v_result from public.set_change_log_staff_id(v_staff_id);

    if v_result = -1  or v_result=v_staff_id
    then
        RAISE NOTICE 'change log staff id was set';
    else
        RAISE NOTICE 'change log staff id could not be set(%)',v_result;
        RAISE exception 'change log staff id could not be set';
    end if;
--   Updating username
     v_tab:='username';
     v_in_count:=in_username_cnt;
     update  csctoss.username 
     set username    = in_new_username
     where username  = in_old_username;
     GET DIAGNOSTICS v_result = ROW_COUNT;
     if  v_in_count = v_result
     then
         return next  rpad(v_tab,9)||'   table : expected ('||v_in_count||') updated ('||v_result||')- passed';
     else
         raise notice 'update of % table failed : updates: expected (%) actual (%)',v_tab,v_in_count,v_result;
         raise exception 'Username Change was NOT successful';
     end if;
--   Updating radreply
     v_tab:='radreply';
     v_in_count:=in_radreply_cnt;
     update  csctoss.radreply 
     set username    = in_new_username
     where username  = in_old_username;
     GET DIAGNOSTICS v_result = ROW_COUNT;
     if  v_in_count = v_result
     then
         return next  rpad(v_tab,9)||'   table : expected ('||v_in_count||') updated ('||v_result||')- passed';
     else
         raise notice 'update of % table failed : updates: expected (%) actual (%)',v_tab,v_in_count,v_result;
         raise exception 'Username Change was NOT successful';
     end if;
--   Updating radcheck
     v_tab:='radcheck';
     v_in_count:=in_radcheck_cnt;
     update  csctoss.radcheck 
     set username    = in_new_username
     where username  = in_old_username;
     GET DIAGNOSTICS v_result = ROW_COUNT;
     if  v_in_count = v_result
     then
         return next  rpad(v_tab,9)||'   table : expected ('||v_in_count||') updated ('||v_result||')- passed';
     else
         raise notice 'update of % table failed : updates: expected (%) actual (%)',v_tab,v_in_count,v_result;
         raise exception 'Username Change was NOT successful';
     end if;
--   Updating usergroup
     v_tab:='usergroup';
     v_in_count:=in_usergroup_cnt;
     update  csctoss.usergroup 
     set username    = in_new_username
     where username  = in_old_username;
     GET DIAGNOSTICS v_result = ROW_COUNT;
     if  v_in_count = v_result
     then
         return next  v_tab||'   table : expected ('||v_in_count||') updated ('||v_result||')- passed';
     else
         raise notice 'update of % table failed : updates: expected (%) actual (%)',v_tab,v_in_count,v_result;
         raise exception 'Username Change was NOT successful';
     end if;
--   Updating line
     v_tab:='line';
     v_in_count:=in_line_cnt;
     update  csctoss.line 
     set radius_username    = in_new_username
     where radius_username  = in_old_username;
     GET DIAGNOSTICS v_result = ROW_COUNT;
     if  v_in_count = v_result
     then
         return next  rpad(v_tab,9)||'   table : expected ('||v_in_count||') updated ('||v_result||')- passed';
     else
         raise notice 'update of % table failed : updates: expected (%) actual (%)',v_tab,v_in_count,v_result;
         raise exception 'Username Change was NOT successful';
     end if;
     return next '';
     return next 'End of DB Username Update Function';
     return;
END ;
$_$;


ALTER FUNCTION csctoss.fix_username_func(text, text, text, integer, integer, integer, integer, integer) OWNER TO csctoss_owner;

--
-- Name: free_ips_in_range(text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION free_ips_in_range(text, text) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
   par_start_ip		 text := $1 ;
   par_end_ip		 text := $2 ;

   var_par_start_ippart_1 text;
   var_par_start_ippart_2 text;
   var_par_start_ippart_3 text; 
   var_par_start_ippart_4 text; 
   var_par_end_ippart_1   text;
   var_par_end_ippart_2   text; 
   var_par_end_ippart_3   text; 
   var_par_end_ippart_4   text; 
   var_par_start_ip       inet;
   var_par_end_ip         inet;
   var_start_ip           integer;
   var_end_ip             integer;
   var_par_missing_ip     text;
   var_count              inet;
   var_i                  integer;
   
   
BEGIN
   var_par_start_ippart_1  := split_part(par_start_ip,'.',1);
   var_par_start_ippart_2  := split_part(par_start_ip,'.',2);
   var_par_start_ippart_3  := split_part(par_start_ip,'.',3);
   var_par_start_ippart_4  := split_part(par_start_ip,'.',4);

   var_par_end_ippart_1    := split_part(par_end_ip,'.',1);
   var_par_end_ippart_2    := split_part(par_end_ip,'.',2);
   var_par_end_ippart_3    := split_part(par_end_ip,'.',3);
   var_par_end_ippart_4    := split_part(par_end_ip,'.',4); 

  -- validate ips
  -- 1) valid ip address, cast to inet and confirm
     BEGIN
        SELECT par_start_ip INTO var_par_start_ip;
        RETURN  NEXT 'Staring IP: '||host(var_par_start_ip)::text;
     EXCEPTION
        WHEN OTHERS THEN
        RAISE EXCEPTION 'Invalid Start IP Address';
     END;

     BEGIN
        SELECT par_end_ip INTO var_par_end_ip;
        RETURN  NEXT 'Ending IP: '||host(var_par_end_ip)::text;
     EXCEPTION
        WHEN OTHERS THEN
        RAISE EXCEPTION 'Invalid End IP Address';
     END;
     
  -- 2) starting ip and ending ip not equal
     BEGIN
        IF var_par_start_ip = var_par_end_ip THEN
           RAISE EXCEPTION 'Start and End IP address can not be the same';
        END IF;
     END;

  -- 3) Ending ip greater than starting ip
     BEGIN
        IF var_par_start_ip > var_par_end_ip THEN
           RAISE EXCEPTION 'Start IP address can not be greater than End IP address';
        END IF;
     END; 
      
   -- 4) The first 3 parts of the IP of Start and End needs to be the same
     BEGIN
        IF var_par_start_ippart_1 != var_par_end_ippart_1 OR var_par_start_ippart_2 != var_par_end_ippart_2 OR var_par_start_ippart_3 != var_par_end_ippart_3 THEN
           RAISE EXCEPTION 'First 3 parameters of the START and END are not the Same';
        END IF;
     END;             
     
   --var_start_ip := var_par_start_ippart_1||var_par_start_ippart_2||var_par_start_ippart_3||var_par_start_ippart_4;
   --var_end_ip   := var_par_end_ippart_1||var_par_end_ippart_2||var_par_end_ippart_3||var_par_end_ippart_4;


   var_start_ip := var_par_start_ippart_1||var_par_start_ippart_2||var_par_start_ippart_3;
   var_end_ip   := var_par_end_ippart_1||var_par_end_ippart_2||var_par_end_ippart_3;
   
   -- Loop through Start IP till End IP
   -- If record found in table, do nothing, increment the last set(4rth portion) of IP part
   -- If record not found, display the IP address, increment the last set(4rth portion) of IP part
   
   FOR var_i IN var_par_start_ippart_4..var_par_end_ippart_4
   LOOP
      IF var_i < 10 THEN
         SELECT INTO var_count value
           FROM radreply
          WHERE attribute = 'Framed-IP-Address'
            AND REPLACE(VALUE,'.','')  = var_start_ip||var_i;   

          IF NOT FOUND THEN
             var_par_missing_ip := var_par_start_ippart_1||'.'||var_par_start_ippart_2||'.'||var_par_start_ippart_3||'.'||var_i;
             RETURN  NEXT var_par_missing_ip;
          END IF;
      ELSE          
         SELECT INTO var_count value
           FROM radreply
          WHERE attribute = 'Framed-IP-Address'
            AND REPLACE(VALUE,'.','')  = var_start_ip||var_i;
          IF NOT FOUND THEN
             var_par_missing_ip := var_par_start_ippart_1||'.'||var_par_start_ippart_2||'.'||var_par_start_ippart_3||'.'||var_i;
             RETURN  NEXT var_par_missing_ip;
          END IF;
      END IF;          
     
   END LOOP;
      
  RETURN;

END ;
$_$;


ALTER FUNCTION csctoss.free_ips_in_range(text, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION free_ips_in_range(text, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION free_ips_in_range(text, text) IS 'Display free IP address in radreply table based on user provided range.';


--
-- Name: get_branding_billing_entity_id_by_radius_username(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION get_branding_billing_entity_id_by_radius_username(text) RETURNS integer
    LANGUAGE plpgsql STRICT SECURITY DEFINER
    AS $_$
DECLARE
	i_username					text := $1 ;
	v_counter					INTEGER ;
	v_loop_counter				INTEGER := 0 ;
	v_loop_max					INTEGER := 10 ;
	v_found						BOOLEAN := FALSE ;
	v_line_id					INTEGER ;
	v_billing_entity_id			INTEGER ;
	v_parent_billing_entity_id	INTEGER ;
	v_check_billing_entity_id	INTEGER ;
	v_is_registered				BOOLEAN := FALSE ;
	o_billing_entity_id			INTEGER := -1 ;
BEGIN
	-- ------------------------------------------------------------
	-- Get the Line ID by Radius Username
	-- ------------------------------------------------------------
	SELECT "value"
	INTO   v_line_id
	FROM   csctoss.radreply
	WHERE  attribute = 'Class'
	AND    username = i_username ;

	-- ------------------------------------------------------------
	-- Get the billing_entity_id for the line
	-- ------------------------------------------------------------
	SELECT billing_entity_id
	INTO   v_billing_entity_id
	FROM   csctoss.line
	WHERE  line_id = v_line_id ;

	IF v_billing_entity_id IS NULL THEN
		-- Line ID not found
		o_billing_entity_id := -1 ;
	ELSE
		-- ------------------------------------------------------------
		-- Loop through the billing_entity_structure to check
		-- if any billing entity ancestors are in the branding
		-- tables.  Don't look more than 10 levels back
		-- (parents, grandparents, etc.)
		-- ------------------------------------------------------------
		v_found := FALSE ;

		IF v_billing_entity_id IS NOT NULL THEN
			WHILE v_loop_counter < v_loop_max
			LOOP
				-- Check the specific billing_entity_id first
				IF v_loop_counter = 0 THEN
					v_check_billing_entity_id := v_billing_entity_id ;
				ELSE
					SELECT parent_billing_entity_id
					INTO   v_check_billing_entity_id
					FROM   csctoss.billing_entity_structure()
					WHERE  billing_entity_id = v_billing_entity_id ;
				END IF ;

				IF v_check_billing_entity_id IS NULL THEN
					-- No more ancestors
					v_loop_counter := v_loop_max ;
				ELSE
					v_loop_counter := v_loop_counter + 1 ;

					-- Check Context table
					SELECT count(*)
					INTO   v_counter
					FROM   csctoss.branding_content
					WHERE  parent_billing_entity_id = v_check_billing_entity_id ;

					IF v_counter > 0 THEN
						SELECT parent_billing_entity_id
						INTO   v_parent_billing_entity_id
						FROM   csctoss.branding_content
						WHERE  parent_billing_entity_id = v_check_billing_entity_id ;

						v_found := TRUE ;
					ELSE
						-- Check Presentation table
						SELECT count(*)
						INTO   v_counter
						FROM   csctoss.branding_presentation
						WHERE  parent_billing_entity_id = v_check_billing_entity_id ;

						IF v_counter > 0 THEN
							SELECT parent_billing_entity_id
							INTO   v_parent_billing_entity_id
							FROM   csctoss.branding_presentation
							WHERE  parent_billing_entity_id = v_check_billing_entity_id ;

							v_found := TRUE ;
						END IF ;
					END IF ;

					IF NOT v_found THEN
						v_billing_entity_id := v_check_billing_entity_id ;
					ELSE
						-- Found branding billing entity ID, stop looking
						o_billing_entity_id := v_parent_billing_entity_id ;
						v_loop_counter := v_loop_max ;
					END IF ;
				END IF ;
			END LOOP ;
		ELSE
		END IF ;
	END IF ; -- check for line id

	-- Return billing_entity_id
	RETURN o_billing_entity_id ;
END ;
$_$;


ALTER FUNCTION csctoss.get_branding_billing_entity_id_by_radius_username(text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION get_branding_billing_entity_id_by_radius_username(text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION get_branding_billing_entity_id_by_radius_username(text) IS '$Id: Returns most specific billing_entity_id used in branding for a line (via Radius Username)';


--
-- Name: get_encrypt_key(integer, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION get_encrypt_key(integer, text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
	par_contract_id		ALIAS FOR $1 ;
	par_pin_code		ALIAS FOR $2 ;
	v_encrypt_key		TEXT ;
BEGIN
	SELECT encryption_key
	INTO   v_encrypt_key
	FROM   cc_encrypt_key
	WHERE  contract_id = par_contract_id
	AND    pin_code    = par_pin_code ;

	IF v_encrypt_key IS NULL THEN
		v_encrypt_key := 'ERROR' ;
	END IF ;

	RETURN v_encrypt_key ;
END ;
$_$;


ALTER FUNCTION csctoss.get_encrypt_key(integer, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION get_encrypt_key(integer, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION get_encrypt_key(integer, text) IS 'Return encryption key for b-Market using the contract ID and PIN code.';


--
-- Name: get_encrypt_key(text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION get_encrypt_key(text, text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
	par_phone_number	ALIAS FOR $1 ;
	par_pin_code		ALIAS FOR $2 ;
	v_encrypt_key		TEXT ;
BEGIN
	SELECT encryption_key
	INTO   v_encrypt_key
	FROM   cc_encrypt_key
	WHERE  phone_number = par_phone_number
	AND    pin_code     = par_pin_code ;

	IF v_encrypt_key IS NULL THEN
		v_encrypt_key := 'ERROR' ;
	END IF ;

	RETURN v_encrypt_key ;
END ;
$_$;


ALTER FUNCTION csctoss.get_encrypt_key(text, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION get_encrypt_key(text, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION get_encrypt_key(text, text) IS 'Return encryption key for b-Market using the phone number and PIN code.';


--
-- Name: get_equipment_line_unique_identifier(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION get_equipment_line_unique_identifier(text) RETURNS SETOF equipment_line_unique_identifier_retval
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
     
     par_value                  text := $1;
     var_equipment_id           integer;
     var_line_id                integer;
     var_equipment_type	        text;
     var_serial_number          text;
     var_esn_hex                text;
     var_esn_dec	        text;
     var_min                    text;
     var_mdn                    text;
     var_mac_address            text;
     var_line_label             text;
     var_uniqid_row             RECORD;
     v_query                    text;
     var_return_row	        equipment_line_unique_identifier_retval%ROWTYPE;

BEGIN
  RAISE NOTICE 'Entering function.';

  IF length(trim(coalesce(par_value, ''))) = 0 THEN
      RAISE EXCEPTION 'Input value is Null.';
  END IF;

 IF ( SELECT TRUE FROM line WHERE radius_username LIKE (par_value || '%@%')) THEN 

    SELECT line_label INTO var_line_label
    FROM line
    WHERE radius_username LIKE (par_value || '%@%'); 

    IF NOT EXISTS (SELECT equipment_id FROM unique_identifier WHERE value LIKE var_line_label) THEN 
 
         RAISE EXCEPTION 'No Unique Identifiers Exists.';

    END IF;

ELSIF NOT EXISTS (SELECT equipment_id FROM unique_identifier WHERE value LIKE (par_value || '%')) THEN 

     RAISE EXCEPTION 'No Unique Identifiers Exists.';

END IF;

IF (par_value LIKE '%@%') THEN 

       v_query := 'SELECT l.line_id AS line_id, 
                          le.equipment_id AS equipment_id, 
                          eq.equipment_type AS equipment_type
                   FROM line l
                   JOIN line_equipment le ON (l.line_id = le.line_id)
                   JOIN equipment eq ON (le.equipment_id = eq.equipment_id)
                   WHERE radius_username LIKE ' ||quote_literal( par_value || '%')||'LIMIT 100'; 
ELSE 

      v_query := 'SELECT ui.equipment_id AS equipment_id,
                         eq.equipment_type AS equipment_type,
                         lieq.line_id AS line_id
                  FROM unique_identifier ui
                  JOIN equipment eq ON(ui.equipment_id = eq.equipment_id)
                  JOIN line_equipment lieq ON (ui.equipment_id = lieq.equipment_id)
                  WHERE ui.unique_identifier_type IN (''ESN HEX'', ''ESN DEC'', ''MDN'', ''MIN'', ''SERIAL NUMBER'', ''MAC ADDRESS'', ''ESN HEX1'', ''ESN HEX2'', ''ESN DEC1'', ''ESN DEC2'', ''MIN1'', ''MIN2'', ''MDN1'', ''MDN2'')
                  AND  ui.value LIKE ' ||quote_literal( par_value || '%')||'GROUP BY  ui.equipment_id, eq.equipment_type, lieq.line_id LIMIT 100';

END IF;

FOR var_uniqid_row IN EXECUTE v_query 

  LOOP

    var_equipment_id := var_uniqid_row.equipment_id ;
    var_line_id := var_uniqid_row.line_id;
    var_equipment_type := var_uniqid_row.equipment_type;

    -- Retrieve Serial Number and Mac Address for the obtained Equipment_Id Value. These are unique for all types of equipments.
   
    SELECT uid1.value INTO var_serial_number FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'SERIAL NUMBER'::text;
    SELECT uid1.value INTO var_mac_address FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MAC ADDRESS'::text;

    IF var_equipment_type = 'ROUTER' THEN 
      -- Get all unique_identifier values for a Router
      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;
      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;
      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;
      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text;

   ELSIF var_equipment_type = 'CARD' THEN 
      -- Get the unique_identifiers for the equipment type Card. 
      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;
      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;
      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;
      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text; 

    ELSIF var_equipment_type = 'MODULE' THEN 
      -- Get the unique_identifiers for the equipment_type Module.
      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;
      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;
      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;
      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text; 
    END IF;

    FOR var_return_row IN
      SELECT line.line_id, lieq.start_date AS line_assignment_start, lieq.end_date AS line_assignment_end, 
             CASE
                 WHEN line.billing_entity_id IS NOT NULL THEN 
                      (SELECT billing_entity.name
                       FROM billing_entity
                       WHERE billing_entity.billing_entity_id = line.billing_entity_id)
                 ELSE NULL::text
             END AS billing_entity, equp.equipment_id, eqmo.carrier, eqty.equipment_type, eqmo.model_number1,line.radius_username, line.ip_pool,
             CASE
                 WHEN line.radius_username IS NOT NULL THEN 
                    COALESCE(( SELECT radreply.value FROM radreply
                               WHERE radreply.attribute::text = 'Framed-IP-Address'::text AND radreply.username::text = line.radius_username), 'N/A'::text::character varying)
                 ELSE 'N/A'::character varying
             END AS static_ip_address, 
	     CASE
                 WHEN eqty.preferred_unique_identifier_type IS NOT NULL AND line.radius_username IS NOT NULL THEN 
                     (SELECT bent2.name FROM username usna2, billing_entity bent2
                      WHERE bent2.billing_entity_id = usna2.billing_entity_id AND usna2.username::text = line.radius_username)
                 ELSE NULL::text
             END AS radius_billing_entity, var_serial_number, var_esn_hex, var_esn_dec, var_min, var_mdn, var_mac_address 
      FROM equipment equp
      JOIN equipment_type eqty ON eqty.equipment_type = equp.equipment_type
      JOIN equipment_model eqmo ON eqmo.equipment_model_id = equp.equipment_model_id
      LEFT JOIN equipment_status eqst ON eqst.equipment_id = equp.equipment_id
      LEFT JOIN line_equipment lieq ON lieq.equipment_id = equp.equipment_id
      JOIN line ON line.line_id = lieq.line_id
      WHERE equp.equipment_id = var_equipment_id 
      AND line.line_id = var_line_id
      --AND lieq.end_date IS NULL
             
    LOOP
      
        RETURN NEXT var_return_row;
    
    END LOOP;

 IF ( var_equipment_type = 'MULTI_NETWORK ROUTER') THEN 
          
  FOR var_return_row IN
        SELECT line.line_id, lieq.start_date AS line_assignment_start, lieq.end_date AS line_assignment_end, 
                 CASE
                      WHEN line.billing_entity_id IS NOT NULL THEN 
                           (SELECT billing_entity.name
                            FROM billing_entity
                            WHERE billing_entity.billing_entity_id = line.billing_entity_id)
                       ELSE NULL::text
                 END AS billing_entity, equp.equipment_id, eqmo.carrier, eqty.equipment_type, eqmo.model_number1,line.radius_username, line.ip_pool,
                 CASE
                      WHEN line.radius_username IS NOT NULL THEN 
                           COALESCE(( SELECT radreply.value FROM radreply
                                       WHERE radreply.attribute::text = 'Framed-IP-Address'::text AND radreply.username::text = line.radius_username), 'N/A'::text::character varying)
                      ELSE 'N/A'::character varying
                 END AS static_ip_address, 
	         CASE
                      WHEN eqty.preferred_unique_identifier_type IS NOT NULL AND line.radius_username IS NOT NULL THEN 
                           (SELECT bent2.name FROM username usna2, billing_entity bent2
                            WHERE bent2.billing_entity_id = usna2.billing_entity_id AND usna2.username::text = line.radius_username)
                      ELSE NULL::text
                 END AS radius_billing_entity, var_serial_number, var_esn_hex, var_esn_dec, var_min, var_mdn, var_mac_address,
            (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN HEX1'::text) AS esn_hex1,
            (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN HEX2'::text) AS esn_hex2,
	    (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN DEC1'::text) AS esn_dec1,
	    (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN DEC2'::text) AS esn_dec2,
            (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MIN1'::text) AS min1,
	    (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MIN2'::text) AS min2,
	    (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MDN1'::text) AS mdn1,	
            (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MDN2'::text) AS mdn2 
        FROM equipment equp
        JOIN equipment_type eqty ON eqty.equipment_type = equp.equipment_type
        JOIN equipment_model eqmo ON eqmo.equipment_model_id = equp.equipment_model_id
        LEFT JOIN equipment_status eqst ON eqst.equipment_id = equp.equipment_id
        LEFT JOIN line_equipment lieq ON lieq.equipment_id = equp.equipment_id
        JOIN line ON line.line_id = lieq.line_id
        WHERE equp.equipment_id = var_equipment_id 
	AND line.line_id = var_line_id
        --AND lieq.end_date IS NULL

    LOOP
   
        RETURN NEXT var_return_row;

    END LOOP;

   END IF; 

  END LOOP;

  RAISE NOTICE 'Finished function.';

  RETURN;

END;
 $_$;


ALTER FUNCTION csctoss.get_equipment_line_unique_identifier(text) OWNER TO csctoss_owner;

--
-- Name: get_is_currently_connected_by_username(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION get_is_currently_connected_by_username(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
  par_username      text := $1 ;
  var_dblink_sql    text;
  var_return        text;
  
BEGIN
    var_dblink_sql := 'SELECT acctstarttime FROM master_radacct m WHERE m.username = ' || quote_literal(par_username) ||
                      ' AND m.acctstoptime IS NULL AND m.acctstarttime >= (current_timestamp - ''2 days''::INTERVAL) ' ||
                      ' AND m.master_radacctid = (SELECT MAX(master_radacctid) FROM master_radacct ' ||
                      ' WHERE acctstarttime >= (current_timestamp - ''2 days''::INTERVAL) AND username = m.username)';

    SELECT acctstarttime INTO var_return
    FROM public.dblink(fetch_csctlog_conn(), var_dblink_sql) AS rec_type (acctstarttime text) ;

    IF var_return IS NULL THEN
      var_return := 'Not Connected' ;
    ELSE
      var_return := 'Connected at ' || var_return;
    END IF;

    RETURN var_return;
END ;
$_$;


ALTER FUNCTION csctoss.get_is_currently_connected_by_username(text) OWNER TO csctoss_owner;

--
-- Name: get_last_connection_by_line_id(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION get_last_connection_by_line_id(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
  par_line_id		TEXT:=$1 ;
  var_return		TEXT;
  var_dblink_sql	TEXT;
  var_username		TEXT;
  var_session		TEXT:=null;
BEGIN

    SET enable_seqscan = off;

    SET client_min_messages TO notice ;

    RAISE NOTICE 'PASSED USERNAME = %' , par_line_id ;

    --get last connection from radius server
    var_dblink_sql := 'SELECT username,max(acctstarttime) FROM master_radacct WHERE class = '||quote_literal(par_line_id)||' group by username' ;

    RAISE NOTICE 'var_dblink_sql = % ', var_dblink_sql ;

    SELECT * INTO var_username,var_session FROM public.dblink(fetch_csctlog_conn(), var_dblink_sql) AS rec_type (username text, acctstarttime text) ;
    
    RAISE NOTICE 'var_username = %' , var_username;
    RAISE NOTICE 'var_session = %' , var_session;

    IF var_session is NULL THEN
      var_session := 'NO SESSION IN LAST 6 MONTHS' ;
    END IF;

    RETURN var_session;

END ;

$_$;


ALTER FUNCTION csctoss.get_last_connection_by_line_id(integer) OWNER TO csctoss_owner;

--
-- Name: get_last_connection_by_username(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION get_last_connection_by_username(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
  par_username		TEXT:=$1 ;
  var_return		TEXT;
  var_dblink_sql	TEXT;
  var_username		TEXT;
  var_session		TEXT:=null;
BEGIN

    SET enable_seqscan = off;

    SET client_min_messages TO notice ;

    RAISE NOTICE 'PASSED USERNAME = %' , par_username ;

    --get last connection from radius server
    var_dblink_sql := 'SELECT username,max(acctstarttime) FROM master_radacct WHERE username = '||quote_literal(par_username)||' group by username' ;

    RAISE NOTICE 'var_dblink_sql = % ', var_dblink_sql ;

    SELECT * INTO var_username,var_session FROM public.dblink(fetch_csctlog_conn(), var_dblink_sql) AS rec_type (username text, acctstarttime text) ;
    
    RAISE NOTICE 'var_username = %' , var_username;
    RAISE NOTICE 'var_session = %' , var_session;

    IF var_session is NULL THEN
      var_session := 'NO SESSION IN LAST 6 MONTHS' ;
    END IF;

    RETURN var_session;

END ;

$_$;


ALTER FUNCTION csctoss.get_last_connection_by_username(text) OWNER TO csctoss_owner;

--
-- Name: get_line_radius_all(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION get_line_radius_all(integer) RETURNS SETOF rad_all_attr_retval
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
	par_line_id			ALIAS FOR $1 ;
	v_radius_username	TEXT ;
	v_calling_station	TEXT ;
	v_return			rad_all_attr_retval ;

	v_radius_row		RECORD ;
	curs_rad			CURSOR (i_username TEXT, i_calling_station TEXT) IS
							SELECT 1 AS ordno, 'UserGroup' AS source, groupname,
								   NULL::text AS attribute, NULL::text AS op, NULL::text AS "value",
								   priority
							FROM   usergroup
							WHERE  username IN (i_username, i_calling_station)
							UNION
							SELECT 2, 'RadCheck', NULL, attribute, op, "value", NULL
							FROM   radcheck
							WHERE  username IN (i_username, i_calling_station)
							UNION
							SELECT 3, 'RadGroupCheck', groupname, attribute, op, "value", NULL
							FROM   radgroupcheck
							WHERE  groupname IN (SELECT groupname
												 FROM   usergroup
												 WHERE  username IN (i_username, i_calling_station))
							AND    LOWER(attribute) <> 'calling-station-id'
							UNION
							SELECT 3, 'RadGroupCheck', rgck.groupname, rgck.attribute, rgck.op,
							       "value", NULL
							FROM   radgroupcheck rgck, usergroup usgr
							WHERE  rgck.groupname = usgr.groupname
							AND    LOWER(rgck.attribute) = 'calling-station-id'
							AND    rgck."value" = i_calling_station
							AND    usgr.username = i_username
							AND    NOT EXISTS (SELECT 1
											   FROM   radreply rare
											   WHERE  LOWER(rare.attribute) = 'calling-station-id'
											   AND    rare.username = i_username
											   AND    rare."value" = i_calling_station )
							UNION
							SELECT 4, 'RadReply', NULL, attribute, op, "value", priority
							FROM   radreply
							WHERE  username IN (i_username, i_calling_station)
							UNION
							SELECT 5, 'RadGroupReply', groupname, attribute, op, "value", NULL
							FROM   radgroupreply
							WHERE  groupname IN (SELECT groupname
												 FROM   usergroup
												 WHERE  username IN (i_username, i_calling_station))
							ORDER BY 1, 6, 4 ;
BEGIN
	SELECT COALESCE(line.calling_station_id,'N/A')
              ,(select username from radreply where attribute = 'Class' and value = line.line_id::text)
	INTO   v_calling_station, v_radius_username
	FROM   line
	WHERE  line_id = par_line_id ;

	OPEN curs_rad (v_radius_username, v_calling_station) ;
	LOOP
		FETCH curs_rad INTO v_radius_row ;
		EXIT WHEN NOT FOUND ;

		v_return := ROW(v_radius_row.source, v_radius_row.groupname, v_radius_row.attribute,
						v_radius_row.op, v_radius_row."value", v_radius_row.priority) ;
		RETURN NEXT v_return ;
	END LOOP ;
	CLOSE curs_rad ;

	RETURN ;
END ;
$_$;


ALTER FUNCTION csctoss.get_line_radius_all(integer) OWNER TO csctoss_owner;

--
-- Name: FUNCTION get_line_radius_all(integer); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION get_line_radius_all(integer) IS 'Return ALL radius attributes associated with a line based on radius username and calling station id';


--
-- Name: get_line_radius_info(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION get_line_radius_info(integer) RETURNS SETOF rad_attrval_retval
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
	par_line_id				ALIAS FOR $1 ;
	v_return				rad_attrval_retval ;
	v_counter				integer ;
	v_calling_station_id	text ;
	v_radius_username		text ;
	v_attribute				text ;
	v_op					text ;
	v_value					text ;

	v_usergroup_row			RECORD ;
	curs_usergroup			CURSOR (user_key1 TEXT, user_key2 TEXT) IS
								SELECT username, groupname, priority
								FROM   usergroup
								WHERE  username IN (user_key1, user_key2)
								ORDER BY priority ;

	v_radcheck_row			RECORD ;
	curs_radcheck			CURSOR (user_key1 TEXT, user_key2 TEXT) IS
								SELECT 'RadCheck' AS source, attribute, op, "value"
								FROM   radcheck
								WHERE  username IN (user_key1, user_key2)
								UNION
								SELECT *
								FROM   get_radgroupcheck_values(user_key1, user_key2)
								ORDER BY 1, 2;
	v_radreply_row			RECORD ;
	curs_radreply			CURSOR (user_key1 TEXT, user_key2 TEXT) IS
								SELECT 'RadReply' AS source, attribute, op, "value"
								FROM   radreply rare
								WHERE  username IN (user_key1,user_key2)
								AND    NOT EXISTS (SELECT 1
												   FROM   radreply rare2
												   WHERE  rare2.username IN (user_key1, user_key2)
												   AND    rare2.attribute = rare.attribute
												   AND    rare2.priority < rare.priority)
								UNION
								SELECT *
								FROM   get_radgroupreply_values(user_key1, user_key2)
								ORDER BY 1 desc, 2;
BEGIN
	-- Get information used for Radius checks and replies
	-- NOTE: calling_station_id is "internationalized" here to match Radius data
	--       the CSID in Comet does not contain the country code
	SELECT COALESCE(line.calling_station_id,'N/A')
              ,(select username from radreply where attribute = 'Class' and value = line.line_id::text)
	INTO   v_calling_station_id, v_radius_username
	FROM   line
	WHERE  line_id = par_line_id ;

	v_return := ROW('Line', 'Calling Station ID', NULL,  v_calling_station_id) ;
	RETURN NEXT v_return ;
	v_return := ROW('Line', 'Radius Username', NULL,  v_radius_username) ;
	RETURN NEXT v_return ;

	-- Get user/group relationships for username and calling station id
	OPEN curs_usergroup(v_radius_username, v_calling_station_id) ;
	LOOP
		FETCH curs_usergroup INTO v_usergroup_row ;
		EXIT WHEN NOT FOUND ;

		v_return := ROW('UserGroup', v_usergroup_row.groupname, 'Priority', v_usergroup_row.priority) ;
		RETURN NEXT v_return ;
	END LOOP ;
	CLOSE curs_usergroup ;

	-- Get Radius check values
	OPEN curs_radcheck(v_radius_username, v_calling_station_id) ;
	LOOP
		FETCH curs_radcheck INTO v_radcheck_row ;
		EXIT WHEN NOT FOUND ;

		v_return := ROW (v_radcheck_row.source, v_radcheck_row.attribute, v_radcheck_row.op, v_radcheck_row."value") ;
		RETURN NEXT v_return ;
	END LOOP ;
	CLOSE curs_radcheck ;

	-- Due to shared user names, calling station id is not included
	-- in the results set for RadGroupCheck.  If there is not an
	-- individual override, query this separately
	v_attribute := NULL ;
	SELECT rgck.attribute, rgck.op, rgck."value"
	INTO   v_attribute, v_op, v_value
	FROM   radgroupcheck rgck, usergroup usgr
	WHERE  rgck.groupname = usgr.groupname
	AND    LOWER(rgck.attribute) = 'calling-station-id'
	AND    rgck."value" = v_calling_station_id
	AND    usgr.username = v_radius_username
	AND    NOT EXISTS (SELECT 1
						FROM   radreply rare
						WHERE  LOWER(rare.attribute) = 'calling-station-id'
						AND    rare.username = v_radius_username
						AND    rare."value" = v_calling_station_id ) ;

	IF v_attribute IS NOT NULL THEN
		v_return := ROW('RadGroupCheck', v_attribute, v_op, v_value) ;
		RETURN NEXT v_return ;
	END IF ;

	-- Get Radius reply values
	OPEN curs_radreply(v_radius_username, v_calling_station_id) ;
	LOOP
		FETCH curs_radreply INTO v_radreply_row ;
		EXIT WHEN NOT FOUND ;

		v_return := ROW (v_radreply_row.source, v_radreply_row.attribute, v_radreply_row.op, v_radreply_row."value") ;
		RETURN NEXT v_return ;
	END LOOP ;
	CLOSE curs_radreply ;

	RETURN ;
END ;
$_$;


ALTER FUNCTION csctoss.get_line_radius_info(integer) OWNER TO csctoss_owner;

--
-- Name: FUNCTION get_line_radius_info(integer); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION get_line_radius_info(integer) IS 'Return a list of prioritized Radius attributes for a line';


--
-- Name: get_list_static_ip(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION get_list_static_ip(text) RETURNS SETOF get_list_static_ip
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
       par_static_ip             ALIAS FOR $1;
       v_return                  get_list_static_ip;
       v_get_static_ips_row      RECORD;
       curs_static_ip_retval     CURSOR (par_static_ip text) IS
                                 SELECT ln.line_id AS line_id, 
                                        TO_CHAR(ln.start_date,'mm/dd/yyyy') AS start_date,
                                        TO_CHAR(ln.end_date,'mm/dd/yyyy') AS end_date,
                                        rp.username AS calling_station,
                                        be.name AS customer_name,
                                        'N/A' AS auth_group_name,
                                        'N/A' AS pool_group_name,
                                        'N/A' AS service_group_name
                                   FROM line ln,
                                        billing_entity be,
                                        radreply rp
                                  WHERE be.billing_entity_id   = ln.billing_entity_id
                                    AND rp.value               = ln.line_id
                                    AND ln.line_id IN (SELECT value 
                                                         FROM radreply 
                                                        WHERE attribute = 'Class' 
                                                          AND username IN (SELECT username 
                                                                             FROM radreply 
                                                                            WHERE attribute LIKE '%Framed-IP-Address%'
                                                                              AND value LIKE '%'||par_static_ip||'%'));

BEGIN
   OPEN curs_static_ip_retval(par_static_ip);
   LOOP
       FETCH curs_static_ip_retval INTO v_get_static_ips_row;
       EXIT WHEN NOT FOUND;

       v_return := ROW(v_get_static_ips_row.line_id, v_get_static_ips_row.start_date, 
                       v_get_static_ips_row.end_date,v_get_static_ips_row.calling_station,
                       v_get_static_ips_row.customer_name, v_get_static_ips_row.auth_group_name, 
                       v_get_static_ips_row.pool_group_name,v_get_static_ips_row.service_group_name);

       RETURN NEXT v_return;
   END LOOP;
   CLOSE curs_static_ip_retval;
   RETURN;
END;
$_$;


ALTER FUNCTION csctoss.get_list_static_ip(text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION get_list_static_ip(text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION get_list_static_ip(text) IS 'Returns list of static ips';


--
-- Name: get_parent_branding(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION get_parent_branding(text) RETURNS integer
    LANGUAGE plpgsql STRICT SECURITY DEFINER
    AS $_$
DECLARE
	i_username					text := $1 ;
	v_counter					INTEGER ;
	v_loop_counter				INTEGER := 0 ;
	v_loop_max					INTEGER := 10 ;
	v_found						BOOLEAN := FALSE ;
	v_line_id					INTEGER ;
	v_billing_entity_id			INTEGER ;
	v_parent_billing_entity_id	INTEGER ;
	v_check_billing_entity_id	INTEGER ;
	v_is_registered				BOOLEAN := FALSE ;
	o_billing_entity_id			INTEGER := -1 ;
BEGIN
	-- ------------------------------------------------------------
	-- Get the Line ID by Radius Username
	-- ------------------------------------------------------------
	SELECT "value"
	INTO   v_line_id
	FROM   csctoss.radreply
	WHERE  attribute = 'Class'
	AND    username = i_username ;

	-- ------------------------------------------------------------
	-- Get the billing_entity_id for the line
	-- ------------------------------------------------------------
	SELECT billing_entity_id
	INTO   v_billing_entity_id
	FROM   csctoss.line
	WHERE  line_id = v_line_id ;

	IF v_billing_entity_id IS NULL THEN
		-- Line ID not found
		o_billing_entity_id := -1 ;
	ELSE
		-- ------------------------------------------------------------
		-- Loop through the billing_entity_structure to check
		-- if any billing entity ancestors are in the branding
		-- tables.  Don't look more than 10 levels back
		-- (parents, grandparents, etc.)
		-- ------------------------------------------------------------
		v_found := FALSE ;

		IF v_billing_entity_id IS NOT NULL THEN
			WHILE v_loop_counter < v_loop_max
			LOOP
				-- Check the specific billing_entity_id first
				IF v_loop_counter = 0 THEN
					v_check_billing_entity_id := v_billing_entity_id ;
				ELSE
					SELECT parent_billing_entity_id
					INTO   v_check_billing_entity_id
					FROM   csctoss.billing_entity_structure()
					WHERE  billing_entity_id = v_billing_entity_id ;
				END IF ;

				IF v_check_billing_entity_id IS NULL THEN
					-- No more ancestors
					v_loop_counter := v_loop_max ;
				ELSE
					v_loop_counter := v_loop_counter + 1 ;

					-- Check Context table
					SELECT count(*)
					INTO   v_counter
					FROM   csctoss.branding_content
					WHERE  parent_billing_entity_id = v_check_billing_entity_id ;

					IF v_counter > 0 THEN
						SELECT parent_billing_entity_id
						INTO   v_parent_billing_entity_id
						FROM   csctoss.branding_content
						WHERE  parent_billing_entity_id = v_check_billing_entity_id ;

						v_found := TRUE ;
					ELSE
						-- Check Presentation table
						SELECT count(*)
						INTO   v_counter
						FROM   csctoss.branding_presentation
						WHERE  parent_billing_entity_id = v_check_billing_entity_id ;

						IF v_counter > 0 THEN
							SELECT parent_billing_entity_id
							INTO   v_parent_billing_entity_id
							FROM   csctoss.branding_presentation
							WHERE  parent_billing_entity_id = v_check_billing_entity_id ;

							v_found := TRUE ;
						END IF ;
					END IF ;

					IF NOT v_found THEN
						v_billing_entity_id := v_check_billing_entity_id ;
					ELSE
						-- Found branding billing entity ID, stop looking
						o_billing_entity_id := v_parent_billing_entity_id ;
						v_loop_counter := v_loop_max ;
					END IF ;
				END IF ;
			END LOOP ;
		ELSE
		END IF ;
	END IF ; -- check for line id

	-- Return billing_entity_id
	RETURN o_billing_entity_id ;
END ;
$_$;


ALTER FUNCTION csctoss.get_parent_branding(text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION get_parent_branding(text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION get_parent_branding(text) IS '$Id: Returns most specific billing_entity_id used in branding for a line (via Radius Username)';


--
-- Name: get_plan_acct_dates(date); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION get_plan_acct_dates(date) RETURNS SETOF plan_acct_dates_retval
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_run_date		DATE	:= $1 ;

  var_date 		DATE ;
  var_counter		INTEGER	:= 0 ;
  var_check_flag	BOOLEAN ;

  pl_rec		PLAN_ACCT_DATES_RETVAL ;

  pl_cur                CURSOR (i_min_end_date DATE) IS
                        SELECT (SELECT be2.name
                                  FROM csctoss.billing_entity be2
                                 WHERE  be2.billing_entity_id = COALESCE(be.parent_billing_entity_id, be.billing_entity_id)) AS parent_company
                              ,COALESCE(be.parent_billing_entity_id, be.billing_entity_id) AS parent_company_id
                              ,be.name AS billing_entity
                              ,be.billing_entity_id
                              ,line.line_id
                              ,line.line_label
                              ,line.current_plan_id AS plan_id
                              ,pln.start_date AS plan_start_date
                              ,pln.end_date AS plan_end_date
                              ,pln.length_days
                              ,NULL AS plan_accounting_date
                              ,product.product_id
                              ,product.product_desc
                          FROM csctoss.line
                          JOIN csctoss.billing_entity be using (billing_entity_id)
                          JOIN csctoss.plan pln on (pln.plan_id = line.current_plan_id)
                          JOIN csctoss.product using (product_id)
                         WHERE pln.plan_type_id = 2
                           AND pln.end_date >= (i_min_end_date - INTERVAL '1 month')
                      ORDER BY 1, 3, 7 ;

BEGIN

  IF par_run_date IS NULL THEN
    par_run_date := current_date ;
  END IF ;

  OPEN pl_cur (par_run_date) ;

  LOOP

    FETCH pl_cur INTO pl_rec ;

    IF NOT FOUND THEN
      EXIT ;
    END IF ;

    -- Check for previous Telecom Battery Plans
    SELECT COUNT(*)
       INTO var_counter
       FROM plan
      WHERE line_id = pl_rec.line_id
        AND plan_type_id = 2
        AND plan_id < pl_rec.plan_id ;

    IF var_counter > 0 THEN
      -- Not the first TB plan, accounting date is same as start date
      pl_rec.plan_accounting_date := pl_rec.plan_start_date ;

    ELSE

      SELECT COUNT(*)
        INTO var_counter
        FROM csctoss.master_radacct
       WHERE class = pl_rec.line_id
         AND acctstarttime > pl_rec.plan_start_date -- NEW NEW NEW
         AND acctstarttime < pl_rec.plan_start_date + INTERVAL '30 days' ;

      IF var_counter < 4 THEN
        -- no usage records or the minimum three usage records not found
        -- default to 30 days after start date
        pl_rec.plan_accounting_date := pl_rec.plan_start_date + INTERVAL '30 days' ;

      ELSE

        var_check_flag := TRUE ;
        SELECT acctstarttime::date
          INTO var_date
          FROM csctoss.master_radacct
         WHERE master_radacctid = (select max(master_radacctid)
                                     from (select master_radacctid
                                             from csctoss.master_radacct
                                            where class = pl_rec.line_id
                                              and acctstarttime > pl_rec.plan_start_date
                                         order by master_radacctid
                                            limit 3) subq) ;

        -- Should never hit this code
        IF NOT FOUND THEN
          var_check_flag := FALSE ;
          pl_rec.plan_accounting_date := pl_rec.plan_start_date + INTERVAL '30 days' ;
        END IF ;

        IF var_check_flag = TRUE THEN
          pl_rec.plan_accounting_date := var_date ;
        -- Should never  hit this code
        ELSE
          pl_rec.plan_accounting_date := pl_rec.plan_start_date + INTERVAL '30 days' ;
        END IF ;

      END IF ;

    END IF ;

    RETURN NEXT pl_rec ;

  END LOOP ;

  CLOSE pl_cur ;

  RETURN ;
END ;
$_$;


ALTER FUNCTION csctoss.get_plan_acct_dates(date) OWNER TO csctoss_owner;

--
-- Name: FUNCTION get_plan_acct_dates(date); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION get_plan_acct_dates(date) IS 'Function to retrieve starting dats for Telecom Battery plans';


--
-- Name: get_radgroupcheck_values(text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION get_radgroupcheck_values(text, text) RETURNS SETOF rad_attrval_retval
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
	par_username			ALIAS FOR $1 ;
	par_calling_station		ALIAS FOR $2 ;
	v_return				rad_attrval_retval ;
	v_source				text := 'RadGroupCheck' ;
	v_value					text ;
	v_counter				integer ;

	v_attr_row				RECORD ;
	curs_attr				CURSOR (user_key1 TEXT, user_key2 TEXT) IS
								SELECT DISTINCT groupname, attribute, op
								FROM   radgroupcheck rgck
								WHERE  groupname IN (SELECT groupname
													 FROM   usergroup
													 WHERE  username IN (user_key1, user_key2))
								AND    LOWER(attribute) <> 'calling-station-id'
								AND    NOT EXISTS (SELECT 1
												   FROM   radcheck rach
												   WHERE  rach.attribute = rgck.attribute
												   AND    username IN (user_key1, user_key2))
								AND    NOT EXISTS (SELECT 1
												   FROM   radgroupcheck rgck2,
														  usergroup usgr
												   WHERE  usgr.groupname = rgck2.groupname
												   AND    usgr.groupname <> rgck.groupname
												   AND    rgck2.attribute = rgck.attribute
												   AND    usgr.username IN (user_key1, user_key2)
												   AND    NOT EXISTS (SELECT 1
																	  FROM   usergroup usgr2
																	  WHERE  usgr2.groupname = rgck2.groupname
																	  AND    usgr2.priority < usgr.priority)) ;
	v_vals_row				text ;
	curs_vals				CURSOR (group_key TEXT, attr_key TEXT) IS
								SELECT "value" AS val
								FROM   radgroupcheck
								WHERE  groupname = group_key
								AND    attribute = attr_key
								AND    LOWER(attribute) <> 'calling-station-id'
								ORDER BY id ;
BEGIN
	OPEN curs_attr(par_calling_station, par_username) ;
	LOOP
		FETCH curs_attr INTO v_attr_row ;
		EXIT WHEN NOT FOUND ;

		IF v_attr_row.op <> '+=' THEN
			-- no concatenation needed
			SELECT "value"
			INTO   v_value
			FROM   radgroupcheck
			WHERE  groupname = v_attr_row.groupname
			AND    attribute = v_attr_row.attribute ;
		ELSE
			-- need to concatenate values
			v_value := ' ' ;
			v_counter := 0 ;
			OPEN curs_vals(v_attr_row.groupname, v_attr_row.attribute) ;
			LOOP
				FETCH curs_vals INTO v_vals_row ;
				EXIT WHEN NOT FOUND ;

				v_counter := v_counter + 1 ;
				v_value := v_value || v_vals_row || ' ' ;
			END LOOP ; -- Values loop
			CLOSE curs_vals ;
			v_value := RTRIM(v_value,' ') ;
		END IF ;

		v_return := ROW(v_source, v_attr_row.attribute, v_attr_row.op,  v_value) ;
		RETURN NEXT v_return ;

	END LOOP ; -- Attributes loop
	CLOSE curs_attr ;

	RETURN ;
END ;
$_$;


ALTER FUNCTION csctoss.get_radgroupcheck_values(text, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION get_radgroupcheck_values(text, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION get_radgroupcheck_values(text, text) IS 'Return a list of Radius Group Check values, concatenated as needed, for a username';


--
-- Name: get_radgroupreply_values(text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION get_radgroupreply_values(text, text) RETURNS SETOF rad_attrval_retval
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
	par_username			ALIAS FOR $1 ;
	par_calling_station		ALIAS FOR $2 ;
	v_return				rad_attrval_retval ;
	v_source				text := 'RadGroupReply' ;
	v_value					text ;
	v_counter				integer ;

	v_attr_row				RECORD ;
	curs_attr				CURSOR (user_key1 TEXT, user_key2 TEXT) IS
								SELECT DISTINCT groupname, attribute, op
								FROM   radgroupreply rgrp
								WHERE  groupname IN (SELECT groupname
													 FROM   usergroup
													 WHERE  username IN (user_key1, user_key2))
								AND    NOT EXISTS (SELECT 1
												   FROM   radreply rare
												   WHERE  rare.attribute = rgrp.attribute
												   AND    username IN (user_key1, user_key2))
								AND    NOT EXISTS (SELECT 1
												   FROM   radgroupreply rgrp2,
														  usergroup usgr
												   WHERE  usgr.groupname = rgrp2.groupname
												   AND    usgr.groupname <> rgrp.groupname
												   AND    rgrp2.attribute = rgrp.attribute
												   AND    usgr.username IN (user_key1, user_key2)
												   AND    NOT EXISTS (SELECT 1
																	  FROM   usergroup usgr2
																	  WHERE  usgr2.groupname = rgrp2.groupname
																	  AND    usgr2.priority < usgr.priority)) ;
	v_vals_row				text ;
	curs_vals				CURSOR (group_key TEXT, attr_key TEXT) IS
								SELECT "value" AS val
								FROM   radgroupreply
								WHERE  groupname = group_key
								AND    attribute = attr_key
								AND    LOWER(attribute) <> 'calling-station-id'
								ORDER BY id ;
BEGIN
	OPEN curs_attr(par_calling_station, par_username) ;
	LOOP
		FETCH curs_attr INTO v_attr_row ;
		EXIT WHEN NOT FOUND ;

		IF v_attr_row.op <> '+=' THEN
			-- no concatenation needed
			SELECT "value"
			INTO   v_value
			FROM   radgroupreply
			WHERE  groupname = v_attr_row.groupname
			AND    attribute = v_attr_row.attribute ;
		ELSE
			-- need to concatenate values
			v_value := ' ' ;
			v_counter := 0 ;
			OPEN curs_vals(v_attr_row.groupname, v_attr_row.attribute) ;
			LOOP
				FETCH curs_vals INTO v_vals_row ;
				EXIT WHEN NOT FOUND ;

				v_counter := v_counter + 1 ;
				v_value := v_value || v_vals_row || ' ' ;
			END LOOP ; -- Values loop
			CLOSE curs_vals ;
			v_value := LTRIM(RTRIM(v_value,' '),' ') ;
		END IF ;

		v_return := ROW(v_source, v_attr_row.attribute, v_attr_row.op,  v_value) ;
		RETURN NEXT v_return ;

	END LOOP ; -- Attributes loop
	CLOSE curs_attr ;

	RETURN ;
END ;
$_$;


ALTER FUNCTION csctoss.get_radgroupreply_values(text, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION get_radgroupreply_values(text, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION get_radgroupreply_values(text, text) IS 'Return a list of Radius Group Reply values, concatenated as needed, for a username and calling station ID';


--
-- Name: get_usage_for_location(integer, integer, date, date, text, integer, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION get_usage_for_location(integer, integer, date, date, text, integer, text) RETURNS SETOF get_usage_for_location_retval
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  var_billing_entity_id         integer 	:= COALESCE($1,-1) ;
  var_line_id                   integer 	:= COALESCE($2,-1) ;
  var_start_date                timestamptz	:= $3 ;
  var_end_date                  timestamptz	:= $4 ;
  var_location_label_type       text		:= COALESCE($5,'NULL') ;
  var_address_id                integer		:= COALESCE($6,-1) ;
  var_line_assignment_type      text		:= COALESCE($7,'NULL') ;

  var_preferred_timezone        text ;
  var_sql                       text ;
  var_cur                       refcursor ;
  var_return                    get_usage_for_location_retval ;

BEGIN

  -- fetch billing entity preferred timezone
  IF var_billing_entity_id > 0 THEN

    SELECT preferred_timezone
      INTO var_preferred_timezone
      FROM csctoss.billing_entity
     WHERE billing_entity_id = var_billing_entity_id ;

    IF NOT FOUND THEN
      RAISE EXCEPTION 'Cannot determine preferred timezone for Billing Entity %.', var_billing_entity_id ;
    END IF ;

  ELSE
    RAISE EXCEPTION 'Billing Entity ID is a required parameter for function get_usage_for_location().' ;
  END IF ;

  -- assign the start and end date variables if null using preferred timezone
  IF var_start_date IS NULL THEN
    var_sql := 'SELECT current_date at time zone '||quote_literal(var_preferred_timezone)||' - interval ''30 days'' '
            || '  FROM csctoss.billing_entity '
            || ' WHERE billing_entity_id = '||var_billing_entity_id ;

    RAISE NOTICE 'var_sql: %', var_sql ;

    OPEN var_cur FOR EXECUTE var_sql ;
      FETCH var_cur INTO var_start_date ;
    CLOSE var_cur ;

  END IF ;

  IF var_end_date IS NULL THEN
    var_sql := 'SELECT current_date at time zone '||quote_literal(var_preferred_timezone)||' + interval ''1 day'' '
            || '  FROM csctoss.billing_entity '
            || ' WHERE billing_entity_id = '||var_billing_entity_id ;
  ELSE
    var_sql := 'SELECT '||quote_literal(var_end_date)||' at time zone '||quote_literal(var_preferred_timezone)||' + interval ''1 day'' '
            || '  FROM csctoss.billing_entity '
            || ' WHERE billing_entity_id = '||var_billing_entity_id ;
  END IF ;

  RAISE NOTICE 'var_sql: %', var_sql ;

  OPEN var_cur FOR EXECUTE var_sql ;
    FETCH var_cur INTO var_end_date ;
  CLOSE var_cur ;

  RAISE NOTICE 'var_start_date: %', var_start_date ;
  RAISE NOTICE 'var_end_date: %', var_end_date ;

  -- dynamically build the sql statement
  var_sql :=
'
  SELECT mrac.master_radacctid
        ,line.line_id
        ,line.line_label
        ,line.calling_station_id
        ,mrac.username
        , (SELECT uniq.value
             FROM unique_identifier uniq, equipment equp, line_equipment lieq
            WHERE uniq.equipment_id = equp.equipment_id
              AND equp.equipment_id = lieq.equipment_id
              AND uniq.unique_identifier_type = CASE WHEN equp.equipment_type IN (''CARD'',''MODULE'') THEN ''ESN DEC''
                                                ELSE ''SERIAL NUMBER'' END
              AND EXISTS (SELECT 1
                            FROM unique_identifier uniq2
                           WHERE uniq2.equipment_id = equp.equipment_id
                             AND uniq2.unique_identifier_type = ''MIN''
                             AND uniq2.value = (SUBSTR(mrac.username,1,10)))
              AND mrac.acctstarttime at time zone bent.preferred_timezone BETWEEN lieq.start_date AND COALESCE(lieq.end_date, ''2999-12-30''::DATE) + INTERVAL ''1 day''
              AND lieq.line_id = line.line_id) AS esn_or_serial
        ,line.billing_entity_id
        ,((mrac.acctstarttime AT TIME ZONE bent.preferred_timezone)::text || '' '' || bent.preferred_timezone) AS start_time
        ,((mrac.acctstoptime  AT TIME ZONE bent.preferred_timezone)::text || '' '' || bent.preferred_timezone) AS stop_time
        ,mrac.framedipaddress::text
        ,mrac.acctinputoctets as bytes_in
        ,mrac.acctoutputoctets as bytes_out
        ,normalize_epoch((EXTRACT(EPOCH FROM mrac.acctstoptime) - 
                          EXTRACT(EPOCH FROM mrac.acctstarttime))::bigint,''HOUR'')::text AS time_connected
        ,line.line_assignment_type
        ,ball.location_label_type
        ,ball.location_label
        ,addr.line1||'' ''||CASE WHEN addr.line2 IS NULL THEN '''' ELSE addr.line2||'' '' END
                          ||CASE WHEN addr.line3 IS NULL THEN '''' ELSE addr.line3||'' '' END
                          ||CASE WHEN addr.line4 IS NULL THEN '''' ELSE addr.line4||'' '' END
                          ||addr.city||'', ''||addr.state_code||'' ''||postal_code AS address
        ,mrac.acctstarttime::timestamp AS start_timestamp
        ,mrac.acctstoptime::timestamp  AS stop_timestamp
    FROM csctoss.line
    JOIN csctoss.master_radacct mrac ON (mrac.class = line.line_id::varchar)
    JOIN csctoss.address addr ON (addr.address_id = line.billing_entity_address_id)
    JOIN csctoss.billing_entity bent ON (bent.billing_entity_id = line.billing_entity_id)
    JOIN csctoss.billing_entity_address bead ON (bead.address_id = line.billing_entity_address_id AND bead.billing_entity_id = line.billing_entity_id)
    JOIN csctoss.billing_entity_location_label ball ON (ball.billing_entity_address_id = addr.address_id)
   WHERE mrac.acctstoptime IS NOT NULL
     AND mrac.acctstoptime at time zone bent.preferred_timezone >= '||quote_literal(var_start_date)||'		-- parameter 3, start date
     AND mrac.acctstoptime at time zone bent.preferred_timezone <  '||quote_literal(var_end_date)||'		-- parameter 4, end date
     AND ('||var_billing_entity_id||' = -1 OR bead.billing_entity_id IN
         (SELECT be2.billing_entity_id 
            FROM csctoss.billing_entity be2 
           WHERE be2.billing_entity_id = '||var_billing_entity_id||'
              OR be2.parent_billing_entity_id = '||var_billing_entity_id||'))					-- parameter 1, billing entity id
     AND ('||var_line_id||' = -1 
          OR line.line_id = '||var_line_id||')									-- parameter 2, line id
     AND ('||quote_literal(var_location_label_type)||' = ''NULL''
          OR ball.location_label_type = '||quote_literal(var_location_label_type)||')				-- parameter 5, location label type
     AND ('||var_address_id||' = -1
          OR line.billing_entity_address_id = '||var_address_id||')						-- parameter 6, address id
     AND ('||quote_literal(var_line_assignment_type)||' = ''NULL''
          OR line.line_assignment_type = '||quote_literal(var_line_assignment_type)||')				-- parameter 7, line assignment type
     AND bead.address_type = ''PHYSICAL''
ORDER BY line.billing_entity_id
        ,esn_or_serial
	,start_time
' ;

  RAISE NOTICE 'var_billing_entity_id: %', var_billing_entity_id ;
  RAISE NOTICE 'var_line_id: %', var_line_id ;
  RAISE NOTICE 'var_location_label_type: %', var_location_label_type ;
  RAISE NOTICE 'var_address_id: %', var_address_id ;
  RAISE NOTICE 'var_line_assignment_type: %', var_line_assignment_type ;

  RAISE NOTICE 'SQL: %', var_sql ;

  FOR var_return IN EXECUTE var_sql LOOP
    RETURN NEXT var_return ;
  END LOOP ;

  RETURN ;

END ;
$_$;


ALTER FUNCTION csctoss.get_usage_for_location(integer, integer, date, date, text, integer, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION get_usage_for_location(integer, integer, date, date, text, integer, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION get_usage_for_location(integer, integer, date, date, text, integer, text) IS 'Returns equipment usage and location information by billing_entity_id or equipment_id for a given address_id.';


--
-- Name: groupname_updater(text, character); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION groupname_updater(text, character) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_primary_key       text    := $1 ;
  par_change_type       char(1) := $2 ;

  var_cols		text ;
  var_vals		text ;
  var_sql               text ;

  sysparm_rec		record ;
  groupname_rec		record ;

BEGIN


  -- dynamically build sql statement based on change type and execute
  IF par_change_type = 'D' THEN

    -- build string for deletes
    var_sql := 'delete from groupname where groupname = '||quote_literal(par_primary_key)||'' ;

  ELSE

    SELECT INTO groupname_rec * FROM csctoss.groupname WHERE groupname = par_primary_key ;
    IF NOT FOUND THEN RETURN FALSE ; END IF ;

    -- build string for inserts, start with not nulls, then evaluate nullable columns
    IF par_change_type = 'I' THEN

      var_cols := 'INSERT INTO groupname (groupname, priority ' ;
      var_vals := '     VALUES (' || quote_literal(groupname_rec.groupname) || ',' || groupname_rec.priority ;

      IF groupname_rec.short_desc IS NOT NULL THEN
        var_cols := var_cols || ', short_desc' ;
        var_vals := var_vals || ',' ||  quote_literal(groupname_rec.short_desc) ;
      END IF ;
      IF groupname_rec.long_desc IS NOT NULL THEN
        var_cols := var_cols || ', long_desc' ;
        var_vals := var_vals || ',' ||  quote_literal(groupname_rec.long_desc) ;
      END IF ;
      IF groupname_rec.start_date IS NOT NULL THEN
        var_cols := var_cols || ', start_date' ;
        var_vals := var_vals || ',''' || groupname_rec.start_date || '''' ;
      END IF ;
      IF groupname_rec.end_date IS NOT NULL THEN
        var_cols := var_cols || ', end_date' ;
        var_vals := var_vals || ',''' || groupname_rec.end_date || '''' ;
      END IF ;

      -- now catenate the cols and vals
      var_sql := var_cols || ') ' || var_vals || ') ' ;

    -- build string for updates, start with not nulls, then evaluate nullable columns
    ELSIF par_change_type = 'U' THEN

      var_sql := 'UPDATE groupname SET priority  = ' || groupname_rec.priority ;

      IF groupname_rec.short_desc IS NULL THEN
        var_sql := var_sql || ', short_desc = NULL ' ;
      ELSE
        var_sql := var_sql || ', short_desc = ' || quote_literal(groupname_rec.short_desc) ;
      END IF ;

      IF groupname_rec.long_desc IS NULL THEN
        var_sql := var_sql || ', long_desc = NULL ' ;
      ELSE
        var_sql := var_sql || ', long_desc = ' || quote_literal(groupname_rec.long_desc) ;
      END IF ;          

      IF groupname_rec.start_date IS NULL THEN
        var_sql := var_sql || ', start_date = NULL ' ;
      ELSE
        var_sql := var_sql || ', start_date = ''' ||groupname_rec.start_date || '''' ;
      END IF ;          

      IF groupname_rec.end_date IS NULL THEN
        var_sql := var_sql || ', end_date = NULL ' ;
      ELSE
        var_sql := var_sql || ', end_date = ''' ||groupname_rec.end_date || '''' ;
      END IF ;

      -- tack on the where clause
      var_sql := var_sql || ' WHERE groupname  =  ' || quote_literal(groupname_rec.groupname) ;

    END IF ;

  END IF ;

  -- now loop through appropriate rows again in system_parameter table performing the actual statement
  FOR sysparm_rec IN SELECT hostname, ip_address
                       FROM csctoss.system_parameter
                      WHERE repl_flag = TRUE
  LOOP

    BEGIN

      PERFORM public.dblink_exec(sysparm_rec.hostname, var_sql, TRUE) ;

    EXCEPTION WHEN OTHERS THEN PERFORM csctoss.replication_failure_insert
                                             (sysparm_rec.hostname
                                             ,sysparm_rec.ip_address
                                             ,'groupname'
                                             ,par_primary_key
                                             ,par_change_type
                                             ,var_sql) ;
    END ;

  END LOOP ;

  RETURN TRUE ;

END;
$_$;


ALTER FUNCTION csctoss.groupname_updater(text, character) OWNER TO slony;

--
-- Name: FUNCTION groupname_updater(text, character); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION groupname_updater(text, character) IS 'Updater based function to replicate groupname data changes from change_log.';


--
-- Name: insert_broadcast_message(text, date, date, text, text, text, integer[]); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION insert_broadcast_message(text, date, date, text, text, text, integer[]) RETURNS text
    LANGUAGE plpgsql
    AS $_$
 DECLARE 
 
       par_created_by                         text := $1;
       par_start_date                         date := $2;
       par_end_date                           date := $3;
       par_subject                            text := $4;
       par_broadcast_message                  text := $5;
       par_message_priority                   text := $6;
       var_broadcast_id                       integer;
       var_broadcast_message_group_id         integer;
       var_message_priority_id                integer;
       billing_entity_id                      ALIAS FOR $7;
       var_return                             text;
       
 BEGIN 
 
       IF par_created_by = ''
       AND par_start_date IS NULL  
       AND par_end_date IS NULL
       AND par_subject = ''
       AND par_broadcast_message = ''
       AND par_message_priority = '' THEN 
 
          RAISE EXCEPTION 'ERROR: All Input Values are Null.';
           
       ELSIF par_start_date > par_end_date OR par_end_date > (par_start_date + '30 days'::interval) THEN
 
           var_return := 'Start Date is greater than end date or end date is more than 30 days of start date';
           RETURN var_return;
        
       ELSE 
             
             var_broadcast_id := nextval('csctoss.broadcast_message_data_broadcast_id_seq');
             
             
           IF par_message_priority != '' THEN 
 
              SELECT message_priority_id 
              INTO var_message_priority_id 
              FROM message_priority
              WHERE message_priority = par_message_priority;

          END IF;
 
             IF array_lower(billing_entity_id, 1) IS NULL THEN 
               
                var_broadcast_message_group_id := NULL;
 
                INSERT INTO broadcast_message_data ( broadcast_id, create_timestamp, created_by, message_start_date, message_end_date, 
                                                     broadcast_message_group_id, subject, broadcast_message, message_priority_id)
                   VALUES (var_broadcast_id, now(), par_created_by, par_start_date, par_end_date, var_broadcast_message_group_id,
                          par_subject, par_broadcast_message, var_message_priority_id); 
              
            ELSE 
                 
               IF (SELECT MAX(broadcast_message_group_id) FROM broadcast_message_data) IS NULL THEN 
                  
                   var_broadcast_message_group_id := 1; 
                
                ELSE 

                    SELECT ((MAX(broadcast_message_group_id))+1) 
                    INTO var_broadcast_message_group_id 
                    FROM broadcast_message_data;
                 
                END IF;
 
               INSERT INTO broadcast_message_data ( broadcast_id, create_timestamp, created_by, message_start_date, message_end_date, 
                                                    broadcast_message_group_id, subject, broadcast_message, message_priority_id)
                  VALUES (var_broadcast_id, now(), par_created_by, par_start_date, par_end_date, var_broadcast_message_group_id,
                          par_subject, par_broadcast_message, var_message_priority_id); 

             IF NOT FOUND THEN 
 
                var_return := 'Insertion Failed!';
                RETURN var_return;
          
             END IF; 
           
         
           FOR i IN array_lower(billing_entity_id,1)..array_upper(billing_entity_id,1)
       
              LOOP
                  
                  INSERT INTO broadcast_message_group VALUES (var_broadcast_message_group_id, billing_entity_id[i], var_broadcast_id);
     
              END LOOP;
        
        END IF;

END IF;
                                             
  var_return := 'All the fields are inserted successfully';
  RETURN var_return;
               

END;
$_$;


ALTER FUNCTION csctoss.insert_broadcast_message(text, date, date, text, text, text, integer[]) OWNER TO csctoss_owner;

--
-- Name: insert_class_values(text[]); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION insert_class_values(text[]) RETURNS text
    LANGUAGE plpgsql
    AS $_$
 DECLARE 

        par_username                      ALIAS FOR $1;
        var_line_id                       INTEGER;
        var_return                        TEXT;
        var_username                      TEXT; 
       
BEGIN 

     PERFORM public.set_change_log_staff_id(3) ;

     IF array_lower(par_username, 1) IS NULL THEN 

          RAISE EXCEPTION 'Username Array is Null.';

     END IF; 

     FOR i IN array_lower(par_username, 1)..array_upper(par_username,1)

       LOOP

            var_username := '';
            var_username := par_username[i]; 

            /* 
            SELECT l.line_id INTO var_line_id 
            FROM line l 
            JOIN line_equipment le USING(line_id) 
            WHERE le.end_date IS NULL 
            AND l.radius_username = var_username; 

              IF NOT EXISTS( SELECT value FROM radreply WHERE username = var_username AND attribute = 'Class') THEN

                  INSERT INTO radreply(username, attribute, op, value, priority)
                    VALUES(var_username, 'Class', '=', var_line_id, 10); 

               ELSE
                      
                    RAISE EXCEPTION 'Class Value already exists.';
                     
              END IF; 
       
        END LOOP; */

          SELECT value INTO var_line_id::integer FROM radreply WHERE username = var_username AND attribute = 'Class'; 
        
              IF (var_line_id IS NOT NULL) THEN 

                  UPDATE line SET radius_username = var_username WHERE line_id = var_line_id; 

              ELSE 

                  RAISE EXCEPTION 'Line id doesnt exists in radreply table.';
           
              END IF; 
END LOOP;

 var_return := 'Radius Username has been updated';
 RETURN var_return; 

END; 
$_$;


ALTER FUNCTION csctoss.insert_class_values(text[]) OWNER TO csctoss_owner;

--
-- Name: insert_static_ip_active_lines_info(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION insert_static_ip_active_lines_info() RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE 
        
       var_username          TEXT;
       var_static_ip         TEXT;
       var_groupname         TEXT;
       var_line_id           INTEGER;
       var_carrier           TEXT;  
       var_return            TEXT;
       var_id                INTEGER;
       var_uniqid_row        RECORD;
       var_return_row        TEXT;

BEGIN

     FOR var_uniqid_row IN 
         SELECT rr.username AS username, 
                rr.value AS ip, 
                ug.groupname AS groupname, 
                l.line_id AS line_id
         FROM radreply rr
	 JOIN usergroup ug ON (rr.username = ug.username)
	 JOIN line l ON (ug.username = l.radius_username)
	 JOIN line_equipment le ON (l.line_id = le.line_id)
	 WHERE rr.attribute LIKE 'Framed-IP-Address'
         AND ug.groupname NOT IN ( 'disconnected', 'userdisconnected' )
         AND rr.value NOT IN ('10.56.113.6', '10.56.52.227', '166.155.205.089', '10.56.8.204', '10.81.20.112', '10.56.56.166', '10.56.92.174')
	 AND le.end_date IS NULL 
	 ORDER BY ug.groupname
 
      LOOP
         
           var_username    := var_uniqid_row.username;
           var_static_ip   := var_uniqid_row.ip;
           var_groupname   := var_uniqid_row.groupname;
           var_line_id     := var_uniqid_row.line_id;       
           
           IF ( var_username LIKE '%sprint%') THEN 

               var_carrier := 'SPRINT';
          
           ELSIF (var_username LIKE '%vzw%') THEN 

               var_carrier := 'VZW';

           ELSIF (var_username LIKE '%uscc%') THEN 
 
               var_carrier := 'USCC';

          END IF;
        
         IF NOT EXISTS(SELECT static_ip FROM static_ip_pool WHERE static_ip LIKE var_static_ip AND line_id = var_line_id ) THEN 

 
             INSERT INTO static_ip_pool (static_ip, groupname, is_assigned, carrier, line_id) 
                VALUES (var_static_ip, var_groupname, 'TRUE', var_carrier, var_line_id);
                  
       
             var_return := 'Insertion was succesful for '|| var_static_ip;
       ELSE 
 
              RAISE EXCEPTION 'Insert into static_ip_pool failed for %', var_static_ip;
          
          END IF;

      END LOOP;

RETURN var_return;

END;
 $$;


ALTER FUNCTION csctoss.insert_static_ip_active_lines_info() OWNER TO csctoss_owner;

--
-- Name: insert_static_ip_usernames(text, text[], text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION insert_static_ip_usernames(text, text[], text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
 DECLARE 

        par_groupname                     text := $1;
        par_username                          ALIAS FOR $2;
        par_carrier                       text := $3;  
        var_static_ip                     text; 
        var_line_id                       integer;
        var_return                        text;
        var_username                      text;
        var_temp_ip                       text;

BEGIN 

     PERFORM public.set_change_log_staff_id(3) ;

     IF par_groupname = '' AND par_carrier = '' THEN 

          RAISE EXCEPTION 'ERROR: All Input Values are Null.'; 
 
     ELSIF array_lower(par_username, 1) IS NULL THEN 

          RAISE EXCEPTION 'Username Array is Null.';

     END IF; 

     FOR i IN array_lower(par_username, 1)..array_upper(par_username,1)

       LOOP

            var_username := '';
            var_username := par_username[i]; 

            SELECT static_ip 
            INTO var_static_ip
            FROM static_ip_pool sip
            JOIN static_ip_carrier_def sid
            ON (sid.carrier_def_id = sip.carrier_id)
            WHERE groupname = par_groupname
            AND is_assigned = FALSE
            AND carrier = par_carrier
            AND static_ip NOT LIKE '166.%'
            ORDER BY static_ip
            LIMIT 1;

            IF ( var_static_ip IS NOT NULL ) THEN 

              IF NOT EXISTS( SELECT value FROM radreply WHERE username = var_username AND attribute = 'Framed-IP-Address') THEN

                  INSERT INTO radreply(username, attribute, op, value, priority)
                    VALUES(var_username, 'Framed-IP-Address', '=', var_static_ip, 10); 

                   SELECT value INTO var_line_id FROM radreply
                   WHERE username = var_username AND attribute = 'Class';

                   UPDATE static_ip_pool SET is_assigned = TRUE, line_id = var_line_id
	           WHERE static_ip = var_static_ip AND groupname = par_groupname;

               ELSE
                      
                    RAISE EXCEPTION 'Static IP is already Assigned.';
                     
              END IF; 
             
           END IF; 
       
        END LOOP; 

 var_return := 'Static ips have been assigned.';
 RETURN var_return; 

END; 
$_$;


ALTER FUNCTION csctoss.insert_static_ip_usernames(text, text[], text) OWNER TO csctoss_owner;

--
-- Name: insert_update_location_labels(integer, text, text, text, text, text, text, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION insert_update_location_labels(integer, text, text, text, text, text, text, integer) RETURNS SETOF ops_api_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE 

    par_line_id           integer := $1;
    par_owner             text := $2;
    par_id                text := $3;
    par_name              text := $4;
    par_address           text := $5;
    par_processor         text := $6;
    par_fwver             text := $7;
    par_uptime            integer := $8;
    var_return_row        ops_api_retval%ROWTYPE;

BEGIN 
  IF EXISTS ( SELECT TRUE FROM location_labels WHERE line_id = par_line_id) THEN        

      UPDATE location_labels 
      SET owner = par_owner, 
      id = par_id, 
      name = par_name, 
      address = par_address, 
      processor = par_processor,
      fwver = par_fwver,
      uptime = par_uptime
      WHERE line_id = par_line_id;

    IF NOT FOUND THEN   
      var_return_row.result_code := 'false'
      var_return_row.error_message := 'Update Failed.'
      RETURN NEXT var_return_row;
      RETURN;
    ELSE
      var_return_row.result_code := 'true';
      var_return_row.error_message := 'Update successful!';
      RETURN NEXT var_return_row;
      RETURN;

    END IF;   
  ELSE  
      INSERT INTO location_labels(line_id, owner, id, name, address, processor, fwver, uptime)
           VALUES (par_line_id, par_owner, par_id, par_name, par_address, par_processor, par_fwver, par_uptime); 
      IF NOT FOUND THEN           
        var_return_row.result_code := 'false'
        var_return_row.error_message := 'Insert Failed.'
        RETURN NEXT var_return_row;
        RETURN;
      ELSE
        var_return_row.result_code := 'true';
        var_return_row.error_message := 'Insert successful!';
        RETURN NEXT var_return_row;
        RETURN;
  END IF; 
END IF;
RETURN;
END; 
$_$;


ALTER FUNCTION csctoss.insert_update_location_labels(integer, text, text, text, text, text, text, integer) OWNER TO csctoss_owner;

--
-- Name: is_user_registered(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION is_user_registered(text) RETURNS boolean
    LANGUAGE plpgsql STRICT SECURITY DEFINER
    AS $_$
DECLARE
	i_username				text := $1 ;
	v_counter				INTEGER ;
	v_line_id				INTEGER ;
	v_billing_entity_type	TEXT ;
	v_found					BOOLEAN := TRUE ;
	v_is_registered			BOOLEAN := FALSE ;
BEGIN
	-- ------------------------------------------------------------
	-- Get the Line ID by Radius Username
	-- ------------------------------------------------------------
	SELECT "value"
	INTO   v_line_id
	FROM   csctoss.radreply
	WHERE  attribute = 'Class'
	AND    username = i_username ;

	IF v_line_id IS NULL THEN
		v_found := FALSE;
	END IF ;

	IF v_found = TRUE THEN
		-- Check for user registration
		SELECT billing_entity_type
		INTO   v_billing_entity_type
		FROM   csctoss.billing_entity AS bent
		       , csctoss.line
		WHERE  bent.billing_entity_id = line.billing_entity_id
		AND    line.line_id = v_line_id ;

		IF v_billing_entity_type = 'CONSUMER' THEN
			SELECT COUNT(*)
			INTO   v_counter
			FROM   csctoss.billing_entity_address AS bead
			       , csctoss.line
			WHERE  bead.billing_entity_id = line.billing_entity_id
			AND    line.line_id = v_line_id ;

			IF v_counter > 0 THEN
				v_is_registered := TRUE ;
			END IF ;
		ELSE
			v_is_registered := FALSE ;
		END IF ;
	ELSE
		-- Line ID not found
		v_is_registered := FALSE ;
	END IF ; -- check for line id

	-- Return registration status
   RETURN v_is_registered ;
END ;
$_$;


ALTER FUNCTION csctoss.is_user_registered(text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION is_user_registered(text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION is_user_registered(text) IS '$Id: Checks for user registration for CONSUMER lines';


--
-- Name: line_alert_monitor(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION line_alert_monitor() RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE

  var_sql                   text ;
  var_subject               text ;
  var_message               text ;

  rec_line                  record ;
  rec_email                 record ;
  rec_usage                 record ;

BEGIN

  -- driving cursor to grab all data at once
  FOR rec_line IN SELECT lalt.line_id
                        ,lalt.threshold_kb
                        ,lalt.threshold_minutes::text || ' MINUTES' as interval_minutes
                        ,line.line_label
                        ,COALESCE((select value from csctoss.unique_identifier where equipment_id = lieq.equipment_id and unique_identifier_type = 'ESN HEX'),'N/A') as esn_hex
                        ,COALESCE((select value from csctoss.unique_identifier where equipment_id = lieq.equipment_id and unique_identifier_type = 'SERIAL NUMBER'),'N/A') as serial_number
                        ,'csctlog.master_radacct_'||TO_CHAR(current_timestamp,'YYYYMM') as table_name
                    FROM csctoss.line_alert lalt
                    JOIN csctoss.line USING (line_id)
                    JOIN csctoss.line_equipment lieq ON (line.line_id = lieq.line_id and lieq.end_date is null)
                ORDER BY lalt.line_id
  LOOP

    -- over dblink, get usage based on interval
    var_sql := 'SELECT ' || quote_literal(rec_line.line_id::text) || ' as class
                      ,ROUND(((SUM(COALESCE(acctinputoctets,0) + COALESCE(acctoutputoctets,0)))/1024),0) as kb_used
                  FROM ' || rec_line.table_name || '
                 WHERE acctstarttime >= current_timestamp - interval ' || quote_literal(rec_line.interval_minutes)|| '
                   AND class = ' || quote_literal(rec_line.line_id::text) || '
              GROUP BY 1' ;

    --RETURN NEXT var_sql ;

    -- execute remote query
    FOR rec_usage IN SELECT *
                       FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                         AS rec_type(class   text
                                    ,kb_used integer)
    LOOP

      RETURN NEXT 'Class: '||rec_usage.class||' used '||rec_usage.kb_used::text ;

      -- evaluate if usage exceeds threshold
      IF FOUND AND rec_usage.kb_used >= rec_line.threshold_kb THEN
        var_subject := rec_line.line_label || 'is running on 3G backup' ;
        var_message := 'Line ID '||rec_line.line_id::text||
                       ' (ESN HEX: '||rec_line.esn_hex||
                       ' - S/N: '||rec_line.serial_number||
                       ' has used '||rec_usage.kb_used||
                       ' KB in the last '||rec_line.interval_minutes ;

        -- send email to appropriate addresses
        FOR rec_email IN SELECT DISTINCT email_address as recipient
                           FROM csctoss.line_alert_email
                          WHERE line_id = rec_line.line_id
        LOOP
          PERFORM public.plsh_send_email(rec_email.recipient, var_subject, var_message) ;
        END LOOP ;

      END IF ;

    END LOOP ;

  END LOOP ;

  RETURN NEXT 'SUCCESS' ;
  RETURN ;

END ;

$$;


ALTER FUNCTION csctoss.line_alert_monitor() OWNER TO csctoss_owner;

--
-- Name: line_class_updater(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION line_class_updater() RETURNS SETOF string_retval
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE

  var_return			string_retval ;
  line_rec			record ;
  var_value			text ;

BEGIN

  PERFORM public.set_change_log_staff_id(3) ; -- data correction user

  var_return.string_value := 'MISSING LINES INSERTED ...' ;
  RETURN NEXT var_return ;
  var_return.string_value := '-----------------------------------------------' ;
  RETURN NEXT var_return ;

  -- first handle new or changed lines which have no class at all
  FOR line_rec IN SELECT line.radius_username
                        ,'Class'::text as attribute
                        ,'='::text as op
                        ,line.line_id::text
                    FROM csctoss.line
                   WHERE line.end_date is null
          AND NOT EXISTS (select true
                            from csctoss.radreply
                           where attribute = 'Class'
                             and username = line.radius_username)
  LOOP

    INSERT INTO csctoss.radreply (username,attribute,op,value)
         VALUES (line_rec.radius_username, line_rec.attribute, line_rec.op, line_rec.line_id) ;

    var_return.string_value := 'Missing Line ID / Class '||line_rec.line_id::text||' inserted.' ;
    RETURN NEXT var_return ;

  END LOOP ;

  var_return.string_value := '' ;
  RETURN NEXT var_return ;
  var_return.string_value := 'MISMATCHED LINES UPDATED ...' ;
  RETURN NEXT var_return ;
  var_return.string_value := '-----------------------------------------------' ;
  RETURN NEXT var_return ;

  -- now update those active lines where radius username matches but line_id / class disagree
  FOR line_rec IN
    SELECT line.line_id
          ,line.radius_username
          ,rrep.username
          ,rrep.value
          ,rrep.id
      FROM csctoss.line
      JOIN csctoss.radreply rrep ON (line.radius_username = rrep.username)
     WHERE line.end_date IS NULL
       AND rrep.attribute = 'Class'
       AND line.line_id <> rrep.value
  LOOP

    UPDATE csctoss.radreply
       SET value = line_rec.line_id
     WHERE id    = line_rec.id ;

    var_return.string_value := 'Username '||line_rec.username||' Class '||line_rec.value||' incorrect. Should be '||line_rec.line_id||'.' ;
    RETURN NEXT var_return ;

  END LOOP ;

  var_return.string_value := '' ;
  RETURN NEXT var_return ;
  var_return.string_value := 'RADREPLY USERNAMES WITH MULTIPLE CLASS RECORDS ...' ;
  RETURN NEXT var_return ;
  var_return.string_value := '-----------------------------------------------' ;
  RETURN NEXT var_return ;

  -- report multiple rows in radreply with same username and multiple class attributes
  FOR line_rec IN SELECT rrep.username
                        ,count(*) as kount
                    FROM csctoss.radreply rrep
                   WHERE rrep.attribute = 'Class'
                GROUP BY rrep.username
                  HAVING count(*) > 1
                ORDER BY rrep.username
  LOOP

    var_return.string_value := 'Radreply Username '||line_rec.username||' has '||line_rec.kount::text||' duplicate Class rows.' ;
    RETURN NEXT var_return ;

  END LOOP ;

  var_return.string_value := '' ;
  RETURN NEXT var_return ;
  var_return.string_value := 'RADREPLY CLASS WITH MULTIPLE USERNAME RECORDS ...' ;
  RETURN NEXT var_return ;
  var_return.string_value := '-----------------------------------------------' ;
  RETURN NEXT var_return ;

  FOR line_rec IN SELECT rrep.value
                        ,count(*) as kount
                    FROM csctoss.radreply rrep
                   WHERE rrep.attribute = 'Class'
                GROUP BY rrep.value
                  HAVING count(*) > 1
                ORDER BY rrep.value
  LOOP

    var_return.string_value := 'Radreply Class '||line_rec.value||' has '||line_rec.kount::text||' duplicate Username rows.' ;
    RETURN NEXT var_return ;

  END LOOP ;

  var_return.string_value := '' ;
  RETURN NEXT var_return ;
  var_return.string_value := 'NULL LINE LABELS UPDATED WITH ESN HEX ...' ;
  RETURN NEXT var_return ;
  var_return.string_value := '-----------------------------------------------' ;
  RETURN NEXT var_return ;

  FOR line_rec IN SELECT line.line_id
                        ,uniq.equipment_id
                    FROM csctoss.line
                    JOIN csctoss.unique_identifier uniq on (substr(line.radius_username,1,10) = uniq.value)
                   WHERE line_label IS NULL
                     AND uniq.unique_identifier_type = 'MIN'
                ORDER BY line.line_id
  LOOP

    SELECT INTO var_value value
           FROM csctoss.unique_identifier
          WHERE equipment_id = line_rec.equipment_id
            AND unique_identifier_type = 'ESN HEX' ;

    IF FOUND THEN

      UPDATE csctoss.line
         SET line_label = var_value
       WHERE line_id = line_rec.line_id ;

      var_return.string_value = 'Line ID '||line_rec.line_id::text||' null Line Label updated to '||var_value||'.' ;

    ELSE    
      var_return.string_value = 'Cannot determine ESN HEX for Line ID '||line_rec.line_id::text||'.' ;
    END IF ;

    RETURN NEXT var_return ;

  END LOOP ;

  RETURN ;

END ;

$$;


ALTER FUNCTION csctoss.line_class_updater() OWNER TO csctoss_owner;

--
-- Name: FUNCTION line_class_updater(); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION line_class_updater() IS 'Populates missing Class attribute in radreply table with line_id and corrects mismatched data.';


--
-- Name: line_equipment_pre_insert(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION line_equipment_pre_insert() RETURNS "trigger"
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN

  -- start date can never be later than end date
  IF NEW.end_date IS NOT NULL AND NEW.start_date > NEW.end_date THEN
    RAISE EXCEPTION 'Start date cannot be later than end date' ;
  END IF ;

  -- null end date checks
  IF NEW.end_date IS NULL THEN

    -- no more than one record for given equipment with null end date
    IF (SELECT count(*) > 0
          FROM csctoss.line_equipment
         WHERE line_id <> NEW.line_id
           AND equipment_id = NEW.equipment_id
           AND end_date IS NULL) THEN
      RAISE EXCEPTION 'Equipment ID % already has active line assignment with NULL end date', NEW.equipment_id ;
    END IF ;

    -- if null end date, then new start date cannot be after oldest end date
    IF (SELECT count(*) > 0
          FROM csctoss.line_equipment
         WHERE line_id <> NEW.line_id
           AND equipment_id = NEW.equipment_id
           AND end_date IS NOT NULL
           AND NEW.start_date < end_date) THEN
      RAISE EXCEPTION 'Equipment ID % already assigned with end date before new start date of %', NEW.equipment_id, NEW.start_date ;
    END IF ;

  END IF ;

  -- make sure new start date does not fall between existing assignment
  IF (SELECT count(*) > 0 
        FROM csctoss.line_equipment 
       WHERE NEW.start_date BETWEEN start_date AND COALESCE(end_date, '9999-12-31')
         AND line_id <> NEW.line_id
         AND equipment_id = NEW.equipment_id) THEN
    RAISE EXCEPTION 'New start date for Equipment ID % falls between existing line assignment', NEW.equipment_id ;

  -- make sure new end date does not fall between existing assignment
  ELSIF NEW.end_date IS NOT NULL AND (SELECT count(*) > 0 
                                        FROM csctoss.line_equipment
                                       WHERE NEW.end_date BETWEEN start_date AND COALESCE(end_date, '9999-12-31')
                                         AND line_id <> NEW.line_id
                                         AND equipment_id = NEW.equipment_id) THEN
    RAISE EXCEPTION 'New end date for Equipment ID % falls between existing line assignment', NEW.equipment_id ;

  END IF ;

  RETURN NEW ;

END ;
$$;


ALTER FUNCTION csctoss.line_equipment_pre_insert() OWNER TO csctoss_owner;

--
-- Name: line_equipment_pre_update(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION line_equipment_pre_update() RETURNS "trigger"
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN

  -- don't alow equipment_id updates - too many conditions to check
  IF NEW.equipment_id <> OLD.equipment_id THEN
    RAISE EXCEPTION 'Cannot update equipment_id. Please delete or end date this line equipment assignment.' ;
  END IF ;

  -- start date can never be before end date
  IF NEW.end_date IS NOT NULL AND NEW.start_date > NEW.end_date THEN
    RAISE EXCEPTION 'Start date cannot be later than end date' ;
  END IF ;

  -- null end date checks
  IF NEW.end_date IS NULL THEN

    -- no more than one record for given equipment with null end date
    IF (SELECT count(*) > 0
          FROM csctoss.line_equipment
         WHERE line_id <> NEW.line_id
           AND equipment_id = NEW.equipment_id
           AND end_date IS NULL) THEN
      RAISE EXCEPTION 'Equipment ID % already has active line assignment with NULL end date', NEW.equipment_id ;
    END IF ;

    -- if null end date, then new start date cannot be after oldest end date
    IF (SELECT count(*) > 0
          FROM csctoss.line_equipment
         WHERE line_id <> NEW.line_id
           AND equipment_id = NEW.equipment_id
           AND end_date IS NOT NULL
           AND NEW.start_date <= end_date) THEN
      RAISE EXCEPTION 'Equipment ID % already assigned with end date before new start date of %', NEW.equipment_id, NEW.start_date ;
    END IF ;

  END IF ;

  -- if start date changing verify new value valid
  IF NEW.start_date <> OLD.start_date THEN

    -- verify new start date does not fall between existing assignment
    IF (SELECT count(*) > 0 
          FROM csctoss.line_equipment
         WHERE NEW.start_date BETWEEN start_date AND COALESCE(end_date, current_date)
           AND equipment_id = NEW.equipment_id
           AND line_id <> NEW.line_id) THEN
      RAISE EXCEPTION 'New start date for Equipment ID % falls between existing line assignment', NEW.equipment_id ;
    END IF ;

  END IF ;

  -- if end date changing verify new value valid
  IF NEW.end_date IS NOT NULL AND NEW.end_date <> OLD.end_date THEN

    -- verify new end date does not fall between existing assignment
    IF (SELECT count(*) > 0 
          FROM csctoss.line_equipment
         WHERE NEW.end_date BETWEEN start_date AND COALESCE(end_date, current_date)
           AND equipment_id = NEW.equipment_id
           AND line_id <> NEW.line_id) THEN
      RAISE EXCEPTION 'New end date for Equipment ID % falls between existing line assignment', NEW.equipment_id ;
    END IF ;

  END IF ;

  RETURN NEW ;

END ;
$$;


ALTER FUNCTION csctoss.line_equipment_pre_update() OWNER TO csctoss_owner;

--
-- Name: line_pre_delete(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION line_pre_delete() RETURNS "trigger"
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  RAISE EXCEPTION 'Lines cannot be deleted. End date the line.' ;
END ;
$$;


ALTER FUNCTION csctoss.line_pre_delete() OWNER TO csctoss_owner;

--
-- Name: line_pre_insert(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION line_pre_insert() RETURNS "trigger"
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN

  -- start date can never be later than end date
  IF NEW.end_date IS NOT NULL AND NEW.start_date > NEW.end_date THEN
    RAISE EXCEPTION 'Start date cannot be later than end date.' ;
  END IF ;

  -- cannot end date line if associated rows exist in line_equipment with null end date
  IF NEW.end_date IS NOT NULL AND (SELECT COUNT(*) > 0
                                     FROM csctoss.line_equipment
                                    WHERE line_id = NEW.line_id
                                      AND end_date IS NULL) THEN
    RAISE EXCEPTION 'Cannot end date line %. Associated records exist in line_equipment with null end date.', NEW.line_id ;
  END IF ;

/*

-- THIS CONSTRAINT REMOVED PER DISCUSSION WITH KTAYLOR AND BBARKER 20090526
-- THIS CONSTRAINT REENABLED AT REQUEST OF BBARKER ON 20090817
-- THIS CONSTRAINT REMOVED AGAIN PER RT TICKET 5535

  -- check for existing line with same username and null end date
  IF NEW.end_date IS NULL AND NEW.radius_username IS NOT NULL AND
    (SELECT COUNT(*) > 0
       FROM csctoss.line
      WHERE radius_username = NEW.radius_username
        AND end_date IS NULL) THEN
    RAISE EXCEPTION 'Radius Username % already assigned to existing Line with Null end date.', NEW.radius_username ;
  END IF ;

  -- make sure new start date for line does not overlap existing line with same radius_username
  IF NEW.radius_username IS NOT NULL AND
    (SELECT count(*) > 0 
       FROM csctoss.line
      WHERE NEW.start_date BETWEEN start_date AND COALESCE(end_date,'9999-12-31')
        AND radius_username = NEW.radius_username) THEN
    RAISE EXCEPTION 'New start date for Radius Username % falls between existing assignment with same Radius Username.', NEW.radius_username ;
  END IF ;

  -- make sure new end date does not fall between existing assignment
  IF NEW.end_date IS NOT NULL AND NEW.radius_username IS NOT NULL AND
    (SELECT count(*) > 0 
       FROM csctoss.line
      WHERE NEW.end_date BETWEEN start_date AND COALESCE(end_date,'9999-12-31')
        AND radius_username = NEW.radius_username) THEN
    RAISE EXCEPTION 'New end date for Radius Username % falls between existing assignment with same Radius username.', NEW.radius_username ;
  END IF ;

*/

  RETURN NEW ;

END ;
$$;


ALTER FUNCTION csctoss.line_pre_insert() OWNER TO csctoss_owner;

--
-- Name: line_pre_update(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION line_pre_update() RETURNS "trigger"
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN

  -- dont alow line_id updates - too many conditions to check
  IF NEW.line_id <> OLD.line_id THEN
    RAISE EXCEPTION 'Cannot update Line ID.' ;
  END IF ;

  -- dont allow billing entity id to change
  IF NEW.billing_entity_id <> OLD.billing_entity_id THEN
    RAISE EXCEPTION 'Cannot update Billing Entity ID.' ;
  END IF ;

  -- start date can never be before end date
  IF NEW.end_date IS NOT NULL AND NEW.start_date > NEW.end_date THEN
    RAISE EXCEPTION 'Start date cannot be later than end date.' ;
  END IF ;

  -- cannot end date line if associated rows exist in line_equipment with null end date
  IF NEW.end_date IS NOT NULL AND (SELECT COUNT(*) > 0
                                     FROM csctoss.line_equipment
                                    WHERE line_id = NEW.line_id
                                      AND end_date IS NULL) THEN
    RAISE EXCEPTION 'Cannot end date line %. Associated records exist in line_equipment with null end date.', NEW.line_id ;
  END IF ;

/* 

-- THIS CONSTRAINT REMOVED PER DISCUSSION WITH KTAYLOR AND BBARKER 20090526
-- THIS CONSTRAINT RE-ENABLED AT REQUEST OF BBARKER RT 5493 ON 20090817
-- THIS CONSTRAINT REMOVED AGAIN PER RT TICKET 5535

  -- if radius username changing check for existing assignment with null end date
  IF NEW.end_date IS NULL AND NEW.radius_username IS NOT NULL AND NEW.radius_username <> OLD.radius_username AND
    (SELECT COUNT(*) > 0
       FROM csctoss.line
      WHERE line_id <> NEW.line_id
        AND radius_username = NEW.radius_username
        AND end_date IS NULL) THEN
    RAISE EXCEPTION 'Null End Date for Radius Username % already assigned to existing Line.', NEW.radius_username ;
  END IF ;

-- THESE ARE REMNANTS OF THE ORIGNAL CONSTRAINT RETAINED IN CASE WE IMPLEMENT

  -- if start date changing, check conditions
  IF NEW.start_date <> OLD.start_date AND NEW.radius_username IS NOT NULL AND
    (SELECT COUNT(*) > 0
       FROM csctoss.line
      WHERE line_id <> NEW.line_id
        AND radius_username = NEW.radius_username
        AND (NEW.start_date BETWEEN start_date AND COALESCE(end_date,'9999-12-31')
             OR
             start_date BETWEEN NEW.start_date AND NEW.end_date)) THEN
    RAISE EXCEPTION 'New Start Date falls between existing Line assignment for Radius Username %.', NEW.radius_username ;
  END IF ;

  -- if end date changing, check conditions
  IF NEW.end_date IS NULL THEN
    IF NEW.radius_username IS NOT NULL AND
      (SELECT COUNT(*) > 0
         FROM csctoss.line
        WHERE line_id <> NEW.line_id
          AND radius_username = NEW.radius_username
          AND end_date IS NULL) THEN
      RAISE EXCEPTION 'Null End Date for Radius Username % already exists for existing Line.', NEW.radius_username ;
    END IF ;
  ELSIF NEW.end_date <> COALESCE(OLD.end_date,'1900-01-01') AND NEW.radius_username IS NOT NULL AND
    (SELECT COUNT(*) > 0
       FROM csctoss.line
      WHERE line_id <> NEW.line_id
        AND radius_username = NEW.radius_username
        AND (NEW.end_date BETWEEN start_date AND COALESCE(end_date,'9999-12-31')
             OR
             end_date BETWEEN NEW.start_date AND NEW.end_date)) THEN
    RAISE EXCEPTION 'New End Date falls between existing Line assignment for Radius Username %.', NEW.radius_username ;
  END IF ;

  -- if radius username changing, check conditions
  IF NEW.radius_username IS NOT NULL AND OLD.radius_username IS NOT NULL AND NEW.radius_username <> OLD.radius_username AND
    (SELECT COUNT(*) > 0
       FROM csctoss.line
      WHERE line_id <> NEW.line_id
        AND radius_username = NEW.radius_username
        AND (start_date BETWEEN NEW.start_date AND COALESCE(NEW.end_date,'9999-12-31')
             OR
             end_date BETWEEN NEW.start_date AND COALESCE(NEW.end_date,'9999-12-31'))) THEN
    RAISE EXCEPTION 'New Radius Username % already has existing Line assignment for given date range.', NEW.radius_username ;
  END IF ;

*/

  RETURN NEW ;

END ;
$$;


ALTER FUNCTION csctoss.line_pre_update() OWNER TO csctoss_owner;

--
-- Name: line_usage_daily_detail(integer, date); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION line_usage_daily_detail(integer, date) RETURNS SETOF line_usage_daily_detail_retval
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_line_id                 integer := $1 ;
  par_usage_date              date    := $2 ;

  var_radius_username         text ;
  var_preferred_timezone      text ;
  var_esn_or_serial           text ;
  var_location_label          text ;
  var_line_label              text ;

  var_sql                     text ;
  var_return                  line_usage_daily_detail_retval ;

BEGIN

  -- validate parameters
  IF par_line_id IS NULL THEN
    RAISE EXCEPTION 'Line ID (%) is required.', par_line_id ;
  ELSIF par_usage_date IS NULL THEN
    RAISE EXCEPTION 'Usage Date (%) is required.', par_usage_date ;
  ELSE
    PERFORM * FROM csctoss.line WHERE line_id = par_line_id ;
    IF NOT FOUND THEN
      RAISE EXCEPTION 'Line ID % does not exist.', par_line_id ;
    END IF ;
  END IF ;

  -- get all non master_radacct data once to avoid any joins
  SELECT COALESCE(line.radius_username,'N/A')
        ,bent.preferred_timezone
        ,(select COALESCE(location_label,'N/A')
            from csctoss.billing_entity_location_label
           where billing_entity_address_id = line.billing_entity_address_id
             and location_label_type = 'USER DEFINED')
        ,COALESCE(line.line_label,'N/A')
         INTO var_radius_username, var_preferred_timezone, var_location_label, var_line_label
         FROM csctoss.line
         JOIN csctoss.billing_entity bent USING (billing_entity_id)
        WHERE line_id = par_line_id ;

  -- get the esn or serial number
  SELECT COALESCE(uniq.value,'N/A')
    INTO var_esn_or_serial
    FROM csctoss.line_equipment lieq
    JOIN csctoss.equipment equp USING (equipment_id)
    JOIN csctoss.unique_identifier uniq USING (equipment_id)
   WHERE lieq.line_id = par_line_id
     AND EXISTS (select true 
                   from csctoss.unique_identifier
                  where equipment_id = lieq.equipment_id
                    and unique_identifier_type = 'MIN')
     AND uniq.unique_identifier_type = CASE WHEN equp.equipment_type = 'ROUTER' THEN 'SERIAL NUMBER'
                                            ELSE 'ESN DEC' 
                                       END ;

RAISE NOTICE 'var_radius_username   : %', var_radius_username ;
RAISE NOTICE 'var_preferred_timezone: %', var_preferred_timezone ;
RAISE NOTICE 'var_location_label    : %', var_location_label ;
RAISE NOTICE 'var_line_label        : %', var_line_label ;
RAISE NOTICE 'var_esn_or_serial     : %', var_esn_or_serial ;

  -- dynamically build the sql statement to ensure indexes being hit - master_radacct only
  var_sql :=
'
  SELECT master_radacctid
        ,' || quote_literal(var_radius_username) || ' AS username
        ,acctstarttime AT TIME ZONE ' || quote_literal(var_preferred_timezone) || ' AS start_time
        ,acctstoptime AT TIME ZONE ' || quote_literal(var_preferred_timezone) || ' AS stop_time
        ,HOST(framedipaddress)::text AS framed_ip_address
        ,acctinputoctets AS bytes_in
        ,acctoutputoctets AS bytes_out
        ,normalize_epoch((EXTRACT(EPOCH FROM acctstoptime)-EXTRACT(EPOCH FROM acctstarttime))::bigint,''HOUR'')::text AS time_connected
        ,callingstationid AS calling_station_id
        ,' || quote_literal(var_esn_or_serial) || ' AS esn_or_serial
        ,' || quote_literal(var_location_label) || ' AS location_label
        ,' || quote_literal(var_line_label) || ' AS line_label
    FROM csctlog.master_radacct
   WHERE class = ' || quote_literal(par_line_id::varchar) || '
     AND acctstoptime IS NOT NULL
     AND acctstoptime AT TIME ZONE ' || quote_literal(var_preferred_timezone) || ' >= ' || quote_literal(par_usage_date) || '
     AND acctstoptime AT TIME ZONE ' || quote_literal(var_preferred_timezone) || ' <  ' || quote_literal(par_usage_date+1) || '
ORDER BY master_radacctid
' ;

  RAISE NOTICE 'SQL: %', var_sql ;

  -- return the data set
  FOR var_return IN SELECT *
                      FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                        AS      rec_type(master_radacctid       bigint
                                        ,username               text
                                        ,start_time             timestamp
                                        ,stop_tim               timestamp
                                        ,framed_ip_address      text
                                        ,bytes_in               bigint
                                        ,bytes_out              bigint
                                        ,time_connected         text
                                        ,calling_station_id     text
                                        ,esn_or_serial          text
                                        ,location_label         text
                                        ,line_label             text)
  LOOP
    RETURN NEXT var_return ;
  END LOOP ;

  RETURN ;

END ;
$_$;


ALTER FUNCTION csctoss.line_usage_daily_detail(integer, date) OWNER TO csctoss_owner;

--
-- Name: FUNCTION line_usage_daily_detail(integer, date); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION line_usage_daily_detail(integer, date) IS 'Returns detail usage data for a given line for a given date in billing entity time zone.';


--
-- Name: line_usage_day_calc(date, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION line_usage_day_calc(date, integer) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_usage_date          date    := $1 ;
  par_line_id             integer := $2 ;

  var_end_date            date ;
  var_sql                 text ;

  line_rec                record ;

BEGIN

  -- check parameters
  IF par_usage_date IS NULL THEN
    RETURN NEXT 'ERROR: Date required.' ;
    RETURN ;
  ELSE
    var_end_date := par_usage_date + INTERVAL '1 day' ;
  END IF ;

  IF par_line_id IS NOT NULL THEN
    PERFORM * FROM csctoss.line WHERE line_id = par_line_id ;
    IF NOT FOUND THEN
      RETURN NEXT 'ERROR: Line ID '||par_line_id::text||' does not exist.' ;
      RETURN ;
    END IF ;
  END IF ;

  PERFORM public.set_change_log_staff_id(9) ; -- Billing Engine user
  RETURN NEXT par_usage_date || ' to ' || var_end_date ;

  -- if this date and/or line_id have already been calculated then delete current rows
  DELETE FROM csctoss.line_usage_day
        WHERE usage_date = par_usage_date
          AND (line_id = par_line_id OR par_line_id IS NULL) ;


  -- truncate and populate usage_calc table with data between previous and next days to capture all possible usage
  EXECUTE 'TRUNCATE TABLE csctoss.usage_calc' ;
  var_sql := 'INSERT INTO csctoss.usage_calc
                   SELECT * 
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn())
                      ,''select class
                               ,acctstarttime
                               ,acctstoptime
                               ,acctsessiontime
                               ,acctinputoctets
                               ,acctoutputoctets
                           from csctlog.master_radacct
                          where class > \'\'0\'\'
                            and acctstoptime >= \''||quote_literal(par_usage_date-2)||'\'
                            and acctstoptime <  \''||quote_literal(var_end_date+2)||'\'
                            and acctstoptime IS NOT NULL'')
                       AS       rec_type(class            text
                                        ,acctstarttime    timestamptz 
                                        ,acctstoptime     timestamptz
                                        ,acctsessiontime  bigint
                                        ,acctinputoctets  bigint
                                        ,acctoutputoctets bigint)' ; 

--RETURN NEXT var_sql ;
--RETURN ;

  EXECUTE var_sql ;

  -- do all calculations and work from the temp table
  FOR line_rec IN SELECT line.line_id
                        ,'AAA' as preferred_timezone
                        ,SUM(COALESCE(EXTRACT(EPOCH FROM uclc.acctstoptime),0)) - 
                         SUM(COALESCE(EXTRACT(EPOCH FROM uclc.acctstarttime),0)) AS time_connected
                        ,SUM(COALESCE(uclc.acctsessiontime,0)) AS acctsessiontime
                        ,SUM(COALESCE(uclc.acctinputoctets,0)) AS acctinputoctets
                        ,SUM(COALESCE(uclc.acctoutputoctets,0)) AS acctoutputoctets
                        ,COUNT(*) AS rowcount
                    FROM csctoss.line
                    JOIN csctoss.billing_entity bent USING (billing_entity_id)
                    JOIN csctoss.usage_calc uclc ON (line.line_id::varchar = uclc.class)
                   WHERE 1=1
                     AND uclc.acctstoptime at time zone 'UTC' >= par_usage_date
                     AND uclc.acctstoptime at time zone 'UTC' <  var_end_date
                GROUP BY line.line_id
                        ,bent.preferred_timezone
                   UNION
                  SELECT line.line_id
                        ,bent.preferred_timezone
                        ,SUM(COALESCE(EXTRACT(EPOCH FROM uclc.acctstoptime),0)) -
                         SUM(COALESCE(EXTRACT(EPOCH FROM uclc.acctstarttime),0)) AS time_connected
                        ,SUM(COALESCE(uclc.acctsessiontime,0)) AS acctsessiontime
                        ,SUM(COALESCE(uclc.acctinputoctets,0)) AS acctinputoctets
                        ,SUM(COALESCE(uclc.acctoutputoctets,0)) AS acctoutputoctets
                        ,COUNT(*) AS rowcount
                    FROM csctoss.line
                    JOIN csctoss.billing_entity bent USING (billing_entity_id)
                    JOIN csctoss.usage_calc uclc ON (line.line_id::varchar = uclc.class)
                   WHERE 1=1
                     AND uclc.acctstoptime at time zone bent.preferred_timezone >= par_usage_date
                     AND uclc.acctstoptime at time zone bent.preferred_timezone <  var_end_date
                GROUP BY line.line_id
                        ,bent.preferred_timezone
                ORDER BY line_id
                        ,preferred_timezone
  LOOP


    -- make sure this is a valid line id
    PERFORM TRUE FROM csctoss.line WHERE line_id::varchar = line_rec.line_id ;

    IF NOT FOUND THEN
      RETURN NEXT 'ERROR: No corresponding Line Id found for MRAD Class '||line_rec.line_id||'.' ;
    ELSE

      -- this is a UTC record
      IF line_rec.preferred_timezone = 'AAA' THEN

        -- populate the line record for given usage date for UTC values
        INSERT INTO csctoss.line_usage_day
                   (line_id
                   ,timezone
                   ,usage_date
                   ,time_connected_utc
                   ,acctsessiontime_utc
                   ,acctinputoctets_utc
                   ,acctoutputoctets_utc
                   ,rowcount_utc)
            VALUES (line_rec.line_id
                   ,'UTC'
                   ,par_usage_date
                   ,line_rec.time_connected
                   ,line_rec.acctsessiontime
                   ,line_rec.acctinputoctets
                   ,line_rec.acctoutputoctets
                   ,line_rec.rowcount) ;
      ELSE

        -- this is a tz record, do an update and trap failure, then transform into an insert
        UPDATE csctoss.line_usage_day
           SET timezone            = line_rec.preferred_timezone
              ,time_connected_tz   = line_rec.time_connected
              ,acctsessiontime_tz  = line_rec.acctsessiontime
              ,acctinputoctets_tz  = line_rec.acctinputoctets
              ,acctoutputoctets_tz = line_rec.acctoutputoctets
              ,rowcount_tz         = line_rec.rowcount
         WHERE line_id             = line_rec.line_id
           AND usage_date          = par_usage_date ;

        IF NOT FOUND THEN
          -- perform and insert for the entire record based on tz values
          INSERT INTO csctoss.line_usage_day
                     (line_id
                     ,timezone
                     ,usage_date
                     ,time_connected_utc
                     ,acctsessiontime_utc
                     ,acctinputoctets_utc
                     ,acctoutputoctets_utc
                     ,rowcount_utc
                     ,time_connected_tz
                     ,acctsessiontime_tz
                     ,acctinputoctets_tz
                     ,acctoutputoctets_tz
                     ,rowcount_tz)
              VALUES (line_rec.line_id
                     ,line_rec.preferred_timezone
                     ,par_usage_date
                     ,0
                     ,0
                     ,0
                     ,0
                     ,0
                     ,line_rec.time_connected
                     ,line_rec.acctsessiontime
                     ,line_rec.acctinputoctets
                     ,line_rec.acctoutputoctets
                     ,line_rec.rowcount) ;
        END IF ;
      END IF ;
    END IF ;
  END LOOP ;

  RETURN NEXT 'SUCCESS' ;
  RETURN ;

END;
$_$;


ALTER FUNCTION csctoss.line_usage_day_calc(date, integer) OWNER TO csctoss_owner;

--
-- Name: FUNCTION line_usage_day_calc(date, integer); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION line_usage_day_calc(date, integer) IS 'Function to calculate daily usage by line and insert into line_usage_day table.';


--
-- Name: line_usage_month_calc(integer, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION line_usage_month_calc(integer, integer) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_year                integer := $1 ;
  par_month               integer := $2 ;

  var_start_date          date ;
  var_end_date            date ;

BEGIN

  -- check parameters
  IF par_year IS NULL OR par_month IS NULL THEN
    RETURN NEXT 'ERROR: Year and Month must be not null.' ;
    RETURN ;
  ELSIF par_year NOT BETWEEN 2007 AND 2020 THEN
    RETURN NEXT 'ERROR: Year must be between 2007 and 2020.' ;
    RETURN ;
  ELSIF par_month NOT BETWEEN 1 AND 12 THEN
    RETURN NEXT 'ERROR: Month must be between 1 and 12.' ;
    RETURN ;
  END IF ;

  -- check to see if this month and year already calculated - if so require user to delete this period first
  IF (SELECT COUNT(*)
        FROM csctoss.line_usage_month
       WHERE year = par_year
         AND month = par_month) > 0 THEN
    RETURN NEXT 'ERROR: Year '||par_year::text||' / Month '|| par_month::text||' already exists. Delete existing records then re-execute for this period.' ;
    RETURN ;
  END IF ;

  -- determine and assign start and end date variables
  var_start_date := par_year::text||'-'||lpad(par_month::text,2,'0')||'-01' ;
  IF par_month = 12 THEN
    var_end_date := (par_year+1)::text||'-01-01' ;
  ELSE
    var_end_date := par_year::text||'-'||lpad((par_month+1)::text,2,'0')||'-01' ;
  END IF ;

  RETURN NEXT var_start_date || ' to ' || var_end_date ;

  PERFORM public.set_change_log_staff_id(9) ; -- Billing Engine user

  -- just do a mass insert into line_usage_month based on sum of line_usage_day entries
  -- to keep it simple, hard code timezone as UTC then go back and update correctly

  INSERT INTO csctoss.line_usage_month
             (line_id
             ,year
             ,month
             ,timezone
             ,time_connected_utc
             ,acctsessiontime_utc
             ,acctinputoctets_utc
             ,acctoutputoctets_utc
             ,rowcount_utc
             ,time_connected_tz
             ,acctsessiontime_tz
             ,acctinputoctets_tz
             ,acctoutputoctets_tz
             ,rowcount_tz)
       SELECT liud.line_id
             ,par_year
             ,par_month
             ,'UTC'
             ,sum(liud.time_connected_utc)
             ,sum(liud.acctsessiontime_utc)
             ,sum(liud.acctinputoctets_utc)
             ,sum(liud.acctoutputoctets_utc)
             ,sum(liud.rowcount_utc)
             ,sum(liud.time_connected_tz)
             ,sum(liud.acctsessiontime_tz)
             ,sum(liud.acctinputoctets_tz)
             ,sum(liud.acctoutputoctets_tz)
             ,sum(liud.rowcount_tz)
         FROM csctoss.line_usage_day liud
        WHERE liud.usage_date >= var_start_date
          AND liud.usage_date <  var_end_date
     GROUP BY liud.line_id ;

  -- now go back and update the timezone correctly
  UPDATE csctoss.line_usage_month
     SET timezone = (select preferred_timezone 
                       from csctoss.billing_entity
                       join csctoss.line using (billing_entity_id)
                      where line.line_id = line_usage_month.line_id)
   WHERE year = par_year
     AND month = par_month ;

  RETURN NEXT 'SUCCESS' ;
  RETURN ;

END;
$_$;


ALTER FUNCTION csctoss.line_usage_month_calc(integer, integer) OWNER TO csctoss_owner;

--
-- Name: FUNCTION line_usage_month_calc(integer, integer); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION line_usage_month_calc(integer, integer) IS 'Function to calculate monthly usage by line and insert into line_usage_month table.';


--
-- Name: location_address_constraint(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION location_address_constraint(integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT EXISTS (SELECT address_id
                     FROM csctoss.billing_entity_address
                    WHERE address_id = $1) ;
                      -- AND address_type = 'PHYSICAL');
$_$;


ALTER FUNCTION csctoss.location_address_constraint(integer) OWNER TO csctoss_owner;

--
-- Name: mrac_loader(); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION mrac_loader() RETURNS SETOF text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE

  var_conn_string                  text ;
  var_last_radius_change_log_id    bigint ;
  var_max_radius_change_log_id     bigint ;
  var_sql                          text ;
  var_kount                        integer ;

  rec_sysparm                      record ;

BEGIN

  -- dump the old table contents initially to be sure table empty
  BEGIN
    EXECUTE 'TRUNCATE TABLE csctoss.mrac_load' ;
  EXCEPTION
    WHEN OTHERS THEN RETURN NEXT 'ERROR: TRUNCATE TABLE csctoss.mrac_load FAILED.' ;
                     RETURN ;
  END ;

  -- get connection info for radius hosts which should replicate radacct data
  FOR rec_sysparm IN SELECT *
                       FROM csctoss.system_parameter
                      WHERE radacct_flag
                   ORDER BY hostname
  LOOP

    var_conn_string := 'hostaddr='||rec_sysparm.ip_address||
                          ' port='||rec_sysparm.repl_port|| 
                        ' dbname='||rec_sysparm.repl_target_db||
                          ' user='||rec_sysparm.repl_target_username||
                      ' password='||rec_sysparm.repl_target_password ;

    -- last radius change log id
    SELECT * INTO var_last_radius_change_log_id
      FROM public.dblink(var_conn_string
                        ,'select radius_change_log_id from radiusdb.radius_last_change_log')
        AS rec_type(last_change_log_id integer) ;

    IF var_last_radius_change_log_id IS NULL THEN
      RETURN NEXT 'WARNING: '||rec_sysparm.hostname||' Last Radius Change Log ID is NULL.' ;
      --RETURN ;
    END IF ;

  -- max radius change log id
  SELECT * INTO var_max_radius_change_log_id 
    FROM public.dblink(var_conn_string
                      ,'select MAX(radius_change_log_id) FROM radiusdb.radius_change_log')
      AS rec_type(max_change_log_id integer) ;

  IF var_max_radius_change_log_id IS NULL THEN
    RETURN NEXT 'WARNING: '||rec_sysparm.hostname||' Max Change Log ID is NULL.' ;
    --RETURN ;
  END IF ;

  --RETURN NEXT 'LAST: '||var_last_radius_change_log_id::text||' - MAX: '||var_max_radius_change_log_id::text ;

  -- now do a mass insert of all radacct records from last to max change log
  BEGIN
    INSERT INTO csctoss.mrac_load
    SELECT * FROM public.dblink(var_conn_string
         ,'SELECT ract.radacctid
                 ,'||quote_literal(rec_sysparm.hostname)||'
                 ,rchl.change_type
                 ,ract.acctsessionid
                 ,ract.acctuniqueid
                 ,ract.username
                 ,ract.realm
                 ,ract.nasipaddress
                 ,ract.nasportid
                 ,ract.nasporttype
                 ,ract.acctstarttime
                 ,ract.acctstoptime
                 ,ract.acctsessiontime
                 ,ract.acctauthentic
                 ,ract.connectinfo_start
                 ,ract.connectinfo_stop
                 ,ract.acctinputoctets
                 ,ract.acctoutputoctets
                 ,ract.calledstationid
                 ,ract.callingstationid
                 ,ract.acctterminatecause
                 ,ract.servicetype
                 ,ract.framedprotocol
                 ,ract.framedipaddress
                 ,ract.acctstartdelay
                 ,ract.acctstopdelay
                 ,ract.xascendsessionsvrkey
                 ,ract.tunnelclientendpoint
                 ,ract.nasidentifier
                 ,ract.class
             FROM radiusdb.radius_change_log rchl
             JOIN radiusdb.radacct ract ON (rchl.primary_key = ract.radacctid)  
            WHERE rchl.table_name = ''radacct''
              AND rchl.radius_change_log_id >  '||var_last_radius_change_log_id||'
              AND rchl.radius_change_log_id <= '||var_max_radius_change_log_id||'
         ORDER BY rchl.radius_change_log_id')
               AS rec_type(radacctid              bigint
                          ,source_hostname        text
                          ,change_type            character(1)
                          ,acctsessionid          character varying(32)
                          ,acctuniqueid           character varying(32)
                          ,username               character varying(64)
                          ,realm                  character varying(64)
                          ,nasipaddress           inet
                          ,nasportid              character varying(15)
                          ,nasporttype            character varying(32)
                          ,acctstarttime          timestamp with time zone
                          ,acctstoptime           timestamp with time zone
                          ,acctsessiontime        bigint
                          ,acctauthentic          character varying(32)
                          ,connectinfo_start      character varying(50)
                          ,connectinfo_stop       character varying(50)
                          ,acctinputoctets        bigint
                          ,acctoutputoctets       bigint
                          ,calledstationid        character varying(50)
                          ,callingstationid       character varying(50)
                          ,acctterminatecause     character varying(32)
                          ,servicetype            character varying(32)
                          ,framedprotocol         character varying(32)
                          ,framedipaddress        inet
                          ,acctstartdelay         bigint
                          ,acctstopdelay          bigint
                          ,xascendsessionsvrkey   character varying(10)
                          ,tunnelclientendpoint   inet
                          ,nasidentifier          character varying(32)
                          ,class                  character varying(128)) ;
    EXCEPTION
      WHEN OTHERS THEN RETURN NEXT 'ERROR: OTHERS exception from '||rec_sysparm.hostname ;
    END ;

    -- update the radius last change log id on the remote database
    BEGIN
      var_sql := 'UPDATE radiusdb.radius_last_change_log SET radius_change_log_id = '||var_max_radius_change_log_id ;
      PERFORM * FROM public.dblink_exec(var_conn_string, var_sql) ;
    EXCEPTION
      WHEN OTHERS THEN RETURN NEXT 'ERROR: '||rec_sysparm.hostname||' Update Max Change Log ID Failed.' ;
                       --RETURN ;
    END ;

  END LOOP ;

  -- insert new (I) records into master_radacct
  INSERT INTO csctoss.master_radacct
             (source_hostname
             ,radacctid
             ,acctsessionid
             ,acctuniqueid
             ,username
             ,realm
             ,nasipaddress
             ,nasportid
             ,nasporttype
             ,acctstarttime
             ,acctstoptime
             ,acctsessiontime
             ,acctauthentic
             ,connectinfo_start
             ,connectinfo_stop
             ,acctinputoctets
             ,acctoutputoctets
             ,calledstationid
             ,callingstationid
             ,acctterminatecause
             ,servicetype
             ,framedprotocol
             ,framedipaddress
             ,acctstartdelay
             ,acctstopdelay
             ,xascendsessionsvrkey
             ,tunnelclientendpoint
             ,nasidentifier
             ,class)
       SELECT source_hostname
             ,radacctid
             ,acctsessionid
             ,acctuniqueid
             ,username
             ,realm
             ,nasipaddress
             ,nasportid
             ,nasporttype
             ,acctstarttime
             ,acctstoptime
             ,acctsessiontime
             ,acctauthentic
             ,connectinfo_start
             ,connectinfo_stop
             ,acctinputoctets
             ,acctoutputoctets
             ,calledstationid
             ,callingstationid
             ,acctterminatecause
             ,servicetype
             ,framedprotocol
             ,framedipaddress
             ,acctstartdelay
             ,acctstopdelay
             ,xascendsessionsvrkey
             ,tunnelclientendpoint
             ,nasidentifier
             ,class
         FROM csctoss.mrac_load
        WHERE change_type = 'I'
     ORDER BY radacctid ;

  -- update changed (U) records from mrac_load to master_radacct
  UPDATE csctoss.master_radacct
     SET username             = mrac_load.username
        ,realm                = mrac_load.realm
        ,nasipaddress         = mrac_load.nasipaddress
        ,nasportid            = mrac_load.nasportid
        ,nasporttype          = mrac_load.nasporttype
        ,acctstarttime        = mrac_load.acctstarttime
        ,acctstoptime         = mrac_load.acctstoptime
        ,acctsessiontime      = mrac_load.acctsessiontime
        ,acctauthentic        = mrac_load.acctauthentic
        ,connectinfo_start    = mrac_load.connectinfo_start
        ,connectinfo_stop     = mrac_load.connectinfo_stop
        ,acctinputoctets      = mrac_load.acctinputoctets
        ,acctoutputoctets     = mrac_load.acctoutputoctets
        ,calledstationid      = mrac_load.calledstationid
        ,callingstationid     = mrac_load.callingstationid
        ,acctterminatecause   = mrac_load.acctterminatecause
        ,servicetype          = mrac_load.servicetype
        ,framedprotocol       = mrac_load.framedprotocol
        ,framedipaddress      = mrac_load.framedipaddress
        ,acctstartdelay       = mrac_load.acctstartdelay
        ,acctstopdelay        = mrac_load.acctstopdelay
        ,xascendsessionsvrkey = mrac_load.xascendsessionsvrkey
        ,tunnelclientendpoint = mrac_load.tunnelclientendpoint
        ,nasidentifier        = mrac_load.nasidentifier
        ,class                = mrac_load.class
    FROM csctoss.mrac_load
   WHERE master_radacct.source_hostname = mrac_load.source_hostname
     AND master_radacct.radacctid = mrac_load.radacctid
     AND mrac_load.change_type = 'U' ;

  FOR rec_sysparm IN SELECT source_hostname, change_type, count(*) as kount
                       FROM csctoss.mrac_load
                   GROUP BY source_hostname, change_type
                   ORDER BY source_hostname
  LOOP
    RETURN NEXT rec_sysparm.kount::text || ' ' || rec_sysparm.change_type || ' radacct rows processed from ' || rec_sysparm.source_hostname ;
  END LOOP ;

  -- dump the old table contents when done to avoid backing up
  BEGIN
    EXECUTE 'TRUNCATE TABLE csctoss.mrac_load' ;
  EXCEPTION
    WHEN OTHERS THEN RETURN NEXT 'ERROR: TRUNCATE TABLE csctoss.mrac_load FAILED.' ;
                     RETURN ;
  END ;

  RETURN NEXT 'SUCCESS' ;
  RETURN ;

END ;

$$;


ALTER FUNCTION csctoss.mrac_loader() OWNER TO slony;

--
-- Name: FUNCTION mrac_loader(); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION mrac_loader() IS 'Replication function to pull all inserts and updates to radlogdb.radacct table since last radlogdb_change_log_id and process into master_radacct.';


--
-- Name: mrad_duplicate_scrub(date, date); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION mrad_duplicate_scrub(date, date) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_start_date          date := $1 ;
  par_end_date            date := $2 ;

  var_sql                 text ;
  var_insert              text ;
  scrub_rec               record ;

BEGIN

  -- check parameters
  IF par_start_date IS NULL OR par_end_date IS NULL THEN
    RAISE EXCEPTION 'ERROR: Start Date and End Date cannot be not null.' ;
  ELSIF par_start_date > par_end_date THEN
    RAISE EXCEPTION 'ERROR: Start Date must be before or equal to End Date.' ;
  END IF ;


  -----------------------------------------------------------------------------------
  -- insert duplicates based on same source_hostname + radacctid
  -----------------------------------------------------------------------------------
  var_sql := 'SELECT source_hostname
                    ,radacctid
                FROM csctoss.master_radacct
               WHERE class > ''0''
                 AND acctstoptime IS NOT NULL
                 AND DATE_TRUNC(''day'', acctstoptime at time zone ''UTC'') >= ' ||quote_literal(par_start_date-1)||'
                 AND DATE_TRUNC(''day'', acctstoptime at time zone ''UTC'') <  ' ||quote_literal(par_end_date+1)||'
            GROUP BY source_hostname
                    ,radacctid
              HAVING count(*) > 1' ;

  FOR scrub_rec IN EXECUTE var_sql LOOP
    var_insert := 'INSERT INTO csctoss.mrad_duplicate
                        SELECT master_radacctid
                              ,NULL
                              ,''SOURCE_HOSTNAME+RADACCTID''
                              ,''SCRUB''
                              ,current_date
                              ,source_hostname
                              ,radacctid
                              ,acctsessionid
                              ,acctuniqueid
                              ,username
                              ,realm
                              ,nasipaddress
                              ,nasportid
                              ,nasporttype
                              ,acctstarttime
                              ,acctstoptime
                              ,acctsessiontime
                              ,acctauthentic
                              ,connectinfo_start
                              ,connectinfo_stop
                              ,acctinputoctets
                              ,acctoutputoctets
                              ,calledstationid
                              ,callingstationid
                              ,acctterminatecause
                              ,servicetype
                              ,framedprotocol
                              ,framedipaddress
                              ,acctstartdelay
                              ,acctstopdelay
                              ,xascendsessionsvrkey
                              ,tunnelclientendpoint
                              ,nasidentifier
                              ,class
                          FROM csctoss.master_radacct mrad
                         WHERE mrad.source_hostname = ' || quote_literal(scrub_rec.source_hostname) || '
                           AND mrad.radacctid = ' || scrub_rec.radacctid ;
    EXECUTE var_insert ;
  END LOOP ;

  -----------------------------------------------------------------------------------
  -- process duplicates based on same source_hostname + radacctid
  -----------------------------------------------------------------------------------
  FOR scrub_rec IN SELECT max(master_radacctid) as retained_mrad_id
                         ,source_hostname
                         ,radacctid
                     FROM csctoss.mrad_duplicate
                    WHERE duplicate_reason = 'SOURCE_HOSTNAME+RADACCTID'
                      AND status = 'SCRUB'
                      AND acctstoptime IS NOT NULL
                 GROUP BY source_hostname
                         ,radacctid
  LOOP

    -- update the retained_mrad_id
    UPDATE csctoss.mrad_duplicate
       SET retained_mrad_id = scrub_rec.retained_mrad_id
     WHERE status = 'SCRUB'
       AND source_hostname = scrub_rec.source_hostname 
       AND radacctid = scrub_rec.radacctid
       AND master_radacctid <> scrub_rec.retained_mrad_id ;

  END LOOP ;

  -- delete these rows from master_radacct so same records are not picked up by other rules
  DELETE FROM csctoss.master_radacct
        WHERE master_radacctid IN (select master_radacctid
                                     from csctoss.mrad_duplicate
                                    where status = 'SCRUB'
                                      and duplicate_reason = 'SOURCE_HOSTNAME+RADACCTID'
                                      and retained_mrad_id is not null) ;

  -- delete retainers from mrad_duplicate
  DELETE FROM csctoss.mrad_duplicate
        WHERE status = 'SCRUB'
          AND retained_mrad_id IS NULL ;

  -----------------------------------------------------------------------------------
  -- insert duplicates based on same acctuniqueid
  -----------------------------------------------------------------------------------
  var_sql := 'SELECT acctuniqueid
                FROM csctoss.master_radacct
               WHERE class > ''0''
                 AND acctstoptime IS NOT NULL
                 AND DATE_TRUNC(''day'', acctstoptime at time zone ''UTC'') >= ' ||quote_literal(par_start_date-1)||'
                 AND DATE_TRUNC(''day'', acctstoptime at time zone ''UTC'') <  ' ||quote_literal(par_end_date+1)||'
            GROUP BY acctuniqueid
              HAVING count(*) > 1' ;

  FOR scrub_rec IN EXECUTE var_sql LOOP
    var_insert := 'INSERT INTO csctoss.mrad_duplicate
                        SELECT master_radacctid
                              ,NULL
                              ,''ACCTUNIQUEID''
                              ,''SCRUB''
                              ,current_date
                              ,source_hostname
                              ,radacctid
                              ,acctsessionid
                              ,acctuniqueid
                              ,username
                              ,realm
                              ,nasipaddress
                              ,nasportid
                              ,nasporttype
                              ,acctstarttime
                              ,acctstoptime
                              ,acctsessiontime
                              ,acctauthentic
                              ,connectinfo_start
                              ,connectinfo_stop
                              ,acctinputoctets
                              ,acctoutputoctets
                              ,calledstationid
                              ,callingstationid
                              ,acctterminatecause
                              ,servicetype
                              ,framedprotocol
                              ,framedipaddress
                              ,acctstartdelay
                              ,acctstopdelay
                              ,xascendsessionsvrkey
                              ,tunnelclientendpoint
                              ,nasidentifier
                              ,class
                          FROM csctoss.master_radacct mrad
                         WHERE mrad.acctuniqueid = ' || quote_literal(scrub_rec.acctuniqueid) ;
    EXECUTE var_insert ;
  END LOOP ;


  -----------------------------------------------------------------------------------
  -- process duplicates based on same acctuniqueid
  -----------------------------------------------------------------------------------
  FOR scrub_rec IN SELECT max(master_radacctid) as retained_mrad_id
                         ,acctuniqueid
                     FROM csctoss.mrad_duplicate
                    WHERE duplicate_reason = 'ACCTUNIQUEID'
                      AND status = 'SCRUB'
                      AND acctstoptime IS NOT NULL
                 GROUP BY acctuniqueid
  LOOP

    -- update the retained_mrad_id
    UPDATE csctoss.mrad_duplicate
       SET retained_mrad_id = scrub_rec.retained_mrad_id
     WHERE status = 'SCRUB'
       AND acctuniqueid = scrub_rec.acctuniqueid
       AND master_radacctid <> scrub_rec.retained_mrad_id ;

  END LOOP ;

--RETURN NEXT 'HALTING ...' ;
--RETURN ;

  -- delete these rows from master_radacct so same records are not picked up by other rules
  DELETE FROM csctoss.master_radacct 
        WHERE master_radacctid IN (select master_radacctid
                                     from csctoss.mrad_duplicate
                                    where status = 'SCRUB'
                                      and duplicate_reason = 'ACCTUNIQUEID'
                                      and retained_mrad_id is not null) ;

  -- delete retainers from mrad_duplicate
  DELETE FROM csctoss.mrad_duplicate
        WHERE status = 'SCRUB'
          AND retained_mrad_id IS NULL ;

  -----------------------------------------------------------------------------------
  -- insert duplicates based on same username + acctstarttime
  -----------------------------------------------------------------------------------
  var_sql := 'SELECT username
                    ,acctstarttime
                FROM csctoss.master_radacct
               WHERE class > ''0''
                 AND acctstoptime is NOT NULL
                 AND DATE_TRUNC(''day'', acctstoptime at time zone ''UTC'') >= ' ||quote_literal(par_start_date-1)||'
                 AND DATE_TRUNC(''day'', acctstoptime at time zone ''UTC'') <  ' ||quote_literal(par_end_date+1)||'
            GROUP BY username
                    ,acctstarttime
              HAVING count(*) > 1' ;

  FOR scrub_rec IN EXECUTE var_sql LOOP
    var_insert := 'INSERT INTO csctoss.mrad_duplicate
                        SELECT master_radacctid
                              ,NULL
                              ,''USERNAME+ACCTSTARTTIME''
                              ,''SCRUB''
                              ,current_date
                              ,source_hostname
                              ,radacctid
                              ,acctsessionid
                              ,acctuniqueid
                              ,username
                              ,realm
                              ,nasipaddress
                              ,nasportid
                              ,nasporttype
                              ,acctstarttime
                              ,acctstoptime
                              ,acctsessiontime
                              ,acctauthentic
                              ,connectinfo_start
                              ,connectinfo_stop
                              ,acctinputoctets
                              ,acctoutputoctets
                              ,calledstationid
                              ,callingstationid
                              ,acctterminatecause
                              ,servicetype
                              ,framedprotocol
                              ,framedipaddress
                              ,acctstartdelay
                              ,acctstopdelay
                              ,xascendsessionsvrkey
                              ,tunnelclientendpoint
                              ,nasidentifier
                              ,class
                          FROM csctoss.master_radacct mrad
                         WHERE mrad.username = ' || quote_literal(scrub_rec.username) || '
                           AND mrad.acctstarttime = ''' || scrub_rec.acctstarttime || '''' ;
    EXECUTE var_insert ;
  END LOOP ;

  -----------------------------------------------------------------------------------
  -- process duplicates based on same username + acctstarttime
  -----------------------------------------------------------------------------------
  FOR scrub_rec IN SELECT max(master_radacctid) as retained_mrad_id
                         ,username
                         ,acctstarttime
                     FROM csctoss.mrad_duplicate
                    WHERE duplicate_reason = 'USERNAME+ACCTSTARTTIME'
                      AND status = 'SCRUB'
                      AND acctstoptime IS NOT NULL
                 GROUP BY username
                         ,acctstarttime
  LOOP

    -- update the retained_mrad_id
    UPDATE csctoss.mrad_duplicate
       SET retained_mrad_id = scrub_rec.retained_mrad_id
     WHERE status = 'SCRUB'
       AND username = scrub_rec.username
       AND acctstarttime = scrub_rec.acctstarttime
       AND master_radacctid <> scrub_rec.retained_mrad_id ;

  END LOOP ;

  -- delete these rows from master_radacct so same records are not picked up by other rules
  DELETE FROM csctoss.master_radacct 
        WHERE master_radacctid IN (select master_radacctid
                                     from csctoss.mrad_duplicate
                                    where status = 'SCRUB'
                                      and duplicate_reason = 'USERNAME+ACCTSTARTTIME'
                                      and retained_mrad_id is not null) ;

  -- delete retainers from mrad_duplicate
  DELETE FROM csctoss.mrad_duplicate
        WHERE status = 'SCRUB'
          AND retained_mrad_id IS NULL ;

  -----------------------------------------------------------------------------------
  -- insert duplicates based on same username + acctstoptime
  -----------------------------------------------------------------------------------
  var_sql := 'SELECT username
                    ,acctstoptime
                FROM csctoss.master_radacct
               WHERE class > ''0''
                 AND acctstoptime is NOT NULL
                 AND DATE_TRUNC(''day'', acctstoptime at time zone ''UTC'') >= ' ||quote_literal(par_start_date-1)||'
                 AND DATE_TRUNC(''day'', acctstoptime at time zone ''UTC'') <  ' ||quote_literal(par_end_date+1)||'
            GROUP BY username, acctstoptime
              HAVING count(*) > 1' ;

  FOR scrub_rec IN EXECUTE var_sql LOOP
    var_insert := 'INSERT INTO csctoss.mrad_duplicate
                        SELECT master_radacctid
                              ,NULL
                              ,''USERNAME+ACCTSTOPTIME''
                              ,''SCRUB''
                              ,current_date
                              ,source_hostname
                              ,radacctid
                              ,acctsessionid
                              ,acctuniqueid
                              ,username
                              ,realm
                              ,nasipaddress
                              ,nasportid
                              ,nasporttype
                              ,acctstarttime
                              ,acctstoptime
                              ,acctsessiontime
                              ,acctauthentic
                              ,connectinfo_start
                              ,connectinfo_stop
                              ,acctinputoctets
                              ,acctoutputoctets
                              ,calledstationid
                              ,callingstationid
                              ,acctterminatecause
                              ,servicetype
                              ,framedprotocol
                              ,framedipaddress
                              ,acctstartdelay
                              ,acctstopdelay
                              ,xascendsessionsvrkey
                              ,tunnelclientendpoint
                              ,nasidentifier
                              ,class
                          FROM csctoss.master_radacct mrad
                         WHERE mrad.username = ' || quote_literal(scrub_rec.username) || '
                           AND mrad.acctstoptime = ''' || scrub_rec.acctstoptime || '''' ;
    EXECUTE var_insert ;
  END LOOP ;

  -----------------------------------------------------------------------------------
  -- process duplicates based on same username + acctstoptime
  -----------------------------------------------------------------------------------
  FOR scrub_rec IN SELECT max(master_radacctid) as retained_mrad_id
                         ,username
                         ,acctstoptime
                     FROM csctoss.mrad_duplicate
                    WHERE duplicate_reason = 'USERNAME+ACCTSTOPTIME'
                      AND status = 'SCRUB'
                      AND acctstoptime IS NOT NULL
                 GROUP BY username
                         ,acctstoptime
  LOOP

    -- update the retained_mrad_id
    UPDATE csctoss.mrad_duplicate
       SET retained_mrad_id = scrub_rec.retained_mrad_id
     WHERE status = 'SCRUB'
       AND username = scrub_rec.username
       AND acctstoptime = scrub_rec.acctstoptime
       AND master_radacctid <> scrub_rec.retained_mrad_id ;

  END LOOP ;

  -- delete these rows from master_radacct so same records are not picked up by other rules
  DELETE FROM csctoss.master_radacct 
        WHERE master_radacctid IN (select master_radacctid
                                     from csctoss.mrad_duplicate
                                    where status = 'SCRUB'
                                      and duplicate_reason = 'USERNAME+ACCTSTOPTIME'
                                      and retained_mrad_id is not null) ;

  -- delete retainers from mrad_duplicate
  DELETE FROM csctoss.mrad_duplicate
        WHERE status = 'SCRUB'
          AND retained_mrad_id IS NULL ;

  -----------------------------------------------------------------------------------
  -- insert duplicates based on overlapping sessions - begin in 2010 ...
  -----------------------------------------------------------------------------------

  --
  -- DO WE EVEN NEED THIS?
  -- THE QUERY FOR OVERLAPPING SESSIONS IS ENTIRELY TOO RESOURCE INTENSIVE
  -- AND INVOLVES SELF JOINING MASTER_RADACCT TO ITSELF ... BAD BAD
  --

  -----------------------------------------------------------------------------------
  -- mass update all scrub records to closed status for this iteration
  -----------------------------------------------------------------------------------
  UPDATE csctoss.mrad_duplicate
     SET status = 'CLOSED'
   WHERE status = 'SCRUB' ;

  RETURN NEXT 'SUCCESS' ;
  RETURN ;

END;
$_$;


ALTER FUNCTION csctoss.mrad_duplicate_scrub(date, date) OWNER TO csctoss_owner;

--
-- Name: FUNCTION mrad_duplicate_scrub(date, date); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION mrad_duplicate_scrub(date, date) IS 'Function to scrub daily master_radacct records by copying duplicates to mrad_duplicate table then delete from master_radacct.';


--
-- Name: mrpa_loader(); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION mrpa_loader() RETURNS SETOF text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE

  var_conn_string            text ;
  var_last_radpostauth_id    bigint ;
  var_max_radpostauth_id     bigint ;
  var_sql                    text ;
  var_kount                  integer ;

  rec_sysparm                record ;

BEGIN

  -- get connection info for radius hosts which should replicate radacct data
  FOR rec_sysparm IN SELECT *
                       FROM csctoss.system_parameter
                      WHERE radpostauth_flag
                   ORDER BY hostname
  LOOP

    var_conn_string := 'hostaddr='||rec_sysparm.ip_address||
                          ' port='||rec_sysparm.repl_port|| 
                        ' dbname='||rec_sysparm.repl_target_db||
                          ' user='||rec_sysparm.repl_target_username||
                      ' password='||rec_sysparm.repl_target_password ;

    -- last radpostauth id
    SELECT * INTO var_last_radpostauth_id
      FROM public.dblink(var_conn_string
                        ,'select radpostauth_id from radiusdb.radius_last_change_log')
        AS rec_type(radpostauth_id bigint) ;

    IF var_last_radpostauth_id IS NULL THEN
      RETURN NEXT 'WARNING: '||rec_sysparm.hostname||' Last Radpostauth ID is NULL.' ;
    END IF ;

    -- max radius change log id
    SELECT * INTO var_max_radpostauth_id
      FROM public.dblink(var_conn_string
                        ,'select MAX(id) FROM radiusdb.radpostauth')
        AS rec_type(id bigint) ;

    IF var_max_radpostauth_id IS NULL THEN
      --RETURN NEXT 'WARNING: '||rec_sysparm.hostname||' Max Radpostauth ID is NULL.' ;
      var_max_radpostauth_id := var_last_radpostauth_id ;
    END IF ;

    -- RETURN NEXT 'LAST: '||var_last_radpostauth_id::text||' - MAX: '||var_max_radpostauth_id::text ;

    -- do a mass insert directly into master_radpostauth from radiusdb radpostauth
    -- execute in a transaction to capture any errors from single server without affecting other servers
    BEGIN
      INSERT INTO csctoss.master_radpostauth
                 (source_hostname
                 ,id
                 ,username
                 ,pass
                 ,reply
                 ,authdate)
          SELECT * FROM public.dblink(var_conn_string
                 ,'SELECT '||quote_literal(rec_sysparm.hostname)||'
                         ,id
                         ,username
                         ,pass
                         ,reply
                         ,authdate
                     FROM radiusdb.radpostauth
                    WHERE id >  '||var_last_radpostauth_id||'
                      AND id <= '||var_max_radpostauth_id||'
                 ORDER BY id')
                       AS rec_type(source_hostname text
                                  ,id              bigint
                                  ,username        character varying(64)
                                  ,pass            character varying(128)
                                  ,reply           character varying(32)
                                  ,authdate        timestamp with time zone) ;
    EXCEPTION
      WHEN OTHERS THEN RETURN NEXT 'ERROR: OTHERS exception from '||rec_sysparm.hostname ;
    END ;

    -- get and report number of radpostauth rows inserted
    GET DIAGNOSTICS var_kount = ROW_COUNT ;
    IF var_kount > 0 THEN
      RETURN NEXT var_kount::text || ' radpostauth rows processed from '||rec_sysparm.hostname ;
    END IF ;

    -- update the radius last change log id on the remote database
    BEGIN
      var_sql := 'UPDATE radiusdb.radius_last_change_log SET radpostauth_id = '||var_max_radpostauth_id ;
      PERFORM * FROM public.dblink_exec(var_conn_string, var_sql) ;
    EXCEPTION
      WHEN OTHERS THEN RETURN NEXT 'ERROR: '||rec_sysparm.hostname||' Update Radpostauth ID Failed.' ;
    END ;

  END LOOP ;

  RETURN NEXT 'SUCCESS' ;
  RETURN ;

END ;

$$;


ALTER FUNCTION csctoss.mrpa_loader() OWNER TO slony;

--
-- Name: FUNCTION mrpa_loader(); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION mrpa_loader() IS 'Replication function to pull all inserts for radiusdb.radpostauth table since last radpostauth_id and insert into csctoss.master_radpostauth.';


--
-- Name: nas_updater(text, character); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION nas_updater(text, character) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_primary_key       text    := $1 ;
  par_change_type       char(1) := $2 ;

  var_cols		text ;
  var_vals		text ;
  var_sql               text ;

  sysparm_rec		record ;
  nas_rec		record ;

BEGIN

  -- dynamically build sql statement based on change type and execute
  IF par_change_type = 'D' THEN

    -- build string for deletes
    var_sql := 'delete from nas where id = '||par_primary_key||'' ;

  ELSE

    SELECT * INTO nas_rec FROM csctoss.nas WHERE id = par_primary_key::integer ;
    IF NOT FOUND THEN RETURN FALSE ; END IF ;

    -- build string for inserts, start with not nulls then evaluate nullable
    IF par_change_type = 'I' THEN

      var_cols := 'INSERT INTO nas( id, nasname, shortname, type, secret ' ;
      var_vals := '     VALUES (' || nas_rec.id                       || ','
                                  || quote_literal(nas_rec.nasname)   || ','
                                  || quote_literal(nas_rec.shortname) || ','
                                  || quote_literal(nas_rec.type)      || ','
                                  || quote_literal(nas_rec.secret) ;

      -- catenate additional fields if not null
      IF nas_rec.ports IS NOT NULL THEN
        var_cols := var_cols || ', ports ' ;
        var_vals := var_vals || ',' || nas_rec.ports ;
      END IF ;
      IF nas_rec.community IS NOT NULL THEN
        var_cols := var_cols || ', community ' ;
        var_vals := var_vals || ',' || quote_literal(nas_rec.community) ;
      END IF ;
      IF nas_rec.description IS NOT NULL THEN
        var_cols := var_cols || ', description ' ;
        var_vals := var_vals || ',' || quote_literal(nas_rec.description) ;
      END IF ;

      -- now catenate the cols and vals
      var_sql := var_cols || ') ' || var_vals || ') ' ;

    -- build string for updates, start with not nulls then evaluate nullable
    ELSIF par_change_type = 'U' THEN

      var_sql := 'UPDATE nas
                     SET nasname     = ' || quote_literal(nas_rec.nasname) || '
                        ,shortname   = ' || quote_literal(nas_rec.shortname) || '
                        ,type        = ' || quote_literal(nas_rec.type) || '
                        ,secret      = ' || quote_literal(nas_rec.secret) ;

      -- catenate remaining fields evaluating nulls
      IF nas_rec.ports IS NULL THEN
        var_sql := var_sql || ', ports = null ' ;
      ELSE
        var_sql := var_sql || ', ports = ' || nas_rec.ports ;
      END IF ;
      IF nas_rec.community IS NULL THEN
        var_sql := var_sql || ', community = null ' ;
      ELSE
        var_sql := var_sql || ', community = ' || quote_literal(nas_rec.community) ;
      END IF ;
      IF nas_rec.description IS NULL THEN
        var_sql := var_sql || ', description = null ' ;
      ELSE
        var_sql := var_sql || ', description = ' || quote_literal(nas_rec.description) ;
      END IF ;

      -- tack on the where clause
      var_sql := var_sql || ' WHERE id = ' || nas_rec.id ;

    END IF ;

  END IF ;

RAISE NOTICE 'SQL: %', var_sql ;

  -- now loop through appropriate rows again in system_parameter table performing the actual statement
  FOR sysparm_rec IN SELECT hostname, ip_address 
                       FROM csctoss.system_parameter
                      WHERE repl_flag = TRUE
  LOOP

    BEGIN

      PERFORM public.dblink_exec(sysparm_rec.hostname, var_sql, FALSE) ;

    EXCEPTION WHEN OTHERS THEN PERFORM csctoss.replication_failure_insert
                                             (sysparm_rec.hostname
                                             ,sysparm_rec.ip_address
                                             ,'nas'
                                             ,par_primary_key
                                             ,par_change_type
                                             ,var_sql) ;
    END ;

  END LOOP ;

  RETURN TRUE ;

END;
$_$;


ALTER FUNCTION csctoss.nas_updater(text, character) OWNER TO slony;

--
-- Name: FUNCTION nas_updater(text, character); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION nas_updater(text, character) IS 'Updater based function to replicate nas data changes from change_log.';


--
-- Name: normalize_epoch(bigint, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION normalize_epoch(bigint, text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_seconds      bigint := $1 ;
  par_denominator  text   := UPPER($2) ;

  var_remainder    integer ;
  var_return       text ;

BEGIN

  -- validate parms
  IF par_seconds <= 0 THEN
    var_return := '00:00:00' ;
    RETURN var_return ;
  ELSIF par_denominator NOT IN ('DAY','HOUR','MINUTE') THEN
    RAISE EXCEPTION 'Denominator must be DAY, HOUR or MINUTE (%).', par_denominator ;
  END IF ;

  -- do the calculations based on denominator
  IF par_denominator = 'DAY' THEN

    -- get the days
    var_return := round(par_seconds/86400,0)::text ;
    IF var_return = '1' THEN
      var_return := var_return || ' day ' ;
    ELSE
      var_return := var_return || ' days ' ;
    END IF ;
    var_remainder := mod(par_seconds,86400) ;
 
    -- get the hours
    var_return := var_return || LPAD(round(var_remainder/3600,0)::text,2,'0') || ':' ;
    var_remainder := mod(var_remainder,3600) ;

    -- get the minutes
    var_return := var_return || LPAD(round(var_remainder/60,0)::text,2,'0') || ':' ;
    var_return := var_return || LPAD(mod(var_remainder,60)::text,2,'0') ;

  ELSIF par_denominator = 'HOUR' THEN

    -- get the hours
    IF LENGTH(round(par_seconds/3600,0)::text) = 1 THEN
      var_return := LPAD(round(par_seconds/3600,0)::text || ':',2,'0') ;
    ELSE
      var_return := round(par_seconds/3600,0)::text || ':' ;
    END IF ;

    var_remainder := mod(par_seconds,3600) ;

    -- get the minutes
    var_return := var_return || LPAD(round(var_remainder/60,0)::text,2,'0') || ':' ;
    var_return := var_return || LPAD(mod(var_remainder,60)::text,2,'0') ;

  ELSE

    -- get the minutes
    var_return := round(par_seconds/60,0)::text || ':' ;
    var_return := var_return || LPAD(mod(par_seconds,60),2,'0') ;

  END IF ;

  RETURN var_return ;

END ;
$_$;


ALTER FUNCTION csctoss.normalize_epoch(bigint, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION normalize_epoch(bigint, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION normalize_epoch(bigint, text) IS 'Simple function to convert epoch seconds to standard display format as text.';


--
-- Name: one_time_ip_fix(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION one_time_ip_fix() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  var_rec		RECORD;
  var_static_ip		text;
  
BEGIN
  set client_min_messages to NOTICE;



  
  FOR var_rec IN SELECT * 
		 FROM   radreply
		 WHERE  1=1
		 AND    attribute = 'Class'
		 AND    substr(username,1,15) IN (882393256289109,
							882393256289137,
							882393256289133,
							882393256289135,
							882393256289110,
							882393256289128,
							882393724735890,
							882393256289138,
							882393256289130,
							882393724735886,
							882393724735889,
							882393724735891,
							882393256289111,
							882393256289132,
							882393256289114,
							882393256289134,
							882393724735887,
							882393724735888,
							882393256289100,
							882393256289113,
							882393256289124,
							882393256289102,
							882393724735879,
							882393256289115,
							882393256289126,
							882393256289152,
							882393256289136,
							882393256289127,
							882393256289129,
							882393256289112,
							882393256289122,
							882393724735880,
							882393256289101,
							882393256289103,
							882393256289120,
							882393256289125,
							882393256289119,
							882393256289123,
							882393256289131,
							882393724735881)    
		  
  LOOP

  IF NOT EXISTS (SELECT TRUE FROM radreply WHERE username = var_rec.username AND attribute = 'Framed-IP-Address') THEN

    SELECT
     static_ip
    INTO
     var_static_ip
    FROM static_ip_pool
    WHERE groupname = 'SERVICE-vodafone'
    and billing_entity_id = 221
    and is_assigned = false 
    order by 1;

    INSERT INTO radreply(
            username, attribute, op, value, priority)
    VALUES (var_rec.username, 'Framed-IP-Address', '=', var_static_ip, 10);

    UPDATE static_ip_pool 
    set is_assigned = true, 
        line_id = var_rec.value::integer
    where static_ip = var_static_ip ;



  ELSE
    UPDATE static_ip_pool 
    set is_assigned = 'true',
    line_id = var_rec.value::integer
    where static_ip = (SELECT value FROM radreply WHERE username = var_rec.username AND attribute = 'Framed-IP-Address') ;

  END IF;

  RAISE NOTICE 'username = % ' , var_rec.username ;
   
  END LOOP ;

  RETURN TRUE ;
  
END ;

$$;


ALTER FUNCTION csctoss.one_time_ip_fix() OWNER TO csctoss_owner;

--
-- Name: ops_api_activate(text, text, text, text, text, text, integer, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_activate(text, text, text, text, text, text, integer, text, text) RETURNS ops_api_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

   par_esn_hex                 text    := $1;
   par_esn_dec                 text    := $2;
   par_mdn                     text    := $3;
   par_min                     text    := $4;
   par_serial_number           text    := $5;
   par_mac_address             text    := $6;
   par_equipment_model_id      integer := $7;
   par_realm                   text    := $8;
   par_carrier                 text    := $9;

   var_equipment_id            integer;
   var_receiving_lot_id        integer;
   var_username                text;
   var_groupname               text;
   v_errmsg                    text;
   var_return                  ops_api_retval%ROWTYPE;

BEGIN

  PERFORM public.set_change_log_staff_id(3) ;

  -- Check to see if the parameters are null
  IF par_esn_hex = ''
    OR par_esn_dec = ''
    OR par_mdn = ''
    OR par_min = ''
    OR par_serial_number = ''
    OR par_mac_address = ''
    OR par_equipment_model_id IS NULL
    OR par_carrier = ''
  THEN
      v_errmsg  := 'All or some of the input parameters are NULL or empty';
      RAISE EXCEPTION 'ERROR: No parameters';
  END IF;

  -- Check to see of parameter does not contain a space character
  IF par_esn_hex LIKE '% %'
    OR par_esn_dec LIKE '% %'
    OR par_mdn LIKE '% %'
    OR par_min LIKE '% %'
    OR par_serial_number LIKE '% %'
    OR par_mac_address LIKE '% %'
  THEN
      v_errmsg  := 'All or some of the input parameters contain a space character.';
      RAISE EXCEPTION 'ERROR: Invalid parameter';
  END IF;


  -- Insert receiving_lot information before inserting equipment details
  var_receiving_lot_id := nextval('csctoss.receiving_lot_receiving_lot_id_seq');
  INSERT INTO receiving_lot (receiving_lot_id, description, receiving_status, purchase_order_date, ship_date, received_date, item_count, vendor)
       VALUES (var_receiving_lot_id, 'Operations API: '||current_date,'OPEN',current_date,current_date,current_date,1,'unknown');

  var_equipment_id := nextval('csctoss.equipment_equipment_id_seq');

  IF EXISTS (SELECT TRUE FROM equipment_model WHERE equipment_model_id = par_equipment_model_id) THEN
    -- Insert equipment details
    IF NOT EXISTS (SELECT TRUE FROM equipment WHERE equipment_id = var_equipment_id) THEN
      INSERT INTO equipment(equipment_id, equipment_type, equipment_model_id, receiving_lot_id, enabled_flag)
           VALUES (var_equipment_id, 'ROUTER', par_equipment_model_id, var_receiving_lot_id, 'TRUE');
    ELSE
      v_errmsg  := 'Equipment_Id ' || var_equipment_id || ' already exists.';
      RAISE EXCEPTION  'ERROR:  Invalid Equipment_Id.' ;
    END IF;

  ELSE
    v_errmsg := 'Equipment Model ID ' || par_equipment_model_id || ' is wrong.';
    RAISE EXCEPTION 'ERROR:  Invalid Equipment Model ID.' ;
  END IF;

  -- Insert equipment details in the equipment_status table
  INSERT INTO equipment_status(equipment_id, equipment_status_type, date_created)
     VALUES (var_equipment_id, 'AVAILABLE-ATLANTA', current_date);

  -- Insert the unique_identifier values in the unique_identifier table for the equipment_id obtained.
  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex) THEN
    INSERT INTO unique_identifier(equipment_id, unique_identifier_type, value, date_created)
       VALUES (var_equipment_id, 'ESN HEX', par_esn_hex, current_date);
  ELSE
    v_errmsg := 'ESN Hex ' || par_esn_hex || ' already exists.';
    RAISE EXCEPTION 'ERROR:  Invalid ESN HEX.';
  END IF;

  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'ESN DEC' AND value = par_esn_dec) THEN
    INSERT INTO unique_identifier(equipment_id, unique_identifier_type, value, date_created)
       VALUES (var_equipment_id, 'ESN DEC', par_esn_dec, current_date);
  ELSE
    v_errmsg := 'ESN DEC ' || par_esn_dec || ' already exists.';
    RAISE EXCEPTION 'ERROR:  Invalid ESN DEC.';
  END IF;

  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'MDN' AND value = par_mdn) THEN
    INSERT INTO unique_identifier(equipment_id, unique_identifier_type, value, date_created)
         VALUES (var_equipment_id, 'MDN', par_mdn, current_date);
  ELSE
    v_errmsg := 'MDN ' || par_mdn || ' already exists.';
    RAISE EXCEPTION 'ERROR:  Invalid MDN';
  END IF;

  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'MIN' AND value = par_min) THEN
    INSERT INTO unique_identifier(equipment_id, unique_identifier_type, value, date_created)
         VALUES (var_equipment_id, 'MIN', par_min, current_date);
  ELSE
    v_errmsg = 'MIN ' || par_min || ' already exists.';
    RAISE EXCEPTION 'ERROR:  Invalid MIN';
  END IF;

  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'SERIAL NUMBER' AND value = par_serial_number) THEN
    INSERT INTO unique_identifier(equipment_id, unique_identifier_type, value, date_created)
       VALUES (var_equipment_id, 'SERIAL NUMBER', par_serial_number, current_date);
  ELSE
--    v_errmsg := 'SERIAL NUMBER already exists.';
    v_errmsg := 'SERIAL NUMBER ' || par_serial_number || ' already exists.';
    RAISE EXCEPTION 'ERROR:  Invalid SERIAL NUMBER';
  END IF;

  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'MAC ADDRESS' AND value = par_mac_address) THEN
    INSERT INTO unique_identifier(equipment_id, unique_identifier_type, value, date_created)
       VALUES (var_equipment_id, 'MAC ADDRESS', par_mac_address, current_date);
  ELSE
    v_errmsg := 'MAC ' || par_mac_address || ' Address already exists.';
    RAISE EXCEPTION 'ERROR:  Invalid MAC ADDRESS';
  END IF;

  -- Insert the details of username table
  par_carrier := lower(par_carrier);

  IF par_carrier LIKE 'sprint%' THEN
    par_carrier := (par_carrier) || 'pcs';
    var_username := par_mdn || par_realm;

  ELSIF par_carrier LIKE 'vzw%' THEN
    var_username := par_mdn || par_realm;
  END IF;

  IF NOT EXISTS (SELECT TRUE FROM username WHERE username = var_username) THEN
    INSERT INTO username(username, billing_entity_id, primary_service, enabled, start_date, end_date, date_created, auth_pod)
       VALUES (var_username, 1, 'TRUE', 'TRUE', current_date, '2999-12-31', current_date, 'FALSE');
  ELSE
    v_errmsg := 'Username ' || var_username || ' already exists in username table.';
    RAISE EXCEPTION 'ERROR:  Invalid Username, username';
  END IF;

  -- Insert the details of radcheck table
  IF NOT EXISTS (SELECT TRUE FROM radcheck WHERE username = var_username) THEN
    IF par_carrier LIKE 'sprint%' THEN
      INSERT INTO radcheck(username, attribute, op, value)
        VALUES (var_username, 'ClearText-Password', ':=', '');
    ELSIF par_carrier LIKE 'vzw%' THEN
      INSERT INTO radcheck(username, attribute, op, value)
        VALUES (var_username, 'Auth-Type', ':=', 'Accept');
    END IF;
  ELSE
    v_errmsg := 'Username ' || var_username || ' already exists in radcheck table.';
    RAISE EXCEPTION 'ERROR:  Invalid Username, radcheck';
  END IF;

  -- Insert the details of usergroup table
  IF par_carrier LIKE 'sprint%' THEN
    var_groupname := 'SERVICE-inventory';
  ELSIF par_carrier LIKE 'vzw%' THEN
    var_groupname := 'SERVICE-vzw_inventory';
  END IF;

  IF NOT EXISTS (SELECT TRUE FROM usergroup WHERE username = var_username) THEN
    INSERT INTO usergroup(username, groupname, priority)
       VALUES (var_username, var_groupname, 50000);
  ELSE
    v_errmsg := 'Username ' || var_username || ' already exists in usergroup table.';
    RAISE EXCEPTION 'ERROR:  Invalid Username, usergroup';
  END IF;

  var_return.result_code := true;
  var_return.error_message := 'SUCCESS:  sevice is activated.' ;
  RETURN var_return ;

EXCEPTION
        WHEN raise_exception THEN
            var_return.result_code := false;
            var_return.error_message:=v_errmsg;
            RAISE NOTICE 'rt_oss_rma: when raise_exception:  % ',v_errmsg;
            RETURN var_return;

        WHEN others THEN
            v_errmsg := 'Unknown error!'
            var_return.result_code := false;
            var_return.error_message := v_errmsg;
            RAISE NOTICE 'ERROR:  Unknown Error! ';
            RETURN var_return;
END;
$_$;


ALTER FUNCTION csctoss.ops_api_activate(text, text, text, text, text, text, integer, text, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION ops_api_activate(text, text, text, text, text, text, integer, text, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION ops_api_activate(text, text, text, text, text, text, integer, text, text) IS 'Activate Function to insert equipment, unique_identifiers, username details.';


--
-- Name: ops_api_activate_w_vodafone(text, text, text, text, text, text, integer, text, text, text, text, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_activate_w_vodafone(text, text, text, text, text, text, integer, text, text, text, text, text, text) RETURNS SETOF ops_api_activate_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

   par_esn_hex                 	text := $1;
   par_esn_dec	               	text := $2;
   par_mdn                     	text := $3;
   par_min                     	text := $4;
   par_serial_number           	text := $5;
   par_mac_address             	text := $6;
   par_equipment_model_id      	integer := $7;
   par_realm                   	text := $8;
   par_carrier                 	text := $9;
--
   par_iccid			text := $10 ;	
   par_imei			text := $11 ;
   par_imsi			text := $12 ;
   par_msisdn			text := $13 ;
--
   					
   var_equipment_id            integer;
   var_receiving_lot_id        integer;
   var_username                text;
   var_groupname               text;
   var_return                  ops_api_activate_retval%ROWTYPE;

BEGIN 

    --TODO: REMOVE SILLY HARCODED STAFF ID
    PERFORM public.set_change_log_staff_id(3) ;

    IF upper(par_carrier) = 'VODAFONE' THEN
      IF (par_iccid IS NULL) OR (par_imei IS NULL) OR (par_imsi IS NULL) OR (par_msisdn IS NULL) OR (par_serial_number IS NULL) OR (par_mac_address IS NULL) THEN
        RAISE EXCEPTION 'All or some of the VODAFONE input parameters are Null.' ;
      END IF;
    ELSE
       	-- check to see if the parameters are null 	
      IF par_esn_hex = ''
        OR par_esn_dec = ''
	OR par_mdn = ''
	OR par_min = ''
	OR par_serial_number = ''
	OR par_mac_address = '' 
	OR par_equipment_model_id IS NULL
	OR par_carrier = ''
      THEN 
        RAISE EXCEPTION 'All or some of the input parameters are Null.' ;
      END IF;
    END IF;
--END parameter check

-----------------
-- Start Loading
-----------------

  --
  -- Insert receiving_lot information before inserting equipment details
  --
  var_receiving_lot_id := nextval('csctoss.receiving_lot_receiving_lot_id_seq');
    
  INSERT INTO receiving_lot 
  (receiving_lot_id, description, receiving_status, purchase_order_date, ship_date, received_date, item_count, vendor)
  VALUES 
  (var_receiving_lot_id, 'Operations API: '||current_date,'OPEN',current_date,current_date,current_date,1,'unknown');



  --
  -- Insert equipment details
  --

  var_equipment_id := nextval('csctoss.equipment_equipment_id_seq');

  IF EXISTS (SELECT TRUE FROM equipment_model WHERE equipment_model_id = par_equipment_model_id) THEN 
	        
    IF NOT EXISTS (SELECT TRUE FROM equipment WHERE equipment_id = var_equipment_id) THEN

      INSERT INTO 
      equipment(equipment_id, equipment_type, equipment_model_id, receiving_lot_id, enabled_flag)
      VALUES 
      (var_equipment_id, 'ROUTER', par_equipment_model_id, var_receiving_lot_id, 'TRUE');

    ELSE 
      RAISE EXCEPTION  'Equipment_Id already exists.' ;
    END IF;		   
  ELSE 
    RAISE EXCEPTION 'Equipment Model ID is wrong.' ;
  END IF; 



  --
  -- Insert equipment details in the equipment_status table 
  --
	
  INSERT INTO equipment_status
  (equipment_id, equipment_status_type, date_created)
  VALUES 
  (var_equipment_id, 'AVAILABLE-ATLANTA', current_date);



  --
  -- Insert the unique_identifier values in the unique_identifier table for the equipment_id obtained.
  --

IF upper(par_carrier) = 'VODAFONE' THEN

  --ICCID
  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'ICCID' AND value = par_iccid) THEN 

    INSERT INTO unique_identifier
    (equipment_id, unique_identifier_type, value, date_created)
    VALUES
    (var_equipment_id, 'ICCID', par_iccid, current_date);
     
  ELSE
    RAISE EXCEPTION 'ICCID Already Exists.';
  END IF;

  --IMEI
  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'IMEI' AND value = par_imei) THEN 

    INSERT INTO unique_identifier
    (equipment_id, unique_identifier_type, value, date_created)
    VALUES
    (var_equipment_id, 'IMEI', par_imei, current_date);
     
  ELSE
    RAISE EXCEPTION 'IMEI Already Exists.';
  END IF;

  --IMSI
  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'IMSI' AND value = par_imsi) THEN 

    INSERT INTO unique_identifier
    (equipment_id, unique_identifier_type, value, date_created)
    VALUES
    (var_equipment_id, 'IMSI', par_imsi, current_date);
     
  ELSE
    RAISE EXCEPTION 'IMSI Already Exists.';
  END IF;

  --MSISDN
  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'MSISDN' AND value = par_msisdn) THEN 

    INSERT INTO unique_identifier
    (equipment_id, unique_identifier_type, value, date_created)
    VALUES
    (var_equipment_id, 'MSISDN', par_msisdn, current_date);
     
  ELSE
    RAISE EXCEPTION 'MSISDN Already Exists.';
  END IF;

  --SERIAL NUMBER
  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'SERIAL NUMBER' AND value = par_serial_number) THEN 

    INSERT INTO unique_identifier
    (equipment_id, unique_identifier_type, value, date_created)
    VALUES
    (var_equipment_id, 'SERIAL NUMBER', par_serial_number, current_date);
     
  ELSE
    RAISE EXCEPTION 'SERIAL NUMBER Already Exists.';
  END IF;

  --MAC ADDRESS
  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'MAC ADDRESS' AND value = par_mac_address) THEN 

    INSERT INTO unique_identifier
    (equipment_id, unique_identifier_type, value, date_created)
    VALUES
    (var_equipment_id, 'MAC ADDRESS', par_mac_address, current_date);
     
  ELSE
    RAISE EXCEPTION 'MAC ADDRESS Already Exists.';
  END IF;    

  --ESN HEX
  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_msisdn) THEN 

    INSERT INTO unique_identifier
    (equipment_id, unique_identifier_type, value, date_created)
    VALUES
    (var_equipment_id, 'ESN HEX', par_msisdn, current_date);
     
  ELSE
    RAISE EXCEPTION 'ESN HEX Already Exists.';
  END IF;

  --ESN DEC
  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'ESN DEC' AND value = par_msisdn) THEN  
       
    INSERT INTO unique_identifier
    (equipment_id, unique_identifier_type, value, date_created)
    VALUES 
    (var_equipment_id, 'ESN DEC', par_msisdn, current_date);

  ELSE 
     RAISE EXCEPTION 'ESN DEC Already Exists';
  END IF;

  --MDN
  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'MDN' AND value = par_msisdn) THEN

    INSERT INTO unique_identifier
    (equipment_id, unique_identifier_type, value, date_created)
    VALUES 
    (var_equipment_id, 'MDN', par_msisdn, current_date);

  ELSE
    RAISE EXCEPTION 'MDN already exists';
  END IF;

  --MIN
  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'MIN' AND value = par_msisdn) THEN

     INSERT INTO unique_identifier
     (equipment_id, unique_identifier_type, value, date_created)
     VALUES 
     (var_equipment_id, 'MIN', par_msisdn, current_date);

  ELSE
    RAISE EXCEPTION 'MIN already exists';
  END IF;  

ELSE  --not vodafone
  	    
  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex) THEN 

    INSERT INTO unique_identifier
    (equipment_id, unique_identifier_type, value, date_created)
    VALUES
    (var_equipment_id, 'ESN HEX', par_esn_hex, current_date);
     
  ELSE
    RAISE EXCEPTION 'ESN HEX Already Exists.';
  END IF;

	  
  IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'ESN DEC' AND value = par_esn_dec) THEN  
       
     INSERT INTO unique_identifier
     (equipment_id, unique_identifier_type, value, date_created)
     VALUES 
     (var_equipment_id, 'ESN DEC', par_esn_dec, current_date);

  ELSE 
     RAISE EXCEPTION 'ESN DEC Already Exists';
  END IF;
 
   IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'MDN' AND value = par_mdn) THEN

     INSERT INTO unique_identifier
     (equipment_id, unique_identifier_type, value, date_created)
     VALUES 
     (var_equipment_id, 'MDN', par_mdn, current_date);

   ELSE
     RAISE EXCEPTION 'MDN already exists';
   END IF;
	
   IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'MIN' AND value = par_min) THEN

       INSERT INTO unique_identifier
       (equipment_id, unique_identifier_type, value, date_created)
       VALUES 
       (var_equipment_id, 'MIN', par_min, current_date);

    ELSE
      RAISE EXCEPTION 'MIN already exists';
    END IF;
	
    IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'SERIAL NUMBER' AND value = par_serial_number) THEN

      INSERT INTO unique_identifier
      (equipment_id, unique_identifier_type, value, date_created)
      VALUES 
      (var_equipment_id, 'SERIAL NUMBER', par_serial_number, current_date);

    ELSE
      RAISE EXCEPTION 'SERIAL NUMBER already exists';
    END IF;
	
    IF NOT EXISTS (SELECT TRUE FROM unique_identifier WHERE unique_identifier_type = 'MAC ADDRESS' AND value = par_mac_address) THEN

      INSERT INTO unique_identifier
      (equipment_id, unique_identifier_type, value, date_created)
      VALUES 
      (var_equipment_id, 'MAC ADDRESS', par_mac_address, current_date);  

    ELSE
      RAISE EXCEPTION 'MAC ADDRESS already exists';
    END IF;

END IF; --END inserting all unique identifier


  --
  -- Insert the details of username table
  --              
  par_carrier := lower(par_carrier); 
 
  IF par_carrier LIKE 'sprint%' THEN 
    par_carrier := (par_carrier) || 'pcs'; 		  
    var_username := par_mdn || '@'|| par_realm || '.'||par_carrier || '.net';
  ELSIF par_carrier LIKE 'vzw%' THEN 
    var_username := par_mdn || '@'|| par_realm || '.com';

  ELSIF upper(par_carrier) = 'VODAFONE' THEN
    var_username = par_msisdn || '@' || par_realm || '.net' ;  
    RAISE NOTICE 'var_username = %' , var_username ; 
  END IF;
	
  IF NOT EXISTS (SELECT TRUE FROM username WHERE username = var_username) THEN 
    INSERT INTO username
    (username, billing_entity_id, primary_service, enabled, start_date, end_date, date_created, auth_pod)
    VALUES 
    (var_username, 1, 'TRUE', 'TRUE', current_date, '2999-12-31', current_date, 'FALSE');
  ELSE
    RAISE EXCEPTION 'Username already exists in username table';
  END IF;


  --	
  -- Insert the details of radcheck table
  --   
  IF NOT EXISTS (SELECT TRUE FROM radcheck WHERE username = var_username) THEN
    IF par_carrier LIKE 'sprint%' THEN 
      INSERT INTO radcheck
      (username, attribute, op, value)
      VALUES 
      (var_username, 'ClearText-Password', ':=', '');
    ELSIF par_carrier LIKE 'vzw%' THEN 
      INSERT INTO radcheck
      (username, attribute, op, value)
      VALUES 
      (var_username, 'Auth-Type', ':=', 'Accept');  
    ELSIF upper(par_carrier) = 'VODAFONE' THEN
      INSERT INTO radcheck
      (username, attribute, op, value)
      VALUES 
      (var_username, 'Auth-Type', ':=', 'Accept'); 
    END IF;

  ELSE
    RAISE EXCEPTION 'Username already exists in radcheck table';
  END IF;


  --  
  -- Insert the details of usergroup table	
  --
  IF par_carrier LIKE 'sprint%' THEN 
    var_groupname := 'SERVICE-inventory';
  ELSIF par_carrier LIKE 'vzw%' THEN 
    var_groupname := 'SERVICE-vzw_inventory';
  ELSIF upper(par_carrier) = 'VODAFONE' THEN
    var_groupname := 'SERVICE-vodafone_inventory';
  END IF;

  IF NOT EXISTS (SELECT TRUE FROM usergroup WHERE username = var_username) THEN 
    INSERT INTO usergroup
    (username, groupname, priority)
    VALUES 
    (var_username, var_groupname, 50000);
   ELSE
     RAISE EXCEPTION 'Username already exists in usergroup table';
   END IF;


  var_return.result_code := true;
  var_return.error_message := 'Device is activated.' ;
  RETURN NEXT var_return ;
  RETURN ;

END;
$_$;


ALTER FUNCTION csctoss.ops_api_activate_w_vodafone(text, text, text, text, text, text, integer, text, text, text, text, text, text) OWNER TO csctoss_owner;

--
-- Name: ops_api_activate_w_vodafone_temp_caller(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_activate_w_vodafone_temp_caller() RETURNS SETOF ops_api_activate_retval
    LANGUAGE plpgsql
    AS $$
DECLARE

   var_row 		RECORD;
   var_return           ops_api_activate_retval%ROWTYPE;
   var_result		text;
   var_result2		text;
   
BEGIN
  set client_min_messages to NOTICE;

  FOR var_row IN SELECT * FROM dba_voda_equipment

  LOOP

  --RAISE NOTICE 'sn = %, iccid = %, imei = %, mac = %, imsisim = %, msisdn = %' , var_row.sn , var_row.iccid, var_row.imei , var_row.mac , var_row.imsisim , var_row.pri_msisdn ;

    
  SELECT * INTO var_result,var_result2 FROM ops_api_activate_w_vodafone(null, null, null, null, var_row.sn, var_row.mac, 171, 'm2m01.contournet', 'VODAFONE', var_row.iccid, var_row.imei, var_row.imsisim, var_row.pri_msisdn) ;

  --SELECT * FROM ops_api_activate_w_vodafone(null, null, null, null, '773036', '008044106BFC', 171, 'm2m01.contournet', 'VODAFONE' ,'89314404000148026553','354283049110921','204043256289109','882393256289109')


  var_return.result_code = var_result ;
  var_return.error_message = var_result2 ;
    
  RAISE NOTICE 'var_result = %' , var_result ;  
  RAISE NOTICE 'var_result2 = %' , var_result2 ;  

  RETURN NEXT var_return ;
    
  END LOOP;  

  RETURN ;

  --var_return.result_code := true;
  --var_return.error_message := 'Devices activated.' ;
  --RETURN NEXT var_return ;
  --RETURN ;
  
END ;

$$;


ALTER FUNCTION csctoss.ops_api_activate_w_vodafone_temp_caller() OWNER TO csctoss_owner;

--
-- Name: ops_api_assign(text, text, integer, text, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_assign(text, text, integer, text, boolean) RETURNS SETOF ops_api_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
    var_return_row                     ops_api_retval%ROWTYPE;
BEGIN
    select * INTO var_return_row from ops_api_assign($1, $2, $3, $4, $5, null, FALSE);
    RETURN NEXT var_return_row;
    RETURN;

END;  
$_$;


ALTER FUNCTION csctoss.ops_api_assign(text, text, integer, text, boolean) OWNER TO csctoss_owner;

--
-- Name: ops_api_assign(text, text, integer, text, boolean, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_assign(text, text, integer, text, boolean, boolean) RETURNS SETOF ops_api_assign_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
    par_esn_hex                        text := $1;
    par_sales_order                    text := $2;
    par_billing_entity_id              integer := $3;
    par_groupname                      text := $4;
    par_static_ip_boolean              boolean := $5;
    par_bypass_jbilling                boolean := $6;
    var_equipment_id                   integer;
    var_line_id                        integer;
    var_mdn                            text;
    var_mdn_min                        text;
    var_username                       text;
    var_billing_entity_address_id      integer;
    var_static_ip                      text;
    var_conn_string                    text;
    var_serial_number                  text;
    var_line_start_date                date;
    var_line_equip_start_date          date;
    var_model_id                       integer;
    var_carrier                        text;
    var_sql                            text;
    var_return_row                     ops_api_assign_retval%ROWTYPE;
    v_return_2                         boolean;
    v_jbilling_item_code               text; 
    var_sql_2                          text;
    v_product_id                       integer;
    v_plan_type_id                     integer;
    v_length_days                      integer;
    v_line_ctr                         integer;
    v_numrows                          integer;
    v_count                            integer;
    v_priority                         integer;

BEGIN
    SET client_min_messages TO notice;
    PERFORM public.set_change_log_staff_id (3);

    -- Check if the parameters are null
    IF par_esn_hex = ''
    OR par_sales_order = ''
    OR par_billing_entity_id IS NULL
    OR par_groupname = ''
    OR par_static_ip_boolean IS NULL
    THEN
        RAISE EXCEPTION 'All or some of the input values are null';
        var_return_row.result_code := false;
        var_return_row.error_message := 'ERROR:  All or some of the input values are null';
        RETURN NEXT var_return_row;
        RETURN;
    END IF;

    -- Validate Parameters
    SELECT equipment_id INTO var_equipment_id
      FROM unique_identifier
     WHERE unique_identifier_type = 'ESN HEX'
       AND value = par_esn_hex;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'The ESN HEX value entered doesnt exist';
        var_return_row.result_code := false;
        var_return_row.error_message := 'ERROR:  The ESN HEX value entered doesnt exist';
        RETURN NEXT var_return_row;
        RETURN;
    END IF;

    SELECT equipment_model_id INTO var_model_id
      FROM equipment
     WHERE equipment_id = var_equipment_id;

    IF NOT FOUND THEN
         RAISE EXCEPTION 'Equipment model doesnt exist.';
            var_return_row.result_code := false;
            var_return_row.error_message := 'ERROR:  Equipment model doesnt exist.';
            RETURN NEXT var_return_row;
            RETURN;
    END IF;

    -- Get carrier name from equipment model table
    SELECT em.carrier INTO var_carrier
      FROM unique_identifier ui
      JOIN equipment e ON ui.equipment_id = e.equipment_id
      JOIN equipment_model em ON em.equipment_model_id = e.equipment_model_id
     WHERE ui.value = par_esn_hex
     LIMIT 1;

    RAISE NOTICE 'Sales Order: %',par_sales_order;
    RAISE NOTICE 'ESN: %',par_esn_hex;
    RAISE NOTICE 'CARRIER: %',var_carrier;

    -- Retrieve a part of username depending upon carrier and MDN/MIN value.
    IF (var_carrier = 'USCC')  THEN
        SELECT value INTO var_mdn_min
          FROM unique_identifier
         WHERE unique_identifier_type = 'MIN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);
    ELSE
        SELECT value INTO var_mdn_min
          FROM unique_identifier
         WHERE unique_identifier_type = 'MDN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);
    END IF;

    RAISE NOTICE 'MDN/MIN: %',var_mdn_min;

    -- Retrieve username value using MDN or MIN value
    SELECT username INTO var_username
    FROM username
    WHERE SUBSTR(username, 1, 10) = var_mdn_min;
    RAISE NOTICE 'USERNAME: % USERGROUP: %',var_username,par_groupname;

    IF NOT FOUND THEN
        SELECT username INTO var_username
        FROM username
        WHERE 1 = 1
        AND substr(username, 1, 15) = var_mdn_min ;

        IF NOT FOUND THEN          
            RAISE EXCEPTION 'Username does not exist';
            var_return_row.result_code := false;
            var_return_row.error_message := 'ERROR:  Username does not exist!';
            RETURN NEXT var_return_row;
            RETURN;
        END IF;
    END IF;

    -- Retrieve Serial Number value from unique_identifier
    SELECT value INTO var_serial_number
    FROM unique_identifier
    WHERE unique_identifier_type = 'SERIAL NUMBER'
    AND equipment_id = var_equipment_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Serial Number value does not exist for the Equipment.';
        var_return_row.result_code := false;
        var_return_row.error_message := 'ERROR:  Serial Number value does not exist for the Equipment.';
        RETURN NEXT var_return_row;
        RETURN;
    END IF;

    -- Billing_entity_address_id retrieval
    SELECT address_id INTO var_billing_entity_address_id
    FROM billing_entity_address
    WHERE billing_entity_id = par_billing_entity_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Billing Entity Address does not exist';
        var_return_row.result_code := false;
        var_return_row.error_message := 'ERROR:  Billing Entity Address does not exist';
        RETURN NEXT var_return_row;
        RETURN;
    ELSE
        var_line_id := nextval('csctoss.line_line_id_seq');
        IF EXISTS (SELECT TRUE
                   FROM line l
                   JOIN line_equipment le USING (line_id) 
                   JOIN unique_identifier ui USING (equipment_id)
                   WHERE ui.unique_identifier_type = 'ESN HEX' 
                   AND ui.value = par_esn_hex AND le.end_date IS NULL) 
        THEN
            RAISE EXCEPTION 'Active Line already exists for the input parameters';
            var_return_row.result_code := false;
            var_return_row.error_message := 'ERROR:  Active Line already exists for the input parameters';
            RETURN NEXT var_return_row;
            RETURN;
        ELSE
            -- Insert required fields values into line table
            INSERT INTO line (
                line_id, line_assignment_type, billing_entity_id, 
                billing_entity_address_id, active_flag, line_label, 
                start_date, date_created, radius_username, notes)
            VALUES (
                var_line_id, 'CUSTOMER ASSIGNED', par_billing_entity_id, 
                var_billing_entity_address_id, TRUE, par_esn_hex, 
                current_date, current_date, var_username, par_sales_order);

            IF NOT FOUND THEN
                RAISE EXCEPTION 'Line Insert Failed!';
                var_return_row.result_code := false;
                var_return_row.error_message := 'ERROR:  Line Insert Failed!';
                RETURN NEXT var_return_row;
                RETURN;
            END IF;

            SELECT start_date INTO var_line_start_date
            FROM line WHERE line_id = var_line_id;

            -- Update username table with SO_ORDER and Billing_Entity_ID
            UPDATE username
                SET notes = par_sales_order,
                    billing_entity_id = par_billing_entity_id
            WHERE username = var_username;

            IF NOT FOUND THEN
                RAISE EXCEPTION 'Username Update Failed!';
                var_return_row.result_code := false;
                var_return_row.error_message := 'ERROR:  Username Update Failed!';
                RETURN NEXT var_return_row;
                RETURN;
            END IF;
        END IF;
    END IF;

    -- If no active line exists for the equipment then Insert line, equipment details.
    IF NOT EXISTS (SELECT TRUE FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date IS NULL) THEN

        -- [BEGIN] NEW CODE TO CHECK IF OWNERSHIP TRANSFER - IF SO, THEN BACK DATE END DATE
        IF EXISTS (SELECT TRUE FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date = current_date ) THEN
            UPDATE line_equipment
            SET 
            end_date = current_date - 1
            WHERE equipment_id = var_equipment_id
            AND   end_date = current_date ;     
        END IF;
        -- [END] NEW CODE TO CHECK IF OWNERSHIP TRANSFER - IF SO, THEN BACK DATE END DATE
           
        INSERT INTO line_equipment
            (line_id, equipment_id, start_date, billing_entity_address_id)
        VALUES 
            (var_line_id, var_equipment_id, current_date, var_billing_entity_address_id);

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Line_Equipment Insert Failed!';
            var_return_row.result_code := false;
            var_return_row.error_message := 'ERROR:  Line_Equipment Insert Failed!';
            RETURN NEXT var_return_row;
            RETURN;
        END IF;

        -- no idea why this is here
        SELECT start_date INTO var_line_equip_start_date
        FROM line_equipment
        WHERE line_id = var_line_id
        AND equipment_id = var_equipment_id;

    ELSE
        RAISE EXCEPTION 'Equipment is already assigned to a line.';
        var_return_row.result_code := false;
        var_return_row.error_message := 'ERROR:  Equipment is already assigned to a line.';
        RETURN NEXT var_return_row;
        RETURN;
    END IF;

    -- Update usergroup table with input groupname.
    SELECT priority INTO v_priority
      FROM groupname 
     WHERE 1 = 1
       AND groupname = par_groupname;

    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    IF v_numrows = 0 THEN
        RAISE EXCEPTION 'Usergroup not found in GROUPNAME table.';
        var_return_row.result_code := false;
        var_return_row.error_message := 'ERROR:  Usergroup not found in GROUPNAME table.';
        RETURN NEXT var_return_row;
        RETURN;
    END IF;

    DELETE FROM usergroup WHERE username LIKE var_username;

    INSERT INTO usergroup 
        (username,groupname,priority) 
    VALUES
        (var_username,par_groupname,v_priority) ;

    -- removed to fix duplicate issue- UPDATE usergroup SET groupname = par_groupname WHERE username LIKE var_username;

    -- SELECT carrier from equipment model table

    SELECT em.carrier INTO var_carrier
    FROM unique_identifier ui
    JOIN equipment e ON (ui.equipment_id = e.equipment_id)
    JOIN equipment_model em ON (em.equipment_model_id = e.equipment_model_id)
    WHERE 1 = 1
    AND ui.value = par_esn_hex
    LIMIT 1;

    -- Assign static ip to radreply table.
    IF par_static_ip_boolean = FALSE THEN
        INSERT INTO radreply (username, attribute, op, value, priority)
        VALUES (var_username, 'Class', '=', var_line_id::text, 10);

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Radreply Update Failed!';
            var_return_row.result_code := false;
            var_return_row.error_message := 'ERROR:  Radreply Update Failed!';
            RETURN NEXT var_return_row;
            RETURN;
        END IF;

        RAISE NOTICE 'DYNAMIC IP- STATIC IP NOT ASSIGNED';
    ELSE
        SELECT * 
          INTO var_static_ip 
          FROM ops_api_static_ip_assign(var_carrier,par_groupname,var_username,var_line_id,par_billing_entity_id);

        -- Check if ops_api_static_ip_assign failed!        
        IF substring(var_static_ip from 1 for 3) = 'ERR'
        THEN
            RAISE EXCEPTION '%', var_static_ip;
            var_return_row.result_code := false;
            var_return_row.error_message := var_static_ip;
            RETURN NEXT var_return_row;
            RETURN;
        ELSE
            RAISE NOTICE 'STATIC IP: %', var_static_ip;
        END IF;

    END IF;

    -- Get product code from JBilling.
    var_sql_2 := '
    SELECT i.internal_number
    FROM purchase_order po,
    order_line ol,
    item i,
    item_type_map itm
    WHERE 1=1
    AND po.public_number = ''' || par_sales_order || '''
    AND po.id = ol.order_id
    AND ol.item_id = i.id
    AND i.id = itm.item_id
    AND itm.type_id = 301
    AND internal_number LIKE ''MRC%''
    LIMIT 1';

    IF (par_bypass_jbilling = FALSE) THEN
        RAISE NOTICE 'Calling Jbilling to get Product Name (internal number) from item table.';

        SELECT prod_code into v_jbilling_item_code FROM public.dblink(fetch_jbilling_conn(), var_sql_2)
            AS rec_type (prod_code  text);
        v_count := length(v_jbilling_item_code);
        RAISE NOTICE 'MRC Product Code from Jbilling: % length: %', v_jbilling_item_code, v_count;

        SELECT product_id, plan_type_id, length_days INTO v_product_id, v_plan_type_id, v_length_days
        FROM csctoss.product
        WHERE 1 = 1
        AND product_code LIKE v_jbilling_item_code;

        GET DIAGNOSTICS v_numrows = ROW_COUNT;
        IF v_numrows = 0 THEN
            RAISE EXCEPTION 'ERROR: Product code not present in Product table';
            var_return_row.result_code := false;
            var_return_row.error_message := 'ERROR:  Product code not present in Product table';
            RETURN NEXT var_return_row;
            RETURN;
        ELSE
            RAISE NOTICE 'Product Info: prod_id: %  plan_type: % length_days: %',v_product_id,v_plan_type_id,v_length_days;
        END IF;

        -- Insert csctoss.plan record.
        RAISE NOTICE 'Inserting Product Info into plan table';

        INSERT INTO plan
        (
        length_days, plan_type_id, comment , create_timestamp, product_id, 
        staff_id, line_id , start_date, end_date , prepaid_unit, 
        prepaid_allowance, prepaid_balance, accounting_start_date , sales_order_number
        )
        VALUES
        (
        v_length_days, v_plan_type_id , par_sales_order, current_timestamp, v_product_id, 
        3, var_line_id , current_date, null,  null,
        null, null,   current_date,   null  
        );

        GET DIAGNOSTICS v_numrows = ROW_COUNT;
        IF v_numrows = 0 THEN
            RAISE EXCEPTION 'Error: No rows inserted into plan table.';
            var_return_row.result_code := false;
            var_return_row.error_message := 'ERROR:  No rows inserted into plan table.';
            RETURN NEXT var_return_row;
            RETURN;
        END IF;
    END IF;

    -- Insert csctoss.equipment_warranty record.
    RAISE NOTICE 'Inserting Warranty Info into equipment_warranty table';

    INSERT INTO equipment_warranty
    SELECT
    var_equipment_id,
    var_line_start_date,
    var_line_start_date + (ewr.num_of_months::text || ' month')::interval
    FROM equipment_warranty_rule ewr
    WHERE ewr.equipment_model_id = var_model_id
    AND NOT EXISTS (SELECT * FROM equipment_warranty ew WHERE ew.equipment_id = var_equipment_id);

    IF (par_bypass_jbilling = FALSE) THEN
        -- Connect to jbilling and query the function ops_api_prov_line, for provisioning line.
        var_sql := 'SELECT * FROM oss.assign_device_jbilling( ' || quote_literal(upper(par_sales_order))
                || ' , ' || quote_literal(par_esn_hex) || ' , ' || quote_literal(var_serial_number)||' , '
                || quote_literal(var_username) || ' ,' || var_line_id || ')';

        RAISE NOTICE 'Calling oss.assign_device_jbilling in Jbilling';
        RAISE NOTICE '###  var_sql: %',var_sql;

        SELECT result_code into v_return_2  FROM public.dblink(fetch_jbilling_conn(), var_sql)
            AS rec_type (result_code boolean);

        IF (v_return_2 = FALSE) THEN
            RAISE EXCEPTION 'Jbilling Provisioning Failed.';
            var_return_row.result_code := false;
            var_return_row.error_message := 'ERROR:  Jbilling Provisioning Failed.';
            RETURN NEXT var_return_row;
            RETURN;
        ELSE
            RAISE NOTICE 'Jbilling Provisioning Successful.';
        END IF;
    END IF;

    var_return_row.result_code := true;
    var_return_row.error_message := 'Line assignment is done succesfully.';
    RETURN NEXT var_return_row;
    RETURN;

 END;
  $_$;


ALTER FUNCTION csctoss.ops_api_assign(text, text, integer, text, boolean, boolean) OWNER TO csctoss_owner;

--
-- Name: ops_api_assign(text, text, integer, text, boolean, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_assign(text, text, integer, text, boolean, text) RETURNS SETOF ops_api_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
    var_return_row                     ops_api_retval%ROWTYPE;
BEGIN
    select * INTO var_return_row from ops_api_assign($1, $2, $3, $4, $5, $6, FALSE);
    RETURN NEXT var_return_row;
    RETURN;

END;  
$_$;


ALTER FUNCTION csctoss.ops_api_assign(text, text, integer, text, boolean, text) OWNER TO csctoss_owner;

--
-- Name: ops_api_assign(text, text, integer, text, boolean, text, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_assign(text, text, integer, text, boolean, text, boolean) RETURNS SETOF ops_api_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
    par_esn_hex                        text := $1;
    par_sales_order                    text := $2;
    par_billing_entity_id              integer := $3;
    par_groupname                      text := $4;
    par_static_ip_boolean              boolean := $5;
    par_product_code                   text := $6;
    par_bypass_jbilling                boolean := $7;
    var_equipment_id                   integer;
    var_line_id                        integer;
    var_mdn                            text;
    var_mdn_min                        text;
    var_username                       text;
    var_billing_entity_address_id      integer;
    var_static_ip                      text;
    var_conn_string                    text;
    var_serial_number                  text;
    var_line_start_date                date;
    var_line_equip_start_date          date;
    var_model_id                       integer;
    var_carrier                        text;
    var_sql                            text;
    var_return_row                     ops_api_retval%ROWTYPE;
    v_return_2                         boolean;
    v_jbilling_item_code               text; 
    var_sql_2                          text;
    v_product_id                       integer;
    v_plan_type_id                     integer;
    v_length_days                      integer;
    v_line_ctr                         integer;
    v_numrows                          integer;
    v_count                            integer;
    v_priority                         integer;

    v_errmsg                           text;

BEGIN
    SET client_min_messages TO notice;
    PERFORM public.set_change_log_staff_id (3);

    -- Check if the parameters are null
    v_errmsg:='All or some of the input values are null.';
    IF par_esn_hex = ''
    OR par_sales_order = ''
    OR par_billing_entity_id IS NULL
    OR par_groupname = ''
    OR par_static_ip_boolean IS NULL
    OR par_product_code is NULL
    THEN
        RAISE NOTICE 'EXCEPTION:  All or some of the input values are null';
        RAISE EXCEPTION '';
    END IF;

    -- Validate Parameters
    v_errmsg:='ERROR:  The ESN HEX value entered does not exist:  ' || par_esn_hex;
    SELECT equipment_id INTO var_equipment_id
      FROM unique_identifier
     WHERE unique_identifier_type = 'ESN HEX'
       AND value = par_esn_hex;

    IF NOT FOUND THEN
        RAISE NOTICE 'The ESN HEX value entered does not exist';
        RAISE EXCEPTION '';
    END IF;

    v_errmsg:='ERROR:  Equipment model does not exist:  ' || var_model_id;
    SELECT equipment_model_id INTO var_model_id
      FROM equipment
     WHERE equipment_id = var_equipment_id;

    IF NOT FOUND THEN
        RAISE NOTICE 'Equipment model does not exist.';
        RAISE EXCEPTION '';
    END IF;

    -- Get carrier name from equipment model table
    SELECT em.carrier INTO var_carrier
      FROM unique_identifier ui
      JOIN equipment e ON ui.equipment_id = e.equipment_id
      JOIN equipment_model em ON em.equipment_model_id = e.equipment_model_id
     WHERE ui.value = par_esn_hex
     LIMIT 1;

    RAISE NOTICE 'Sales Order: %',par_sales_order;
    RAISE NOTICE 'ESN: %',par_esn_hex;
    RAISE NOTICE 'CARRIER: %',var_carrier;

    -- Retrieve a part of username depending upon carrier and MDN/MIN value.
    IF (var_carrier = 'USCC')  THEN
        SELECT value INTO var_mdn_min
          FROM unique_identifier
         WHERE unique_identifier_type = 'MIN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);
    ELSE
        SELECT value INTO var_mdn_min
          FROM unique_identifier
         WHERE unique_identifier_type = 'MDN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);
    END IF;

    RAISE NOTICE 'MDN/MIN: %',var_mdn_min;

    -- Retrieve username value using MDN or MIN value
    v_errmsg:='ERROR:  Username does not exist:  ' || var_username;
    SELECT username INTO var_username
    FROM username
    WHERE SUBSTR(username, 1, 10) = var_mdn_min;

    IF NOT FOUND THEN
        SELECT username INTO var_username
        FROM username
        WHERE 1 = 1
        AND substr(username, 1, 15) = var_mdn_min ;

        IF NOT FOUND THEN          
            RAISE NOTICE 'Username does not exist!';
            RAISE EXCEPTION '';
        END IF;
    END IF;
    RAISE NOTICE 'USERNAME: % USERGROUP: %',var_username,par_groupname;

    -- Retrieve Serial Number value from unique_identifier
    v_errmsg:='ERROR:  Serial Number value does not exist for the Equipment:  ' || var_serial_number;
    SELECT value INTO var_serial_number
    FROM unique_identifier
    WHERE unique_identifier_type = 'SERIAL NUMBER'
    AND equipment_id = var_equipment_id;

    IF NOT FOUND THEN
        RAISE NOTICE 'Serial Number value does not exist for the Equipment.';
        RAISE EXCEPTION '';
    END IF;

    -- Billing_entity_address_id retrieval
    v_errmsg:='ERROR:  Billing Entity Address does not exist:  ' || par_billing_entity_id;
    SELECT address_id INTO var_billing_entity_address_id
    FROM billing_entity_address
    WHERE billing_entity_id = par_billing_entity_id;

    IF NOT FOUND THEN
        RAISE NOTICE 'Billing Entity Address does not exist';
        RAISE EXCEPTION '';
    ELSE
        v_errmsg:='ERROR:  Active Line already exists for ESN Hex provided:  ' || par_esn_hex;
        var_line_id := nextval('csctoss.line_line_id_seq');
        IF EXISTS (SELECT TRUE
                   FROM line l
                   JOIN line_equipment le USING (line_id) 
                   JOIN unique_identifier ui USING (equipment_id)
                   WHERE ui.unique_identifier_type = 'ESN HEX' 
                   AND ui.value = par_esn_hex AND le.end_date IS NULL) 
        THEN
            RAISE NOTICE 'Active Line already exists for the ESN Hex provided';
            RAISE EXCEPTION '';
        ELSE
            -- Insert required fields values into line table
            INSERT INTO line (
                line_id, line_assignment_type, billing_entity_id, 
                billing_entity_address_id, active_flag, line_label, 
                start_date, date_created, radius_username, notes)
            VALUES (
                var_line_id, 'CUSTOMER ASSIGNED', par_billing_entity_id, 
                var_billing_entity_address_id, TRUE, par_esn_hex, 
                current_date, current_date, var_username, par_sales_order);

            v_errmsg:='ERROR:  Line Insert Failed!';
            IF NOT FOUND THEN
                RAISE NOTICE 'Line Insert Failed!';
                RAISE EXCEPTION '';
            END IF;

            SELECT start_date INTO var_line_start_date
            FROM line WHERE line_id = var_line_id;

            -- Update username table with SO_ORDER and Billing_Entity_ID
            v_errmsg:='ERROR:  Username Update Failed:  ' || var_username;
            UPDATE username
                SET notes = par_sales_order,
                    billing_entity_id = par_billing_entity_id
            WHERE username = var_username;

            IF NOT FOUND THEN
                RAISE NOTICE 'Username Update Failed!';
                RAISE EXCEPTION '';
            END IF;
        END IF;
    END IF;

    -- If no active line exists for the equipment then Insert line, equipment details.
    v_errmsg:='ERROR:  Equipment is already assigned to a line:  ' || var_equipment_id;
    IF NOT EXISTS (SELECT TRUE FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date IS NULL) THEN

        -- [BEGIN] NEW CODE TO CHECK IF OWNERSHIP TRANSFER - IF SO, THEN BACK DATE END DATE
        IF EXISTS (SELECT TRUE FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date = current_date ) THEN
            UPDATE line_equipment
            SET    end_date = current_date - 1
            WHERE  equipment_id = var_equipment_id
            AND    end_date = current_date ;
        END IF;
        -- [END] NEW CODE TO CHECK IF OWNERSHIP TRANSFER - IF SO, THEN BACK DATE END DATE
        v_errmsg:='ERROR:  Line_Equipment Insert Failed!';   
        INSERT INTO line_equipment
            (line_id, equipment_id, start_date, billing_entity_address_id)
        VALUES 
            (var_line_id, var_equipment_id, current_date, var_billing_entity_address_id);

        IF NOT FOUND THEN
            RAISE NOTICE 'Line_Equipment Insert Failed!';
            RAISE EXCEPTION '';
        END IF;

        -- no idea why this is here
        SELECT start_date INTO var_line_equip_start_date
        FROM line_equipment
        WHERE line_id = var_line_id
        AND equipment_id = var_equipment_id;

    ELSE
        RAISE NOTICE 'Equipment is already assigned to a line.';
        RAISE EXCEPTION '';
    END IF;

    -- Update usergroup table with input groupname.
    SELECT priority INTO v_priority
        FROM groupname 
     WHERE 1 = 1
        AND groupname = par_groupname;

    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    v_errmsg:='ERROR:  Usergroup not found in GROUPNAME table:  ' || par_groupname;
    IF v_numrows = 0 THEN
        RAISE NOTICE 'Usergroup not found in GROUPNAME table:  %', par_groupname;
        RAISE EXCEPTION '';
    END IF;

    DELETE FROM usergroup WHERE username LIKE var_username;

    INSERT INTO usergroup 
        (username,groupname,priority) 
    VALUES
        (var_username,par_groupname,v_priority) ;

    -- removed to fix duplicate issue- UPDATE usergroup SET groupname = par_groupname WHERE username LIKE var_username;

    -- SELECT carrier from equipment model table

    SELECT em.carrier INTO var_carrier
    FROM unique_identifier ui
    JOIN equipment e ON (ui.equipment_id = e.equipment_id)
    JOIN equipment_model em ON (em.equipment_model_id = e.equipment_model_id)
    WHERE 1 = 1
    AND ui.value = par_esn_hex
    LIMIT 1;

    -- Assign static ip to radreply table.
    
    IF par_static_ip_boolean = FALSE THEN
        v_errmsg:='ERROR:  Radreply Update Failed:  ' || var_username || ', ' || var_line_id;
        INSERT INTO radreply (username, attribute, op, value, priority)
        VALUES (var_username, 'Class', '=', var_line_id::text, 10);

        IF NOT FOUND THEN
            RAISE NOTICE 'Radreply Update Failed!';
            RAISE EXCEPTION '';
        END IF;

        RAISE NOTICE 'DYNAMIC IP- STATIC IP NOT ASSIGNED';
    ELSE
        SELECT * 
          INTO var_static_ip 
          FROM ops_api_static_ip_assign(var_carrier,par_groupname,var_username,var_line_id,par_billing_entity_id);

        -- Check if ops_api_static_ip_assign failed!        
         
        IF substring(var_static_ip from 1 for 3) = 'ERR'
        THEN
            v_errmsg:=var_static_ip;
            RAISE NOTICE 'Error from ops_api_static_ip_assign!';
            RAISE EXCEPTION '';
        ELSE
            RAISE NOTICE 'STATIC IP: %', var_static_ip;
        END IF;

    END IF;

    SELECT product_id, plan_type_id, length_days INTO v_product_id, v_plan_type_id, v_length_days
    FROM csctoss.product
    WHERE 1 = 1
    AND product_code = par_product_code;
    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    v_errmsg:='ERROR: Invalid Product code:  ' || par_product_code;
    IF v_numrows = 0 THEN
        RAISE NOTICE 'Invalid Product code';
        RAISE EXCEPTION '';
    ELSE
        INSERT INTO plan
        (
        length_days, plan_type_id, comment , create_timestamp, product_id, 
        staff_id, line_id , start_date, end_date , prepaid_unit, 
        prepaid_allowance, prepaid_balance, accounting_start_date , sales_order_number
        )
        VALUES
        (
        v_length_days, v_plan_type_id , par_sales_order, current_timestamp, v_product_id, 
        3, var_line_id , current_date, null,  null,
        null, null,   current_date,   null  
        );

        GET DIAGNOSTICS v_numrows = ROW_COUNT;
        v_errmsg:='Error: No rows inserted into plan table.';
        IF v_numrows = 0 THEN
            RAISE NOTICE 'No rows inserted into plan table.';
            RAISE EXCEPTION '';
        END IF;
    END IF;

--    IF (par_bypass_jbilling = FALSE) THEN
--            -- Get product code from JBilling.
--        var_sql_2 := '
--        SELECT i.internal_number
--        FROM purchase_order po,
--        order_line ol,
--        item i,
--        item_type_map itm
--        WHERE 1=1
--        AND po.public_number = ''' || par_sales_order || '''
--        AND po.id = ol.order_id
--        AND ol.item_id = i.id
--        AND i.id = itm.item_id
--        AND itm.type_id = 301
--        AND internal_number LIKE ''MRC%''
--        LIMIT 1';
--
--        RAISE NOTICE 'Calling Jbilling to get Product Name (internal number) from item table.';
--
--        SELECT prod_code into v_jbilling_item_code FROM public.dblink(fetch_jbilling_conn(), var_sql_2)
--            AS rec_type (prod_code  text);
--        v_count := length(v_jbilling_item_code);
--        RAISE NOTICE 'MRC Product Code from Jbilling: % length: %', v_jbilling_item_code, v_count;
--
--        SELECT product_id, plan_type_id, length_days INTO v_product_id, v_plan_type_id, v_length_days
--        FROM csctoss.product
--        WHERE 1 = 1
--        AND product_code LIKE v_jbilling_item_code;
--
--        GET DIAGNOSTICS v_numrows = ROW_COUNT;
--        v_errmsg:='ERROR: Product code not present in Product table.';
--        IF v_numrows = 0 THEN
--            RAISE NOTICE 'Product code not present in Product table.';
--            RAISE EXCEPTION '';
--        ELSE
--            RAISE NOTICE 'Product Info: prod_id: %  plan_type: % length_days: %',v_product_id,v_plan_type_id,v_length_days;
--        END IF;
--
--        -- Insert csctoss.plan record.
--        RAISE NOTICE 'Inserting Product Info into plan table';
--
--        INSERT INTO plan
--        (
--        length_days, plan_type_id, comment , create_timestamp, product_id, 
--        staff_id, line_id , start_date, end_date , prepaid_unit, 
--        prepaid_allowance, prepaid_balance, accounting_start_date , sales_order_number
--        )
--        VALUES
--        (
--        v_length_days, v_plan_type_id , par_sales_order, current_timestamp, v_product_id, 
--        3, var_line_id , current_date, null,  null,
--        null, null,   current_date,   null  
--        );
--
--        GET DIAGNOSTICS v_numrows = ROW_COUNT;
--        v_errmsg:='Error: No rows inserted into plan table.';
--        IF v_numrows = 0 THEN
--            RAISE NOTICE 'No rows inserted into plan table.';
--            RAISE EXCEPTION '';
--        END IF;
--    END IF;

    -- Insert csctoss.equipment_warranty record.
    RAISE NOTICE 'Inserting Warranty Info into equipment_warranty table';

    INSERT INTO equipment_warranty
    SELECT
    var_equipment_id,
    var_line_start_date,
    var_line_start_date + (ewr.num_of_months::text || ' month')::interval
    FROM equipment_warranty_rule ewr
    WHERE ewr.equipment_model_id = var_model_id
    AND NOT EXISTS (SELECT * FROM equipment_warranty ew WHERE ew.equipment_id = var_equipment_id);

--    IF (par_bypass_jbilling = FALSE) THEN
--        -- Connect to jbilling and query the function ops_api_prov_line, for provisioning line.
--        var_sql := 'SELECT * FROM oss.assign_device_jbilling( ' || quote_literal(upper(par_sales_order))
--                || ' , ' || quote_literal(par_esn_hex) || ' , ' || quote_literal(var_serial_number)||' , '
--                || quote_literal(var_username) || ' ,' || var_line_id || ')';
--
--        RAISE NOTICE 'Calling oss.assign_device_jbilling in Jbilling';
--        RAISE NOTICE '###  var_sql: %',var_sql;
--
--        SELECT result_code into v_return_2  FROM public.dblink(fetch_jbilling_conn(), var_sql)
--            AS rec_type (result_code boolean);
--
--        v_errmsg:='ERROR:  Jbilling Provisioning Failed.';
--        IF (v_return_2 = FALSE) THEN
--            RAISE NOTICE 'Jbilling Provisioning Failed.';
--            RAISE EXCEPTION '';
--        ELSE
--            RAISE NOTICE 'Jbilling Provisioning Successful.';
--        END IF;
--    END IF;

    var_return_row.result_code := true;
    var_return_row.error_message := 'Line assignment is done succesfully.';
    RETURN NEXT var_return_row;
    RETURN;

EXCEPTION
        WHEN raise_exception THEN
           var_return_row.result_code := false;
           var_return_row.error_message:=v_errmsg;
           RETURN NEXT var_return_row;
           RETURN;

        WHEN others THEN
           var_return_row.result_code := false;
           var_return_row.error_message:=v_errmsg;
           RAISE NOTICE 'OTHER EXCEPTION:  %', v_errmsg;
           RETURN NEXT var_return_row;
           RETURN;
END;
$_$;


ALTER FUNCTION csctoss.ops_api_assign(text, text, integer, text, boolean, text, boolean) OWNER TO csctoss_owner;

--
-- Name: ops_api_assign_20171219(text, text, integer, text, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_assign_20171219(text, text, integer, text, boolean) RETURNS SETOF ops_api_assign_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
   par_esn_hex                        text := $1;
   par_sales_order                    text := $2;
   par_billing_entity_id              integer := $3;
   par_groupname                      text := $4;
   par_static_ip_boolean              boolean := $5;
   var_equipment_id                   integer;
   var_line_id                        integer;
   var_mdn                            text;
   var_mdn_min                        text;
   var_username                       text;
   var_billing_entity_address_id      integer;
   var_static_ip                      text;
   var_conn_string                    text;
   var_serial_number                  text;
   var_line_start_date                date;
   var_line_equip_start_date          date;
   var_model_id                       integer;
   var_carrier                        text;
   var_sql                            text;
   var_return_row                     ops_api_assign_retval%ROWTYPE;
   v_return_2                         boolean;
   v_jbilling_item_code               text; 
   var_sql_2                          text;
   v_product_id                       integer;
   v_plan_type_id                     integer;
   v_length_days                      integer;
   v_line_ctr                         integer;
   v_numrows                          integer;
   v_count                            integer;
   v_priority                         integer;

BEGIN
    PERFORM public.set_change_log_staff_id (3);

    -- Check if the parameters are null
    IF par_esn_hex = ''
        OR par_sales_order = ''
        OR par_billing_entity_id IS NULL
        OR par_groupname = ''
        OR par_static_ip_boolean IS NULL
    THEN
       RAISE EXCEPTION 'All or some of the input values are null';
    END IF;

    -- Validate Parameters
    SELECT equipment_id INTO var_equipment_id
    FROM unique_identifier
    WHERE unique_identifier_type = 'ESN HEX'
    AND value = par_esn_hex;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'The ESN HEX value entered doesnt exist';
    END IF;

    SELECT equipment_model_id INTO var_model_id
    FROM equipment
    WHERE equipment_id = var_equipment_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Equipment model doesnt exist.';
    END IF;

    -- Get carrier name from equipment model table
    SELECT em.carrier INTO var_carrier
    FROM unique_identifier ui
    JOIN equipment e ON ui.equipment_id = e.equipment_id
    JOIN equipment_model em ON em.equipment_model_id = e.equipment_model_id
    WHERE ui.value = par_esn_hex
    LIMIT 1;

    RAISE NOTICE 'Sales Order: %',par_sales_order;
    RAISE NOTICE 'ESN: %',par_esn_hex;
    RAISE NOTICE 'CARRIER: %',var_carrier;

    -- Retrieve a part of username depending upon carrier and MDN/MIN value.
    IF ( var_carrier = 'SPRINT') THEN
        SELECT value INTO var_mdn_min
        FROM unique_identifier
        WHERE unique_identifier_type = 'MDN'
        AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

    ELSIF (var_carrier = 'VZW') THEN
        SELECT value INTO var_mdn_min
        FROM unique_identifier
        WHERE unique_identifier_type = 'MDN'
        AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

    ELSIF (var_carrier = 'USCC')  THEN
        SELECT value INTO var_mdn_min
        FROM unique_identifier
        WHERE unique_identifier_type = 'MIN'
        AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

    ELSIF (var_carrier = 'VODAFONE')  THEN
        SELECT value INTO var_mdn_min
        FROM unique_identifier
        WHERE unique_identifier_type = 'MDN'
        AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

    END IF;

    RAISE NOTICE 'MDN/MIN: %',var_mdn_min;

    -- Retrieve username value using MDN or MIN value
    SELECT username INTO var_username
    FROM username
    WHERE SUBSTR(username, 1, 10) = var_mdn_min;
    RAISE NOTICE 'USERNAME: % USERGROUP: %',var_username,par_groupname;

    IF NOT FOUND THEN
        SELECT username INTO var_username
        FROM username
        WHERE 1 = 1
        AND substr(username, 1, 15) = var_mdn_min ;

        IF NOT FOUND THEN          
            RAISE EXCEPTION 'Username doesnt exist';
        END IF;
    END IF;

    -- Retrieve Serial Number value from unique_identifier
    SELECT value INTO var_serial_number
    FROM unique_identifier
    WHERE unique_identifier_type = 'SERIAL NUMBER'
    AND equipment_id = var_equipment_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Serial Number value doesnt exist for the Equipment.';
    END IF;

    -- Billing_entity_address_id retrieval
    SELECT address_id INTO var_billing_entity_address_id
    FROM billing_entity_address
    WHERE billing_entity_id = par_billing_entity_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Billing Entity Address doesnt exist';
    ELSE
        var_line_id := nextval('csctoss.line_line_id_seq');
        IF EXISTS (SELECT TRUE
                   FROM line l
                   JOIN line_equipment le USING (line_id) 
                   JOIN unique_identifier ui USING (equipment_id)
                   WHERE ui.unique_identifier_type = 'ESN HEX' 
                   AND ui.value = par_esn_hex AND le.end_date IS NULL) 
        THEN
            RAISE EXCEPTION 'Active Line already exists for the input parameters';
        ELSE
            -- Insert required fields values into line table
            INSERT INTO line (
                line_id, line_assignment_type, billing_entity_id, 
                billing_entity_address_id, active_flag, line_label, 
                start_date, date_created, radius_username, notes)
            VALUES (
                var_line_id, 'CUSTOMER ASSIGNED', par_billing_entity_id, 
                var_billing_entity_address_id, TRUE, par_esn_hex, 
                current_date, current_date, var_username, par_sales_order);

            SELECT start_date INTO var_line_start_date
            FROM line WHERE line_id = var_line_id;

            -- Update username table with SO_ORDER and Billing_Entity_ID
            UPDATE username
                SET notes = par_sales_order,
                    billing_entity_id = par_billing_entity_id
            WHERE username = var_username;

            IF NOT FOUND THEN
                RAISE EXCEPTION 'Username Update Failed!';
            END IF;
        END IF;
    END IF;

    -- If no active line exists for the equipment then Insert line, equipment details.
    IF NOT EXISTS (SELECT TRUE FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date IS NULL) THEN

        -- [BEGIN] NEW CODE TO CHECK IF OWNERSHIP TRANSFER - IF SO, THEN BACK DATE END DATE
        IF EXISTS (SELECT TRUE FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date = current_date ) THEN
            UPDATE line_equipment
            SET 
            end_date = current_date - 1
            WHERE equipment_id = var_equipment_id
            AND   end_date = current_date ;     
        END IF;
        -- [END] NEW CODE TO CHECK IF OWNERSHIP TRANSFER - IF SO, THEN BACK DATE END DATE
           
        INSERT INTO line_equipment
            (line_id, equipment_id, start_date, billing_entity_address_id)
        VALUES 
            (var_line_id, var_equipment_id, current_date, var_billing_entity_address_id);

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Line_Equipment Insert Failed!';
        END IF;

        -- no idea why this is here
        SELECT start_date INTO var_line_equip_start_date
        FROM line_equipment
        WHERE line_id = var_line_id
        AND equipment_id = var_equipment_id;

    ELSE
        RAISE EXCEPTION 'Equipment is already assigned to a line.';
    END IF;

    -- Update usergroup table with input groupname.
    SELECT priority INTO v_priority
    FROM groupname 
    WHERE 1 = 1
    AND groupname = par_groupname;

    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    IF v_numrows = 0 THEN
        RAISE EXCEPTION 'Usergroup not found in GROUPNAME table.';
    END IF;
          
    DELETE FROM usergroup WHERE username LIKE var_username;

    INSERT INTO usergroup 
        (username,groupname,priority) 
    VALUES
        (var_username,par_groupname,v_priority) ;

    -- removed to fix duplicate issue- UPDATE usergroup SET groupname = par_groupname WHERE username LIKE var_username;

    -- SELECT carrier from equipment model table

    SELECT em.carrier INTO var_carrier
    FROM unique_identifier ui
    JOIN equipment e ON (ui.equipment_id = e.equipment_id)
    JOIN equipment_model em ON (em.equipment_model_id = e.equipment_model_id)
    WHERE 1 = 1
    AND ui.value = par_esn_hex
    LIMIT 1;

    -- Assign static ip to radreply table.
    IF par_static_ip_boolean = FALSE THEN
        INSERT INTO radreply (username, attribute, op, value, priority)
        VALUES (var_username, 'Class', '=', var_line_id::text, 10);

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Radreply Update Failed!';
        END IF;

        RAISE NOTICE 'DYNAMIC IP- STATIC IP NOT ASSIGNED';
    ELSE
        SELECT * INTO var_static_ip FROM ops_api_static_ip_assign(var_carrier,par_groupname,var_username,var_line_id,par_billing_entity_id);
        RAISE NOTICE 'STATIC IP: %',var_static_ip;
    END IF;
          
    -- Get product code from JBilling.
    var_sql_2 := '
    SELECT i.internal_number
    FROM purchase_order po,
    order_line ol,
    item i,
    item_type_map itm
    WHERE 1=1
    AND po.public_number = ''' || par_sales_order || '''
    AND po.id = ol.order_id
    AND ol.item_id = i.id
    AND i.id = itm.item_id
    AND itm.type_id = 301
    AND internal_number LIKE ''MRC%''
    LIMIT 1';

    RAISE NOTICE 'Calling Jbilling to get Product Name (internal number) from item table.';

    SELECT prod_code into v_jbilling_item_code FROM public.dblink(fetch_jbilling_conn(), var_sql_2)
        AS rec_type (prod_code  text);
    v_count := length(v_jbilling_item_code);
    RAISE NOTICE 'MRC Product Code from Jbilling: % length: %', v_jbilling_item_code, v_count;

    SELECT product_id, plan_type_id, length_days INTO v_product_id, v_plan_type_id, v_length_days
    FROM csctoss.product
    WHERE 1 = 1
    AND product_code LIKE v_jbilling_item_code;

    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    IF v_numrows = 0 THEN
        RAISE EXCEPTION 'ERROR: Product code not present in Product table';
    ELSE
        RAISE NOTICE 'Product Info: prod_id: %  plan_type: % length_days: %',v_product_id,v_plan_type_id,v_length_days;
    END IF;

    -- Insert csctoss.plan record.
    RAISE NOTICE 'Inserting Product Info into plan table';

    INSERT INTO plan
    (
    length_days, plan_type_id, comment , create_timestamp, product_id, 
    staff_id, line_id , start_date, end_date , prepaid_unit, 
    prepaid_allowance, prepaid_balance, accounting_start_date , sales_order_number
    )
    VALUES
    (
    v_length_days, v_plan_type_id , par_sales_order, current_timestamp, v_product_id, 
    3, var_line_id , current_date, null,  null,
    null, null,   current_date,   null  
    );

    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    IF v_numrows = 0 THEN
        RAISE EXCEPTION 'Error: No rows inserted into plan table.';
    END IF;

    -- Insert csctoss.equipment_warranty record.
    RAISE NOTICE 'Inserting Warranty Info into equipment_warranty table';

    INSERT INTO equipment_warranty
    SELECT
    var_equipment_id,
    var_line_start_date,
    var_line_start_date + (ewr.num_of_months::text || ' month')::interval
    FROM equipment_warranty_rule ewr
    WHERE ewr.equipment_model_id = var_model_id
    AND NOT EXISTS (SELECT * FROM equipment_warranty ew WHERE ew.equipment_id = var_equipment_id);

    -- Connect to jbilling and query the function ops_api_prov_line, for provisioning line.
    var_sql := 'SELECT * FROM oss.assign_device_jbilling( ' || quote_literal(upper(par_sales_order))
            || ' , ' || quote_literal(par_esn_hex) || ' , ' || quote_literal(var_serial_number)||' , '
            || quote_literal(var_username) || ' ,' || var_line_id || ')';

    RAISE NOTICE 'Calling oss.assign_device_jbilling in Jbilling';
    RAISE NOTICE '###  var_sql: %',var_sql;

    SELECT result_code into v_return_2  FROM public.dblink(fetch_jbilling_conn(), var_sql)
        AS rec_type (result_code boolean);

    IF (v_return_2 = FALSE) THEN
        RAISE EXCEPTION 'Jbilling Provisioning Failed.';
    ELSE
        RAISE NOTICE 'Jbilling Provisioning Successful.';
    END IF;

    var_return_row.result_code := true;
    var_return_row.error_message := 'Line assignment is done succesfully.';
    RETURN NEXT var_return_row;
    RETURN;

 END;
  $_$;


ALTER FUNCTION csctoss.ops_api_assign_20171219(text, text, integer, text, boolean) OWNER TO csctoss_owner;

--
-- Name: ops_api_assign_backup_20150219(text, text, integer, text, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_assign_backup_20150219(text, text, integer, text, boolean) RETURNS SETOF ops_api_assign_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
   par_esn_hex                        text := $1;
   par_sales_order                    text := $2;
   par_billing_entity_id              integer := $3;
   par_groupname                      text := $4;
   par_static_ip_boolean              boolean := $5;
   var_equipment_id                   integer;
   var_line_id                        integer;
   var_mdn                            text;
   var_mdn_min                        text;
   var_username                       text;
   var_billing_entity_address_id      integer;
   var_static_ip                      text;
   var_conn_string                    text;
   var_serial_number                  text;
   var_line_start_date                date;
   var_line_equip_start_date          date;
   var_model_id                       integer;
   var_carrier                        text;
   var_sql                            text;
   var_return_row                     ops_api_assign_retval%ROWTYPE;
   v_return_2                           boolean;
   v_jbilling_item_code               text;
   var_sql_2                            text;
   v_product_id                         integer;
   v_plan_type_id                       integer;
   v_length_days                        integer;
   v_line_ctr                           integer;
   v_numrows                           integer;
   v_count                             integer;
   v_priority                          integer;


BEGIN

    PERFORM public.set_change_log_staff_id (3);

    -- Check if the parameters are null

    IF par_esn_hex = ''
    OR par_sales_order = ''
    OR par_billing_entity_id IS NULL
    OR par_groupname = ''
    OR par_static_ip_boolean IS NULL THEN

       RAISE EXCEPTION 'All or some of the input values are null';

    ELSE
        -- Validate Parameters
        SELECT equipment_id INTO var_equipment_id
        FROM unique_identifier
        WHERE unique_identifier_type = 'ESN HEX'
        AND value = par_esn_hex;

        IF NOT FOUND THEN

           RAISE EXCEPTION 'The ESN HEX value entered doesnt exist';

        END IF;

        SELECT equipment_model_id INTO var_model_id
        FROM equipment
        WHERE equipment_id = var_equipment_id;

        IF NOT FOUND THEN

            RAISE EXCEPTION 'Equipment model doesnt exist.';

        END IF;
        -- Start new username search based on MDN/MIN
        -- SELECT carrier from equipment model table

        SELECT em.carrier INTO var_carrier
        FROM unique_identifier ui
        JOIN equipment e on ui.equipment_id = e.equipment_id
        JOIN equipment_model em on em.equipment_model_id = e.equipment_model_id
        WHERE ui.value = par_esn_hex
        LIMIT 1;

        RAISE NOTICE 'Sales Order: %',par_sales_order;
        RAISE NOTICE 'ESN: %',par_esn_hex;
        RAISE NOTICE 'CARRIER: %',var_carrier;

        -- Retrieve username value depending upon Carrier and MDN/MIN value.

        IF ( var_carrier = 'SPRINT') THEN

           SELECT value INTO var_mdn_min
           FROM unique_identifier
           WHERE unique_identifier_type = 'MDN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

        ELSIF (var_carrier = 'VZW') THEN

           SELECT value INTO var_mdn_min
           FROM unique_identifier
           WHERE unique_identifier_type = 'MDN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

        ELSIF (var_carrier = 'USCC') THEN

          SELECT value INTO var_mdn_min
           FROM unique_identifier
           WHERE unique_identifier_type = 'MIN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

        END IF;
        RAISE NOTICE 'MDN/MIN: %',var_mdn_min;
        -- Retrieve username value using MDN value

        SELECT username INTO var_username
        FROM username
        WHERE SUBSTR(username,1,10) = var_mdn_min;
        RAISE NOTICE 'USERNAME: % USERGROUP: %',var_username,par_groupname;
        IF NOT FOUND THEN
           RAISE EXCEPTION 'Username doesnt exist';
        END IF;
        --   End new username search

        -- Retrieve Serial Number value from unique_identifier
        SELECT value INTO var_serial_number
        FROM unique_identifier
        WHERE unique_identifier_type = 'SERIAL NUMBER'
        AND equipment_id = var_equipment_id;

        IF NOT FOUND THEN
               RAISE EXCEPTION 'Serial Number value doesnt exist for the Equipment.';
        END IF;

         -- Billing_entity_address_id retrieval
        SELECT address_id INTO var_billing_entity_address_id
        FROM billing_entity_address
        WHERE billing_entity_id = par_billing_entity_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Billing Entity Address doesnt exist';
        ELSE
            var_line_id :=  nextval('csctoss.line_line_id_seq');
            IF EXISTS ( SELECT TRUE  FROM line l JOIN  line_equipment le  USING (line_id)
                        JOIN  unique_identifier ui USING (equipment_id) WHERE ui.unique_identifier_type = 'ESN HEX'
                               AND ui.value = par_esn_hex AND le.end_date IS NULL)
            THEN
                RAISE EXCEPTION 'Active Line already exists for the input parameters';
            ELSE
            -- Insert required fields values into line table

                INSERT INTO line (
                                 line_id, line_assignment_type, billing_entity_id,
                                 billing_entity_address_id, active_flag, line_label,
                                 start_date, date_created, radius_username, notes)
                VALUES           (
                                  var_line_id, 'CUSTOMER ASSIGNED', par_billing_entity_id,
                                  var_billing_entity_address_id, TRUE, par_esn_hex,
                                  current_date, current_date, var_username, par_sales_order
                                  );

                 SELECT start_date INTO var_line_start_date
                 FROM line WHERE line_id = var_line_id;

                   -- Update username table with SO_ORDER and Billing_Entity_ID
                  UPDATE username SET notes = par_sales_order,
                                      billing_entity_id = par_billing_entity_id
                  WHERE username = var_username;
                  IF NOT FOUND THEN
                       RAISE EXCEPTION 'Username Update Failed!';
                  END IF;

            END IF;

         END IF;

         IF NOT EXISTS (SELECT TRUE FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date IS NULL)
         THEN

         -- If no active line exists for the equipment then Insert line, equipment details.

             INSERT INTO line_equipment(line_id, equipment_id, start_date, billing_entity_address_id)
                                 VALUES (var_line_id, var_equipment_id, current_date, var_billing_entity_address_id);
             IF NOT FOUND THEN
                    RAISE EXCEPTION 'Line_Equipment Insert Failed!';
             END IF;
             SELECT start_date INTO var_line_equip_start_date
             FROM line_equipment
             WHERE line_id = var_line_id
               AND equipment_id = var_equipment_id;
          ELSE

              RAISE EXCEPTION 'Equipment is already assigned to a line';
          END IF;

           -- Update usergroup table with input groupname.
          SELECT priority INTO v_priority
          FROM groupname
          WHERE 1=1
            AND groupname=par_groupname;
          GET DIAGNOSTICS v_numrows = ROW_COUNT;
          IF v_numrows = 0 THEN
              RAISE EXCEPTION 'Usergroup not found in GROUPNAME table';
          END IF;

          DELETE FROM usergroup WHERE username LIKE var_username;
          INSERT INTO usergroup
                        (username,groupname,priority)
                 values (var_username,par_groupname,v_priority) ;

          -- removed to fix duplicate issue- UPDATE usergroup SET groupname = par_groupname WHERE username LIKE var_username;

          -- SELECT carrier from equipment model table

          SELECT em.carrier INTO var_carrier
          FROM unique_identifier ui
          JOIN equipment e on ui.equipment_id = e.equipment_id
          JOIN equipment_model em on em.equipment_model_id = e.equipment_model_id
          WHERE 1=1
            AND ui.value = par_esn_hex
                LIMIT 1;
          -- Assign static ip to radreply table.

          IF par_static_ip_boolean = FALSE THEN
              INSERT INTO radreply (username, attribute, op, value, priority)
                            VALUES (var_username, 'Class', '=', var_line_id::text, 10);

              IF NOT FOUND THEN
                  RAISE EXCEPTION 'Radreply Update Failed!';

              END IF;
          RAISE NOTICE 'DYNAMIC IP- STATIC IP NOT ASSIGNED';

          ELSE

                SELECT * INTO var_static_ip FROM ops_api_static_ip_assign(var_carrier,par_groupname,var_username,var_line_id,par_billing_entity_id);
          RAISE NOTICE 'STATIC IP: %',var_static_ip;
          END IF;


          var_sql_2:='select i.internal_number
          from
          purchase_order po,
          order_line ol,
          item i
          where 1=1
            and po.public_number= '''||par_sales_order||'''
            and po.id=ol.order_id
            and ol.item_id = i.id
            and internal_number like ''MRC%'' limit 1'
            ;
          RAISE NOTICE 'Calling Jbilling to get Product Name (internal number) from  item';

          SELECT prod_code into v_jbilling_item_code FROM public.dblink(fetch_jbilling_conn(), var_sql_2)
              AS rec_type (prod_code  text);
          v_count:=length(v_jbilling_item_code);
          RAISE NOTICE 'MRC Product Code from Jbilling: % length: %',v_jbilling_item_code,v_count;

          SELECT product_id, plan_type_id, length_days into v_product_id,v_plan_type_id,v_length_days
          FROM csctoss.product
          WHERE 1=1
            and product_code like v_jbilling_item_code;

          GET DIAGNOSTICS v_numrows = ROW_COUNT;
          IF v_numrows = 0 THEN
              RAISE EXCEPTION 'ERROR: Product code not present in Product table';
          ELSE
              RAISE NOTICE 'Product Info: prod_id: %  plan_type: % length_days: %',v_product_id,v_plan_type_id,v_length_days;
          END IF;
--
          RAISE NOTICE 'Inserting Product Info into plan table';
          INSERT INTO plan
          (
            length_days, plan_type_id, comment , create_timestamp, product_id,
            staff_id, line_id , start_date, end_date , prepaid_unit,
            prepaid_allowance, prepaid_balance, accounting_start_date , sales_order_number
          )
          VALUES
          (
           v_length_days, v_plan_type_id , par_sales_order, current_timestamp, v_product_id,
           3, var_line_id , current_date, null,  null,
           null, null,   current_date,   null
           );
           GET DIAGNOSTICS v_numrows = ROW_COUNT;
          IF v_numrows = 0 THEN
              RAISE EXCEPTION 'Error: No rows inserted into plan table.';
          END IF;

     --Connect to jbilling and query the function ops_api_prov_line, for provisioning line.

     var_sql := 'select * from oss.assign_device_jbilling( '|| quote_literal(upper(par_sales_order))
              ||' , '||quote_literal(par_esn_hex)||' , '||quote_literal(var_serial_number)||' , '
              ||quote_literal(var_username)||' ,'||var_line_id||')';

     RAISE NOTICE 'Calling oss.assign_device_jbilling in Jbilling';
     RAISE NOTICE '###  var_sql: %',var_sql;
     SELECT result_code into v_return_2  FROM public.dblink(fetch_jbilling_conn(), var_sql)
           AS rec_type (result_code boolean);

     IF (v_return_2 = FALSE) THEN
         RAISE EXCEPTION 'Jbilling Provisioning Failed.';
     ELSE
         RAISE NOTICE 'Jbilling Provisioning Successful.';
     END IF;

  END IF;

              var_return_row.result_code := true;
              var_return_row.error_message := 'Line assignment is done succesfully.';
              RETURN NEXT var_return_row;
              RETURN;
 END;
  $_$;


ALTER FUNCTION csctoss.ops_api_assign_backup_20150219(text, text, integer, text, boolean) OWNER TO csctoss_owner;

--
-- Name: ops_api_assign_backup_20150724(text, text, integer, text, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_assign_backup_20150724(text, text, integer, text, boolean) RETURNS SETOF ops_api_assign_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
   par_esn_hex                        text := $1;
   par_sales_order                    text := $2;
   par_billing_entity_id              integer := $3;
   par_groupname                      text := $4;
   par_static_ip_boolean              boolean := $5;
   var_equipment_id                   integer;
   var_line_id                        integer;
   var_mdn                            text;
   var_mdn_min                        text;
   var_username                       text;
   var_billing_entity_address_id      integer;
   var_static_ip                      text;
   var_conn_string                    text;
   var_serial_number                  text;
   var_line_start_date                date;
   var_line_equip_start_date          date;
   var_model_id                       integer;
   var_carrier                        text;
   var_sql                            text;
   var_return_row                     ops_api_assign_retval%ROWTYPE;
   v_return_2                           boolean;
   v_jbilling_item_code               text; 
   var_sql_2                            text;
   v_product_id                         integer;
   v_plan_type_id                       integer;
   v_length_days                        integer;
   v_line_ctr                           integer;
   v_numrows                           integer;
   v_count                             integer;
   v_priority                          integer;


BEGIN

    PERFORM public.set_change_log_staff_id (3);

    -- Check if the parameters are null

    IF par_esn_hex = ''
    OR par_sales_order = ''
    OR par_billing_entity_id IS NULL
    OR par_groupname = ''
    OR par_static_ip_boolean IS NULL THEN

       RAISE EXCEPTION 'All or some of the input values are null';

    ELSE
        -- Validate Parameters
        SELECT equipment_id INTO var_equipment_id
        FROM unique_identifier
        WHERE unique_identifier_type = 'ESN HEX'
        AND value = par_esn_hex;

        IF NOT FOUND THEN

           RAISE EXCEPTION 'The ESN HEX value entered doesnt exist';

        END IF;

        SELECT equipment_model_id INTO var_model_id
        FROM equipment
        WHERE equipment_id = var_equipment_id;

        IF NOT FOUND THEN

            RAISE EXCEPTION 'Equipment model doesnt exist.';

        END IF;
        -- Start new username search based on MDN/MIN
        -- SELECT carrier from equipment model table

        SELECT em.carrier INTO var_carrier
        FROM unique_identifier ui
        JOIN equipment e on ui.equipment_id = e.equipment_id
        JOIN equipment_model em on em.equipment_model_id = e.equipment_model_id
        WHERE ui.value = par_esn_hex
        LIMIT 1;
 
        RAISE NOTICE 'Sales Order: %',par_sales_order;
        RAISE NOTICE 'ESN: %',par_esn_hex;
        RAISE NOTICE 'CARRIER: %',var_carrier;

        -- Retrieve username value depending upon Carrier and MDN/MIN value.

        IF ( var_carrier = 'SPRINT') THEN

           SELECT value INTO var_mdn_min
           FROM unique_identifier
           WHERE unique_identifier_type = 'MDN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

        ELSIF (var_carrier = 'VZW') THEN

           SELECT value INTO var_mdn_min
           FROM unique_identifier
           WHERE unique_identifier_type = 'MDN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

        ELSIF (var_carrier = 'USCC') THEN

          SELECT value INTO var_mdn_min
           FROM unique_identifier
           WHERE unique_identifier_type = 'MIN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

        END IF;
        RAISE NOTICE 'MDN/MIN: %',var_mdn_min;
        -- Retrieve username value using MDN value

        SELECT username INTO var_username
        FROM username
        WHERE SUBSTR(username,1,10) = var_mdn_min;
        RAISE NOTICE 'USERNAME: % USERGROUP: %',var_username,par_groupname;
        IF NOT FOUND THEN
           RAISE EXCEPTION 'Username doesnt exist';
        END IF;
        --   End new username search

        -- Retrieve Serial Number value from unique_identifier
        SELECT value INTO var_serial_number
        FROM unique_identifier
        WHERE unique_identifier_type = 'SERIAL NUMBER'
        AND equipment_id = var_equipment_id;

        IF NOT FOUND THEN
               RAISE EXCEPTION 'Serial Number value doesnt exist for the Equipment.';
        END IF;

         -- Billing_entity_address_id retrieval
        SELECT address_id INTO var_billing_entity_address_id
        FROM billing_entity_address
        WHERE billing_entity_id = par_billing_entity_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Billing Entity Address doesnt exist';
        ELSE
            var_line_id :=  nextval('csctoss.line_line_id_seq');
            IF EXISTS ( SELECT TRUE  FROM line l JOIN  line_equipment le  USING (line_id) 
                        JOIN  unique_identifier ui USING (equipment_id) WHERE ui.unique_identifier_type = 'ESN HEX' 
                               AND ui.value = par_esn_hex AND le.end_date IS NULL) 
            THEN
                RAISE EXCEPTION 'Active Line already exists for the input parameters';
            ELSE
            -- Insert required fields values into line table

                INSERT INTO line (
                                 line_id, line_assignment_type, billing_entity_id, 
                                 billing_entity_address_id, active_flag, line_label, 
                                 start_date, date_created, radius_username, notes)
                VALUES           (
                                  var_line_id, 'CUSTOMER ASSIGNED', par_billing_entity_id, 
                                  var_billing_entity_address_id, TRUE, par_esn_hex, 
                                  current_date, current_date, var_username, par_sales_order
                                  );

                 SELECT start_date INTO var_line_start_date
                 FROM line WHERE line_id = var_line_id;

                   -- Update username table with SO_ORDER and Billing_Entity_ID
                  UPDATE username SET notes = par_sales_order,
                                      billing_entity_id = par_billing_entity_id
                  WHERE username = var_username;
                  IF NOT FOUND THEN
                       RAISE EXCEPTION 'Username Update Failed!';
                  END IF;

            END IF;

         END IF;

         IF NOT EXISTS (SELECT TRUE FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date IS NULL) THEN
         -- If no active line exists for the equipment then Insert line, equipment details.

           --[BEGIN]BY BEN: NEW CODE TO CHECK IF OWNERSHIP TRANSFER - IF SO, THEN BACK DATE END DATE
           IF EXISTS (SELECT TRUE FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date = current_date ) THEN
             UPDATE line_equipment
             SET 
              end_date = current_date - 1
             WHERE equipment_id = var_equipment_id
             AND   end_date = current_date ;     
           END IF;
           --[END]BY BEN: NEW CODE TO CHECK IF OWNERSHIP TRANSFER - IF SO, THEN BACK DATE END DATE
           
           INSERT INTO line_equipment
            (line_id, equipment_id, start_date, billing_entity_address_id)
           VALUES 
            (var_line_id, var_equipment_id, current_date, var_billing_entity_address_id);

           IF NOT FOUND THEN
             RAISE EXCEPTION 'Line_Equipment Insert Failed!';
           END IF;

           --no idea why this is here
           SELECT 
            start_date 
           INTO 
            var_line_equip_start_date
           FROM  line_equipment
           WHERE line_id = var_line_id
           AND   equipment_id = var_equipment_id;
          ELSE
             RAISE EXCEPTION 'Equipment is already assigned to a line';
          END IF;

           -- Update usergroup table with input groupname.
          SELECT priority INTO v_priority
          FROM groupname 
          WHERE 1=1
            AND groupname=par_groupname;
          GET DIAGNOSTICS v_numrows = ROW_COUNT;
          IF v_numrows = 0 THEN
              RAISE EXCEPTION 'Usergroup not found in GROUPNAME table';
          END IF;
          
          DELETE FROM usergroup WHERE username LIKE var_username;
          INSERT INTO usergroup 
                        (username,groupname,priority) 
                 values (var_username,par_groupname,v_priority) ;

          -- removed to fix duplicate issue- UPDATE usergroup SET groupname = par_groupname WHERE username LIKE var_username;

          -- SELECT carrier from equipment model table

          SELECT em.carrier INTO var_carrier
          FROM unique_identifier ui
          JOIN equipment e on ui.equipment_id = e.equipment_id
          JOIN equipment_model em on em.equipment_model_id = e.equipment_model_id
          WHERE 1=1
            AND ui.value = par_esn_hex
                LIMIT 1;
          -- Assign static ip to radreply table.

          IF par_static_ip_boolean = FALSE THEN
              INSERT INTO radreply (username, attribute, op, value, priority)
                            VALUES (var_username, 'Class', '=', var_line_id::text, 10);

              IF NOT FOUND THEN
                  RAISE EXCEPTION 'Radreply Update Failed!';

              END IF;
          RAISE NOTICE 'DYNAMIC IP- STATIC IP NOT ASSIGNED';

          ELSE

                SELECT * INTO var_static_ip FROM ops_api_static_ip_assign(var_carrier,par_groupname,var_username,var_line_id,par_billing_entity_id);
          RAISE NOTICE 'STATIC IP: %',var_static_ip;
          END IF;
          

          var_sql_2:='select i.internal_number
          from
          purchase_order po,
          order_line ol,
          item i
          where 1=1
            and po.public_number= '''||par_sales_order||'''
            and po.id=ol.order_id
            and ol.item_id = i.id
            and internal_number like ''MRC%'' limit 1'
            ;
          RAISE NOTICE 'Calling Jbilling to get Product Name (internal number) from  item';

          SELECT prod_code into v_jbilling_item_code FROM public.dblink(fetch_jbilling_conn(), var_sql_2)
              AS rec_type (prod_code  text);
          v_count:=length(v_jbilling_item_code);
          RAISE NOTICE 'MRC Product Code from Jbilling: % length: %',v_jbilling_item_code,v_count;

          SELECT product_id, plan_type_id, length_days into v_product_id,v_plan_type_id,v_length_days
          FROM csctoss.product
          WHERE 1=1
            and product_code like v_jbilling_item_code;

          GET DIAGNOSTICS v_numrows = ROW_COUNT;
          IF v_numrows = 0 THEN
              RAISE EXCEPTION 'ERROR: Product code not present in Product table';
          ELSE
              RAISE NOTICE 'Product Info: prod_id: %  plan_type: % length_days: %',v_product_id,v_plan_type_id,v_length_days;
          END IF;
--
          RAISE NOTICE 'Inserting Product Info into plan table';
          INSERT INTO plan
          (
            length_days, plan_type_id, comment , create_timestamp, product_id, 
            staff_id, line_id , start_date, end_date , prepaid_unit, 
            prepaid_allowance, prepaid_balance, accounting_start_date , sales_order_number
          )
          VALUES
          (
           v_length_days, v_plan_type_id , par_sales_order, current_timestamp, v_product_id, 
           3, var_line_id , current_date, null,  null,
           null, null,   current_date,   null  
           );
           GET DIAGNOSTICS v_numrows = ROW_COUNT;
          IF v_numrows = 0 THEN
              RAISE EXCEPTION 'Error: No rows inserted into plan table.';
          END IF;

     --Connect to jbilling and query the function ops_api_prov_line, for provisioning line.

     var_sql := 'select * from oss.assign_device_jbilling( '|| quote_literal(upper(par_sales_order))
              ||' , '||quote_literal(par_esn_hex)||' , '||quote_literal(var_serial_number)||' , '
              ||quote_literal(var_username)||' ,'||var_line_id||')';

     RAISE NOTICE 'Calling oss.assign_device_jbilling in Jbilling';
     RAISE NOTICE '###  var_sql: %',var_sql;
     SELECT result_code into v_return_2  FROM public.dblink(fetch_jbilling_conn(), var_sql)
           AS rec_type (result_code boolean);

     IF (v_return_2 = FALSE) THEN
         RAISE EXCEPTION 'Jbilling Provisioning Failed.';
     ELSE
         RAISE NOTICE 'Jbilling Provisioning Successful.';
     END IF;

  END IF;

              var_return_row.result_code := true;
              var_return_row.error_message := 'Line assignment is done succesfully.';
              RETURN NEXT var_return_row;
              RETURN;
 END;
  $_$;


ALTER FUNCTION csctoss.ops_api_assign_backup_20150724(text, text, integer, text, boolean) OWNER TO csctoss_owner;

--
-- Name: ops_api_assign_test(text, text, integer, text, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_assign_test(text, text, integer, text, boolean) RETURNS SETOF ops_api_assign_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

   par_esn_hex                        text := $1;
   par_sales_order                    text := $2;
   par_billing_entity_id              integer := $3;
   par_groupname                      text := $4;
   par_static_ip_boolean	      boolean := $5;
   var_equipment_id                   integer;
   var_line_id                        integer;
   var_mdn                            text;
   var_username                       text;
   var_billing_entity_address_id      integer;
   var_static_ip                      text;
   var_conn_string                    text;
   var_serial_number		      text;
   var_line_start_date                date;
   var_line_equip_start_date          date;
   var_model_id                       integer;
   var_carrier                        text;
   var_sql                            text;
   var_return_row                     ops_api_assign_retval%ROWTYPE;


BEGIN

        PERFORM public.set_change_log_staff_id (3);

        -- Check if the parameters are null

	IF par_esn_hex = ''
	OR par_sales_order = ''
	OR par_billing_entity_id IS NULL
        OR par_groupname = ''
        OR par_static_ip_boolean IS NULL THEN

	       RAISE EXCEPTION 'All or some of the input values are null';
	       
	ELSE

	-- Validate Parameters

	    SELECT equipment_id INTO var_equipment_id
	    FROM unique_identifier
	    WHERE unique_identifier_type = 'ESN HEX'
	    AND value = par_esn_hex;

	    IF NOT FOUND THEN

	       RAISE EXCEPTION 'The ESN HEX value entered doesnt exists';
	       
	    END IF;

         SELECT equipment_model_id INTO var_model_id
         FROM equipment
         WHERE equipment_id = var_equipment_id;

           IF NOT FOUND THEN

	       RAISE EXCEPTION 'Equipment model doesnt exists.';
	       
	    END IF;

    -- Retrieve MDN value from Equipment_ID

	SELECT value INTO var_mdn
	FROM unique_identifier
	WHERE unique_identifier_type = 'MDN'
	AND equipment_id = var_equipment_id;

        IF NOT FOUND THEN

	    RAISE EXCEPTION 'MDN Value doesnt exists for the Equipment';
	    
	END IF;
    -- SELECT carrier from equipment model table

		SELECT em.carrier
		INTO var_carrier
		FROM unique_identifier ui
		JOIN equipment e on ui.equipment_id = e.equipment_id
		JOIN equipment_model em on em.equipment_model_id = e.equipment_model_id
		WHERE
		  ui.value = par_esn_hex
		LIMIT 1;

        -- Retrieve username value depending upon Carrier and MDN/MIN value. 

	/*SELECT username INTO var_username
	FROM username
	WHERE SUBSTR(username,1,10) = var_mdn;*/

        IF ( var_carrier = 'SPRINT') THEN 

           SELECT value INTO var_username
           FROM unique_identifier
           WHERE unique_identifier_type = 'MDN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex); 
           
        ELSIF (var_carrier = 'VERIZON') THEN 

           SELECT value INTO var_username
           FROM unique_identifier
           WHERE unique_identifier_type = 'MDN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex); 
          
       ELSIF (var_carrier = 'USCC') THEN 

          SELECT value INTO var_username
           FROM unique_identifier
           WHERE unique_identifier_type = 'MIN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex); 

       END IF;

        -- Retrieve username value using MDN value
	SELECT username INTO var_username
	FROM username
	WHERE SUBSTR(username,1,10) = var_username;


	   IF NOT FOUND THEN

	      RAISE EXCEPTION 'Username doesnt exists';
	      
	   END IF;

        -- Retrieve Serial Number value from unique_identifier

         SELECT value INTO var_serial_number
         FROM unique_identifier
         WHERE unique_identifier_type = 'SERIAL NUMBER'
         AND equipment_id = var_equipment_id;

          IF NOT FOUND THEN

              RAISE EXCEPTION 'Serial Number value doesnt exists for the Equipment.';
	 
 	END IF;

         -- Billing_entity_address_id retrieval
	SELECT address_id INTO var_billing_entity_address_id
	FROM billing_entity_address
	WHERE billing_entity_id = par_billing_entity_id;

	 IF NOT FOUND THEN

           RAISE EXCEPTION 'Billing Entity Address doesnt exists';
	  
	 ELSE

	    var_line_id :=  nextval('csctoss.line_line_id_seq');

            --IF EXISTS ( SELECT TRUE FROM line WHERE line_label = par_esn_hex AND radius_username = var_username AND notes = par_sales_order) THEN
           IF EXISTS ( SELECT TRUE  FROM line l JOIN  line_equipment le  USING (line_id) JOIN  unique_identifier ui USING (equipment_id) WHERE ui.unique_identifier_type = 'ESN HEX' AND ui.value = par_esn_hex AND le.end_date IS NULL) THEN
                        RAISE EXCEPTION 'Active Line already exists for the input parameters';

            ELSE

            -- Insert required fields values into line table

             INSERT INTO line(line_id, line_assignment_type, billing_entity_id, billing_entity_address_id, active_flag, line_label, start_date, date_created, radius_username, notes)
	       VALUES (var_line_id, 'CUSTOMER ASSIGNED', par_billing_entity_id, var_billing_entity_address_id, TRUE, par_esn_hex, current_date, current_date, var_username, par_sales_order);

               SELECT start_date INTO var_line_start_date
               FROM line WHERE line_id = var_line_id;

                   -- Update username table with SO_ORDER and Billing_Entity_ID

	            UPDATE username SET notes = par_sales_order,
                           billing_entity_id = par_billing_entity_id
		    WHERE username = var_username;

	              IF NOT FOUND THEN
	                 RAISE EXCEPTION 'Username Update Failed!';
	              END IF;

	   END IF;
	 END IF;

         IF NOT EXISTS (SELECT TRUE FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date IS NULL) THEN

         -- If no active line exists for the equipment then Insert line, equipment details.

	        INSERT INTO line_equipment(line_id, equipment_id, start_date, billing_entity_address_id)
		     VALUES (var_line_id, var_equipment_id, current_date, var_billing_entity_address_id);

                 IF NOT FOUND THEN
                    RAISE EXCEPTION 'Line_Equipment Insert Failed!';
                 END IF;

                SELECT start_date INTO var_line_equip_start_date
                FROM line_equipment
                WHERE line_id = var_line_id
                AND equipment_id = var_equipment_id;

          ELSE

	         RAISE EXCEPTION 'Equipment is already assigned to a line';
	        
	  END IF;

           -- Update usergroup table with input groupname.

             UPDATE usergroup SET groupname = par_groupname WHERE username LIKE var_username;

            -- Assign static ip to radreply table.

          IF par_static_ip_boolean = 'FALSE' THEN

              INSERT INTO radreply (username, attribute, op, value, priority)
                   VALUES (var_username, 'Class', '=', var_line_id::text, 10);

                IF NOT FOUND THEN
                   RAISE EXCEPTION 'Radreply Update Failed!';

                END IF;

           ELSE

             
		SELECT * INTO var_static_ip FROM ops_api_static_ip_assign(var_carrier,par_groupname,var_username,var_line_id,par_billing_entity_id);

        END IF;

      --Connect to jbilling and query the function ops_api_prov_line, for provisioning line.

      --var_conn_string := 'hostaddr=10.17.70.25'||' port=5440'||' dbname=jbilling'||' user=jbilling'||' password=wrub5N4b';

         var_sql := 'select * from oss.assign_device_jbilling( '|| quote_literal(upper(par_sales_order)) ||' , '||quote_literal(par_esn_hex)||' , '||quote_literal(var_serial_number)||' , '||quote_literal(var_username)||' ,'||var_line_id||')';
	
           FOR var_return_row IN

            SELECT * FROM public.dblink(fetch_jbilling_conn(), var_sql) 
                AS rec_type (result_code boolean)

               LOOP

                    IF (var_return_row.result_code = 'FALSE') THEN

                          RAISE EXCEPTION 'Jbilling Provisioning Failed.';
                          
                   END IF;
               END LOOP;

       END IF;

	      var_return_row.result_code := true;
              var_return_row.error_message := 'Line assignment is done succesfully.';
              RETURN NEXT var_return_row;
              RETURN;

 END;
  $_$;


ALTER FUNCTION csctoss.ops_api_assign_test(text, text, integer, text, boolean) OWNER TO csctoss_owner;

--
-- Name: ops_api_assign_tmp(text, text, integer, text, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_assign_tmp(text, text, integer, text, boolean) RETURNS SETOF ops_api_assign_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
   par_esn_hex                        text := $1;
   par_sales_order                    text := $2;
   par_billing_entity_id              integer := $3;
   par_groupname                      text := $4;
   par_static_ip_boolean              boolean := $5;
   var_equipment_id                   integer;
   var_line_id                        integer;
   var_mdn                            text;
   var_username                       text;
   var_billing_entity_address_id      integer;
   var_static_ip                      text;
   var_conn_string                    text;
   var_serial_number                  text;
   var_line_start_date                date;
   var_line_equip_start_date          date;
   var_model_id                       integer;
   var_carrier                        text;
   var_sql                            text;
   var_return_row                     ops_api_assign_retval%ROWTYPE;
--   v_return_2                         integer;
   v_return_2                           record;
   var_sql_2                            text;
   v_product_Id                         integer;
   v_plan_type_id                       integer;
   v_length_days                        integer;
   v_line_ctr                           integer;


BEGIN

        PERFORM public.set_change_log_staff_id (3);

        -- Check if the parameters are null

        IF par_esn_hex = ''
        OR par_sales_order = ''
        OR par_billing_entity_id IS NULL
        OR par_groupname = ''
        OR par_static_ip_boolean IS NULL THEN

               var_return_row.result_code := false;
               var_return_row.error_message := 'All or some of the input values are null';
               RETURN NEXT var_return_row;
               RETURN;

        ELSE

        -- Validate Parameters

            SELECT equipment_id INTO var_equipment_id
            FROM unique_identifier
            WHERE unique_identifier_type = 'ESN HEX'
            AND value = par_esn_hex;

            IF NOT FOUND THEN

               var_return_row.result_code := false;
               var_return_row.error_message := 'The ESN HEX value entered doesnt exists';
               RETURN NEXT var_return_row;
               RETURN;

            END IF;

         SELECT equipment_model_id INTO var_model_id
         FROM equipment
         WHERE equipment_id = var_equipment_id;

           IF NOT FOUND THEN

               var_return_row.result_code := false;
               var_return_row.error_message := 'Equipment model doesnt exists.';
               RETURN NEXT var_return_row;
               RETURN;

            END IF;

    -- Retrieve MDN value from Equipment_ID

        SELECT value INTO var_mdn
        FROM unique_identifier
        WHERE unique_identifier_type = 'MDN'
        AND equipment_id = var_equipment_id;

        IF NOT FOUND THEN

            var_return_row.result_code := false;
            var_return_row.error_message := 'MDN Value doesnt exists for the Equipment';
            RETURN NEXT var_return_row;
            RETURN;

        END IF;

        -- Retrieve username value using MDN value
        SELECT username INTO var_username
        FROM username
        WHERE SUBSTR(username,1,10) = var_mdn;


           IF NOT FOUND THEN

              var_return_row.result_code := false;
              var_return_row.error_message := 'Username doesnt exists for the MDN value';
              RETURN NEXT var_return_row;
              RETURN;

           END IF;

        -- Retrieve Serial Number value from unique_identifier

         SELECT value INTO var_serial_number
         FROM unique_identifier
         WHERE unique_identifier_type = 'SERIAL NUMBER'
         AND equipment_id = var_equipment_id;

          IF NOT FOUND THEN

            var_return_row.result_code := false;
            var_return_row.error_message := 'Serial Number value doesnt exists for the Equipment.';
            RETURN NEXT var_return_row;
            RETURN;

        END IF;

         -- Billing_entity_address_id retrieval
        SELECT address_id INTO var_billing_entity_address_id
        FROM billing_entity_address
        WHERE billing_entity_id = par_billing_entity_id;

         IF NOT FOUND THEN

            var_return_row.result_code := false;
            var_return_row.error_message := 'Billing Entity Address doesnt exists';
            RETURN NEXT var_return_row;
            RETURN;

         ELSE

            var_line_id :=  nextval('csctoss.line_line_id_seq');

            --IF EXISTS ( SELECT TRUE FROM line WHERE line_label = par_esn_hex AND radius_username = var_username AND notes = par_sales_order) THEN
           IF EXISTS ( SELECT TRUE  FROM line l JOIN  line_equipment le  USING (line_id) JOIN  unique_identifier ui USING (equipment_id) WHERE ui.unique_identifier_type = 'ESN HEX' AND ui.value = par_esn_hex AND le.end_date IS NULL) THEN
                        RAISE EXCEPTION 'Active Line already exists for the input parameters';

            ELSE

            -- Insert required fields values into line table

             INSERT INTO line(line_id, line_assignment_type, billing_entity_id, billing_entity_address_id, active_flag, line_label, start_date, date_created, radius_username, notes)
               VALUES (var_line_id, 'CUSTOMER ASSIGNED', par_billing_entity_id, var_billing_entity_address_id, TRUE, par_esn_hex, current_date, current_date, var_username, par_sales_order);

               SELECT start_date INTO var_line_start_date
               FROM line WHERE line_id = var_line_id;

                   -- Update username table with SO_ORDER and Billing_Entity_ID

                    UPDATE username SET notes = par_sales_order,
                           billing_entity_id = par_billing_entity_id
                    WHERE username = var_username;

                      IF NOT FOUND THEN
                         RAISE EXCEPTION 'Username Update Failed!';
                      END IF;

           END IF;
         END IF;

         IF NOT EXISTS (SELECT TRUE FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date IS NULL) THEN

         -- If no active line exists for the equipment then Insert line, equipment details.

                INSERT INTO line_equipment(line_id, equipment_id, start_date, billing_entity_address_id)
                     VALUES (var_line_id, var_equipment_id, current_date, var_billing_entity_address_id);

                 IF NOT FOUND THEN
                    RAISE EXCEPTION 'Line_Equipment Insert Failed!';
                 END IF;

                SELECT start_date INTO var_line_equip_start_date
                FROM line_equipment
                WHERE line_id = var_line_id
                AND equipment_id = var_equipment_id;

          ELSE

                 var_return_row.result_code := false;
                 var_return_row.error_message := 'Equipment is already assigned to a line';
                 RETURN NEXT var_return_row;
                 RETURN;

          END IF;

           -- Update usergroup table with input groupname.

             UPDATE usergroup SET groupname = par_groupname WHERE username LIKE var_username;

               -- SELECT carrier from equipment model table

                SELECT em.carrier
                INTO var_carrier
                FROM unique_identifier ui
                JOIN equipment e on ui.equipment_id = e.equipment_id
                JOIN equipment_model em on em.equipment_model_id = e.equipment_model_id
                WHERE
                  ui.value = par_esn_hex
                LIMIT 1;

          -- Assign static ip to radreply table.

          IF par_static_ip_boolean = 'FALSE' THEN

              INSERT INTO radreply (username, attribute, op, value, priority)
                   VALUES (var_username, 'Class', '=', var_line_id::text, 10);

                IF NOT FOUND THEN
                   RAISE EXCEPTION 'Radreply Update Failed!';

                END IF;

           ELSE

                SELECT * INTO var_static_ip FROM ops_api_static_ip_assign(var_carrier,par_groupname,var_username,var_line_id,par_billing_entity_id);

        END IF;

      --Connect to jbilling and query the function ops_api_prov_line, for provisioning line.

          var_conn_string := 'hostaddr=10.17.70.25'||' port=5440'||' dbname=jbilling'||' user=jbilling'||' password=wrub5N4b';
--          var_conn_string := 'hostaddr=192.168.144.146'||' port=5440'||' dbname=jbilling'||' user=jbilling'||' password=wrub5N4b';

         var_sql := 'select * from oss.assign_device_jbilling( '|| quote_literal(upper(par_sales_order)) ||' , '||quote_literal(par_esn_hex)||' , '||quote_literal(var_serial_number)||' , '||quote_literal(var_username)||' ,'||var_line_id||')';
        RAISE INFO 'var_sql_dump= %',var_sql;
        RAISE WARNING 'var_sql_dump = %',var_sql;
        RAISE NOTICE 'var_sql_dump = %',var_sql;

raise notice 'debug 110';

           FOR var_return_row IN
           SELECT * FROM public.dblink(var_conn_string, var_sql)
              AS rec_type (result_code boolean)

               LOOP

                    IF (var_return_row.result_code = 'FALSE') THEN

                          var_return_row.error_message := 'Jbilling Provisioning Failed.';
                          RETURN NEXT var_return_row;
                          RETURN;
                   END IF;
               END LOOP;
       ---    start of code to insert plan_table
raise notice 'debug 200';
--        var_sql_2:='select 1234 from prov_line limit 1';
raise notice 'debug 220 :line_id=%',var_line_id;
        var_sql_2:='select i.external_id
        from prov_line pl,item i
        where 1=1
        and pl.item_id = i.id
        and pl.end_date is null
        and pl.archived is null
        and pl.line_id =' || var_line_id ||
        ' limit 1'
        ;

raise notice 'debug 350';

     var_conn_string := 'hostaddr=10.17.70.25'||' port=5440'||' dbname=jbilling'||' user=jbilling'||' password=wrub5N4b';
--     var_conn_string := 'hostaddr=192.168.144.146'||' port=5440'||' dbname=jbilling'||' user=jbilling'||' password=wrub5N4b';
raise notice 'debug 500';
        RAISE NOTICE 'var_sql_2 dump = %',var_sql_2;
    FOR v_return_2 IN
           SELECT * FROM public.dblink(var_conn_string, var_sql_2)
              AS rec_type (external_code integer)
    loop
       v_line_ctr:=0;
       v_line_ctr:=v_line_ctr + 1;

       select product_id, plan_type_id, length_days into v_product_id,v_plan_type_id,v_length_days
       from product
       where 1=1
         and  product_id = v_return_2.external_code ;
       IF NOT FOUND THEN
         var_return_row.result_code := false;
         var_return_row.error_message := 'ERROR: External code not present in Product table';
         RETURN NEXT var_return_row;
         RETURN;
      end if;
--
       insert into plan
       (
        -- plan_id
         length_days,
         plan_type_id,
         comment ,
         create_timestamp,
         product_id,
         staff_id,
         line_id ,
         start_date,
         end_date ,
         prepaid_unit ,
         prepaid_allowance,
         prepaid_balance,
         accounting_start_date ,
         sales_order_number
       )
       values
       (
         v_length_days,
         v_plan_type_id ,
         par_sales_order, --comment ,
         current_timestamp,
         v_product_id,
         3, --staff_id,
         var_line_id ,
         current_date,
         null,  -- end_date ,
         null,  --prepaid_unit ,
         null, --prepaid_allowance,
         null,  --prepaid_balance,
         current_date,  --accounting_start_date ,
         null  --sales_order_number
       );
    end loop;
      if v_line_ctr > 0 then
          null;
      else
          var_return_row.error_message := 'Error: No rows inserted into plan table.';
          RETURN NEXT var_return_row;
          RETURN;
     end if;

       END IF;

              var_return_row.result_code := true;
              var_return_row.error_message := 'Line assignment is done succesfully.';
              RETURN NEXT var_return_row;
              RETURN;

 END;
  $_$;


ALTER FUNCTION csctoss.ops_api_assign_tmp(text, text, integer, text, boolean) OWNER TO csctoss_owner;

--
-- Name: ops_api_assign_uscc(text, text, integer, text, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_assign_uscc(text, text, integer, text, boolean) RETURNS SETOF ops_api_assign_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

   par_esn_hex                        text := $1;
   par_sales_order                    text := $2;
   par_billing_entity_id              integer := $3;
   par_groupname                      text := $4;
   par_static_ip_boolean              boolean := $5;
   var_equipment_id                   integer;
   var_line_id                        integer;
   var_mdn                            text;
   var_username                       text;
   var_billing_entity_address_id      integer;
   var_static_ip                      text;
   var_conn_string                    text;
   var_serial_number                  text;
   var_line_start_date                date;
   var_line_equip_start_date          date;
   var_model_id                       integer;
   var_carrier                        text;
   var_sql                            text;
   var_sql_2                            text;
   var_return_row                     ops_api_assign_retval%ROWTYPE;
   v_return_2                          record;
   v_product_Id                         integer;
   v_plan_type_id                       integer;
   v_length_days                        integer;
   v_line_ctr                           integer;


BEGIN

        PERFORM public.set_change_log_staff_id (3);

        -- Check if the parameters are null

        IF par_esn_hex = ''
        OR par_sales_order = ''
        OR par_billing_entity_id IS NULL
        OR par_groupname = ''
        OR par_static_ip_boolean IS NULL THEN

               RAISE EXCEPTION 'All or some of the input values are null';

        ELSE

        -- Validate Parameters

            SELECT equipment_id INTO var_equipment_id
            FROM unique_identifier
            WHERE unique_identifier_type = 'ESN HEX'
            AND value = par_esn_hex;

            IF NOT FOUND THEN

               RAISE EXCEPTION 'The ESN HEX value entered doesnt exists';

            END IF;

         SELECT equipment_model_id INTO var_model_id
         FROM equipment
         WHERE equipment_id = var_equipment_id;

           IF NOT FOUND THEN

               RAISE EXCEPTION 'Equipment model doesnt exists.';

            END IF;

    -- Retrieve MDN value from Equipment_ID

        SELECT value INTO var_mdn
        FROM unique_identifier
        WHERE unique_identifier_type = 'MDN'
        AND equipment_id = var_equipment_id;

        IF NOT FOUND THEN

            RAISE EXCEPTION 'MDN Value doesnt exists for the Equipment';

        END IF;
    -- SELECT carrier from equipment model table

                SELECT em.carrier
                INTO var_carrier
                FROM unique_identifier ui
                JOIN equipment e on ui.equipment_id = e.equipment_id
                JOIN equipment_model em on em.equipment_model_id = e.equipment_model_id
                WHERE
                  ui.value = par_esn_hex
                LIMIT 1;

        -- Retrieve username value depending upon Carrier and MDN/MIN value.

        /*SELECT username INTO var_username
        FROM username
        WHERE SUBSTR(username,1,10) = var_mdn;*/

        IF ( var_carrier = 'SPRINT') THEN

           SELECT value INTO var_username
           FROM unique_identifier
           WHERE unique_identifier_type = 'MDN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

        ELSIF (var_carrier = 'VERIZON') THEN

           SELECT value INTO var_username
           FROM unique_identifier
           WHERE unique_identifier_type = 'MDN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

       ELSIF (var_carrier = 'USCC') THEN

          SELECT value INTO var_username
           FROM unique_identifier
           WHERE unique_identifier_type = 'MIN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

       END IF;

        -- Retrieve username value using MDN value
        SELECT username INTO var_username
        FROM username
        WHERE SUBSTR(username,1,10) = var_username;


           IF NOT FOUND THEN

              RAISE EXCEPTION 'Username doesnt exists';

           END IF;

        -- Retrieve Serial Number value from unique_identifier

         SELECT value INTO var_serial_number
         FROM unique_identifier
         WHERE unique_identifier_type = 'SERIAL NUMBER'
         AND equipment_id = var_equipment_id;

          IF NOT FOUND THEN

              RAISE EXCEPTION 'Serial Number value doesnt exists for the Equipment.';

        END IF;

         -- Billing_entity_address_id retrieval
        SELECT address_id INTO var_billing_entity_address_id
        FROM billing_entity_address
        WHERE billing_entity_id = par_billing_entity_id;

         IF NOT FOUND THEN

           RAISE EXCEPTION 'Billing Entity Address doesnt exists';

         ELSE

            var_line_id :=  nextval('csctoss.line_line_id_seq');

            --IF EXISTS ( SELECT TRUE FROM line WHERE line_label = par_esn_hex AND radius_username = var_username AND notes = par_sales_order) THEN
           IF EXISTS ( SELECT TRUE  FROM line l JOIN  line_equipment le  USING (line_id) JOIN  unique_identifier ui USING (equipment_id) WHERE ui.unique_identifier_type = 'ESN HEX' AND ui.value = par_esn_hex AND le.end_date IS NULL) THEN
                        RAISE EXCEPTION 'Active Line already exists for the input parameters';

            ELSE

            -- Insert required fields values into line table

             INSERT INTO line(line_id, line_assignment_type, billing_entity_id, billing_entity_address_id, active_flag, line_label, start_date, date_created, radius_username, notes)
               VALUES (var_line_id, 'CUSTOMER ASSIGNED', par_billing_entity_id, var_billing_entity_address_id, TRUE, par_esn_hex, current_date, current_date, var_username, par_sales_order);

               SELECT start_date INTO var_line_start_date
               FROM line WHERE line_id = var_line_id;

                   -- Update username table with SO_ORDER and Billing_Entity_ID

                    UPDATE username SET notes = par_sales_order,
                           billing_entity_id = par_billing_entity_id
                    WHERE username = var_username;

                      IF NOT FOUND THEN
                         RAISE EXCEPTION 'Username Update Failed!';
                      END IF;

           END IF;
         END IF;

         IF NOT EXISTS (SELECT TRUE FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date IS NULL) THEN

         -- If no active line exists for the equipment then Insert line, equipment details.

                INSERT INTO line_equipment(line_id, equipment_id, start_date, billing_entity_address_id)
                     VALUES (var_line_id, var_equipment_id, current_date, var_billing_entity_address_id);

                 IF NOT FOUND THEN
                    RAISE EXCEPTION 'Line_Equipment Insert Failed!';
                 END IF;

                SELECT start_date INTO var_line_equip_start_date
                FROM line_equipment
                WHERE line_id = var_line_id
                AND equipment_id = var_equipment_id;

          ELSE

                 RAISE EXCEPTION 'Equipment is already assigned to a line';

          END IF;

           -- Update usergroup table with input groupname.

             UPDATE usergroup SET groupname = par_groupname WHERE username LIKE var_username;

            -- Assign static ip to radreply table.

          IF par_static_ip_boolean = 'FALSE' THEN

              INSERT INTO radreply (username, attribute, op, value, priority)
                   VALUES (var_username, 'Class', '=', var_line_id::text, 10);

                IF NOT FOUND THEN
                   RAISE EXCEPTION 'Radreply Update Failed!';

                END IF;

           ELSE


                SELECT * INTO var_static_ip FROM ops_api_static_ip_assign(var_carrier,par_groupname,var_username,var_line_id,par_billing_entity_id);

        END IF;
--//
       ---    start of code to insert plan_table
        var_sql_2:='select i.internal_number
        from
             purchase_order po,
             order_line ol,
             item i
        where 1=1
        and po.public_number= '''||par_sales_order||''' and po.id=ol.order_id
        and ol.item_id = i.id
        and internal_number like ''MRC%'' limit 1'
        ;


        RAISE NOTICE 'var_sql_2 dump = %',var_sql_2;
    FOR v_return_2 IN
          SELECT * FROM public.dblink(fetch_jbilling_conn(), var_sql_2)
              AS rec_type (result_value text)
    loop
       v_line_ctr:=0;
       v_line_ctr:=v_line_ctr + 1;

         select product_id, plan_type_id, length_days into v_product_id,v_plan_type_id,v_length_days
         from product
         where 1=1
           and  product_code = v_return_2.result_value ;
        RAISE NOTICE 'product_id= %  result=%',v_product_id,v_return_2.result_value;

          IF NOT FOUND THEN

             RAISE EXCEPTION 'ERROR: External code not present in Product table';

       END IF;
--
       insert into plan
       (
        -- plan_id
         length_days,
         plan_type_id,
         comment ,
         create_timestamp,
         product_id,
         staff_id,
         line_id ,
         start_date,
         end_date ,
         prepaid_unit ,
         prepaid_allowance,
         prepaid_balance,
         accounting_start_date ,
         sales_order_number
       )
       values
       (
         v_length_days,
         v_plan_type_id ,
         par_sales_order, --comment ,
         current_timestamp,
         v_product_id,
         3, --staff_id,
         var_line_id ,
         current_date,
         null,  -- end_date ,
         null,  --prepaid_unit ,
         null, --prepaid_allowance,
         null,  --prepaid_balance,
         current_date,  --accounting_start_date ,
         null  --sales_order_number
       );
    end loop;
      if v_line_ctr > 0 then
          null;
      else

          RAISE EXCEPTION 'Error: No rows inserted into plan table.';

     end if;

      --Connect to jbilling and query the function ops_api_prov_line, for provisioning line.
         var_sql := 'select * from oss.assign_device_jbilling( '|| quote_literal(upper(par_sales_order)) ||' , '||quote_literal(par_esn_hex)||' , '||quote_literal(var_serial_number)||' , '||quote_literal(var_username)||' ,'||var_line_id||')';

           FOR var_return_row IN

            SELECT * FROM public.dblink(fetch_jbilling_conn(), var_sql)
                AS rec_type (result_code boolean)

               LOOP

                    IF (var_return_row.result_code = 'FALSE') THEN

                          RAISE EXCEPTION 'Jbilling Provisioning Failed.';

                   END IF;
               END LOOP;
--
--
--
-- //
       END IF;

              var_return_row.result_code := true;
              var_return_row.error_message := 'Line assignment is done succesfully.';
              RETURN NEXT var_return_row;
              RETURN;

 END;
  $_$;


ALTER FUNCTION csctoss.ops_api_assign_uscc(text, text, integer, text, boolean) OWNER TO csctoss_owner;

--
-- Name: ops_api_assign_uscc_oss_only(text, text, integer, text, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_assign_uscc_oss_only(text, text, integer, text, boolean) RETURNS SETOF ops_api_assign_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

   par_esn_hex                        text := $1;
   par_sales_order                    text := $2;
   par_billing_entity_id              integer := $3;
   par_groupname                      text := $4;
   par_static_ip_boolean              boolean := $5;
   var_equipment_id                   integer;
   var_line_id                        integer;
   var_mdn                            text;
   var_username                       text;
   var_billing_entity_address_id      integer;
   var_static_ip                      text;
   var_conn_string                    text;
   var_serial_number                  text;
   var_line_start_date                date;
   var_line_equip_start_date          date;
   var_model_id                       integer;
   var_carrier                        text;
   var_sql                            text;
   var_sql_2                            text;
   var_return_row                     ops_api_assign_retval%ROWTYPE;
   v_return_2                          record;
   v_product_Id                         integer;
   v_plan_type_id                       integer;
   v_length_days                        integer;
   v_line_ctr                           integer;


BEGIN

        PERFORM public.set_change_log_staff_id (3);

        -- Check if the parameters are null

        IF par_esn_hex = ''
        OR par_sales_order = ''
        OR par_billing_entity_id IS NULL
        OR par_groupname = ''
        OR par_static_ip_boolean IS NULL THEN

               RAISE EXCEPTION 'All or some of the input values are null';

        ELSE

        -- Validate Parameters

            SELECT equipment_id INTO var_equipment_id
            FROM unique_identifier
            WHERE unique_identifier_type = 'ESN HEX'
            AND value = par_esn_hex;

            IF NOT FOUND THEN

               RAISE EXCEPTION 'The ESN HEX value entered doesnt exists';

            END IF;

         SELECT equipment_model_id INTO var_model_id
         FROM equipment
         WHERE equipment_id = var_equipment_id;

           IF NOT FOUND THEN

               RAISE EXCEPTION 'Equipment model doesnt exists.';

            END IF;

    -- Retrieve MDN value from Equipment_ID

        SELECT value INTO var_mdn
        FROM unique_identifier
        WHERE unique_identifier_type = 'MDN'
        AND equipment_id = var_equipment_id;

        IF NOT FOUND THEN

            RAISE EXCEPTION 'MDN Value doesnt exists for the Equipment';

        END IF;
    -- SELECT carrier from equipment model table

                SELECT em.carrier
                INTO var_carrier
                FROM unique_identifier ui
                JOIN equipment e on ui.equipment_id = e.equipment_id
                JOIN equipment_model em on em.equipment_model_id = e.equipment_model_id
                WHERE
                  ui.value = par_esn_hex
                LIMIT 1;

        -- Retrieve username value depending upon Carrier and MDN/MIN value.

        /*SELECT username INTO var_username
        FROM username
        WHERE SUBSTR(username,1,10) = var_mdn;*/

        IF ( var_carrier = 'SPRINT') THEN

           SELECT value INTO var_username
           FROM unique_identifier
           WHERE unique_identifier_type = 'MDN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

        ELSIF (var_carrier = 'VERIZON') THEN

           SELECT value INTO var_username
           FROM unique_identifier
           WHERE unique_identifier_type = 'MDN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

       ELSIF (var_carrier = 'USCC') THEN

          SELECT value INTO var_username
           FROM unique_identifier
           WHERE unique_identifier_type = 'MIN'
           AND equipment_id = (SELECT equipment_id FROM unique_identifier WHERE unique_identifier_type = 'ESN HEX' AND value = par_esn_hex);

       END IF;

        -- Retrieve username value using MDN value
        SELECT username INTO var_username
        FROM username
        WHERE SUBSTR(username,1,10) = var_username;


           IF NOT FOUND THEN

              RAISE EXCEPTION 'Username doesnt exists';

           END IF;

        -- Retrieve Serial Number value from unique_identifier

         SELECT value INTO var_serial_number
         FROM unique_identifier
         WHERE unique_identifier_type = 'SERIAL NUMBER'
         AND equipment_id = var_equipment_id;

          IF NOT FOUND THEN

              RAISE EXCEPTION 'Serial Number value doesnt exists for the Equipment.';

        END IF;

         -- Billing_entity_address_id retrieval
        SELECT address_id INTO var_billing_entity_address_id
        FROM billing_entity_address
        WHERE billing_entity_id = par_billing_entity_id;

         IF NOT FOUND THEN

           RAISE EXCEPTION 'Billing Entity Address doesnt exists';

         ELSE

            var_line_id :=  nextval('csctoss.line_line_id_seq');

            --IF EXISTS ( SELECT TRUE FROM line WHERE line_label = par_esn_hex AND radius_username = var_username AND notes = par_sales_order) THEN
           IF EXISTS ( SELECT TRUE  FROM line l JOIN  line_equipment le  USING (line_id) JOIN  unique_identifier ui USING (equipment_id) WHERE ui.unique_identifier_type = 'ESN HEX' AND ui.value = par_esn_hex AND le.end_date IS NULL) THEN
                        RAISE EXCEPTION 'Active Line already exists for the input parameters';

            ELSE

            -- Insert required fields values into line table

             INSERT INTO line(line_id, line_assignment_type, billing_entity_id, billing_entity_address_id, active_flag, line_label, start_date, date_created, radius_username, notes)
               VALUES (var_line_id, 'CUSTOMER ASSIGNED', par_billing_entity_id, var_billing_entity_address_id, TRUE, par_esn_hex, current_date, current_date, var_username, par_sales_order);

               SELECT start_date INTO var_line_start_date
               FROM line WHERE line_id = var_line_id;

                   -- Update username table with SO_ORDER and Billing_Entity_ID

                    UPDATE username SET notes = par_sales_order,
                           billing_entity_id = par_billing_entity_id
                    WHERE username = var_username;

                      IF NOT FOUND THEN
                         RAISE EXCEPTION 'Username Update Failed!';
                      END IF;

           END IF;
         END IF;

         IF NOT EXISTS (SELECT TRUE FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date IS NULL) THEN

         -- If no active line exists for the equipment then Insert line, equipment details.

                INSERT INTO line_equipment(line_id, equipment_id, start_date, billing_entity_address_id)
                     VALUES (var_line_id, var_equipment_id, current_date, var_billing_entity_address_id);

                 IF NOT FOUND THEN
                    RAISE EXCEPTION 'Line_Equipment Insert Failed!';
                 END IF;

                SELECT start_date INTO var_line_equip_start_date
                FROM line_equipment
                WHERE line_id = var_line_id
                AND equipment_id = var_equipment_id;

          ELSE

                 RAISE EXCEPTION 'Equipment is already assigned to a line';

          END IF;

           -- Update usergroup table with input groupname.

             UPDATE usergroup SET groupname = par_groupname WHERE username LIKE var_username;

            -- Assign static ip to radreply table.

          IF par_static_ip_boolean = 'FALSE' THEN

              INSERT INTO radreply (username, attribute, op, value, priority)
                   VALUES (var_username, 'Class', '=', var_line_id::text, 10);

                IF NOT FOUND THEN
                   RAISE EXCEPTION 'Radreply Update Failed!';

                END IF;

           ELSE


                SELECT * INTO var_static_ip FROM ops_api_static_ip_assign(var_carrier,par_groupname,var_username,var_line_id,par_billing_entity_id);

        END IF;
--//
       ---    start of code to insert plan_table
        var_sql_2:='select i.internal_number
        from
             purchase_order po,
             order_line ol,
             item i
        where 1=1
        and po.public_number= '''||par_sales_order||''' and po.id=ol.order_id
        and ol.item_id = i.id
        and internal_number like ''MRC%'' limit 1'
        ;


        RAISE NOTICE 'var_sql_2 dump = %',var_sql_2;
    FOR v_return_2 IN
          SELECT * FROM public.dblink(fetch_jbilling_conn(), var_sql_2)
              AS rec_type (result_value text)
    loop
       v_line_ctr:=0;
       v_line_ctr:=v_line_ctr + 1;

         select product_id, plan_type_id, length_days into v_product_id,v_plan_type_id,v_length_days
         from product
         where 1=1
           and  product_code = v_return_2.result_value ;
        RAISE NOTICE 'product_id= %  result=%',v_product_id,v_return_2.result_value;

          IF NOT FOUND THEN

             RAISE EXCEPTION 'ERROR: External code not present in Product table';

       END IF;
--
       insert into plan
       (
        -- plan_id
         length_days,
         plan_type_id,
         comment ,
         create_timestamp,
         product_id,
         staff_id,
         line_id ,
         start_date,
         end_date ,
         prepaid_unit ,
         prepaid_allowance,
         prepaid_balance,
         accounting_start_date ,
         sales_order_number
       )
       values
       (
         v_length_days,
         v_plan_type_id ,
         par_sales_order, --comment ,
         current_timestamp,
         v_product_id,
         3, --staff_id,
         var_line_id ,
         current_date,
         null,  -- end_date ,
         null,  --prepaid_unit ,
         null, --prepaid_allowance,
         null,  --prepaid_balance,
         current_date,  --accounting_start_date ,
         null  --sales_order_number
       );
    end loop;
      if v_line_ctr > 0 then
          null;
      else

          RAISE EXCEPTION 'Error: No rows inserted into plan table.';

     end if;
/*
      --Connect to jbilling and query the function ops_api_prov_line, for provisioning line.
         var_sql := 'select * from oss.assign_device_jbilling( '|| quote_literal(upper(par_sales_order)) ||' , '||quote_literal(par_esn_hex)||' , '||quote_literal(var_serial_number)||' , '||quote_literal(var_username)||' ,'||var_line_id||')';

           FOR var_return_row IN

            SELECT * FROM public.dblink(fetch_jbilling_conn(), var_sql)
                AS rec_type (result_code boolean)

               LOOP

                    IF (var_return_row.result_code = 'FALSE') THEN

                          RAISE EXCEPTION 'Jbilling Provisioning Failed.';

                   END IF;
               END LOOP;
*/
--
--
--
-- //
       END IF;

              var_return_row.result_code := true;
              var_return_row.error_message := 'Line assignment is done succesfully.';
              RETURN NEXT var_return_row;
              RETURN;

 END;
  $_$;


ALTER FUNCTION csctoss.ops_api_assign_uscc_oss_only(text, text, integer, text, boolean) OWNER TO csctoss_owner;

--
-- Name: ops_api_assign_with_reservation(text, text, integer, text, boolean, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_assign_with_reservation(text, text, integer, text, boolean, integer) RETURNS SETOF ops_api_assign_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
   par_esn_hex                        text := $1;
   par_sales_order                    text := $2;
   par_billing_entity_id              integer := $3;
   par_groupname                      text := $4;
   par_static_ip_boolean              boolean := $5;
   par_res_id                         integer := $6;
   var_equipment_id                   integer;
   var_line_id                        integer;
   var_mdn                            text;
   var_username                       text;
   var_billing_entity_address_id      integer;
   var_static_ip                      text;
   var_conn_string                    text;
   var_serial_number                  text;
   var_line_start_date                date;
   var_line_equip_start_date          date;
   var_model_id                       integer;
   var_carrier                        text;
   var_sql                            text;
   var_return_row                     ops_api_assign_retval%ROWTYPE;
--   v_return_2                         integer;
   v_return_2                           record;
   var_sql_2                            text;
   v_product_Id                         integer;
   v_plan_type_id                       integer;
   v_length_days                        integer;
   v_line_ctr                           integer;


BEGIN

        PERFORM public.set_change_log_staff_id (3);

        -- Check if the parameters are null

        IF par_esn_hex = ''
        OR par_sales_order = ''
        OR par_billing_entity_id IS NULL
        OR par_groupname = ''
        OR par_static_ip_boolean IS NULL THEN

               RAISE EXCEPTION 'All or some of the input values are null';
             
        ELSE

        IF (par_res_id = 0) THEN
           par_res_id = NULL;
        END IF;
        

        -- Validate Parameters

            SELECT equipment_id INTO var_equipment_id
            FROM unique_identifier
            WHERE unique_identifier_type = 'ESN HEX'
            AND value = par_esn_hex;

            IF NOT FOUND THEN

               RAISE EXCEPTION 'The ESN HEX value entered doesnt exists';
              
            END IF;

         SELECT equipment_model_id INTO var_model_id
         FROM equipment
         WHERE equipment_id = var_equipment_id;

           IF NOT FOUND THEN

               RAISE EXCEPTION 'Equipment model doesnt exists.';
             
           END IF;

    -- Retrieve MDN value from Equipment_ID

        SELECT value INTO var_mdn
        FROM unique_identifier
        WHERE unique_identifier_type = 'MDN'
        AND equipment_id = var_equipment_id;

        IF NOT FOUND THEN

            RAISE EXCEPTION 'MDN Value doesnt exists for the Equipment';
            
        END IF;

        -- Retrieve username value using MDN value
        SELECT username INTO var_username
        FROM username
        WHERE SUBSTR(username,1,10) = var_mdn;


           IF NOT FOUND THEN

              RAISE EXCEPTION 'Username doesnt exists for the MDN value';
              
           END IF;

        -- Retrieve Serial Number value from unique_identifier

         SELECT value INTO var_serial_number
         FROM unique_identifier
         WHERE unique_identifier_type = 'SERIAL NUMBER'
         AND equipment_id = var_equipment_id;

          IF NOT FOUND THEN

               RAISE EXCEPTION 'Serial Number value doesnt exists for the Equipment.';
            
          END IF;

         -- Billing_entity_address_id retrieval
        SELECT address_id INTO var_billing_entity_address_id
        FROM billing_entity_address
        WHERE billing_entity_id = par_billing_entity_id;

         IF NOT FOUND THEN

            RAISE EXCEPTION 'Billing Entity Address doesnt exists';
            
         ELSE

            var_line_id :=  nextval('csctoss.line_line_id_seq');

           IF EXISTS ( SELECT TRUE  FROM line l JOIN  line_equipment le  USING (line_id) JOIN  unique_identifier ui USING (equipment_id) WHERE ui.unique_identifier_type = 'ESN HEX' AND ui.value = par_esn_hex AND le.end_date IS NULL) THEN
                        RAISE EXCEPTION 'Active Line already exists for the input parameters';

            ELSE

            -- Insert required fields values into line table

             INSERT INTO line(line_id, line_assignment_type, billing_entity_id, billing_entity_address_id, active_flag, line_label, start_date, date_created, radius_username, notes)
               VALUES (var_line_id, 'CUSTOMER ASSIGNED', par_billing_entity_id, var_billing_entity_address_id, TRUE, par_esn_hex, current_date, current_date, var_username, par_sales_order);

               SELECT start_date INTO var_line_start_date
               FROM line WHERE line_id = var_line_id;

                   -- Update username table with SO_ORDER and Billing_Entity_ID

                    UPDATE username SET notes = par_sales_order,
                           billing_entity_id = par_billing_entity_id
                    WHERE username = var_username;

                      IF NOT FOUND THEN

                         RAISE EXCEPTION 'Username Update Failed!';

                      END IF;

           END IF;

         END IF;

         IF NOT EXISTS (SELECT TRUE FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date IS NULL) THEN

         -- If no active line exists for the equipment then Insert line, equipment details.

                INSERT INTO line_equipment(line_id, equipment_id, start_date, billing_entity_address_id)
                     VALUES (var_line_id, var_equipment_id, current_date, var_billing_entity_address_id);

                 IF NOT FOUND THEN

                    RAISE EXCEPTION 'Line_Equipment Insert Failed!';

                 END IF;

                SELECT start_date INTO var_line_equip_start_date
                FROM line_equipment
                WHERE line_id = var_line_id
                AND equipment_id = var_equipment_id;

          ELSE

                 RAISE EXCEPTION 'Equipment is already assigned to a line';
              
          END IF;

           -- Update usergroup table with input groupname.

             UPDATE usergroup SET groupname = par_groupname WHERE username LIKE var_username;

               -- SELECT carrier from equipment model table

                SELECT em.carrier
                INTO var_carrier
                FROM unique_identifier ui
                JOIN equipment e on ui.equipment_id = e.equipment_id
                JOIN equipment_model em on em.equipment_model_id = e.equipment_model_id
                WHERE
                  ui.value = par_esn_hex
                LIMIT 1;

          -- Assign static ip to radreply table.

          IF par_static_ip_boolean = 'FALSE' THEN

              INSERT INTO radreply (username, attribute, op, value, priority)
                   VALUES (var_username, 'Class', '=', var_line_id::text, 10);

                IF NOT FOUND THEN

                   RAISE EXCEPTION 'Radreply Update Failed!';

                END IF;

           ELSE

                SELECT * INTO var_static_ip FROM ops_api_static_ip_assign_v2(var_carrier,par_groupname,var_username,var_line_id,par_billing_entity_id,par_res_id,3);

        END IF;

          var_sql := 'select * from oss.assign_device_jbilling( '|| quote_literal(upper(par_sales_order)) ||' , '||quote_literal(par_esn_hex)||' , '||quote_literal(var_serial_number)||' , '||quote_literal(var_username)||' ,'||var_line_id||')';
  
           FOR var_return_row IN
               
             SELECT * FROM public.dblink(fetch_jbilling_conn(), var_sql) 
                AS rec_type (result_code boolean)

               LOOP

                    IF (var_return_row.result_code = 'FALSE') THEN
 
                       RAISE EXCEPTION 'Jbilling Provisioning Failed.';

                   END IF;

           END LOOP;
       END IF;
              var_return_row.result_code := true;
              var_return_row.error_message := 'Line assignment is done succesfully.';
              RETURN NEXT var_return_row;
              RETURN;

 END;
  $_$;


ALTER FUNCTION csctoss.ops_api_assign_with_reservation(text, text, integer, text, boolean, integer) OWNER TO csctoss_owner;

--
-- Name: ops_api_assign_without_jbilling_data(text, integer, text, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_assign_without_jbilling_data(text, integer, text, boolean) RETURNS SETOF ops_api_assign_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
   par_esn_hex                        text := $1;
   par_billing_entity_id              integer := $2;
   par_groupname                      text := $3;
   par_static_ip_boolean              boolean := $4;
   var_equipment_id                   integer;
   var_line_id                        integer;
   var_mdn                            text;
   var_username                       text;
   var_billing_entity_address_id      integer;
   var_static_ip                      text;
   var_conn_string                    text;
   var_serial_number                  text;
   var_line_start_date                date;
   var_line_equip_start_date          date;
   var_model_id                       integer;
   var_carrier                        text;
   var_sql                            text;
   var_return_row                     ops_api_assign_retval%ROWTYPE;
--   v_return_2                         integer;
   v_return_2                           record;
   var_sql_2                            text;
   v_product_Id                         integer;
   v_plan_type_id                       integer;
   v_length_days                        integer;
   v_line_ctr                           integer;


BEGIN

        PERFORM public.set_change_log_staff_id (3);

        -- Check if the parameters are null

        IF par_esn_hex = ''
--        OR par_sales_order = ''
        OR par_billing_entity_id IS NULL
        OR par_groupname = ''
        OR par_static_ip_boolean IS NULL THEN

               RAISE EXCEPTION 'All or some of the input values are null';
             
        ELSE

        -- Validate Parameters

            SELECT equipment_id INTO var_equipment_id
            FROM unique_identifier
            WHERE unique_identifier_type = 'ESN HEX'
            AND value = par_esn_hex;

            IF NOT FOUND THEN

               RAISE EXCEPTION 'The ESN HEX value entered doesnt exists';
              
            END IF;

         SELECT equipment_model_id INTO var_model_id
         FROM equipment
         WHERE equipment_id = var_equipment_id;

           IF NOT FOUND THEN

               RAISE EXCEPTION 'Equipment model doesnt exists.';
             
           END IF;

    -- Retrieve MDN value from Equipment_ID

        SELECT value INTO var_mdn
        FROM unique_identifier
        WHERE unique_identifier_type = 'MDN'
        AND equipment_id = var_equipment_id;

        IF NOT FOUND THEN

            RAISE EXCEPTION 'MDN Value doesnt exists for the Equipment';
            
        END IF;

        -- Retrieve username value using MDN value
        SELECT username INTO var_username
        FROM username
        WHERE SUBSTR(username,1,10) = var_mdn;


           IF NOT FOUND THEN

              RAISE EXCEPTION 'Username doesnt exists for the MDN value';
              
           END IF;

        -- Retrieve Serial Number value from unique_identifier

         SELECT value INTO var_serial_number
         FROM unique_identifier
         WHERE unique_identifier_type = 'SERIAL NUMBER'
         AND equipment_id = var_equipment_id;

          IF NOT FOUND THEN

               RAISE EXCEPTION 'Serial Number value doesnt exists for the Equipment.';
            
          END IF;

         -- Billing_entity_address_id retrieval
        SELECT address_id INTO var_billing_entity_address_id
        FROM billing_entity_address
        WHERE billing_entity_id = par_billing_entity_id;

         IF NOT FOUND THEN

            RAISE EXCEPTION 'Billing Entity Address doesnt exists';
            
         ELSE

            var_line_id :=  nextval('csctoss.line_line_id_seq');

           IF EXISTS ( SELECT TRUE  FROM line l JOIN  line_equipment le  USING (line_id) JOIN  unique_identifier ui USING (equipment_id) WHERE ui.unique_identifier_type = 'ESN HEX' AND ui.value = par_esn_hex AND le.end_date IS NULL) THEN
                        RAISE EXCEPTION 'Active Line already exists for the input parameters';

            ELSE

            -- Insert required fields values into line table

             INSERT INTO line(line_id, line_assignment_type, billing_entity_id, billing_entity_address_id, active_flag, line_label, start_date, date_created, radius_username, notes)
               VALUES (var_line_id, 'CUSTOMER ASSIGNED', par_billing_entity_id, var_billing_entity_address_id, TRUE, par_esn_hex, current_date, current_date, var_username, '');

               SELECT start_date INTO var_line_start_date
               FROM line WHERE line_id = var_line_id;

                   -- Update username table with SO_ORDER and Billing_Entity_ID

                    UPDATE username SET notes = '',
                           billing_entity_id = par_billing_entity_id
                    WHERE username = var_username;

                      IF NOT FOUND THEN

                         RAISE EXCEPTION 'Username Update Failed!';

                      END IF;

           END IF;

         END IF;

         IF NOT EXISTS (SELECT TRUE FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date IS NULL) THEN

         -- If no active line exists for the equipment then Insert line, equipment details.

                INSERT INTO line_equipment(line_id, equipment_id, start_date, billing_entity_address_id)
                     VALUES (var_line_id, var_equipment_id, current_date, var_billing_entity_address_id);

                 IF NOT FOUND THEN

                    RAISE EXCEPTION 'Line_Equipment Insert Failed!';

                 END IF;

                SELECT start_date INTO var_line_equip_start_date
                FROM line_equipment
                WHERE line_id = var_line_id
                AND equipment_id = var_equipment_id;

          ELSE

                 RAISE EXCEPTION 'Equipment is already assigned to a line';
              
          END IF;

           -- Update usergroup table with input groupname.

             UPDATE usergroup SET groupname = par_groupname WHERE username LIKE var_username;

               -- SELECT carrier from equipment model table

                SELECT em.carrier
                INTO var_carrier
                FROM unique_identifier ui
                JOIN equipment e on ui.equipment_id = e.equipment_id
                JOIN equipment_model em on em.equipment_model_id = e.equipment_model_id
                WHERE
                  ui.value = par_esn_hex
                LIMIT 1;

          -- Assign static ip to radreply table.

          IF par_static_ip_boolean = 'FALSE' THEN

              INSERT INTO radreply (username, attribute, op, value, priority)
                   VALUES (var_username, 'Class', '=', var_line_id::text, 10);

                IF NOT FOUND THEN

                   RAISE EXCEPTION 'Radreply Update Failed!';

                END IF;

           ELSE

                SELECT * INTO var_static_ip FROM ops_api_static_ip_assign(var_carrier,par_groupname,var_username,var_line_id,par_billing_entity_id);

        END IF;

      --Connect to jbilling and query the function ops_api_prov_line, for provisioning line.

 --         var_conn_string := 'hostaddr=10.17.70.25'||' port=5440'||' dbname=jbilling'||' user=jbilling'||' password=wrub5N4b';
/*
          var_sql := 'select * from oss.assign_device_jbilling( '|| quote_literal(upper(par_sales_order)) ||' , '||quote_literal(par_esn_hex)||' , '||quote_literal(var_serial_number)||' , '||quote_literal(var_username)||' ,'||var_line_id||')';
  
           FOR var_return_row IN
               
             SELECT * FROM public.dblink(fetch_jbilling_conn(), var_sql) 
                AS rec_type (result_code boolean)

               LOOP

                    IF (var_return_row.result_code = 'FALSE') THEN
 
                       RAISE EXCEPTION 'Jbilling Provisioning Failed.';

                   END IF;

           END LOOP;
*/

/*
       ---    start of code to insert plan_table
raise notice 'debug 200';
--        var_sql_2:='select 1234 from prov_line limit 1';
raise notice 'debug 220 :line_id=%',var_line_id;
        var_sql_2:='select i.external_id
        from prov_line pl,item i
        where 1=1
        and pl.item_id = i.id
        and pl.end_date is null
        and pl.archived is null
        and pl.line_id =' || var_line_id ||
        ' limit 1'
        ;

raise notice 'debug 350';

     --var_conn_string := 'hostaddr=10.17.70.25'||' port=5440'||' dbname=jbilling'||' user=jbilling'||' password=wrub5N4b';
--     var_conn_string := 'hostaddr=192.168.144.146'||' port=5440'||' dbname=jbilling'||' user=jbilling'||' password=wrub5N4b';
raise notice 'debug 500';
        RAISE NOTICE 'var_sql_2 dump = %',var_sql_2;
    FOR v_return_2 IN
          SELECT * FROM public.dblink(fetch_jbilling_conn(), var_sql_2) 
              AS rec_type (result_value integer)
    loop
       v_line_ctr:=0;
       v_line_ctr:=v_line_ctr + 1;

       select product_id, plan_type_id, length_days into v_product_id,v_plan_type_id,v_length_days
       from product
       where 1=1
         and  product_id = v_return_2.result_value ;
       
        IF NOT FOUND THEN
        
           RAISE EXCEPTION 'ERROR: External code not present in Product table';

       END IF;
--
       insert into plan
       (
        -- plan_id
         length_days,
         plan_type_id,
         comment ,
         create_timestamp,
         product_id,
         staff_id,
         line_id ,
         start_date,
         end_date ,
         prepaid_unit ,
         prepaid_allowance,
         prepaid_balance,
         accounting_start_date ,
         sales_order_number
       )
       values
       (
         v_length_days,
         v_plan_type_id ,
         par_sales_order, --comment ,
         current_timestamp,
         v_product_id,
         3, --staff_id,
         var_line_id ,
         current_date,
         null,  -- end_date ,
         null,  --prepaid_unit ,
         null, --prepaid_allowance,
         null,  --prepaid_balance,
         current_date,  --accounting_start_date ,
         null  --sales_order_number
       );
    end loop;
      if v_line_ctr > 0 then
          null;
      else
          
          RAISE EXCEPTION 'Error: No rows inserted into plan table.';
          
     end if; 
*/
       END IF;
              var_return_row.result_code := true;
              var_return_row.error_message := 'Line assignment is done succesfully.';
              RETURN NEXT var_return_row;
              RETURN;

 END;
  $_$;


ALTER FUNCTION csctoss.ops_api_assign_without_jbilling_data(text, integer, text, boolean) OWNER TO csctoss_owner;

--
-- Name: ops_api_create_customer_oss_jbilling(integer, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, integer, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_create_customer_oss_jbilling(integer, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, integer, integer) RETURNS SETOF ops_api_expire_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_parent_id                    integer := $1;
  par_org_name                     text := $2;
  par_line1                        text := $3;
  par_line2                        text := $4;
  par_city                         text := $5;
  par_state_code                   text := $6;
  par_postal_code                  text := $7;
  par_phone_number1                text := $8;
  par_phone_number2                text := $9;
  par_fax_number1                  text := $10;
  par_fax_number2                  text := $11;
  par_customer_url                 text := $12;
  par_location_name                text := $13;
  par_billing_entity_type          text := $14;
  par_preferred_timezone           text := $15;
  par_username                     text := $16;
  par_email                        text := $17;
  par_country_code                 text := $18;
  par_first_name                   text := $19;
  par_last_name                    text := $20;
  par_is_parent                    integer := $21;
  par_staff_id                     integer := $22;
  var_bid                          integer;
  var_phone_area_code              integer;
  var_phone_number                 integer;
  var_phone2_area_code             integer;
  var_phone2_phone_number          integer;
  var_fax_area_code                integer;
  var_fax_phone_number             integer;
  var_conn_string                  text;
  var_sql                          text;
  var_result                       boolean;
  var_return_row                   ops_api_expire_retval%ROWTYPE;


BEGIN

  IF par_staff_id IS NULL THEN
    RAISE EXCEPTION 'Staff ID is required.';
  END IF;

  PERFORM public.set_change_log_staff_id(par_staff_id);

  --====================================================================--
  --CHECK PARAMS
  --====================================================================--

  IF par_line1 is NULL THEN
    var_return_row.result_code := FALSE;
    var_return_row.error_message := 'Street Address1 is required.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;

  IF par_city is NULL THEN
    var_return_row.result_code := FALSE;
    var_return_row.error_message := 'CITY is required.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;

  IF par_state_code is NULL THEN
    var_return_row.result_code := FALSE;
    var_return_row.error_message := 'STATE CODE is required.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;

  IF par_postal_code is NULL THEN
    var_return_row.result_code := FALSE;
    var_return_row.error_message := 'Postal code is required.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;

  IF par_org_name is NULL THEN
    var_return_row.result_code := FALSE;
    var_return_row.error_message := 'Company name is required.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;

  IF par_phone_number1 is NULL THEN
    var_return_row.result_code := FALSE;
    var_return_row.error_message := 'Phone number 1 is required.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;

  IF par_username IS NULL THEN
    var_return_row.result_code := FALSE;
    var_return_row.error_message := 'Username is required.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;

  IF par_email IS NULL THEN
    var_return_row.result_code := FALSE;
    var_return_row.error_message := 'Email address is required.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;

  IF par_country_code IS NULL THEN
    var_return_row.result_code := FALSE;
    var_return_row.error_message := 'Country Code is required.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;

  IF par_first_name IS NULL THEN
    var_return_row.result_code := FALSE;
    var_return_row.error_message := 'First Name is required.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;

  IF par_last_name IS NULL THEN
    var_return_row.result_code := FALSE;
    var_return_row.error_message := 'Last Name is required.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;

  IF par_billing_entity_type IS NULL THEN
    var_return_row.result_code := FALSE;
    var_return_row.error_message := 'Billing Entity Type is required.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;
/*
  IF par_location_name IS NULL THEN
    var_return_row.result_code := FALSE;
    var_return_row.error_message := 'Location Name is required.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;
*/
  IF par_preferred_timezone IS NULL THEN
    var_return_row.result_code := FALSE;
    var_return_row.error_message := 'Preferred Timezone is required.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;

  IF par_parent_id IS NULL THEN
    par_parent_id := NULL;
  END IF;

  --====================================================================--
  --CREATE ADDRESS
  --====================================================================--
  INSERT INTO address
    (line1, line2, city, state_code, postal_code)
  VALUES
    (par_line1, par_line2, par_city, par_state_code, par_postal_code);

--====================================================================--
--CREATE BILLING ENTITY
--====================================================================--
  INSERT INTO billing_entity
    (parent_billing_entity_id, name, phone_number1, phone_number2, fax_number1, fax_number2, url, preferred_timezone, billing_entity_type, opt_in_flag)
  VALUES
    (par_parent_id, par_org_name, par_phone_number1, par_phone_number2, par_fax_number1, par_fax_number2, par_customer_url, par_preferred_timezone, par_billing_entity_type, FALSE);

  --====================================================================--
  -- CREATE BILLING ENTITY ADDRESS
  --====================================================================--
  INSERT INTO billing_entity_address
    (billing_entity_id, address_type, address_id)
  VALUES
    ((SELECT billing_entity_id FROM billing_entity WHERE name = par_org_name LIMIT 1), 'MAILING', (SELECT address_id FROM address WHERE postal_code = par_postal_code AND line1 = par_line1 LIMIT 1));


  --====================================================================--
  -- CREATE a new customer on JBilling
  --====================================================================--
  RAISE INFO '[Created new customer on OSS]';

  SELECT billing_entity_id INTO var_bid FROM billing_entity WHERE name = par_org_name LIMIT 1;

  SELECT substring(par_phone_number1 FROM 1 for  3) INTO var_phone_area_code::integer;
  SELECT substring(par_phone_number1 FROM 4 for 10) INTO var_phone_number::integer;
  SELECT substring(par_phone_number2 FROM 1 for  3) INTO var_phone2_area_code::integer;
  SELECT substring(par_phone_number2 FROM 4 for 10) INTO var_phone2_phone_number::integer;
  SELECT substring(par_fax_number1   FROM 1 for  3) INTO var_fax_area_code::integer;
  SELECT substring(par_fax_number1   FROM 4 for 10) INTO var_fax_phone_number::integer;

  -- Debug parameters for JBilling
  RAISE INFO '------------------------------------------------------';
  RAISE INFO 'quote_literal(par_username) = %', par_username;
  RAISE INFO 'quote_literal(par_email) = %', par_email;
  RAISE INFO 'quote_literal(par_line1) = %', par_line1;
  RAISE INFO 'quote_literal(par_line2) = %', par_line2;
  RAISE INFO 'quote_literal(par_city) = %', par_city;
  RAISE INFO 'quote_literal(par_country_code) = %', par_country_code;
  RAISE INFO 'quote_literal(par_first_name) = %', par_first_name;
  RAISE INFO 'quote_literal(par_last_name) = %', par_last_name;
  RAISE INFO 'quote_literal(par_org_name) = %', par_org_name;
  RAISE INFO 'var_fax_area_code = %', var_fax_area_code;
  RAISE INFO 'var_fax_phone_number = %', var_fax_phone_number;
  RAISE INFO 'var_phone_area_code = %', var_phone_area_code;
  RAISE INFO 'var_phone_number = %', var_phone_number;
  RAISE INFO 'var_phone2_area_code = %', var_phone2_area_code;
  RAISE INFO 'var_phone2_phone_number = %', var_phone2_phone_number;
  RAISE INFO 'quote_literal(par_postal_code) = %', par_postal_code;
  RAISE INFO 'quote_literal(par_state_code) = %', par_state_code;
  RAISE INFO 'var_bid = %', var_bid;
  RAISE INFO 'par_is_parent = %', par_is_parent;
  RAISE INFO 'par_parent_id = %', par_parent_id;
  RAISE INFO '------------------------------------------------------';

  --Connect to jbilling and query the function oss.create_jbilling_customer, for creating customer in jBilling.
  var_sql := 'SELECT * FROM oss.create_jbilling_customer('
  || quote_literal(par_username)
  || ' , '
  || quote_literal(par_email)
  || ' , '
  || quote_literal(par_line1)
  || ' , '
  || quote_literal(par_line2)
  || ' , '
  || quote_literal(par_city)
  || ' , '
  || quote_literal(par_country_code)
  || ' , '
  || quote_literal(par_first_name)
  || ' , '
  || quote_literal(par_last_name)
  || ' , '
  || quote_literal(par_org_name)
  || ' , '
  || var_fax_area_code
  || ' , '
  || var_fax_phone_number
  || ' , '
  || var_phone_area_code
  || ' , '
  || var_phone_number
  || ' , '
  || var_phone2_area_code
  || ' , '
  || var_phone2_phone_number
  || ' , '
  || quote_literal(par_postal_code)
  || ' , '
  || quote_literal(par_state_code)
  || ' , '
  || var_bid
  || ' , '
  || par_is_parent
  || ' , '
  || CASE WHEN par_parent_id::text IS NULL THEN 'NULL' ELSE par_parent_id::text END
  || ')';

  RAISE INFO '------------------------------------------------------';
  RAISE INFO '[SQL] %', var_sql;
  RAISE INFO '------------------------------------------------------';


  SELECT * INTO var_result FROM public.dblink(fetch_jbilling_conn(), var_sql) AS rec_type (result_code boolean);
  --SELECT * INTO var_result FROM public.dblink(fetch_jbilling_conn(), 'SELECT false') AS rec_type (result_code boolean);
  IF (var_result = FALSE) THEN
    var_return_row.result_code := FALSE;
    var_return_row.error_message := 'ERROR: Customer Creation in jBilling Failed..';
    RETURN NEXT var_return_row;
    RETURN;
  ELSE
    var_return_row.result_code := TRUE;
    var_return_row.error_message := 'New customer successfully created in OSS and jBilling.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;

END;
$_$;


ALTER FUNCTION csctoss.ops_api_create_customer_oss_jbilling(integer, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, integer, integer) OWNER TO csctoss_owner;

--
-- Name: ops_api_expire(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_expire(text) RETURNS SETOF ops_api_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
    var_return_row                ops_api_retval%ROWTYPE;
BEGIN
    select * INTO var_return_row from ops_api_expire($1, true);
    RETURN NEXT var_return_row;
    RETURN;

END;
$_$;


ALTER FUNCTION csctoss.ops_api_expire(text) OWNER TO csctoss_owner;

--
-- Name: ops_api_expire(text, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_expire(text, boolean) RETURNS SETOF ops_api_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

    par_esn_hex                   text := $1;
    par_bypass_jbilling           boolean := $2;
    var_equipment_id              integer;
    var_line_id                   integer;
    var_username                  text;
    --var_mdn                     text;
    var_static_ip                 text;
    var_usergroup_id              integer;
    var_conn_string               text;
    var_sql                       text;
    v_numrows                     integer;
    var_return_row                ops_api_retval%ROWTYPE;

    v_errmsg                      text;

BEGIN
    PERFORM public.set_change_log_staff_id (3);

    v_errmsg := 'ERROR:  Input ESN HEX Is Null. Please enter a value.';
    IF par_esn_hex = '' THEN
        RAISE EXCEPTION '';
    ELSE
        -- Validate parameters.
        v_errmsg := 'ERROR:  ESN HEX value doesnt exist.';
        SELECT equipment_id INTO var_equipment_id
        FROM unique_identifier
        WHERE unique_identifier_type = 'ESN HEX'
        AND value = par_esn_hex;

        IF NOT FOUND THEN
            RAISE EXCEPTION '';
        END IF;
    END IF;

    RAISE NOTICE 'Equipment id: %', var_equipment_id;
    -- Retrieve line_id using equipment_id
    SELECT line_id INTO var_line_id
      FROM line_equipment
     WHERE equipment_id = var_equipment_id
       AND end_date IS NULL;

    v_errmsg := 'ERROR:  Username does not exist for this device';
    SELECT radius_username INTO var_username 
      FROM line 
     WHERE line_id = var_line_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION '';
    END IF;

    RAISE NOTICE 'line_id: %', var_line_id;
    RAISE NOTICE 'radius_username: %', var_username;
    -- Deallocate static IP address and delete radreply records.
    IF EXISTS (SELECT TRUE FROM radreply WHERE username LIKE var_username) THEN
        SELECT value INTO var_static_ip
        FROM radreply
        WHERE username = var_username
        AND attribute = 'Framed-IP-Address';

        IF NOT FOUND THEN
            RAISE NOTICE 'ed-IP-Address does not exist in RADREPLY for this device';
        END IF;

        RAISE NOTICE 'var_static_ip: %', var_static_ip;
        IF EXISTS ( SELECT TRUE FROM static_ip_pool WHERE static_ip = var_static_ip AND line_id = var_line_id ) THEN
            UPDATE static_ip_pool 
               SET is_assigned = 'FALSE'
                  ,line_id = NULL
             WHERE static_ip = var_static_ip 
               AND line_id = var_line_id;

        END IF;

        DELETE FROM radreply WHERE username = var_username;
    END IF;

    -- To suspend an assigned device which is not expired
    IF (SELECT TRUE FROM username WHERE username LIKE var_username) THEN

        IF var_username ~ '@vzw' THEN
            IF NOT EXISTS( SELECT TRUE 
                             FROM usergroup 
                            WHERE username LIKE var_username 
                              AND groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione') THEN

                v_errmsg := 'ERROR:  Insert failed for usergroup, username:  ' || var_username;
                INSERT INTO usergroup(username, groupname, priority)
                VALUES (var_username, 'SERVICE-vzwretail_wallgarden_cnione', 2);

                GET DIAGNOSTICS v_numrows = ROW_COUNT;
                IF v_numrows = 0 THEN
                    RAISE EXCEPTION '';
                END IF;
                RAISE NOTICE 'VZW Username % inserted into usergroup.';
            END IF;
        ELSE
            IF NOT EXISTS( SELECT TRUE 
                             FROM usergroup 
                            WHERE username LIKE var_username 
                              AND groupname LIKE '%disconnected' 
                              AND priority = 1) THEN

                v_errmsg := 'ERROR2:  Insert failed for usergroup, username:  ' || var_username;
                INSERT INTO usergroup(username, groupname, priority)
                VALUES (var_username, 'disconnected', 1);

                GET DIAGNOSTICS v_numrows = ROW_COUNT;
                IF v_numrows = 0 THEN
                    RAISE EXCEPTION '';
                END IF;
                RAISE NOTICE 'Non VZW Username % inserted into usergroup.';
            END IF;
        END IF;
    END IF;

    v_errmsg := 'ERROR:  Line associated to the equipment has already expired';
    IF EXISTS ( SELECT TRUE 
                  FROM line_equipment 
                 WHERE line_id = var_line_id 
                   AND end_date IS NULL) THEN
 
        v_errmsg := 'ERROR:  Update Failed for line_equipment:  ' || var_equipment_id;
        UPDATE line_equipment SET end_date = current_date
        WHERE line_id = var_line_id
        AND equipment_id = var_equipment_id;

        GET DIAGNOSTICS v_numrows = ROW_COUNT;
        IF v_numrows = 0 THEN
            RAISE EXCEPTION '';
        END IF;

        -- UPDATE line end_date too
        v_errmsg := 'ERROR:  Update Failed for line:  ' || var_line_id;
        UPDATE line
        SET end_date = current_date,
            radius_username = null,
            line_label = null
        WHERE line_id = var_line_id;

        GET DIAGNOSTICS v_numrows = ROW_COUNT;
        IF v_numrows = 0 THEN
            RAISE EXCEPTION '';
        END IF;
    ELSE
        RAISE EXCEPTION '' ;
    END IF ;

    /*connect to jbilling to cancel*/
    IF (par_bypass_jbilling = FALSE) THEN
        v_errmsg := 'ERROR:  Jbilling Provisioning Failed.';
        var_sql := 'select * from oss.archive_equipment('||quote_literal(par_esn_hex)||')';
        FOR var_return_row IN
            SELECT * FROM public.dblink(fetch_jbilling_conn(), var_sql) AS rec_type (result_code boolean)
        LOOP
            IF (var_return_row.result_code = 'FALSE') THEN
                RAISE EXCEPTION '';
            END IF;
        END LOOP;
    END IF;

    var_return_row.result_code := 'true';
    var_return_row.error_message := 'Line associated to the equipment is now expired';
    RETURN NEXT var_return_row;
    RETURN;

EXCEPTION
    WHEN raise_exception THEN
      var_return_row.result_code := false;
      var_return_row.error_message:=v_errmsg;
      RAISE NOTICE 'rt_oss_rma: when raise_exception:  % ',v_errmsg;
      RETURN NEXT var_return_row;
      RETURN;

    WHEN others THEN
      v_errmsg := 'Unknown error!';
      var_return_row.result_code := false;
      var_return_row.error_message := v_errmsg;
      RAISE NOTICE 'OTHER EXCEPTION:  %', v_errmsg;
      RETURN NEXT var_return_row;
      RETURN;

END;
$_$;


ALTER FUNCTION csctoss.ops_api_expire(text, boolean) OWNER TO csctoss_owner;

--
-- Name: ops_api_expire_bulk(text, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_expire_bulk(text, integer) RETURNS SETOF ops_api_expire_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_esn_hex                   text := $1;
  par_staff_id			integer :=$2 ;
  var_equipment_id              integer;
  var_line_id                   integer;
  var_username                  text;
  --var_mdn                     text;
  var_static_ip                 text;
  var_usergroup_id              integer;
  var_conn_string               text;
  var_sql                       text;
  var_return_row                ops_api_expire_retval%ROWTYPE;

 
BEGIN

 
   PERFORM public.set_change_log_staff_id (par_staff_id);

    IF par_esn_hex = '' THEN 
  
	 --RAISE EXCEPTION 'Input ESN HEX Is Null. Please enter a value ';
	 var_return_row.result_code  	= 'FALSE' ;
	 var_return_row.error_message 	= 'Input ESN HEX Is Null. Please enter a value' ; 
	 RETURN NEXT var_return_row ;
	 RETURN;
	 EXIT;
    ELSE 
  
          -- Validate parameters.
         SELECT equipment_id INTO var_equipment_id
         FROM unique_identifier
         WHERE unique_identifier_type = 'ESN HEX'
         AND value = par_esn_hex;

         IF NOT FOUND THEN
           --RAISE EXCEPTION 'ESN HEX value doesnt exists'; 
           var_return_row.result_code  		= 'FALSE' ;
	   var_return_row.error_message 	= 'ESN HEX value doesnt exist' ; 
	   RETURN NEXT var_return_row ;
	   RETURN;
	   EXIT;
         END IF;
   END IF;   
-- Retrieve line_id using equipment_id 

     SELECT line_id INTO var_line_id 
     FROM line_equipment 
     WHERE equipment_id = var_equipment_id
     AND end_date IS NULL;	 

     SELECT radius_username INTO var_username FROM line WHERE line_id = var_line_id;

     IF NOT FOUND THEN 
        --RAISE EXCEPTION 'Username doesnt exists for the device';
	var_return_row.result_code  	= 'FALSE' ;
	var_return_row.error_message 	= 'Username doesnt exists for the device' ; 
	RETURN NEXT var_return_row ;
	RETURN;
	EXIT;     
     END IF;	

      
     IF EXISTS (SELECT TRUE FROM radreply WHERE username LIKE var_username) THEN 
    
         SELECT 
          value 
         INTO 
          var_static_ip 
         FROM  radreply 
         WHERE username = var_username 
         AND   attribute = 'Framed-IP-Address'; 

         IF EXISTS ( SELECT TRUE FROM static_ip_pool WHERE static_ip = var_static_ip AND line_id = var_line_id ) THEN 
           UPDATE static_ip_pool 
           SET 
            is_assigned = 'FALSE', 
            line_id = NULL 
           WHERE static_ip = var_static_ip 
           AND   line_id = var_line_id; 
         END IF;
         
         DELETE FROM radreply WHERE username = var_username; 

      END IF; 
	  -- To Suspend an assigned device which is not expired

       	  IF (SELECT TRUE FROM username WHERE username LIKE var_username) THEN 

	      IF NOT EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND groupname LIKE 'disconnected' and priority = 1) THEN 

		    INSERT INTO usergroup(username, groupname, priority)
	              VALUES (var_username, 'disconnected', 1);

			   IF NOT FOUND THEN

                              --RAISE EXCEPTION 'Insert Failed';
				var_return_row.result_code  	= 'FALSE' ;
				var_return_row.error_message 	= 'Insert into usergroup failed' ; 
				RETURN NEXT var_return_row ;
				RETURN;
				EXIT;                   

			   END IF;

	               
              END IF;

        END IF;
 
               IF EXISTS ( SELECT TRUE FROM line_equipment WHERE line_id = var_line_id AND end_date IS NULL) THEN 
            
                   UPDATE line_equipment SET end_date = current_date 
                   WHERE line_id = var_line_id 
                   AND equipment_id = var_equipment_id;
		   
                  -- UPDATE line end_date too 
 
                   UPDATE line SET end_date = current_date,
                                   radius_username = null,
                                   line_label = null
                   WHERE line_id = var_line_id;
		   
                    IF NOT FOUND THEN 

			--RAISE EXCEPTION 'Update Failed';
			var_return_row.result_code  	= 'FALSE' ;
			var_return_row.error_message 	= 'Update failed on line table' ; 
			RETURN NEXT var_return_row ;
			RETURN;
			EXIT;                       

                    END IF;

             ELSE 

                 RAISE EXCEPTION 'Line associated to the equipment has already expired' ;
		var_return_row.result_code  	= 'FALSE' ;
		var_return_row.error_message 	= 'Update failed on line table' ; 
		RETURN NEXT var_return_row ;
		RETURN;
		EXIT;                       

       	     END IF ;


	/*connect to jbilling to cancel*/

         var_sql := 'select * from oss.archive_equipment('||quote_literal(par_esn_hex)||')';
    
         FOR var_return_row IN
      
          SELECT * FROM public.dblink(fetch_jbilling_conn(), var_sql) 
                 AS rec_type (result_code boolean)

               LOOP

                    IF (var_return_row.result_code = 'FALSE') THEN

                        --RAISE EXCEPTION 'Jbilling Provisioning Failed.';
                        var_return_row.result_code  	= 'FALSE' ;
			var_return_row.error_message 	= 'Jbilling side cancellation failed' ; 
			RETURN NEXT var_return_row ;
			RETURN;
			EXIT;                       
                          
                   END IF;
               END LOOP;

 var_return_row.result_code := true;
  var_return_row.error_message := 'Line associated to the equipment is now expired';
  RETURN NEXT var_return_row;
  RETURN;

END;
$_$;


ALTER FUNCTION csctoss.ops_api_expire_bulk(text, integer) OWNER TO csctoss_owner;

--
-- Name: ops_api_expire_ex(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_expire_ex(text) RETURNS SETOF ops_api_expire_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
  var_return_row                ops_api_expire_retval%ROWTYPE;
BEGIN
  select * INTO var_return_row from ops_api_expire_ex($1, false);
  RETURN NEXT var_return_row;
  RETURN;

END;
$_$;


ALTER FUNCTION csctoss.ops_api_expire_ex(text) OWNER TO csctoss_owner;

--
-- Name: ops_api_expire_ex(text, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_expire_ex(text, boolean) RETURNS SETOF ops_api_expire_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_esn_hex                   text := $1;
  par_bypass_jbilling           boolean := $2;
  var_equipment_id              integer;
  var_line_id                   integer;
  var_username                  text;
  --var_mdn                     text;
  var_static_ip                 text;
  var_usergroup_id              integer;
  var_conn_string               text;
  var_sql                       text;
  var_return_row                ops_api_expire_retval%ROWTYPE;

BEGIN
  PERFORM public.set_change_log_staff_id (3);

  IF par_esn_hex IS NULL OR par_esn_hex = '' THEN
    var_return_row.result_code := false;
    var_return_row.error_message := 'Input ESN HEX is NULL or empty. Please enter a value.';
    RETURN NEXT var_return_row;
    RETURN;
  ELSE
    -- Validate parameters.
    SELECT equipment_id INTO var_equipment_id
    FROM unique_identifier
    WHERE unique_identifier_type = 'ESN HEX'
    AND value = par_esn_hex;

    IF NOT FOUND THEN
      var_return_row.result_code := false;
      var_return_row.error_message := 'ESN HEX value does not exists.';
      RETURN NEXT var_return_row;
      RETURN;
    END IF;
  END IF;

  -- Retrieve line_id using equipment_id
  SELECT line_id INTO var_line_id
  FROM line_equipment
  WHERE equipment_id = var_equipment_id
  AND end_date IS NULL;

  SELECT radius_username INTO var_username FROM line WHERE line_id = var_line_id;
  IF NOT FOUND THEN
    var_return_row.result_code := false;
    var_return_row.error_message := 'Username does not exists for the device.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF;

  -- Deallocate static IP address and delete radreply records.
  IF EXISTS (SELECT TRUE FROM radreply WHERE username LIKE var_username) THEN
    SELECT value INTO var_static_ip
    FROM radreply
    WHERE username = var_username
    AND attribute = 'Framed-IP-Address';

    IF EXISTS ( SELECT TRUE FROM static_ip_pool WHERE static_ip = var_static_ip AND line_id = var_line_id ) THEN
      UPDATE static_ip_pool SET is_assigned = 'FALSE', line_id = NULL
      WHERE static_ip = var_static_ip AND line_id = var_line_id;
    END IF;

    DELETE FROM radreply WHERE username = var_username;
    --DELETE FROM radcheck WHERE username = var_username;

  END IF;

  -- To Suspend an assigned device which is not expired
  IF (SELECT TRUE FROM username WHERE username LIKE var_username) THEN

    IF var_username ~ '@vzw' THEN
      IF NOT EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione') THEN
        INSERT INTO usergroup(username, groupname, priority)
        VALUES (var_username, 'SERVICE-vzwretail_wallgarden_cnione', 2);
      END IF;
    ELSE
      IF NOT EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND groupname LIKE '%disconnected' AND priority = 1) THEN
        INSERT INTO usergroup(username, groupname, priority)
        VALUES (var_username, 'disconnected', 1);
      END IF;
    END IF;

  END IF;

  IF EXISTS ( SELECT TRUE FROM line_equipment WHERE line_id = var_line_id AND end_date IS NULL) THEN
    UPDATE line_equipment SET end_date = current_date
    WHERE line_id = var_line_id
    AND equipment_id = var_equipment_id;

    -- UPDATE line end_date too
    UPDATE line SET end_date = current_date,
                    radius_username = null,
                    line_label = null
    WHERE line_id = var_line_id;
    IF NOT FOUND THEN
      var_return_row.result_code := false;
      var_return_row.error_message := 'Updating line.end_date failed.';
      RETURN NEXT var_return_row;
      RETURN;
    END IF;

  ELSE
    var_return_row.result_code := false;
    var_return_row.error_message := 'Line associated to the equipment has already expired.';
    RETURN NEXT var_return_row;
    RETURN;
  END IF ;


  /*connect to jbilling to cancel*/
  IF (par_bypass_jbilling = FALSE) THEN
    var_sql := 'SELECT * FROM oss.archive_equipment(' || quote_literal(par_esn_hex) || ')';
    FOR var_return_row IN
      SELECT * FROM public.dblink(fetch_jbilling_conn(), var_sql) AS rec_type (result_code boolean)
    LOOP
      IF (var_return_row.result_code = 'FALSE') THEN
        var_return_row.result_code := false;
        var_return_row.error_message := 'Jbilling Provisioning Failed.';
        RETURN NEXT var_return_row;
        RETURN;
      END IF;
    END LOOP;
  END IF;
  
  var_return_row.result_code := true;
  var_return_row.error_message := 'Line associated to the equipment is now expired';
  RETURN NEXT var_return_row;
  RETURN;

EXCEPTION
  WHEN OTHERS THEN
    var_return_row.result_code := false;
    var_return_row.error_message := 'Exception: Unknown exception happened.';
    RETURN NEXT var_return_row;
    RETURN;
END;
$_$;


ALTER FUNCTION csctoss.ops_api_expire_ex(text, boolean) OWNER TO csctoss_owner;

--
-- Name: ops_api_expire_oss_only(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_expire_oss_only(text) RETURNS SETOF ops_api_expire_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_esn_hex                   text := $1;
  var_equipment_id              integer;
  var_line_id                   integer;
  var_username                  text;
  --var_mdn                     text;
  var_static_ip                 text;
  var_usergroup_id              integer;
  var_conn_string               text;
  var_sql                       text;
  var_return_row                ops_api_expire_retval%ROWTYPE;

 
BEGIN

 
   PERFORM public.set_change_log_staff_id (3);

    IF par_esn_hex = '' THEN 
  
	 RAISE EXCEPTION 'Input ESN HEX Is Null. Please enter a value ';
	
    ELSE 
  
          -- Validate parameters.
         SELECT equipment_id INTO var_equipment_id
         FROM unique_identifier
         WHERE unique_identifier_type = 'ESN HEX'
         AND value = par_esn_hex;

           IF NOT FOUND THEN
      
               RAISE EXCEPTION 'ESN HEX value doesnt exists'; 
 
           END IF;

   END IF;   
-- Retrieve line_id using equipment_id 

     SELECT line_id INTO var_line_id 
     FROM line_equipment 
     WHERE equipment_id = var_equipment_id
     AND end_date IS NULL;	 

     SELECT radius_username INTO var_username FROM line WHERE line_id = var_line_id;

           IF NOT FOUND THEN 
     
              RAISE EXCEPTION 'Username doesnt exists for the device';
     
           END IF;	

      
     IF EXISTS (SELECT TRUE FROM radreply WHERE username LIKE var_username) THEN 
    
         SELECT value INTO var_static_ip 
         FROM radreply 
         WHERE username = var_username 
         AND attribute = 'Framed-IP-Address'; 


         IF EXISTS ( SELECT TRUE FROM static_ip_pool WHERE static_ip = var_static_ip AND line_id = var_line_id ) THEN 

             UPDATE static_ip_pool SET is_assigned = 'FALSE', line_id = NULL 
             WHERE static_ip = var_static_ip AND line_id = var_line_id; 
    
         END IF;
         
           DELETE FROM radreply WHERE username = var_username; 
           --DELETE FROM radcheck WHERE username = var_username;

      

      END IF; 
	  -- To Suspend an assigned device which is not expired

       	  IF (SELECT TRUE FROM username WHERE username LIKE var_username) THEN 

	      IF NOT EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND groupname LIKE 'disconnected' and priority = 1) THEN 

		    INSERT INTO usergroup(username, groupname, priority)
	              VALUES (var_username, 'disconnected', 1);

			   IF NOT FOUND THEN

                              RAISE EXCEPTION 'Insert Failed';

			   END IF;

	               
              END IF;

        END IF;
 
               IF EXISTS ( SELECT TRUE FROM line_equipment WHERE line_id = var_line_id AND end_date IS NULL) THEN 
            
                   UPDATE line_equipment SET end_date = current_date 
                   WHERE line_id = var_line_id 
                   AND equipment_id = var_equipment_id;
		   
                  -- UPDATE line end_date too 
 
                   UPDATE line SET end_date = current_date,
                                   radius_username = null,
                                   line_label = null
                   WHERE line_id = var_line_id;
		   
                    IF NOT FOUND THEN 

                       RAISE EXCEPTION 'Update Failed';

                    END IF;

             ELSE 

                 RAISE EXCEPTION 'Line associated to the equipment has already expired' ;

       	     END IF ;


	/*connect to jbilling to cancel*/
	 --var_conn_string := 'hostaddr=10.17.70.25'||' port=5440'||' dbname=jbilling'||' user=jbilling'||' password=wrub5N4b';

 /*        var_sql := 'select * from oss.archive_equipment('||quote_literal(par_esn_hex)||')';
    
         FOR var_return_row IN
      
          SELECT * FROM public.dblink(fetch_jbilling_conn(), var_sql) 
                 AS rec_type (result_code boolean)

               LOOP

                    IF (var_return_row.result_code = 'FALSE') THEN

                         RAISE EXCEPTION 'Jbilling Provisioning Failed.';
                          
                   END IF;
               END LOOP;
*/
 var_return_row.result_code := true; 
  var_return_row.error_message := 'Line associated to the equipment is now expired';
  RETURN NEXT var_return_row;
  RETURN;

END;
$_$;


ALTER FUNCTION csctoss.ops_api_expire_oss_only(text) OWNER TO csctoss_owner;

--
-- Name: ops_api_expire_oss_only_by_serial_num(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_expire_oss_only_by_serial_num(text) RETURNS SETOF ops_api_expire_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_esn_hex                   text := $1;
  var_equipment_id              integer;
  var_line_id                   integer;
  var_username                  text;
  --var_mdn                     text;
  var_static_ip                 text;
  var_usergroup_id              integer;
  var_conn_string               text;
  var_sql                       text;
  var_return_row                ops_api_expire_retval%ROWTYPE;

 
BEGIN

 
   PERFORM public.set_change_log_staff_id (3);

    IF par_esn_hex = '' THEN 
  
	 RAISE EXCEPTION 'Input ESN HEX Is Null. Please enter a value ';
	
    ELSE 
  
          -- Validate parameters.
         SELECT equipment_id INTO var_equipment_id
         FROM unique_identifier
         WHERE unique_identifier_type = 'SERIAL NUMBER'
         AND value = par_esn_hex;

           IF NOT FOUND THEN
      
               RAISE EXCEPTION 'ESN HEX value doesnt exists'; 
 
           END IF;

   END IF;   
-- Retrieve line_id using equipment_id 

     SELECT line_id INTO var_line_id 
     FROM line_equipment 
     WHERE equipment_id = var_equipment_id
     AND end_date IS NULL;	 

     SELECT radius_username INTO var_username FROM line WHERE line_id = var_line_id;

           IF NOT FOUND THEN 
     
              RAISE EXCEPTION 'Username doesnt exists for the device';
     
           END IF;	

      
     IF EXISTS (SELECT TRUE FROM radreply WHERE username LIKE var_username) THEN 
    
         SELECT value INTO var_static_ip 
         FROM radreply 
         WHERE username = var_username 
         AND attribute = 'Framed-IP-Address'; 


         IF EXISTS ( SELECT TRUE FROM static_ip_pool WHERE static_ip = var_static_ip AND line_id = var_line_id ) THEN 

             UPDATE static_ip_pool SET is_assigned = 'FALSE', line_id = NULL 
             WHERE static_ip = var_static_ip AND line_id = var_line_id; 
    
         END IF;
         
           DELETE FROM radreply WHERE username = var_username; 
           --DELETE FROM radcheck WHERE username = var_username;

      

      END IF; 
	  -- To Suspend an assigned device which is not expired

       	  IF (SELECT TRUE FROM username WHERE username LIKE var_username) THEN 

	      IF NOT EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND groupname LIKE 'disconnected' and priority = 1) THEN 

		    INSERT INTO usergroup(username, groupname, priority)
	              VALUES (var_username, 'disconnected', 1);

			   IF NOT FOUND THEN

                              RAISE EXCEPTION 'Insert Failed';

			   END IF;

	               
              END IF;

        END IF;
 
               IF EXISTS ( SELECT TRUE FROM line_equipment WHERE line_id = var_line_id AND end_date IS NULL) THEN 
            
                   UPDATE line_equipment SET end_date = current_date 
                   WHERE line_id = var_line_id 
                   AND equipment_id = var_equipment_id;
		   
                  -- UPDATE line end_date too 
 
                   UPDATE line SET end_date = current_date,
                                   radius_username = null,
                                   line_label = null
                   WHERE line_id = var_line_id;
		   
                    IF NOT FOUND THEN 

                       RAISE EXCEPTION 'Update Failed';

                    END IF;

             ELSE 

                 RAISE EXCEPTION 'Line associated to the equipment has already expired' ;

       	     END IF ;


	/*connect to jbilling to cancel*/
	 --var_conn_string := 'hostaddr=10.17.70.25'||' port=5440'||' dbname=jbilling'||' user=jbilling'||' password=wrub5N4b';

 /*        var_sql := 'select * from oss.archive_equipment('||quote_literal(par_esn_hex)||')';
    
         FOR var_return_row IN
      
          SELECT * FROM public.dblink(fetch_jbilling_conn(), var_sql) 
                 AS rec_type (result_code boolean)

               LOOP

                    IF (var_return_row.result_code = 'FALSE') THEN

                         RAISE EXCEPTION 'Jbilling Provisioning Failed.';
                          
                   END IF;
               END LOOP;
*/
 var_return_row.result_code := true; 
  var_return_row.error_message := 'Line associated to the equipment is now expired';
  RETURN NEXT var_return_row;
  RETURN;

END;
$_$;


ALTER FUNCTION csctoss.ops_api_expire_oss_only_by_serial_num(text) OWNER TO csctoss_owner;

--
-- Name: ops_api_line_equipment_unique_ids_info(text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_line_equipment_unique_ids_info(text, text) RETURNS SETOF ops_api_line_equipment_unique_ids_info_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_type                    text      := $1;
  par_value                   text      := $2;
  var_billing_entity_id       integer;
  var_unique_identifier_type  text;
  var_equipment_id            integer;
  var_line_id                 integer;
  var_equipment_type          text;
  var_serial_number           text;
  var_esn_hex                 text;
  var_esn_dec                 text;
  var_min                     text;
  var_mdn                     text;
  var_mac_address             text;
  var_uniqid_row              RECORD;
  v_query                     text;
  var_return_row              ops_api_line_equipment_unique_ids_info_retval%ROWTYPE;

BEGIN
  RAISE NOTICE 'Entering Function';

  IF LENGTH(TRIM(COALESCE(par_value, ''))) = 0  AND par_type = '' THEN
    RAISE EXCEPTION 'Input Values are Null.';
  ELSIF par_type = '' THEN
    RAISE EXCEPTION 'Type is Null. Enter either Unique_Identifier OR Billing_Entity_ID for Input Type.';
  ELSIF par_value = '' THEN
    RAISE EXCEPTION 'Value is Null. Enter the Unique_Identifier Value or Billing_Entity_ID value.';
  END IF;

  -- Validate parameters.
  IF par_type = 'Unique_Identifier' THEN
    v_query := 'SELECT ui.equipment_id AS equipment_id,
                       eq.equipment_type AS equipment_type,
                       lieq.line_id AS line_id
                FROM unique_identifier ui
                JOIN equipment eq ON(ui.equipment_id = eq.equipment_id)
                JOIN line_equipment lieq ON (ui.equipment_id = lieq.equipment_id)
                WHERE ui.unique_identifier_type IN (''ESN HEX'', ''ESN DEC'', ''MDN'', ''MIN'', ''SERIAL NUMBER'', ''MAC ADDRESS'', ''ESN HEX1'', ''ESN HEX2'', ''ESN DEC1'', ''ESN DEC2'', ''MIN1'', ''MIN2'', ''MDN1'', ''MDN2'')
                AND ui.value LIKE ' ||quote_literal('%'||par_value||'%')|| 'GROUP BY  ui.equipment_id, eq.equipment_type, lieq.line_id LIMIT 100';

   ELSIF par_type = 'Billing_Entity_ID' THEN
     var_billing_entity_id := (par_value)::integer;

     v_query :=  'SELECT line.line_id AS line_id,
                         lieq.equipment_id AS equipment_id,
                         eq.equipment_type AS equipment_type
                  FROM line
                  JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
                  JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
                  WHERE line.billing_entity_id = '||(var_billing_entity_id)||'LIMIT 100';
  END IF;

  FOR var_uniqid_row IN EXECUTE v_query
  LOOP
    var_equipment_id := var_uniqid_row.equipment_id ;
    var_line_id := var_uniqid_row.line_id;
    var_equipment_type := var_uniqid_row.equipment_type;

    -- Retrieve Serial Number and Mac Address for the obtained Equipment_Id Value. These are unique for all types of equipments.
    SELECT uid1.value INTO var_serial_number FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'SERIAL NUMBER'::text;
    SELECT uid1.value INTO var_mac_address FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MAC ADDRESS'::text;

    IF var_equipment_type = 'ROUTER' THEN
      -- Get all unique_identifier values for a Router
      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;
      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;
      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;
      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text;

    ELSIF var_equipment_type = 'CARD' THEN
      -- Get the unique_identifiers for the equipment type Card.
      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;
      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;
      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;
      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text;

    ELSIF var_equipment_type = 'MODULE' THEN
      -- Get the unique_identifiers for the equipment_type Module.
      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;
      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;
      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;
      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text;
    END IF;

  
    FOR var_return_row IN
      SELECT
        line.line_id,
        CASE
          WHEN line.active_flag  = 't' THEN 'TRUE'::text
          WHEN line.active_flag  = 'f' THEN 'FALSE'::text
          ELSE 'N/A'::text
        END AS active,
        line.line_assignment_type,
        lieq.start_date AS line_assignment_start,
        lieq.end_date AS line_assignment_end,
        eqmo.carrier,
        line.billing_entity_id,
        CASE
          WHEN line.billing_entity_id IS NOT NULL THEN
               ( SELECT billing_entity.name
                 FROM billing_entity
                 WHERE billing_entity.billing_entity_id = line.billing_entity_id)
          ELSE NULL::text
        END AS billing_entity,
        equp.equipment_id,
        equp.equipment_type,
        eqmo.model_number1,
        var_esn_hex,
        var_esn_dec,
        var_mac_address,
        var_serial_number,
        var_mdn,
        var_min,
        '', '', '', '', '', '', '', '',
        eqst.equipment_status_type,
        line.ip_pool,
        CASE
          WHEN line.radius_username IS NOT NULL THEN
               COALESCE(( SELECT radreply.value
               FROM radreply
               WHERE radreply.attribute::text = 'Framed-IP-Address'::text AND radreply.username::text = line.radius_username), 'N/A'::text::character varying)
          ELSE 'N/A'::character varying
        END AS static_ip_address,
       (SELECT count(*)::integer AS count
        FROM bp_billing_equipment_assignment bbea
        WHERE bbea.line_id = line.line_id AND 'now'::text::date >= bbea.start_date::date
        AND 'now'::text::date <= COALESCE(bbea.end_date::date::timestamp without time zone, 'now'::text::date + '1 day'::interval))
        AS number_active_charges,
        line.radius_username AS radius_username
      FROM equipment equp
      JOIN equipment_type eqty ON eqty.equipment_type = equp.equipment_type
      JOIN equipment_model eqmo ON eqmo.equipment_model_id = equp.equipment_model_id
      LEFT JOIN equipment_status eqst ON eqst.equipment_id = equp.equipment_id
      LEFT JOIN line_equipment lieq ON lieq.equipment_id = equp.equipment_id
      LEFT JOIN line ON line.line_id = lieq.line_id
      WHERE equp.equipment_id = var_equipment_id
      AND line.line_id = var_line_id

    LOOP
      RETURN NEXT var_return_row;
    END LOOP;


    IF (var_equipment_type = 'MULTI_NETWORK ROUTER') THEN

      FOR var_return_row IN
        SELECT
          line.line_id,
          CASE
            WHEN line.active_flag  = 't' THEN 'TRUE'::text
            WHEN line.active_flag  = 'f' THEN 'FALSE'::text
            ELSE 'N/A'::text
          END AS active, line.line_assignment_type, lieq.start_date AS line_assignment_start,
          lieq.end_date AS line_assignment_end, eqmo.carrier, line.billing_entity_id,
          CASE
            WHEN line.billing_entity_id IS NOT NULL THEN
                 ( SELECT billing_entity.name
                   FROM billing_entity
                   WHERE billing_entity.billing_entity_id = line.billing_entity_id)
            ELSE NULL::text
          END AS billing_entity,
          equp.equipment_id,
          equp.equipment_type,
          eqmo.model_number1,
          var_esn_hex,
          var_esn_dec,
          var_mac_address,
          var_serial_number,
          var_mdn,
          var_min,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN HEX1'::text) AS esn_hex1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN HEX2'::text) AS esn_hex2,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN DEC1'::text) AS esn_dec1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN DEC2'::text) AS esn_dec2,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MIN1'::text) AS min1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MIN2'::text) AS min2,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MDN1'::text) AS mdn1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MDN2'::text) AS mdn2,
          eqst.equipment_status_type,
          line.ip_pool,
          CASE
            WHEN line.radius_username IS NOT NULL THEN
                 COALESCE(( SELECT radreply.value
                            FROM radreply
                            WHERE radreply.attribute::text = 'Framed-IP-Address'::text AND radreply.username::text = line.radius_username), 'N/A'::text::character varying)
            ELSE 'N/A'::character varying
          END AS static_ip_address,
          (SELECT count(*)::integer AS count
           FROM bp_billing_equipment_assignment bbea
           WHERE bbea.line_id = line.line_id AND 'now'::text::date >= bbea.start_date::date
           AND 'now'::text::date <= COALESCE(bbea.end_date::date::timestamp without time zone, 'now'::text::date + '1 day'::interval)) AS number_active_charges,
          line.radius_username AS radius_username
        FROM equipment equp
        JOIN equipment_type eqty ON eqty.equipment_type = equp.equipment_type
        JOIN equipment_model eqmo ON eqmo.equipment_model_id = equp.equipment_model_id
        LEFT JOIN equipment_status eqst ON eqst.equipment_id = equp.equipment_id
        LEFT JOIN line_equipment lieq ON lieq.equipment_id = equp.equipment_id
        LEFT JOIN line ON line.line_id = lieq.line_id
        WHERE equp.equipment_id = var_equipment_id
        AND line.line_id = var_line_id

      LOOP
        RETURN NEXT var_return_row;
      END LOOP;

    END IF;

  END LOOP;

  RAISE NOTICE 'Finished Function.';

  RETURN;

END ;
$_$;


ALTER FUNCTION csctoss.ops_api_line_equipment_unique_ids_info(text, text) OWNER TO csctoss_owner;

--
-- Name: ops_api_line_plan_product_info(text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_line_plan_product_info(text, text) RETURNS SETOF ops_api_line_plan_product_info_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_type                    text      := $1;
  par_value                   text      := $2;
  var_equipment_id            integer;
  var_line_id                 integer;
  var_equipment_type          text;
  var_serial_number           text;
  var_esn_hex                 text;
  var_esn_dec                 text;
  var_min                     text;
  var_mdn                     text;
  var_mac_address             text;
  var_uniqid_row              RECORD;
  v_query                     text;
  var_billing_entity_id       integer;
  var_return_row              ops_api_line_plan_product_info_retval%ROWTYPE;

BEGIN
    RAISE NOTICE 'Entering Function';

  IF LENGTH(TRIM(COALESCE(par_value, ''))) = 0  AND par_type = '' THEN

      RAISE EXCEPTION 'Input Values Are Null.';

  ELSIF par_type = '' THEN

     RAISE EXCEPTION 'Input type is null. Please enter either Unique_Identifier or Line_ID or Username or Static IP Address or Billing_Entity_ID.';


  ELSIF par_value = '' THEN

      RAISE EXCEPTION 'Input value is null. Please enter values for either Unique_Identifier or Line_ID or Username or Static IP Address or Billing_Entity_ID.';

 END IF;
      -- Validate parameters.
   IF par_type = 'Unique_Identifier' THEN

          v_query := 'SELECT ui.equipment_id AS equipment_id,
                           eq.equipment_type AS equipment_type,
                           lieq.line_id AS line_id
                    FROM unique_identifier ui
                    JOIN equipment eq ON(ui.equipment_id = eq.equipment_id)
                    JOIN line_equipment lieq ON (ui.equipment_id = lieq.equipment_id)
                    WHERE 1=1
                      AND lieq.end_date is null
                      AND  ui.unique_identifier_type IN (''ESN HEX'', ''ESN DEC'', ''MDN'', ''MIN'', ''SERIAL NUMBER'', ''MAC ADDRESS'',
                                                                            ''ESN HEX1'', ''ESN HEX2'', ''ESN DEC1'', ''ESN DEC2'', ''MIN1'', ''MIN2'', ''MDN1'', ''MDN2'')
                    AND ui.value LIKE ' ||quote_literal(par_value||'%')|| 'GROUP BY  ui.equipment_id, eq.equipment_type, lieq.line_id LIMIT 100';

         ELSIF par_type = 'Line_ID' THEN

          var_line_id := (par_value)::integer;

            v_query :=  'SELECT  line.line_id AS line_id,
                                 lieq.equipment_id AS equipment_id,
                                 eq.equipment_type AS equipment_type
                         FROM line
                         JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
                         JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
                         WHERE 1=1 
                           AND lieq.end_date is null
                           AND line.line_id = '||(var_line_id)||'';

          ELSIF par_type = 'Username' THEN

            v_query := 'SELECT line.line_id AS line_id,
                                   lieq.equipment_id AS equipment_id,
                                   eq.equipment_type AS equipment_type
                        FROM line
                        JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
                        JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
                        WHERE 1=1
                          AND lieq.end_date is null
                          AND line.radius_username LIKE '||quote_literal(par_value||'%')||'LIMIT 100';

          ELSIF par_type = 'Static IP Address' THEN

        v_query := 'SELECT line.line_id AS line_id,
                           lieq.equipment_id AS equipment_id,
                           eq.equipment_type AS equipment_type
                    FROM radreply
                    JOIN line ON (radreply.username = line.radius_username)
                    JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
                    JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
                    WHERE  1=1
                      AND lieq.end_date is null
                      AND radreply.attribute::text = ''Framed-IP-Address''::text
                      AND radreply.value = '||quote_literal(par_value);


          ELSIF par_type = 'Billing_Entity_ID' THEN

          var_billing_entity_id := (par_value)::integer;

            v_query :=  'SELECT  line.line_id AS line_id,
                                 lieq.equipment_id AS equipment_id,
                                 eq.equipment_type AS equipment_type
                     FROM line
                     JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
                     JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
                     WHERE  1=1
                          AND lieq.end_date is null
                          AND line.billing_entity_id = '||(var_billing_entity_id)||'LIMIT 100';
 END IF;

     FOR var_uniqid_row IN EXECUTE v_query

       LOOP

             var_equipment_id := var_uniqid_row.equipment_id ;
             var_line_id := var_uniqid_row.line_id;
             var_equipment_type := var_uniqid_row.equipment_type;

-- Retrieve Serial Number and Mac Address for the obtained Equipment_Id Value. These are unique for all types of equipments.

     SELECT uid1.value INTO var_serial_number FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'SERIAL NUMBER'::text;

     SELECT uid1.value INTO var_mac_address FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MAC ADDRESS'::text;

   IF var_equipment_type = 'ROUTER' THEN

      -- Get all unique_identifier values for a Router

      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;

      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;

      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text;

      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;

    ELSIF var_equipment_type = 'CARD' THEN

      -- Get the unique_identifiers for the equipment type Card.

      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;

      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;

      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text;

      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;

    ELSIF var_equipment_type = 'MODULE' THEN

      -- Get the unique_identifiers for the equipment_type Module.

      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;

      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;

      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text;

      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;

    END IF;

   FOR var_return_row IN
     SELECT
           CASE
               WHEN line.billing_entity_id IS NOT NULL THEN
                   ( SELECT billing_entity.name
                     FROM billing_entity
                     WHERE billing_entity.billing_entity_id = line.billing_entity_id)
               ELSE NULL::text
           END AS customer_name, line.line_id,
           CASE
               WHEN line.billing_entity_address_id IS NOT NULL THEN
                    (SELECT  locn.location_label
                     FROM billing_entity_location_label locn
                     WHERE locn.billing_entity_address_id = line.billing_entity_address_id
                     AND locn.location_label_type = 'USER DEFINED')
               ELSE NULL::text
            END AS location, line.line_label, line.radius_username, line.notes, --line.active_flag,
            CASE
                WHEN lieq.end_date IS NULL THEN 'TRUE'::text
                WHEN lieq.end_date IS NOT NULL THEN 'FALSE'::text
                ELSE 'N/A'::text
            END AS active_flag,
            pt.plan_type_desc AS plan_type, plan.comment AS plan_comment, prd.product_code,
            plan.start_date, plan.end_date, plan.length_days, plan.prepaid_unit,
            plan.prepaid_allowance, plan.prepaid_balance, eqm.model_description AS model,
            eqm.model_number1 AS model_number, eq.equipment_type,
           (SELECT eqm1.model_number1 FROM equipment_model eqm1
            WHERE eqm1.equipment_model_id = eqm.embedded_equipment_model_id) AS Embedded_Model,
            var_esn_hex, var_esn_dec, var_mdn, var_min, var_serial_number, var_mac_address
    FROM line
    LEFT JOIN plan ON (line.line_id = plan.line_id)
    LEFT JOIN plan_type pt ON (plan.plan_type_id = pt.plan_type_id)
    LEFT JOIN product prd ON ( plan.product_id = prd.product_id)
    JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
    JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
    JOIN equipment_model eqm ON ( eq.equipment_model_id = eqm.equipment_model_id)
    WHERE line.line_id = var_line_id
    --AND lieq.end_date IS NULL
    AND eq.equipment_id = var_equipment_id

    LOOP

         RETURN NEXT var_return_row;

    END LOOP;

  IF ( var_equipment_type = 'MULTI_NETWORK ROUTER') THEN

   FOR var_return_row IN

      SELECT
           CASE
               WHEN line.billing_entity_id IS NOT NULL THEN
                   ( SELECT billing_entity.name
                     FROM billing_entity
                     WHERE billing_entity.billing_entity_id = line.billing_entity_id)
               ELSE NULL::text
           END AS customer_name, line.line_id,
           CASE
               WHEN line.billing_entity_address_id IS NOT NULL THEN
                    (SELECT  locn.location_label
                     FROM billing_entity_location_label locn
                     WHERE locn.billing_entity_address_id = line.billing_entity_address_id
                     AND locn.location_label_type = 'USER DEFINED')
               ELSE NULL::text
            END AS location, line.line_label, line.radius_username, line.notes, --line.active_flag,
            CASE
                WHEN lieq.end_date IS NULL THEN 'TRUE'::text
                WHEN lieq.end_date IS NOT NULL THEN 'FALSE'::text
                ELSE 'N/A'::text
            END AS active_flag,
            pt.plan_type_desc AS plan_type, plan.comment AS plan_comment, prd.product_code,
            plan.start_date, plan.end_date, plan.length_days, plan.prepaid_unit,
            plan.prepaid_allowance, plan.prepaid_balance, eqm.model_description AS model,
            eqm.model_number1 AS model_number, eq.equipment_type,
           (SELECT eqm1.model_number1 FROM equipment_model eqm1
            WHERE eqm1.equipment_model_id = eqm.embedded_equipment_model_id) AS Embedded_Model,
            var_esn_hex, var_esn_dec, var_mdn, var_min, var_serial_number, var_mac_address
          ,(SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN HEX1'::text) AS esn_hex1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN DEC1'::text) AS esn_dec1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MDN1'::text) AS mdn1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MIN1'::text) AS min1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN HEX2'::text) AS esn_hex2,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN DEC2'::text) AS esn_dec2,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MDN2'::text) AS mdn2,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MIN2'::text) AS min2
    FROM line
    LEFT JOIN plan ON (line.line_id = plan.line_id)
    LEFT JOIN plan_type pt ON (plan.plan_type_id = pt.plan_type_id)
    LEFT JOIN product prd ON ( plan.product_id = prd.product_id)
    JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
    JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
    JOIN equipment_model eqm ON ( eq.equipment_model_id = eqm.equipment_model_id)
    WHERE line.line_id = var_line_id
    AND eq.equipment_id = var_equipment_id

    LOOP

         RETURN NEXT var_return_row;

    END LOOP;


END IF;

 END LOOP;

  RAISE NOTICE 'Finished Function.';

    RETURN;
END ;
$_$;


ALTER FUNCTION csctoss.ops_api_line_plan_product_info(text, text) OWNER TO csctoss_owner;

--
-- Name: ops_api_modify(text, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_modify(text, text, text) RETURNS SETOF ops_api_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_unique_identifier_type    text := $1 ;
  par_old_value                 text := $2 ;
  par_new_value                 text := $3 ;
  var_equipment_id              integer;
  var_username                  text;
  v_numrows                     integer;
  v_errmsg                      text;

  var_return_row                ops_api_retval%ROWTYPE;

BEGIN

  v_errmsg := 'ERROR - All or some of the input values are null.';
  IF par_unique_identifier_type = ''
               OR par_old_value = ''
               OR par_new_value = '' THEN 

      RAISE EXCEPTION '';
  ELSE 
      -- Validate parameters.
      v_errmsg := 'ERROR - Old value does not exist:  ' || par_old_value;
      SELECT equipment_id INTO var_equipment_id
        FROM unique_identifier
       WHERE unique_identifier_type = par_unique_identifier_type
         AND value = par_old_value ;

      IF NOT FOUND THEN
          RAISE EXCEPTION '' ;
      END IF ;

      -- check to see if MDN and MIN have the same values (only if the input type is MDN/MIN)
      IF par_unique_identifier_type IN ('MDN', 'MIN') THEN

          v_errmsg := 'ERROR - MDN update failed, old value ' || par_old_value || ', new value ' || par_new_value;
          UPDATE csctoss.unique_identifier 
          SET value = par_new_value
          WHERE equipment_id = var_equipment_id
          AND unique_identifier_type = 'MDN'
          AND value = par_old_value ;

          GET DIAGNOSTICS v_numrows = ROW_COUNT;
          IF v_numrows = 0 THEN
              RAISE EXCEPTION '';
          END IF;

          v_errmsg := 'ERROR - MIN update failed, old value ' || par_old_value || ', new value ' || par_new_value;
          UPDATE csctoss.unique_identifier 
          SET value = par_new_value
          WHERE equipment_id = var_equipment_id
          AND unique_identifier_type = 'MIN'
          AND value = par_old_value ;
      
          GET DIAGNOSTICS v_numrows = ROW_COUNT;
          IF v_numrows = 0 THEN
              RAISE EXCEPTION '';
          END IF;

          -- Also update the username/usergroup/radcheck tables for the username column
          v_errmsg := 'ERROR - Username ' || var_username || ' does not match with MDN/MIN value.';
          SELECT username INTO var_username
          FROM username
          WHERE (SUBSTR(username,1,10)) = par_old_value; 

          IF NOT FOUND THEN
              RAISE EXCEPTION '' ;
          END IF;
        
          v_errmsg := 'ERROR - Update failed for username:  ' || var_username;
          UPDATE username 
          SET username = replace(var_username, par_old_value, par_new_value)
          WHERE SUBSTR(username,1,10) = par_old_value; 
  	    
          GET DIAGNOSTICS v_numrows = ROW_COUNT;
          IF v_numrows = 0 THEN
              RAISE EXCEPTION '';
          END IF;
  	   
          v_errmsg := 'ERROR - Update failed for usergroup; username:  ' || var_username;
          UPDATE usergroup
          SET username = replace(var_username, par_old_value, par_new_value)
          WHERE SUBSTR(username,1,10) = par_old_value;
  	   
          GET DIAGNOSTICS v_numrows = ROW_COUNT;
          IF v_numrows = 0 THEN
              RAISE EXCEPTION '';
          END IF;

          v_errmsg := 'ERROR - Update failed for radcheck; username:  ' || var_username;
          UPDATE radcheck
          SET username = replace(var_username, par_old_value, par_new_value)
          WHERE SUBSTR(username,1,10) = par_old_value;
    
          GET DIAGNOSTICS v_numrows = ROW_COUNT;
          IF v_numrows = 0 THEN
              RAISE EXCEPTION '';
          END IF;

      ELSE
          -- Update unique identifier value from old to new for other types.
          v_errmsg := 'ERROR - Update failed, unique_identifier_type ' || par_unique_identifier_type || ' value ' || par_new_value;
          UPDATE csctoss.unique_identifier
          SET value = par_new_value
          WHERE equipment_id = var_equipment_id
          AND unique_identifier_type = par_unique_identifier_type
          AND value = par_old_value ;

          GET DIAGNOSTICS v_numrows = ROW_COUNT;
          IF v_numrows = 0 THEN
              RAISE EXCEPTION '';
          END IF;
      END IF;
  END IF;
  
  var_return_row.result_code := true ;
  var_return_row.error_message := '' ;
  RETURN NEXT var_return_row ;
  RETURN ;

  EXCEPTION
    WHEN raise_exception THEN
      var_return_row.result_code := false;
      var_return_row.error_message := v_errmsg;
      RETURN NEXT var_return_row;
      RETURN;

    WHEN others THEN
      var_return_row.result_code := false;
      var_return_row.error_message:=v_errmsg;
      RAISE NOTICE 'OTHER EXCEPTION:  %', v_errmsg;
      RETURN NEXT var_return_row;
      RETURN;
END ;
$_$;


ALTER FUNCTION csctoss.ops_api_modify(text, text, text) OWNER TO csctoss_owner;

--
-- Name: ops_api_restore(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_restore(text) RETURNS SETOF ops_api_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_esn_hex                   text := $1;
  var_equipment_id              integer;
  var_username                  text;
  var_mdn                       text;
  var_return_row                ops_api_retval%ROWTYPE;
  v_errmsg                      text;

BEGIN
  PERFORM public.set_change_log_staff_id (3);

  v_errmsg := 'ERROR:  Input ESN HEX Is Null. Please enter a value.';
  IF par_esn_hex = '' THEN
    RAISE EXCEPTION '';
  ELSE
    -- Validate parameters.
    v_errmsg := 'ERROR:  ESN HEX value does not exist.';
    SELECT equipment_id INTO var_equipment_id
    FROM unique_identifier
    WHERE unique_identifier_type = 'ESN HEX'
    AND value LIKE par_esn_hex;

    IF NOT FOUND THEN
      RAISE EXCEPTION '' ;
    ELSE
      /*
      --Check if active line_id is mapped to the equipment_id
      IF EXISTS (SELECT line_id FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date IS NOT NULL) THEN
        RAISE EXCEPTION 'Line_ID is inactive and hence the device cannot be restored.';
      END IF;
      */
  
      -- Retrieve MDN and Username values
      SELECT value INTO var_mdn
      FROM unique_identifier
      WHERE unique_identifier_type = 'MDN'
      AND equipment_id = var_equipment_id;
  
      SELECT unam.username INTO var_username
      FROM username unam
      WHERE SUBSTR(unam.username,1,10) = var_mdn;
    END IF;

    -- To Restore a suspended device
    v_errmsg := 'ERROR:  Cannot restore a canceled device.';
    IF EXISTS(SELECT TRUE 
                FROM unique_identifier 
                JOIN line_equipment le USING (equipment_id) 
               WHERE value = var_mdn 
                 AND le.end_date IS NULL) THEN
      v_errmsg := 'ERROR:  Device is not suspended and can not be restored.';
      IF EXISTS( SELECT TRUE 
                   FROM usergroup 
                  WHERE username LIKE var_username 
                    AND (groupname LIKE 'disconnected' OR 
                         groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione')) THEN
        DELETE FROM usergroup
        WHERE username LIKE var_username
        AND groupname LIKE 'disconnected';

        DELETE FROM usergroup
        WHERE username LIKE var_username
        AND groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione';
  
      ELSE
        RAISE EXCEPTION '';
      END IF;
    ELSE
      RAISE EXCEPTION '';
    END IF;
  END IF;

  var_return_row.result_code := true ;
  var_return_row.error_message := 'Device is restored.' ;
  RETURN NEXT var_return_row ;
  RETURN ;

  EXCEPTION
    WHEN raise_exception THEN
      var_return_row.result_code := false;
      var_return_row.error_message:=v_errmsg;
      RETURN NEXT var_return_row;
      RETURN;

    WHEN others THEN
      var_return_row.result_code := false;
      var_return_row.error_message:=v_errmsg;
      RAISE NOTICE 'OTHER EXCEPTION:  %', v_errmsg;
      RETURN NEXT var_return_row;
      RETURN;

END ;
$_$;


ALTER FUNCTION csctoss.ops_api_restore(text) OWNER TO csctoss_owner;

--
-- Name: ops_api_restore_ex(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_restore_ex(text) RETURNS SETOF ops_api_restore_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_esn_hex                   text := $1;
  var_equipment_id              integer;
  var_username                  text;
  var_mdn                       text;
  var_return_row                ops_api_restore_retval%ROWTYPE;

BEGIN
  PERFORM public.set_change_log_staff_id (3);

  IF par_esn_hex = '' THEN
    var_return_row.result_code := false;
    var_return_row.error_message := 'Input ESN HEX is NULL or empty. Please enter a value.' ;
    RETURN NEXT var_return_row ;
    RETURN ;
  ELSE
    -- Validate parameters.
    SELECT equipment_id INTO var_equipment_id
    FROM unique_identifier
    WHERE unique_identifier_type = 'ESN HEX'
    AND value LIKE par_esn_hex;

    IF NOT FOUND THEN
      var_return_row.result_code := false;
      var_return_row.error_message := 'ESN HEX value does not exists.' ;
      RETURN NEXT var_return_row ;
      RETURN ;
    ELSE
/*
      -- Check if active line_id is mapped to the equipment_id
      IF EXISTS (SELECT line_id FROM line_equipment WHERE equipment_id = var_equipment_id AND end_date IS NOT NULL) THEN
        var_return_row.result_code := false;
        var_return_row.error_message := 'Line_ID is inactive and hence the device cannot be restored.' ;
        RETURN NEXT var_return_row ;
        RETURN ;
      END IF;
*/
      -- Retrieve MDN and Username values
      SELECT value INTO var_mdn
      FROM unique_identifier
      WHERE unique_identifier_type = 'MDN'
      AND equipment_id = var_equipment_id;

      SELECT unam.username INTO var_username
      FROM username unam
      WHERE SUBSTR(unam.username,1,10) = var_mdn;
    END IF;

    -- To Restore a suspended device
    IF EXISTS( SELECT TRUE FROM unique_identifier JOIN line_equipment le USING (equipment_id) WHERE value = var_mdn AND le.end_date IS NULL) THEN
      IF EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND (groupname LIKE 'disconnected' OR groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione')) THEN
        DELETE FROM usergroup
        WHERE username LIKE var_username
        AND groupname LIKE 'disconnected';

        DELETE FROM usergroup
        WHERE username LIKE var_username
        AND groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione';

      ELSE
        var_return_row.result_code := false;
        var_return_row.error_message := 'Device is not suspended and can not be restored.' ;
        RETURN NEXT var_return_row ;
        RETURN ;
      END IF;
    ELSE
      var_return_row.result_code := false;
      var_return_row.error_message := 'Cannot restore a canceled device since the device is not suspended.' ;
      RETURN NEXT var_return_row ;
      RETURN ;
    END IF;
  END IF;

  var_return_row.result_code := true ;
  var_return_row.error_message := 'Device is restored.' ;
  RETURN NEXT var_return_row ;
  RETURN ;

END ;
$_$;


ALTER FUNCTION csctoss.ops_api_restore_ex(text) OWNER TO csctoss_owner;

--
-- Name: ops_api_rma(text, text, text, integer, boolean, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_rma(text, text, text, integer, boolean, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
--
in_old_esn              text:=$1;
in_new_esn              text:=$2;
in_new_usergroup        text:=$3;
in_beid                 integer:=$4;
in_static_ip            boolean:=$5;
in_sales_order          text:=$6;
--
c_staff_id              integer:=3;
v_result                integer;
v_return                text;
v_tab                   text;
v_fail_ind              integer;
v_in_count              integer;
v_esnhex                text;
v_old_username          text;
v_new_username          text;
v_groupname             text;
v_rma_groupname         text;
v_beid                  text;
v_bename                text;
v_line_id               text;
v_oequipid              text;
v_nequipid              text;
v_ip                    text;
v_carrier               text;
v_priority              integer;
v_notes                 text;
v_lstrtdat              text;
v_lenddat               text;
v_lestrtdat             text;
v_leenddat              text;
v_return_text           text;
v_sn                    text;
v_numrows               integer;
v_count                 integer;
v_value                 text;
v_value2                text;
var_sql                 text;
--var_return_row          ops_api_assign_retval%ROWTYPE;
var_return_row          ops_api_retval_boolean%ROWTYPE;
var_conn_string         text;

begin

    SET client_min_messages=NOTICE;


    SELECT * INTO v_result FROM public.set_change_log_staff_id(c_staff_id);

    IF
        v_result = -1  or v_result=c_staff_id
    THEN
    ELSE
        RAISE exception 'change log staff id could not be set';
    END IF;
--
    SELECT count(*)  into v_count
    from unique_identifier ui
    where 1=1
       and  ui.unique_identifier_type = 'ESN HEX'
       and ui.value = in_old_esn;
    IF v_count = 0
    then
        RAISE EXCEPTION 'OLD ESN HEX NOT PRESENT UI TABLE';
    END IF;
--
    SELECT count(*) into v_count
    FROM unique_identifier ui
    JOIN line_equipment le ON (ui.equipment_id = le.equipment_id)
    where 1=1
      and  ui.unique_identifier_type = 'ESN HEX'
      and ui.value = in_old_esn
      AND le.end_date IS NULL
    ;
    IF v_count = 0
    then
       RAISE EXCEPTION 'EQUIPMENT ID ASSOCIATED WITH OLD ESN NOT FOUND IN LINE_EQUIPMENT TABLE';
    END IF;
--
    SELECT count(*)  into v_count
    from unique_identifier ui
    where 1=1
       and  ui.unique_identifier_type = 'ESN HEX'
       and ui.value = in_new_esn;
    IF v_count = 0
    then
        RAISE EXCEPTION 'NEW ESN HEX NOT PRESENT UI TABLE';
    END IF;
    SELECT count(*) into v_count
        FROM unique_identifier ui
        JOIN line_equipment le ON (ui.equipment_id = le.equipment_id)
        where 1=1
           and  ui.unique_identifier_type = 'ESN HEX'
           and ui.value = in_new_esn
           AND le.end_date IS NULL
    ;
    IF v_count > 0
    then
          RAISE EXCEPTION 'EQUIPMENT ID ASSOCIATED WITH NEW ESN FOUND IN LINE_EQUIPMENT TABLE';
    END IF;
--
    SELECT count(*) into v_count
    from billing_entity
    where 1=1
      and in_beid=billing_entity_id
    ;
    IF v_count = 0
    then
         RAISE EXCEPTION 'BILLING_ENTIY_ID NOT PRESENT IN BILLING_ENTITY_TABLE';
    END IF;
--
    IF in_new_usergroup IN ('disconnected', 'userdisconnected','keepalive')
    THEN
       RAISE EXCEPTION 'Invalid new Usergroup';
    END IF ;

    SELECT  count(*) FROM groupname INTO v_count
    WHERE 1=1
      AND groupname = in_new_usergroup ;
    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    IF v_numrows  = 0 then
        RAISE EXCEPTION 'Invalid new Usergroup';
    END IF;
--
    SELECT
    ui.value ,
    l.radius_username ,
    be.billing_entity_id ,
    be.name ,
    l.line_id ,
    ui.equipment_id ,
    (SELECT groupname FROM usergroup WHERE username = l.radius_username order by priority desc limit 1) ,
    (SELECT value FROM radreply WHERE username = l.radius_username AND attribute = 'Framed-IP-Address' ) ,
    l.start_date ,
    l.end_date ,
    le.start_date ,
    le.end_date ,
    l.notes
    INTO
       v_esnhex,v_old_username,v_beid, v_bename,v_line_id,v_oequipid,v_groupname,v_ip,v_lstrtdat,v_lenddat,v_lestrtdat,v_leenddat,v_notes
    FROM unique_identifier ui
    JOIN equipment eq ON (ui.equipment_id = eq.equipment_id)
    JOIN line_equipment le ON (ui.equipment_id = le.equipment_id)
    JOIN line l ON (le.line_id = l.line_id)
    JOIN billing_entity be ON (l.billing_entity_id = be.billing_entity_id)
    WHERE 1 = 1
    AND ui.unique_identifier_type = 'ESN HEX'
    AND ui.value = in_old_esn
    AND le.end_date IS NULL
    AND l.end_date IS NULL
    ;
    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    IF v_numrows  = 0 then
        RAISE EXCEPTION 'No match for parameters';
    END IF;

    SELECT ui.equipment_id
    INTO v_nequipid
    FROM unique_identifier ui
    JOIN equipment eq ON (ui.equipment_id = eq.equipment_id)
    WHERE 1 = 1
    AND ui.unique_identifier_type = 'ESN HEX'
    AND ui.value = in_new_esn
    ;
    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    IF v_numrows = 0
    THEN

         RAISE EXCEPTION 'NEW ESN HEX NOT PRESENT';
    END if;
--
     SELECT value INTO v_sn
     FROM unique_identifier
     WHERE 1=1
       and equipment_id = v_nequipid
       and unique_identifier_type = 'SERIAL NUMBER';
    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    IF v_numrows = 0
    THEN
         RAISE EXCEPTION 'SERIAL NUMBER NOT PRESENT FOR NEW ESN HEX';
    END IF;

--
    SELECT carrier INTO v_carrier
    FROM equipment e
    JOIN equipment_model em ON (e.equipment_model_id = em.equipment_model_id)
    WHERE 1=1
      AND e.equipment_id = v_nequipid;
    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    IF v_numrows = 0
    THEN
         RAISE EXCEPTION 'CARRIER FOR EQUIPMENT MODEL NOT FOUND';
    END IF;

--
    IF
      v_carrier != 'USCC'
    THEN
        SELECT username INTO v_new_username
        FROM username u,
             unique_identifier ui
        WHERE 1=1
             AND substring(u.username FROM 1 FOR 10) = ui.value
             AND ui.equipment_id=v_nequipid
             AND ui.unique_identifier_type = 'MDN'
             AND u.end_date = to_date('2999-12-31','yyyy-mm-dd');
    ELSE
       SELECT username INTO v_new_username
       FROM username u,
       unique_identifier ui
       WHERE 1=1
         AND substring(u.username FROM 1 FOR 10) = ui.value
         AND ui.equipment_id=v_nequipid
         AND ui.unique_identifier_type = 'MIN'
         AND u.end_date = to_date('2999-12-31','yyyy-mm-dd');
    END IF;
    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    IF v_numrows = 0
    THEN
        RAISE EXCEPTION 'USERNAME FOR NEW EQUIPMENT NOT FOUND';
    END IF;
--
      RAISE NOTICE '----- Begin Function data ----------';
      RAISE NOTICE 'old ESN           : %',in_old_esn;
      RAISE NOTICE 'old ip            : %',v_ip;
      RAISE NOTICE 'old username      : %',v_old_username;
      RAISE NOTICE 'old equipment id  : %',v_oequipid;
      RAISE NOTICE 'new ESN           : %',in_new_esn;
      RAISE NOTICE 'new equipment id  : %',v_nequipid;
      RAISE NOTICE 'new username      : %',v_new_username;
      RAISE NOTICE 'billing entity    : %',v_beid;
      RAISE NOTICE 'billing entity nm : %',v_bename;
      RAISE NOTICE 'groupname         : %',v_groupname;
      RAISE NOTICE '----- End of Function data ----------';


--    UPDATE line_equipment     --    set end_date to current_date
     SELECT count(*) into v_count
     from line_equipment
     where 1=1
       and equipment_id = v_oequipid
       and end_date is null;
     IF v_count = 1
     THEN
          UPDATE line_equipment set end_date = current_date
          where 1=1
            and equipment_id = v_oequipid
            and end_date is null;
            GET DIAGNOSTICS v_numrows = ROW_COUNT;
            IF v_numrows = 0
            THEN
                RAISE EXCEPTION 'LINE_EQUIPMENT END_DATE NOT UPDATED';
           END IF;
     ELSE
         RAISE EXCEPTION 'ACTIVE LINE FOR OLD EQUIPMENT NOT FOUND IN LINE_EQUIPMENT';
     END IF;
--
     SELECT count(*) INTO v_count
     FROM usergroup
     WHERE 1=1
       AND username = v_new_username
     ;
     IF v_count <= 0
     THEN
        RAISE EXCEPTION 'NEW USERNAME NOT PRESENT IN USERGROUP TABLE ';
     END IF;

--
      IF v_ip IS NOT null
      THEN
          UPDATE static_ip_pool
             SET is_assigned = false,
             line_id = null
          WHERE 1=1
            AND static_ip = v_ip;
     END IF;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     IF v_numrows = 0
     THEN
         RAISE EXCEPTION 'Static IP not unassigned: % rows updated: %',v_ip,v_numrows;
     END IF;

--    capture rows deleted and use for debugging later
     DELETE FROM radreply WHERE  username = v_old_username;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     IF v_numrows = 0
     THEN
         RAISE EXCEPTION 'ROW(S) NOT DELETED FROM RADREPLY TABLE';
      END IF;

     DELETE FROM radcheck WHERE  username = v_old_username;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     IF v_numrows = 0
     THEN
         RAISE EXCEPTION 'ROW(S) NOT DELETED FROM RADCHECK FOR OLD USERNAME: %',v_old_username;
      END IF;
     DELETE FROM radcheck WHERE  username = v_new_username;
     /*
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     IF v_numrows = 0
     THEN
         RAISE EXCEPTION 'ROW(S) NOT DELETED FROM RADCHECK FOR NEW USERNAME: %',v_new_username;
      END IF;
*/
     v_rma_groupname:=
      ( CASE
           WHEN v_carrier = 'VZW'
            THEN 'SERVICE-rma_vzwr'
           ELSE
              'SERVICE-rma_uscc_sprint'
         END
      );
      SELECT  priority FROM groupname INTO v_priority
      WHERE 1=1
        and groupname =v_rma_groupname ;
      GET DIAGNOSTICS v_numrows = ROW_COUNT;
      IF v_numrows <> 1 then
          RAISE EXCEPTION  'Unable to obtain priority for groupname : %', v_rma_groupname;
      END IF;

--
      UPDATE usergroup SET groupname = v_rma_groupname , priority=v_priority
      WHERE 1=1
        AND username=v_old_username;
      GET DIAGNOSTICS v_numrows = ROW_COUNT;
      IF v_numrows <> 1 then
          RAISE EXCEPTION  'UPDATE OF OLD USERGROUP WAS UNSUCESSFULL!';
      END IF;

--   get the priority for the new usergroup
      SELECT  priority FROM groupname INTO v_priority
      WHERE 1=1
        AND groupname = in_new_usergroup ;

      GET DIAGNOSTICS v_numrows = ROW_COUNT;
      IF v_numrows <> 1 then
          RAISE EXCEPTION  'UNABLE TO OBTAIN PRIORITY FOR GROUPNAME : % !', in_new_usergroup;
      END IF;


--     Replace  new username data in usergroup table
--     First delete the old data  then insert the new data

      DELETE FROM usergroup
      where 1=1
        and username = v_new_username;
--  new code by danny on 0219
      INSERT into usergroup
             ( username,groupname,priority)
      VALUES
             ( v_new_username,in_new_usergroup,v_priority);

/*
      --   bad code. fixed by danny on 0219    
      INSERT into usergroup
      ( SELECT max(id)+1, v_new_username,in_new_usergroup,v_priority
        from usergroup
      );
*/
      GET DIAGNOSTICS v_numrows = ROW_COUNT;
      IF v_numrows <> 1 then
          RAISE EXCEPTION  'INSERT INTO USERGROUP TABLE WAS UNSUCESSFULL!';
      END IF;
--

     UPDATE line SET radius_username = v_new_username, line_label = in_new_esn WHERE line_id = v_line_id;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;

--         INSERT into line_equipment
     INSERT INTO line_equipment
         ( SELECT v_line_id::integer,v_nequipid::integer,current_date,
                  null,billing_entity_address_id,ship_date,install_date,installed_by
           from line_equipment le
           where 1=1
             and le.line_id=v_line_id
             and le.equipment_id=v_oequipid
             and le.end_date =current_date);
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     IF v_numrows <> 1 then
          RAISE EXCEPTION  'MORE THAN 1 ROW IN LINE_EQUIPMENT WAS UPDATED.';
     END IF;

--     assign a static ip if requested
    IF in_static_ip
    THEN
        SELECT * into v_return from
        ops_api_static_ip_assign(v_carrier::text, in_new_usergroup::text, v_new_username::text, v_line_id::integer, in_beid::integer);
        RAISE NOTICE 'ops_api_static_ip return: %', v_return;
        IF v_return is null
        then
           RAISE EXCEPTION  'CALL TO OPS_API_STATIC_IP_ASSIGN FUNCTION WAS NOT SUCESSFUL!';
        END IF;
    ELSE
       INSERT INTO radreply(username, attribute, op, value, priority) VALUES (v_new_username, 'Class', '=', v_line_id, 10);
       GET DIAGNOSTICS v_numrows = ROW_COUNT;
       IF v_numrows <> 1 then
          RAISE EXCEPTION  'INSERT INTO RADREPLY TABLE WAS UNSUCESSFUL!!';
       END IF;

    END IF;
    IF v_carrier = 'SPRINT' THEN
        v_value:='';
        v_value2:='ClearText-Password';
    ELSIF
        v_carrier = 'USCC' THEN
        v_value:='CP@11U$ers';
        v_value2:='ClearText-Password';
    ELSIF
        v_carrier = 'VZW' THEN
        v_value:='Accept';
        v_value2:='Auth-Type';
    ELSE
        RAISE EXCEPTION  'Invalid Carrier for new equipment';
    END IF;


    INSERT into radcheck (username,attribute,op,value) VALUES (v_new_username,v_value2,':=',v_value);
    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    IF v_numrows <> 1 then
        RAISE EXCEPTION  'INSERT INTO RADCHECK TABLE WAS UNSUCESSFUL!!';
    END IF;


    UPDATE username
        SET billing_entity_id = 2,
            end_date=current_date ,
            enabled=false
    WHERE 1=1
      AND username = v_old_username;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     IF v_numrows <> 1
     then
         RAISE EXCEPTION  'UPDATE OF OLD USERNAME FAILED.';
     END IF;

    UPDATE username
           SET  billing_entity_id=in_beid,
                notes=v_notes,
                primary_service=false,
                enabled=true
    WHERE 1=1
      AND username = v_new_username;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     IF v_numrows = 0
     then
         RAISE EXCEPTION  'UPDATE  OF NEW USERNAME FAILED.';
     END IF;

     var_sql := 'SELECT * from oss.jbilling_rma( '|| quote_literal(upper(in_sales_order)) ||' , '
              ||quote_literal(in_old_esn)||' , '||quote_literal(in_new_esn)||' , '
              ||quote_literal(v_sn)||' , '||quote_literal(v_new_username)||','||v_line_id||')';
     raise notice 'call to jbilling_rma: %',var_sql;

        FOR var_return_row IN
        SELECT * FROM public.dblink(fetch_jbilling_conn(), var_sql)
             AS rec_type (result_code boolean)

             LOOP
                IF (var_return_row.result_code = FALSE) THEN
                   RAISE NOTICE 'CALL TO oss.jbilling_rma RESULTED IN FAILURE';
                   RAISE EXCEPTION 'CALL TO oss.jbilling_rma RESULTED IN FAILURE';
--                  RETURN false;
                END IF;
             END LOOP;

return true;
END;
$_$;


ALTER FUNCTION csctoss.ops_api_rma(text, text, text, integer, boolean, text) OWNER TO csctoss_owner;

--
-- Name: ops_api_static_ip_assign(text, text, text, integer, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_static_ip_assign(text, text, text, integer, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_carrier                   text := $1;
  par_vrf                       text := $2;
  par_username                  text := $3;
  par_line_id					integer := $4;
  par_billing_entity_id         integer := $5;
  var_static_ip                 text;
  var_check_if_has_range        text;
  v_numrows               		integer;

BEGIN
    SET client_min_messages TO notice;
    RAISE NOTICE 'ops_api_static_ip_assign is called: parameters => [carrier=%][vrf=%][username=%][line_id=%][billing_entity_id=%]', par_carrier, par_vrf, par_username, par_line_id, par_billing_entity_id;

	PERFORM public.set_change_log_staff_id(3);

    -- Check if the parameters are null
    IF par_carrier IS NULL
        OR par_username IS NULL
        OR par_line_id IS NULL
        OR par_billing_entity_id IS NULL
        OR par_vrf IS NULL
    THEN
        RAISE NOTICE 'All or some of the input values are null.';
        var_static_ip = 'ERROR - All or some of the input values are null.';
        RETURN var_static_ip;
    END IF;

	SELECT static_ip
	INTO var_check_if_has_range
	FROM static_ip_pool sip
	JOIN static_ip_carrier_def sid
	ON (sid.carrier_def_id = sip.carrier_id)
	WHERE groupname = par_vrf
	AND carrier LIKE '%'||par_carrier||'%'
	AND billing_entity_id = par_billing_entity_id
	--AND static_ip not like '166.%'
	ORDER BY billing_entity_id
	LIMIT 1;

    IF FOUND THEN
        RAISE NOTICE 'We found IP pool.';
        SELECT static_ip
          INTO var_static_ip
          FROM static_ip_pool sip
          JOIN static_ip_carrier_def sid
            ON (sid.carrier_def_id = sip.carrier_id)
         WHERE groupname = par_vrf
           AND is_assigned = FALSE
           AND carrier LIKE '%'||par_carrier||'%'
           AND billing_entity_id = par_billing_entity_id
         ORDER BY billing_entity_id , static_ip
         LIMIT 1
           FOR UPDATE;

        IF FOUND THEN
			RAISE NOTICE 'We found an available IP address in the IP pool. [IP=%]', var_static_ip;
			IF ( SELECT TRUE FROM radreply WHERE username = par_username AND attribute = 'Class') THEN

			  --Update rad_reply IP
			    INSERT INTO radreply (username, attribute, op, value, priority)
			    	VALUES (par_username, 'Framed-IP-Address', '=', var_static_ip::text, 10);
                RAISE NOTICE 'Inserted Framed-IP-Address attribute value into radreply table. [IP=%]', var_static_ip;
			ELSE 
	            --Update rad_reply Class
	            RAISE NOTICE 'Inserting Class attribute value into radreply table. [line_id=%]', par_line_id;
			    INSERT INTO radreply (username, attribute, op, value, priority)
			    	VALUES (par_username, 'Class', '=', par_line_id::text, 10);
				RAISE NOTICE 'Inserted Class attribute value into radreply table. [line_id=%]', par_line_id;

	             --Update rad_reply IP
	            RAISE NOTICE 'Inserting Framed-IP-Address attribute value into radreply table. [IP=%]', var_static_ip;
			    INSERT INTO radreply (username, attribute, op, value, priority)
			    	VALUES (par_username, 'Framed-IP-Address', '=', var_static_ip::text, 10);
                RAISE NOTICE 'Inserted Framed-IP-Address attribute value into radreply table. [IP=%]', var_static_ip;
                       
            END IF; 

            RAISE NOTICE 'Updating static_ip_pool table for [IP=% / VRF=%]', var_static_ip, par_vrf;
			--Update static_ip_pool
			UPDATE static_ip_pool
			   SET is_assigned = 'TRUE'
                  ,line_id = par_line_id
			 WHERE static_ip = var_static_ip
  			   AND groupname = par_vrf;

            IF NOT FOUND THEN
               RAISE EXCEPTION 'OSS: Radreply Update Failed.';
                var_static_ip = 'ERROR - OSS: Radreply Update Failed.';
                RETURN var_static_ip;
			ELSE
			   RETURN var_static_ip;
            END IF;
	    ELSE
			RAISE EXCEPTION 'OSS: No avalible static IPs for ip block selected';
            var_static_ip = 'ERROR - OSS: No avalible static IPs for ip block selected.';
            RETURN var_static_ip;
		END IF;

	ELSE
        RAISE NOTICE 'No billing entity id path selected.';
		SELECT static_ip
		INTO var_static_ip
		FROM static_ip_pool sip
		JOIN static_ip_carrier_def sid
		 ON (sid.carrier_def_id = sip.carrier_id)
		WHERE groupname = par_vrf
		AND is_assigned = FALSE
		AND carrier LIKE '%'||par_carrier||'%'
		AND billing_entity_id is null
		ORDER BY static_ip
		LIMIT 1
		FOR UPDATE;

        IF FOUND THEN
        	RAISE NOTICE 'Processing radreply: Username: %, static_ip: %.', par_username, var_static_ip;
			IF( SELECT TRUE FROM radreply WHERE username = par_username AND attribute = 'Class') THEN

				--Update rad_reply IP
				INSERT INTO radreply (username, attribute, op, value, priority)
				              VALUES (par_username, 'Framed-IP-Address', '=', var_static_ip::text, 10);
				GET DIAGNOSTICS v_numrows = ROW_COUNT;
	    		IF v_numrows <> 1 then
			        RAISE NOTICE 'INSERT Failed for radreply, Framed-IP : username - %, var_static_ip - %', par_username, var_static_ip;
			        RAISE EXCEPTION  '';
			    END IF;

            ELSE 

                --Update rad_reply Class
				INSERT INTO radreply (username, attribute, op, value, priority)
							VALUES (par_username, 'Class', '=', par_line_id::text, 10);
				GET DIAGNOSTICS v_numrows = ROW_COUNT;
	    		IF v_numrows <> 1 then
			        RAISE NOTICE 'INSERT Failed for radreply Class: username - %, var_static_ip - %', par_username, var_static_ip;
			        RAISE EXCEPTION  '';
			    END IF;

				--Update rad_reply IP
				INSERT INTO radreply (username, attribute, op, value, priority)
				 			VALUES (par_username, 'Framed-IP-Address', '=', var_static_ip::text, 10);
				GET DIAGNOSTICS v_numrows = ROW_COUNT;
	    		IF v_numrows <> 1 then
			        RAISE NOTICE 'INSERT Failed for radreply 2nd Framed IP: username - %, var_static_ip - %', par_username, var_static_ip;
			        RAISE EXCEPTION  '';
			    END IF;
                       
            END IF; 
			--Update static_ip_pool
			RAISE NOTICE 'Update static_ip_pool for static_ip %: line_id - %, groupname - %', var_static_ip, par_line_id, par_vrf;
			UPDATE static_ip_pool
			 SET is_assigned = 'TRUE' ,
                         line_id = par_line_id
			WHERE static_ip = var_static_ip
			AND groupname = par_vrf;

            IF NOT FOUND THEN
                RAISE NOTICE 'OSS: Radreply Update Failed.';
                var_static_ip = 'ERROR:  OSS: Radreply Update Failed.';
                RETURN var_static_ip;
			ELSE
				RETURN var_static_ip;
            END IF;

		ELSE
			RAISE NOTICE 'Check for a valid range for par_vrf %, carrier %', par_vrf, par_carrier;
			--check input paramiters for a valid range
			SELECT static_ip
			INTO var_static_ip
			FROM static_ip_pool sip
			JOIN static_ip_carrier_def sid
			 ON (sid.carrier_def_id = sip.carrier_id)
			WHERE groupname = par_vrf
			AND carrier LIKE '%'||par_carrier||'%'
			AND billing_entity_id is null
			--AND static_ip NOT LIKE '166.%'
			ORDER BY static_ip
			LIMIT 1;

			RAISE NOTICE 'var_static_ip:  %', var_static_ip;
			IF (var_static_ip IS NOT NULL) THEN
                RAISE NOTICE 'OSS: No avalible static ips for ip block selected';
                var_static_ip = 'ERROR:  OSS: No avalible static ips for ip block selected.';
                RETURN var_static_ip;
			ELSE
                RAISE NOTICE 'OSS: No IP Block For given VRF/CARRIER combination.';
                var_static_ip = 'ERROR:  OSS: No IP Block For given VRF/CARRIER combination.';
                RETURN var_static_ip;
			END IF;
		END IF;
	END IF;
 END;
  $_$;


ALTER FUNCTION csctoss.ops_api_static_ip_assign(text, text, text, integer, integer) OWNER TO csctoss_owner;

--
-- Name: ops_api_static_ip_assign_20171219(text, text, text, integer, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_static_ip_assign_20171219(text, text, text, integer, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_carrier                   text := $1;
  par_vrf                       text := $2;
  par_username                  text := $3;
  par_line_id			integer := $4;
  par_billing_entity_id         integer := $5;
  var_static_ip                 text;
  var_check_if_has_range        text;

BEGIN
    SET client_min_messages TO notice;
    RAISE NOTICE 'ops_api_static_ip_assign_20171219 is called: parameters => [carrier=%][vrf=%][username=%][line_id=%][billing_entity_id=%]', par_carrier, par_vrf, par_username, par_line_id, par_billing_entity_id;

	PERFORM public.set_change_log_staff_id(3);

	IF  par_carrier IS NULL THEN
	 RAISE EXCEPTION 'OSS: NOT ENOUGH PARAMETERS TO ASSIGN IP: CARRIER ID IS NULL';
	END IF;
	IF  par_username IS NULL THEN
	 RAISE EXCEPTION 'OSS: NOT ENOUGH PARAMETERS TO ASSIGN IP: USERNAME ID IS NULL';
	END IF;
	IF  par_line_id IS NULL THEN
	 RAISE EXCEPTION 'OSS: NOT ENOUGH PARAMETERS TO ASSIGN IP: LINE ID IS NULL';
	END IF;
	IF  par_billing_entity_id IS NULL THEN
	 RAISE EXCEPTION 'OSS: NOT ENOUGH PARAMETERS TO ASSIGN IP : BILLING ENTITY IS NULL';
	END IF;
	IF  par_vrf IS NULL THEN
	 RAISE EXCEPTION 'OSS: NOT ENOUGH PARAMETERS TO ASSIGN IP : GROUP NAME IS NULL';
	END IF;

	SELECT static_ip
	INTO var_check_if_has_range
	FROM static_ip_pool sip
	JOIN static_ip_carrier_def sid
	ON (sid.carrier_def_id = sip.carrier_id)
	WHERE groupname = par_vrf
	AND carrier LIKE '%'||par_carrier||'%'
	AND billing_entity_id = par_billing_entity_id
	--AND static_ip not like '166.%'
	ORDER BY billing_entity_id
	LIMIT 1;

	IF(var_check_if_has_range is not null)THEN
            RAISE NOTICE 'We found IP pool.';

		SELECT static_ip
		INTO var_static_ip
		FROM static_ip_pool sip
		JOIN static_ip_carrier_def sid
		ON (sid.carrier_def_id = sip.carrier_id)
		WHERE groupname = par_vrf
		AND is_assigned = FALSE
		AND carrier LIKE '%'||par_carrier||'%'
		AND billing_entity_id = par_billing_entity_id
		--AND static_ip NOT LIKE '166.%'
		ORDER BY billing_entity_id , static_ip
		LIMIT 1
		FOR UPDATE;

		     IF (var_static_ip IS NOT NULL) THEN
                         RAISE NOTICE 'We found an available IP address in the IP pool. [IP=%]', var_static_ip;

                       IF ( SELECT TRUE FROM radreply WHERE username = par_username AND attribute = 'Class') THEN

			  --Update rad_reply IP
			    INSERT INTO radreply (username, attribute, op, value, priority)
			      VALUES (par_username, 'Framed-IP-Address', '=', var_static_ip::text, 10);
                            RAISE NOTICE 'Inserted Framed-IP-Address attribute value into radreply table. [IP=%]', var_static_ip;

                       ELSE 

                            --Update rad_reply Class
                            RAISE NOTICE 'Inserting Class attribute value into radreply table. [line_id=%]', par_line_id;
			    INSERT INTO radreply (username, attribute, op, value, priority)
			      VALUES (par_username, 'Class', '=', par_line_id::text, 10);
                            RAISE NOTICE 'Inserted Class attribute value into radreply table. [line_id=%]', par_line_id;

                             --Update rad_reply IP
                            RAISE NOTICE 'Inserting Framed-IP-Address attribute value into radreply table. [IP=%]', var_static_ip;
			    INSERT INTO radreply (username, attribute, op, value, priority)
			       VALUES (par_username, 'Framed-IP-Address', '=', var_static_ip::text, 10);
                            RAISE NOTICE 'Inserted Framed-IP-Address attribute value into radreply table. [IP=%]', var_static_ip;
                       
                       END IF; 

                        RAISE NOTICE 'Updating static_ip_pool table for [IP=% / VRF=%]', var_static_ip, par_vrf;

			--Update static_ip_pool
			UPDATE static_ip_pool
			 SET is_assigned = 'TRUE' ,
                         line_id = par_line_id
			WHERE static_ip = var_static_ip
			AND groupname = par_vrf;

                        IF NOT FOUND THEN
                           RAISE EXCEPTION 'OSS: Radreply Update Failed.';
			ELSE
			   RETURN var_static_ip;
                        END IF;
		    ELSE
			RAISE EXCEPTION 'OSS: No avalible staic IPs for ip block selected';
		    END IF;

	    ELSE
		--no billing entity id
		SELECT static_ip
		INTO var_static_ip
		FROM static_ip_pool sip
		JOIN static_ip_carrier_def sid
		 ON (sid.carrier_def_id = sip.carrier_id)
		WHERE groupname = par_vrf
		AND is_assigned = FALSE
		AND carrier LIKE '%'||par_carrier||'%'
		AND billing_entity_id is null
		--AND static_ip NOT LIKE '166.%'
		ORDER BY static_ip
		LIMIT 1
		FOR UPDATE;

		IF (var_static_ip IS NOT NULL) THEN

                     IF( SELECT TRUE FROM radreply WHERE username = par_username AND attribute = 'Class') THEN

			--Update rad_reply IP
			INSERT INTO radreply (username, attribute, op, value, priority)
			 VALUES (par_username, 'Framed-IP-Address', '=', var_static_ip::text, 10);

                      ELSE 

                          --Update rad_reply Class
			INSERT INTO radreply (username, attribute, op, value, priority)
			 VALUES (par_username, 'Class', '=', par_line_id::text, 10);

                           --Update rad_reply IP
			INSERT INTO radreply (username, attribute, op, value, priority)
			 VALUES (par_username, 'Framed-IP-Address', '=', var_static_ip::text, 10);
                       
                       END IF; 
			--Update static_ip_pool
			UPDATE static_ip_pool
			 SET is_assigned = 'TRUE' ,
                         line_id = par_line_id
			WHERE static_ip = var_static_ip
			AND groupname = par_vrf;

                        IF NOT FOUND THEN
                           RAISE EXCEPTION 'OSS: Radreply Update Failed.';
			ELSE
			   RETURN var_static_ip;
                        END IF;

		ELSE
			--check input paramiters for a valid range
			SELECT static_ip
			INTO var_static_ip
			FROM static_ip_pool sip
			JOIN static_ip_carrier_def sid
			 ON (sid.carrier_def_id = sip.carrier_id)
			WHERE groupname = par_vrf
			AND carrier LIKE '%'||par_carrier||'%'
			AND billing_entity_id is null
			--AND static_ip NOT LIKE '166.%'
			ORDER BY static_ip
			LIMIT 1;

			IF (var_static_ip IS NOT NULL) THEN
				RAISE EXCEPTION 'OSS: No avalible staic ips for ip block selected';
			ELSE
				RAISE EXCEPTION 'OSS: No IP Block For given VRF/CARRIER combination.';
			END IF;

		END IF;
	END IF;

 END;
  $_$;


ALTER FUNCTION csctoss.ops_api_static_ip_assign_20171219(text, text, text, integer, integer) OWNER TO csctoss_owner;

--
-- Name: ops_api_static_ip_assign_lo(text, text, text, integer, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_static_ip_assign_lo(text, text, text, integer, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE

    par_carrier                   text := $1;
    par_vrf                       text := $2;
    par_username                  text := $3;
    par_line_id                   integer := $4;
    par_billing_entity_id         integer := $5;
    var_static_ip                 text;
    var_check_if_has_range        text;

BEGIN
    SET client_min_messages TO notice;
    RAISE NOTICE 'ops_api_static_ip_assign_lo is called: parameters => [carrier=%][vrf=%][username=%][line_id=%][billing_entity_id=%]', par_carrier, par_vrf, par_username, par_line_id, par_billing_entity_id;

    PERFORM public.set_change_log_staff_id(3);

    IF  par_carrier IS NULL THEN
        RAISE NOTICE 'OSS: NOT ENOUGH PARAMETERS TO ASSIGN IP: CARRIER ID IS NULL';
        var_static_ip = 'ERROR:  OSS - NOT ENOUGH PARAMETERS TO ASSIGN IP: CARRIER ID IS NULL';
        RETURN var_static_ip;
    END IF;
    IF  par_username IS NULL THEN
        RAISE NOTICE 'OSS: NOT ENOUGH PARAMETERS TO ASSIGN IP: USERNAME ID IS NULL';
        var_static_ip = 'ERROR:  OSS - NOT ENOUGH PARAMETERS TO ASSIGN IP: USERNAME ID IS NULL';
        RETURN var_static_ip;
    END IF;
    IF  par_line_id IS NULL THEN
        RAISE NOTICE 'OSS: NOT ENOUGH PARAMETERS TO ASSIGN IP: LINE ID IS NULL';
        var_static_ip = 'ERROR:  OSS - NOT ENOUGH PARAMETERS TO ASSIGN IP: USERNAME ID IS NULL';
        RETURN var_static_ip;
    END IF;
    IF  par_billing_entity_id IS NULL THEN
        RAISE NOTICE 'OSS: NOT ENOUGH PARAMETERS TO ASSIGN IP : BILLING ENTITY IS NULL';
        var_static_ip = 'ERROR:  OSS - NOT ENOUGH PARAMETERS TO ASSIGN IP : BILLING ENTITY IS NULL';
        RETURN var_static_ip;
    END IF;
    IF  par_vrf IS NULL THEN
        RAISE NOTICE 'OSS: NOT ENOUGH PARAMETERS TO ASSIGN IP : GROUP NAME IS NULL';
        var_static_ip = 'ERROR:  OSS - NOT ENOUGH PARAMETERS TO ASSIGN IP : GROUP NAME IS NULL';
        RETURN var_static_ip;
    END IF;

    SELECT static_ip
    INTO var_check_if_has_range
    FROM static_ip_pool sip
    JOIN static_ip_carrier_def sid
    ON (sid.carrier_def_id = sip.carrier_id)
    WHERE groupname = par_vrf
    AND carrier LIKE '%'||par_carrier||'%'
    AND billing_entity_id = par_billing_entity_id
    --AND static_ip not like '166.%'
    ORDER BY billing_entity_id
    LIMIT 1;

    IF FOUND THEN
        RAISE NOTICE 'We found IP pool.';
        SELECT static_ip
          INTO var_static_ip
          FROM static_ip_pool sip
          JOIN static_ip_carrier_def sid
            ON (sid.carrier_def_id = sip.carrier_id)
         WHERE groupname = par_vrf
           AND is_assigned = FALSE
           AND carrier LIKE '%'||par_carrier||'%'
           AND billing_entity_id = par_billing_entity_id
         ORDER BY billing_entity_id , static_ip
         LIMIT 1
           FOR UPDATE;
        IF FOUND THEN

            RAISE NOTICE 'Available address in the IP pool. [IP=%]', var_static_ip;

            IF ( SELECT TRUE 
                   FROM radreply 
                  WHERE username = par_username 
                    AND attribute = 'Class') THEN

                INSERT INTO radreply (username, attribute, op, value, priority)
                     VALUES (par_username, 'Framed-IP-Address', '=', var_static_ip::text, 10);
                RAISE NOTICE 'Inserted Framed-IP-Address attribute value into radreply table. [IP=%]', var_static_ip;

            ELSE 

                --Update rad_reply Class
                RAISE NOTICE 'Inserting Class attribute value into radreply table. [line_id=%]', par_line_id;
                INSERT INTO radreply (username, attribute, op, value, priority)
                     VALUES (par_username, 'Class', '=', par_line_id::text, 10);
                RAISE NOTICE 'Inserted Class attribute value into radreply table. [line_id=%]', par_line_id;

                 --Update rad_reply IP
                RAISE NOTICE 'Inserting Framed-IP-Address attribute value into radreply table. [IP=%]', var_static_ip;
                INSERT INTO radreply (username, attribute, op, value, priority)
                    VALUES (par_username, 'Framed-IP-Address', '=', var_static_ip::text, 10);
                RAISE NOTICE 'Inserted Framed-IP-Address attribute value into radreply table. [IP=%]', var_static_ip;
                           
            END IF; 

            RAISE NOTICE 'Updating static_ip_pool table for [IP=% / VRF=%]', var_static_ip, par_vrf;

            --Update static_ip_pool
            UPDATE static_ip_pool
               SET is_assigned = 'TRUE' 
                  ,line_id = par_line_id
             WHERE static_ip = var_static_ip
               AND groupname = par_vrf;

            -- Check if static_ip is valid.
            IF NOT FOUND THEN
                RAISE NOTICE 'UPDATE failure to static_ip_pool.';
                var_static_ip = 'ERROR:  UPDATE failure to static_ip_pool.';
                RETURN var_static_ip;
            ELSE
                RETURN var_static_ip;
            END IF;
        ELSE
            RAISE NOTICE 'OSS: No avalible staic IPs for ip block selected';
            var_static_ip = 'ERROR:  No avalible static IPs for ip block selected.';
            RETURN var_static_ip;
        END IF;
    ELSE
        --no billing entity id
        SELECT static_ip
        INTO var_static_ip
        FROM static_ip_pool sip
        JOIN static_ip_carrier_def sid
         ON (sid.carrier_def_id = sip.carrier_id)
        WHERE groupname = par_vrf
        AND is_assigned = FALSE
        AND carrier LIKE '%'||par_carrier||'%'
        AND billing_entity_id is null
        --AND static_ip NOT LIKE '166.%'
        ORDER BY static_ip
        LIMIT 1
        FOR UPDATE;

        IF FOUND THEN

            IF( SELECT TRUE FROM radreply WHERE username = par_username AND attribute = 'Class') THEN

                --Update rad_reply IP
                INSERT INTO radreply (username, attribute, op, value, priority)
                     VALUES (par_username, 'Framed-IP-Address', '=', var_static_ip::text, 10);
            ELSE 

                --Update rad_reply Class
                INSERT INTO radreply (username, attribute, op, value, priority)
                 VALUES (par_username, 'Class', '=', par_line_id::text, 10);

                --Update rad_reply IP
                INSERT INTO radreply (username, attribute, op, value, priority)
                 VALUES (par_username, 'Framed-IP-Address', '=', var_static_ip::text, 10);
                       
            END IF; 
            --Update static_ip_pool
            UPDATE static_ip_pool
             SET is_assigned = 'TRUE' ,
                               line_id = par_line_id
            WHERE static_ip = var_static_ip
            AND groupname = par_vrf;

            IF NOT FOUND THEN
                RAISE NOTICE 'OSS: Radreply Update Failed.';
                var_static_ip = 'ERROR:  OSS: Radreply Update Failed.';
                RETURN var_static_ip;
            ELSE
               RETURN var_static_ip;
            END IF;

        ELSE
            --check input paramiters for a valid range
            SELECT static_ip
            INTO var_static_ip
            FROM static_ip_pool sip
            JOIN static_ip_carrier_def sid
             ON (sid.carrier_def_id = sip.carrier_id)
            WHERE groupname = par_vrf
            AND carrier LIKE '%'||par_carrier||'%'
            AND billing_entity_id is null
            --AND static_ip NOT LIKE '166.%'
            ORDER BY static_ip
            LIMIT 1;

            IF (var_static_ip IS NOT NULL) THEN
                RAISE NOTICE 'OSS: No avalible staic ips for ip block selected';
                var_static_ip = 'ERROR:  OSS: No avalible staic ips for ip block selected.';
                RETURN var_static_ip;
            ELSE
                RAISE NOTICE 'OSS: No IP Block For given VRF/CARRIER combination.';
                var_static_ip = 'ERROR:  OSS: No IP Block For given VRF/CARRIER combination.';
                RETURN var_static_ip;
            END IF;
        END IF;
    END IF;
END;
  $_$;


ALTER FUNCTION csctoss.ops_api_static_ip_assign_lo(text, text, text, integer, integer) OWNER TO csctoss_owner;

--
-- Name: ops_api_static_ip_assign_v2(text, text, text, integer, integer, integer, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_static_ip_assign_v2(text, text, text, integer, integer, integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_carrier                   text := $1;
  par_vrf                       text := $2;
  par_username                  text := $3;
  par_line_id			integer := $4;
  par_billing_entity_id         integer := $5;
  par_reservation_id            integer := $6;
  par_staff_id                  integer := $7;
  var_static_ip                 text;
  var_num_affected	        integer;
  
BEGIN
  PERFORM public.set_change_log_staff_id (par_staff_id);

   --CHECK THE PARAMITERS

   --CHECK CARRIER
   IF  par_carrier IS NULL THEN
    RAISE EXCEPTION 'OSS: NOT ENOUGH PARAMETERS TO ASSIGN IP: CARRIER ID IS NULL'; 
   END IF;
   IF ((SELECT true FROM static_ip_carrier_def where carrier = par_carrier limit 1) IS NULL) THEN
      RAISE EXCEPTION 'OSS: IP ASSIGNMENT ERROR: INVALID CARRIER'; 
   END IF;
   
   --CHECK USERNAME
   IF  par_username IS NULL THEN
     RAISE EXCEPTION 'OSS: IP ASSIGNMENT ERROR: INVALID USERNAME'; 
   END IF;
   IF  par_username = '' THEN
     RAISE EXCEPTION 'OSS: IP ASSIGNMENT ERROR: INVALID USERNAME'; 
   END IF;
   IF ((SELECT TRUE FROM username WHERE username = par_username LIMIT 1) IS NULL) THEN
      RAISE EXCEPTION 'OSS: IP ASSIGNMENT ERROR:USERNAME NOT IN USERNAME TABLE'; 
   END IF;
   
   --CHECK LINE ID
   IF  par_line_id IS NULL THEN
    RAISE EXCEPTION 'OSS: IP ASSIGNMENT ERROR: LINE ID IS REQUIRED'; 
   END IF;

   --CHECK BILLING ENTITY ID
   IF  par_billing_entity_id IS NULL THEN
    RAISE EXCEPTION 'OSS: IP ASSIGNMENT ERROR: BILLING ENTITY ID IS REQUIRED'; 
   END IF;
   IF ((SELECT TRUE FROM billing_entity WHERE billing_entity_id = par_billing_entity_id LIMIT 1) IS NULL) THEN
      RAISE EXCEPTION 'OSS: IP ASSIGNMENT ERROR: BILLING ENITY ID IS NOT A VALID BILLING ENITY'; 
   END IF;
   

   IF  par_vrf IS NULL THEN
    RAISE EXCEPTION 'OSS: IP ASSIGNMENT ERROR: GROUPNAME IS REQUIRED'; 
   END IF;
   IF  par_vrf = '' THEN
    RAISE EXCEPTION 'OSS: IP ASSIGNMENT ERROR: INVALID GROUPNAME'; 
   END IF;
   IF ((SELECT TRUE FROM groupname WHERE groupname = par_vrf LIMIT 1) IS NULL) THEN
      RAISE EXCEPTION 'OSS: IP ASSIGNMENT ERROR:INVALID USERGROUP/VRF'; 
   END IF;

    RAISE NOTICE 'reservation_id = %',par_reservation_id;
    --Assigning the device to a reserved IP, if a reservation ID is passed to the function. 
    IF par_reservation_id IS NOT NULL THEN
      --GET IP FROM RESERVATION
      RAISE NOTICE 'par_reservation_id (reservation) = %',par_reservation_id;
      SELECT static_ip INTO  var_static_ip from static_ip_active_reservations_vw where reservation_id = par_reservation_id AND carrier = par_carrier AND groupname = par_vrf;

      RAISE NOTICE 'var_static_ip (reservation) = %',var_static_ip;
  
      --CHECK THAT AN IP HAS BEEN SELECTED. 
      IF (var_static_ip IS NULL) THEN
          IF ((SELECT TRUE FROM static_ip_active_reservations_vw WHERE id = par_reservation_id) IS NOT NULL) THEN
              RAISE EXCEPTION 'OSS: RESERVATION ERROR: THE RESERVATION ID IS NOT ACTIVE';
	  ELSE			
             RAISE EXCEPTION 'OSS: RESERVATION ERROR: THE RESERVATION IP DOSE NOT MATCH IP POOL CONSTRATINTS';
          END IF;

      ELSE
        --ASSIGN THE IP
	INSERT INTO radreply (username, attribute, op, value, priority)
	 VALUES (par_username, 'Class', '=', par_line_id::text, 10);
        IF (ROW_COUNT = 0) THEN
          RAISE EXCEPTION ' OSS: IP ASSIGNMENT ERROR: ERROR INSERTING INTO RADREPLY';   
        END IF; 

         
        INSERT INTO radreply (username, attribute, op, value, priority)
	 VALUES (par_username, 'Framed-IP-Address', '=', var_static_ip::text, 10);
        IF (ROW_COUNT = 0) THEN
          RAISE EXCEPTION ' OSS: IP ASSIGNMENT ERROR: ERROR INSERTING INTO RADREPLY';   
        END IF; 
         
        UPDATE static_ip_pool
	SET is_assigned = 'TRUE',
        line_id = par_line_id
	WHERE static_ip = var_static_ip
	AND groupname = par_vrf;
        IF (ROW_COUNT = 0) THEN
          RAISE EXCEPTION ' OSS: IP ASSIGNMENT ERROR: ERROR UPDATING STATIC IP POOL';   
        END IF; 

        
      END IF; 


    --Assigning the device to the next avalible IP in the POOL.
   ELSE 
     IF((SELECT TRUE from static_ips_vw WHERE groupname = par_vrf AND carrier = par_carrier AND billing_entity_id = par_billing_entity_id ORDER BY billing_entity_id LIMIT 1)IS NOT NULL)THEN
       RAISE NOTICE 'HAS SPECIAL POOL';
       SELECT static_ip INTO var_static_ip FROM static_ips_available_vw WHERE groupname = par_vrf AND carrier = par_carrier AND billing_entity_id = par_billing_entity_id ORDER BY billing_entity_id LIMIT 1;
     ELSE
       SELECT static_ip INTO var_static_ip FROM static_ips_available_vw where carrier = par_carrier AND groupname = par_vrf order by billing_entity_id asc limit 1;
     END IF;

      RAISE NOTICE 'var_static_ip (regular ip assign) = %',var_static_ip;
      
     IF (var_static_ip IS NULL) THEN
       
	IF((SELECT true from static_ips_vw where carrier = par_carrier AND groupname = par_vrf limit 1) IS NULL) THEN
             RAISE EXCEPTION 'OSS: IP ASSIGNMENT ERROR: NO IP FOR VRF / CARRIER COMBINATION';
        ELSE
             RAISE EXCEPTION 'OSS: IP ASSIGNMENT ERROR: NO IPS AVALIBLE IN IP POOL';
	END IF; 
      ELSE
        --ASSIGN THE IP
        INSERT INTO radreply (username, attribute, op, value, priority)
	 VALUES (par_username, 'Class', '=', par_line_id::text, 10);
         GET DIAGNOSTICS var_num_affected = ROW_COUNT;
        IF var_num_affected = 0 THEN
          RAISE EXCEPTION ' OSS: IP ASSIGNMENT ERROR: ERROR INSERTING INTO RADREPLY';   
         END IF; 



        INSERT INTO radreply (username, attribute, op, value, priority)
	 VALUES (par_username, 'Framed-IP-Address', '=', var_static_ip::text, 10);
       GET DIAGNOSTICS var_num_affected = ROW_COUNT;
       IF var_num_affected = 0 THEN
          RAISE EXCEPTION ' OSS: IP ASSIGNMENT ERROR: ERROR INSERTING INTO RADREPLY';   
         END IF; 

        
        UPDATE static_ip_pool
	SET is_assigned = 'TRUE',
        line_id = par_line_id
	WHERE static_ip = var_static_ip
	AND groupname = par_vrf;
	GET DIAGNOSTICS var_num_affected = ROW_COUNT;
       IF var_num_affected = 0 THEN
          RAISE EXCEPTION ' OSS: IP ASSIGNMENT ERROR: ERROR UPDATING STATIC IP POOL';   
        END IF; 
        
     END IF;
    END IF;
   RETURN true;
 END;
  $_$;


ALTER FUNCTION csctoss.ops_api_static_ip_assign_v2(text, text, text, integer, integer, integer, integer) OWNER TO csctoss_owner;

--
-- Name: ops_api_suspend(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_suspend(text) RETURNS SETOF ops_api_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_esn_hex                   text := $1;
  var_equipment_id              integer;
  var_line_id                   integer;
  var_username                  text;
  var_mdn                       text;
  var_usergroup_id              integer;
  v_numrows                     integer;
  v_errmsg                      text;

  var_return_row                ops_api_retval%ROWTYPE;

BEGIN
  PERFORM public.set_change_log_staff_id (3);

  v_errmsg := 'ERROR:  Input ESN HEX Is Null. Please enter a value.';
  IF par_esn_hex = '' THEN
    RAISE EXCEPTION '';
  END IF;

  -- Validate parameters.
  v_errmsg := 'ERROR:  ESN HEX value does not exist - ' || par_esn_hex;
  SELECT equipment_id INTO var_equipment_id
  FROM unique_identifier
  WHERE unique_identifier_type = 'ESN HEX'
  AND value LIKE par_esn_hex;

  IF NOT FOUND THEN
    RAISE EXCEPTION '' ;
  ELSE
    -- Retrieve MDN and Username values
    SELECT value INTO var_mdn
    FROM unique_identifier
    WHERE unique_identifier_type = 'MDN'
    AND equipment_id = var_equipment_id;

    v_errmsg := 'ERROR:  Username does not exist for the device ' || var_equipment_id;
    SELECT unam.username INTO var_username
    FROM username unam
    WHERE SUBSTR(unam.username,1,10) = var_mdn;

    IF NOT FOUND THEN
      RAISE EXCEPTION '';
    END IF;
  END IF;

  -- To Suspend an assigned device which is not expired
  IF EXISTS (SELECT TRUE 
               FROM line 
              WHERE radius_username LIKE var_username 
                AND line_label LIKE par_esn_hex AND end_date IS NULL) THEN
    IF var_username ~ '@vzw' THEN
      IF NOT EXISTS( SELECT TRUE 
                       FROM usergroup 
                      WHERE username LIKE var_username 
                        AND groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione') THEN
        INSERT INTO usergroup(username, groupname, priority)
        VALUES (var_username, 'SERVICE-vzwretail_wallgarden_cnione', 2);
      END IF;

      IF NOT EXISTS( SELECT TRUE 
                       FROM usergroup 
                      WHERE username LIKE var_username 
                        AND groupname LIKE 'userdisconnected') THEN
        INSERT INTO usergroup(username, groupname, priority)
        VALUES (var_username, 'userdisconnected', 3);
      END IF;
    END IF;
  ELSE
    IF EXISTS (SELECT TRUE FROM username WHERE username LIKE var_username) THEN

      IF var_username ~ '@vzw' THEN
        IF NOT EXISTS( SELECT TRUE 
                         FROM usergroup 
                        WHERE username LIKE var_username 
                          AND groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione' 
                          AND priority = 1) THEN
          INSERT INTO usergroup(username, groupname, priority)
          VALUES (var_username, 'SERVICE-vzwretail_wallgarden_cnione', 2);
        END IF;
      ELSE
        IF NOT EXISTS( SELECT TRUE 
                         FROM usergroup 
                        WHERE username LIKE var_username 
                          AND groupname LIKE 'disconnected' 
                          AND priority = 1) THEN
          INSERT INTO usergroup(username, groupname, priority)
	        VALUES (var_username, 'disconnected', 1);
        END IF;
      END IF;

	  END IF;

  END IF;

  var_return_row.result_code := true ;
  var_return_row.error_message := '' ;
  RETURN NEXT var_return_row ;
  RETURN ;

  EXCEPTION
    WHEN raise_exception THEN
      var_return_row.result_code := false;
      var_return_row.error_message:=v_errmsg;
      RETURN NEXT var_return_row;
      RETURN;

    WHEN others THEN
      var_return_row.result_code := false;
      var_return_row.error_message:=v_errmsg;
      RAISE NOTICE 'OTHER EXCEPTION:  %', v_errmsg;
      RETURN NEXT var_return_row;
      RETURN;

END ;
$_$;


ALTER FUNCTION csctoss.ops_api_suspend(text) OWNER TO csctoss_owner;

--
-- Name: ops_api_suspend_ex(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_suspend_ex(text) RETURNS SETOF ops_api_suspend_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_esn_hex                   text := $1;
  var_equipment_id              integer;
  var_line_id                   integer;
  var_username                  text;
  var_mdn                       text;
  var_usergroup_id              integer;
  var_return_row                ops_api_suspend_retval%ROWTYPE;

BEGIN
  PERFORM public.set_change_log_staff_id (3);

  IF par_esn_hex IS NULL OR par_esn_hex = '' THEN
    var_return_row.result_code := false;
    var_return_row.error_message := 'Input ESN HEX is NULL or empty. Please enter a value.';
    RETURN NEXT var_return_row ;
    RETURN ;
  END IF;

  -- Validate parameters.
  SELECT equipment_id INTO var_equipment_id
  FROM unique_identifier
  WHERE unique_identifier_type = 'ESN HEX'
  AND value LIKE par_esn_hex;

  IF NOT FOUND THEN
    var_return_row.result_code := false;
    var_return_row.error_message := 'ESN HEX value does not exists.';
    RETURN NEXT var_return_row ;
    RETURN ;
  ELSE
    -- Retrieve MDN and Username values
    SELECT value INTO var_mdn
    FROM unique_identifier
    WHERE unique_identifier_type = 'MDN'
    AND equipment_id = var_equipment_id;

    SELECT unam.username INTO var_username
    FROM username unam
    WHERE SUBSTR(unam.username,1,10) = var_mdn;

    IF NOT FOUND THEN
      var_return_row.result_code := false;
      var_return_row.error_message := 'Username does not exists for the device.';
      RETURN NEXT var_return_row ;
      RETURN ;
    END IF;
  END IF;

  -- To Suspend an assigned device which is not expired
  IF EXISTS (SELECT TRUE FROM line WHERE radius_username LIKE var_username AND line_label LIKE par_esn_hex AND end_date IS NULL) THEN
    IF var_username ~ '@vzw' THEN
      IF NOT EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione' AND priority = 1) THEN
        INSERT INTO usergroup(username, groupname, priority)
        VALUES (var_username, 'SERVICE-vzwretail_wallgarden_cnione', 2);
      END IF;
    ELSE
      IF NOT EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND groupname LIKE 'disconnected' AND priority = 1) THEN
        INSERT INTO usergroup(username, groupname, priority)
        VALUES (var_username, 'disconnected', 1);
      END IF;
    END IF;

  ELSE
    IF EXISTS (SELECT TRUE FROM username WHERE username LIKE var_username) THEN

      IF var_username ~ '@vzw' THEN
        IF NOT EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione' AND priority = 1) THEN
          INSERT INTO usergroup(username, groupname, priority)
          VALUES (var_username, 'SERVICE-vzwretail_wallgarden_cnione', 2);
        END IF;
      ELSE
        IF NOT EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND groupname LIKE 'disconnected' AND priority = 1) THEN
          INSERT INTO usergroup(username, groupname, priority)
	        VALUES (var_username, 'disconnected', 1);
        END IF;
      END IF;

	  END IF;

  END IF;

  var_return_row.result_code := true ;
  var_return_row.error_message := 'Succeeded.' ;
  RETURN NEXT var_return_row ;
  RETURN ;

END ;
$_$;


ALTER FUNCTION csctoss.ops_api_suspend_ex(text) OWNER TO csctoss_owner;

--
-- Name: ops_api_toggle_userdisconnect(text, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_toggle_userdisconnect(text, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$

DECLARE
  par_username		text:=$1;
  par_line_id		integer:=$2;
  var_usergroup		text:='userdisconnected';
  username_chk		text:='';
  rapreply_line_chk	integer:='';
  var_priority		integer:=0;
  var_num_affected	integer:=0;
  
BEGIN

  SELECT
   username
  INTO
   username_chk
  WHERE 1=1
  AND username = par_username;

  IF username_chk IS NULL THEN
    RAISE EXCEPTION '[ops_api_toggle_userdisconnect(text,integer)] Username not found in table csctoss.username [username=%]', par_username;
  END IF;

  SELECT
   value
  INTO
   rapreply_line_chk
  FROM radreply
  WHERE 1=1
  AND attribute = 'Class'
  AND username = par_username;

  IF rapreply_line_chk != par_line_id THEN
    RAISE EXCEPTION '[ops_api_toggle_userdisconnect(text,integer)] Line assigned to device does not match line_id passed to function [passed line_id=%][assigned line_id=%]' ,par_line_id,rapreply_line_chk;
  END IF;

  SELECT
   priority
  INTO
   var_priority
  FROM groupname
  WHERE 1=1
  AND groupname = var_usergroup;

  IF var_priority IS NULL OR var_priority < 1 THEN
    RAISE EXCEPTION '[ops_api_toggle_userdisconnect(text,integer)] Could not find priority of usergroup in table csctoss.groupname [usergroup=%]', var_usergroup;
  END IF;

  
  --if device already userdisconnected - then toggle
  IF (SELECT TRUE from usergroup WHERE groupname = 'userdisconnected' AND username = par_username)
    DELETE FROM usergroup WHERE groupname = 'userdisconnected' AND username = par_username;

    GET DIAGNOSTICS var_num_affected = ROW_COUNT;
    IF var_num_affected = 0 THEN
      RAISE EXCEPTION '[ops_api_toggle_userdisconnect(text,integer)] Error while removing userdisconencted usergroup';
    END IF;
  ELSE
    --if device not userdisconnected - then toggle
    --TODO test this
    IF (SELECT TRUE from usergroup WHERE groupname != 'userdisconnected' AND username = par_username)
      INSERT INTO usergroup 
       (username,groupname,priority)
      VALUES
       (par_username,var_usergroup,var_priority);

      GET DIAGNOSTICS var_num_affected = ROW_COUNT;
      IF var_num_affected = 0 THEN
        RAISE EXCEPTION '[ops_api_toggle_userdisconnect(text,integer)] Error while adding userdisconencted usergroup';   
      END IF;
    END IF;  
  END IF;

 RETURN true;
 
END;
$_$;


ALTER FUNCTION csctoss.ops_api_toggle_userdisconnect(text, integer) OWNER TO csctoss_owner;

--
-- Name: ops_api_unique_ids_by_static_ip(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_unique_ids_by_static_ip(text) RETURNS SETOF ops_api_unique_ids_by_static_ip_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_static_ip			text:= $1;
  var_return			ops_api_unique_ids_by_static_ip_retval;
  var_username_from_rr		text;
  var_mdn_from_username		text;
  var_equipment_id		integer;
  var_hex			text;
  var_dec			text;
  var_min			text;
  var_mac			text;
  var_sn			text;

  
BEGIN

  set client_min_messages TO notice;

  IF par_static_ip IS NULL THEN
    RAISE EXCEPTION 'static_ip cannot be null' ;  
  END IF;


  IF NOT EXISTS (SELECT TRUE FROM radreply where attribute = 'Framed-IP-Address' and value = par_static_ip) THEN
    RAISE EXCEPTION 'The given Static IP is not assigned to a live line. (%)' , par_static_ip ;     
    --IF NOT (SELECT TRUE FROM static_ip_pool WHERE static_ip = par_static_ip) THEN
      --RAISE EXCEPTION 'Unrecongnized static_ip given. Cannot proceed.' ;
    --END IF;
  END IF;

  SELECT
   username
  INTO
   var_username_from_rr
  FROM csctoss.radreply
  WHERE 1=1
  AND attribute = 'Framed-IP-Address'
  AND value = par_static_ip ;

  --if null
----------------------
--gather identifiers
----------------------
  --get MDN
  SELECT substr(var_username_from_rr,1,10) INTO var_mdn_from_username ;
  --if null

  --get equipment_id
  SELECT 
   equipment_id
  INTO
   var_equipment_id
  FROM csctoss.unique_identifier
  WHERE 1=1
  AND unique_identifier_type = 'MDN'
  AND value = var_mdn_from_username ;

  --IF var_equipment_id IS NULL THEN
    --var_equipment_id := 'NOT FOUND' ;
  --END IF;

  --get hex
  SELECT 
   value 
  INTO 
   var_hex 
  FROM csctoss.unique_identifier 
  WHERE 1=1
  AND unique_identifier_type = 'ESN HEX'
  AND equipment_id = var_equipment_id ;  

  IF var_hex IS NULL THEN
    var_hex := 'NOT FOUND' ;
  END IF;

  --get dec
  SELECT 
   value 
  INTO 
   var_dec 
  FROM csctoss.unique_identifier 
  WHERE 1=1
  AND unique_identifier_type = 'ESN DEC'
  AND equipment_id = var_equipment_id ;  

  IF var_dec IS NULL THEN
    var_dec := 'NOT FOUND' ;
  END IF;
  
  --get SN
  SELECT 
   value 
  INTO 
   var_sn 
  FROM csctoss.unique_identifier 
  WHERE 1=1
  AND unique_identifier_type = 'SERIAL NUMBER'
  AND equipment_id = var_equipment_id ;  

  IF var_sn IS NULL THEN
    var_sn := 'NOT FOUND' ;
  END IF;
  
  --get MIN
  SELECT 
   value 
  INTO 
   var_min
  FROM csctoss.unique_identifier 
  WHERE 1=1
  AND unique_identifier_type = 'MIN'
  AND equipment_id = var_equipment_id ;  

  IF var_min IS NULL THEN
    var_min := 'NOT FOUND' ;
  END IF;
  
  --get mac
  SELECT 
   value 
  INTO 
   var_mac
  FROM csctoss.unique_identifier 
  WHERE 1=1
  AND unique_identifier_type = 'MAC ADDRESS'
  AND equipment_id = var_equipment_id ;  
  
  IF var_mac IS NULL THEN
    var_mac := 'NOT FOUND' ;
  END IF;
  
  RAISE NOTICE 'var_username_from_rr 	= %' , var_username_from_rr ;
  RAISE NOTICE 'var_equipment_id 	= %' , var_equipment_id ;
  RAISE NOTICE 'var_mdn_from_username	= %' , var_mdn_from_username;
  RAISE NOTICE 'var_hex		 	= %' , var_hex ;
  RAISE NOTICE 'var_dec		 	= %' , var_dec ;
  RAISE NOTICE 'var_min		 	= %' , var_min ;
  RAISE NOTICE 'var_mac 		= %' , var_mac ;
  RAISE NOTICE 'var_sn	 		= %' , var_sn ;


  var_return.equipment_id = var_equipment_id ;
  var_return.esn_hex = var_hex ;
  var_return.esn_dec = var_dec;
  var_return.serial_number = var_sn ;
  var_return.mac_address = var_mac;
  var_return.mdn = var_mdn_from_username ;
  var_return.min = var_min ;
  
  RETURN NEXT var_return;
  RETURN;

END;
$_$;


ALTER FUNCTION csctoss.ops_api_unique_ids_by_static_ip(text) OWNER TO csctoss_owner;

--
-- Name: ops_api_unique_ids_by_static_ip_test(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_unique_ids_by_static_ip_test(text) RETURNS SETOF ops_api_unique_ids_by_static_ip_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_static_ip			text := $1;
  var_return			ops_api_unique_ids_by_static_ip_retval;

 
BEGIN
/*
  IF par_static_ip IS NULL THEN
    RAISE EXCEPTION 'static_ip cannot be null' ;  
  END IF;


  IF NOT (SELECT TRUE FROM radreply where attribute = 'Framed-IP-Address' and value = par_static_ip) THEN
       
    IF NOT (SELECT TRUE FROM static_ip_pool WHERE static_ip = par_static_ip) THEN
      RAISE EXCEPTION 'Unrecongnized static_ip given. Cannot proceed.' ;
    END IF;
  END IF;
*/

  var_return.equipment_id = 32456 ;
  var_return.esn_hex = 'A1000009426225' ;
  var_return.esn_dec = '270113178504350501';
  var_return.serial_number = '688531' ;
  var_return.mac_address = '0080440F037A' ;
  var_return.mdn = '9173329909';
  var_return.min = '000009174981129' ;
  
  RETURN NEXT var_return;
  RETURN;


  --select * from unique_identifier where equipment_id = 32456

END;
$_$;


ALTER FUNCTION csctoss.ops_api_unique_ids_by_static_ip_test(text) OWNER TO csctoss_owner;

--
-- Name: ops_api_unique_ids_radius_info(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_unique_ids_radius_info(text) RETURNS SETOF ops_api_unique_ids_radius_info_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_esn_hex              text := $1;
  var_equipment_id         integer;
  var_mdn                  text;
  var_return_row           ops_api_unique_ids_radius_info_retval%ROWTYPE;

BEGIN
    IF par_esn_hex = '' THEN 
	  
       RAISE EXCEPTION 'Input ESN HEX Is Null. Please enter a value ';

    ELSE 

   -- Validate parameters.
    SELECT equipment_id INTO var_equipment_id
    FROM unique_identifier
    WHERE unique_identifier_type LIKE 'ESN HEX'
    AND value LIKE par_esn_hex;

      IF var_equipment_id IS NULL THEN

          RAISE EXCEPTION 'ESN HEX value doesnt exists' ;

      ELSE 
	
          SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text; 	   

      END IF;
      
    END IF;
	
    FOR var_return_row IN 

 	SELECT equp.equipment_id, le.line_id, le.start_date AS line_assignment_start, le.end_date AS line_assignment_end
              ,par_esn_hex  
              ,(SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text) AS esn_dec
	      ,(SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MAC ADDRESS'::text) AS mac_address
	      ,(SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'SERIAL NUMBER'::text) AS serial_number
	      ,var_mdn
	      ,(SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text) AS min
              ,(SELECT unam.username FROM username unam WHERE SUBSTR(unam.username,1,10) LIKE var_mdn) AS radius_username
              ,(SELECT groupname FROM usergroup WHERE SUBSTR(username,1,10) LIKE var_mdn AND groupname NOT LIKE 'disconnected')
              ,(SELECT attribute FROM  radcheck WHERE SUBSTR(username,1,10) LIKE var_mdn)
	FROM equipment equp
        JOIN line_equipment le ON (le.equipment_id = equp.equipment_id)
        WHERE equp.equipment_id = var_equipment_id 
        ORDER BY equp.equipment_id

        LOOP

           RETURN NEXT var_return_row;
 
       END LOOP;      

    RETURN;

END ;
$_$;


ALTER FUNCTION csctoss.ops_api_unique_ids_radius_info(text) OWNER TO csctoss_owner;

--
-- Name: ops_api_user_restore(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_user_restore(text) RETURNS SETOF ops_api_restore_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_esn_hex                   text := $1;
  par_username                  text;
  var_equipment_id              integer;
  var_username                  text;
  var_mdn                       text;
  var_return_row                ops_api_restore_retval%ROWTYPE;

BEGIN
  PERFORM public.set_change_log_staff_id (3);

  IF par_esn_hex = '' THEN
    RAISE EXCEPTION 'Input ESN HEX Is Null. Please enter a value ';
  END IF;

  -- Validate parameters.
  SELECT equipment_id INTO var_equipment_id
  FROM unique_identifier
  WHERE unique_identifier_type = 'ESN HEX'
  AND value LIKE par_esn_hex;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'ESN HEX value doesnt exists' ;
  END IF;

  -- Retrieve MDN or MIN and Username values
  IF par_username LIKE '%@uscc.net' THEN
    SELECT value INTO var_mdn
    FROM unique_identifier
    WHERE unique_identifier_type = 'MIN'
    AND equipment_id = var_equipment_id;
  ELSE
    SELECT value INTO var_mdn
    FROM unique_identifier
    WHERE unique_identifier_type = 'MDN'
    AND equipment_id = var_equipment_id;
  END IF;

  SELECT unam.username INTO var_username
  FROM username unam
  WHERE 1 = 1
  AND username ~ '@'
  AND username NOT LIKE '%cn01.%'
  AND substr(username, 1, strpos(username, '@') - 1) = var_mdn;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Username does not exists for the device';
  END IF;

  -- To Restore a suspended device
  IF EXISTS(SELECT TRUE 
              FROM unique_identifier 
              JOIN line_equipment le USING (equipment_id) 
             WHERE value = var_mdn 
               AND le.end_date IS NULL) THEN
    IF EXISTS( SELECT TRUE 
                 FROM usergroup 
                WHERE username LIKE var_username 
                  AND (   groupname LIKE 'userdisconnected' 
                       OR groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione')) THEN
      DELETE FROM usergroup
      WHERE username LIKE var_username
      AND groupname LIKE 'userdisconnected';

      DELETE FROM usergroup
      WHERE username LIKE var_username
      AND groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione';
  
    ELSE
      RAISE EXCEPTION 'Device is not suspended and can not be restored';
    END IF;
  ELSE
    RAISE EXCEPTION 'Cannot restore a canceled device';
  END IF;

  var_return_row.result_code := true ;
  var_return_row.error_message := 'Device is restored.' ;
  RETURN NEXT var_return_row ;
  RETURN ;

END ;
$_$;


ALTER FUNCTION csctoss.ops_api_user_restore(text) OWNER TO csctoss_owner;

--
-- Name: ops_api_user_restore(text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_user_restore(text, text) RETURNS SETOF ops_api_restore_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_esn_hex                   text := $1;
  par_username                  text := $2;

  var_equipment_id              integer;
  var_username                  text;
  var_mdn                       text;
  var_return_row                ops_api_restore_retval%ROWTYPE;

BEGIN
  PERFORM public.set_change_log_staff_id (3);

  IF par_esn_hex = '' THEN
    RAISE EXCEPTION 'Input ESN HEX is Null. Please enter a value ';
  END IF;

  IF par_username = '' THEN
    RAISE EXCEPTION 'Input username is Null. Please enter a value ';
  END IF;

  -- Validate parameters.
  SELECT equipment_id INTO var_equipment_id
  FROM unique_identifier
  WHERE unique_identifier_type = 'ESN HEX'
  AND value LIKE par_esn_hex;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'ESN HEX value does not exists' ;
  END IF;

  -- Retrieve MDN or MIN and Username values
  IF par_username LIKE '%@uscc.net' THEN
    SELECT value INTO var_mdn
    FROM unique_identifier
    WHERE unique_identifier_type = 'MIN'
    AND equipment_id = var_equipment_id;
  ELSE
    SELECT value INTO var_mdn
    FROM unique_identifier
    WHERE unique_identifier_type = 'MDN'
    AND equipment_id = var_equipment_id;
  END IF;

  SELECT unam.username INTO var_username
  FROM username unam
  WHERE 1 = 1
  AND username ~ '@'
  AND username NOT LIKE '%cn01.%'
  AND substr(username, 1, strpos(username, '@') - 1) = var_mdn;
  --AND SUBSTR(unam.username,1,10) = var_mdn;

  -- To Restore a suspended device
  IF EXISTS(SELECT TRUE 
              FROM unique_identifier 
              JOIN line_equipment le USING (equipment_id) 
             WHERE value = var_mdn 
               AND le.end_date IS NULL) THEN
    IF EXISTS( SELECT TRUE 
                 FROM usergroup 
                WHERE username LIKE var_username 
                  AND (   groupname LIKE 'userdisconnected' 
                       OR groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione')) THEN
      DELETE FROM usergroup
       WHERE username LIKE var_username
         AND groupname LIKE 'userdisconnected';

      DELETE FROM usergroup
      WHERE username LIKE var_username
      AND groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione';
    ELSE
      RAISE EXCEPTION 'Device is not suspended and can not be restored';
    END IF;
  ELSE
    RAISE EXCEPTION 'Cannot restore a canceled device';
  END IF;

  var_return_row.result_code := true ;
  var_return_row.error_message := 'Device is restored.' ;
  RETURN NEXT var_return_row ;
  RETURN ;

END ;
$_$;


ALTER FUNCTION csctoss.ops_api_user_restore(text, text) OWNER TO csctoss_owner;

--
-- Name: ops_api_user_suspend(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_user_suspend(text) RETURNS SETOF ops_api_suspend_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_esn_hex                   text := $1;
  par_username                  text;
  var_equipment_id              integer;
  var_line_id                   integer;
  var_username                  text;
  var_mdn                       text;
  var_usergroup_id              integer;
  var_return_row                ops_api_suspend_retval%ROWTYPE;

BEGIN
  PERFORM public.set_change_log_staff_id (3);

  IF par_esn_hex = '' THEN
     RAISE EXCEPTION 'Input ESN HEX Is Null. Please enter a value ';
  END IF;

  -- Validate parameters.
  SELECT equipment_id INTO var_equipment_id
  FROM unique_identifier
  WHERE unique_identifier_type = 'ESN HEX'
  AND value LIKE par_esn_hex;

  IF NOT FOUND THEN
     RAISE EXCEPTION 'ESN HEX value doesnt exists' ;
  END IF;

  -- Retrieve MDN or MIN and Username values
  IF par_username LIKE '%@uscc.net' THEN
    SELECT value INTO var_mdn
    FROM unique_identifier
    WHERE unique_identifier_type = 'MIN'
    AND equipment_id = var_equipment_id;
  ELSE
    SELECT value INTO var_mdn
    FROM unique_identifier
    WHERE unique_identifier_type = 'MDN'
    AND equipment_id = var_equipment_id;
  END IF;

  SELECT unam.username INTO var_username
  FROM username unam
  WHERE 1 = 1
  AND username ~ '@'
  AND username NOT LIKE '%cn01.%'
  AND substr(username, 1, strpos(username, '@') - 1) = var_mdn;
  --AND SUBSTR(unam.username,1,10) = var_mdn;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Username doesnt exists for the device';
  END IF;

  -- To Suspend an assigned device which is not expired
  IF EXISTS (SELECT TRUE FROM line WHERE radius_username LIKE var_username AND line_label LIKE par_esn_hex AND end_date IS NULL) THEN
    IF var_username ~ '@vzw' THEN
      IF NOT EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione') THEN
        INSERT INTO usergroup(username, groupname, priority)
        VALUES (var_username, 'SERVICE-vzwretail_wallgarden_cnione', 2);
      END IF;
/*
      IF NOT EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND groupname LIKE 'userdisconnected') THEN
        INSERT INTO usergroup(username, groupname, priority)
        VALUES (var_username, 'userdisconnected', 3);
      END IF;
*/
    ELSE
      IF NOT EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND groupname LIKE 'userdisconnected') THEN
        INSERT INTO usergroup(username, groupname, priority)
        VALUES (var_username, 'userdisconnected', 1);
      END IF;
    END IF;

  ELSE
    IF EXISTS (SELECT TRUE FROM username WHERE username LIKE var_username) THEN

      IF var_username ~ '@vzw' THEN
        IF NOT EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione') THEN
          INSERT INTO usergroup(username, groupname, priority)
          VALUES (var_username, 'SERVICE-vzwretail_wallgarden_cnione', 2);
        END IF;
      ELSE
        IF NOT EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND groupname LIKE 'userdisconnected') THEN
          INSERT INTO usergroup(username, groupname, priority)
	        VALUES (var_username, 'userdisconnected', 1);
        END IF;
      END IF;

	  END IF;

  END IF;

  var_return_row.result_code := true ;
  var_return_row.error_message := '' ;
  RETURN NEXT var_return_row ;
  RETURN ;

END ;
$_$;


ALTER FUNCTION csctoss.ops_api_user_suspend(text) OWNER TO csctoss_owner;

--
-- Name: ops_api_user_suspend(text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_api_user_suspend(text, text) RETURNS SETOF ops_api_suspend_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_esn_hex                   text := $1;
  par_username                  text := $2;

  var_equipment_id              integer;
  var_line_id                   integer;
  var_username                  text;
  var_mdn                       text;
  var_usergroup_id              integer;
  var_return_row                ops_api_suspend_retval%ROWTYPE;

BEGIN
  PERFORM public.set_change_log_staff_id (3);

  IF par_esn_hex = '' THEN
     RAISE EXCEPTION 'Input ESN HEX is Null. Please enter a value ';
  END IF;

  IF par_username = '' THEN
     RAISE EXCEPTION 'Input username is Null. Please enter a value ';
  END IF;

  -- Validate parameters.
  SELECT equipment_id INTO var_equipment_id
  FROM unique_identifier
  WHERE unique_identifier_type = 'ESN HEX'
  AND value LIKE par_esn_hex;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'ESN HEX value does not exists' ;
  END IF;

  -- Retrieve MDN or MIN and Username values
  IF par_username LIKE '%@uscc.net' THEN
    SELECT value INTO var_mdn
    FROM unique_identifier
    WHERE unique_identifier_type = 'MIN'
    AND equipment_id = var_equipment_id;
  ELSE
    SELECT value INTO var_mdn
    FROM unique_identifier
    WHERE unique_identifier_type = 'MDN'
    AND equipment_id = var_equipment_id;
  END IF;

  SELECT unam.username INTO var_username
  FROM username unam
  WHERE 1 = 1
  AND username ~ '@'
  AND username NOT LIKE '%cn01.%'
  AND substr(username, 1, strpos(username, '@') - 1) = var_mdn;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Username does not exists for the device';
  END IF;

  -- To Suspend an assigned device which is not expired
  IF EXISTS (SELECT TRUE 
               FROM line 
              WHERE radius_username LIKE var_username 
                AND line_label LIKE par_esn_hex 
                AND end_date IS NULL) THEN
    IF var_username ~ '@vzw' THEN
      IF NOT EXISTS( SELECT TRUE 
                       FROM usergroup 
                      WHERE username LIKE var_username 
                        AND groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione') THEN
        INSERT INTO usergroup(username, groupname, priority)
        VALUES (var_username, 'SERVICE-vzwretail_wallgarden_cnione', 2);
      END IF;
/*
      IF NOT EXISTS( SELECT TRUE FROM usergroup WHERE username LIKE var_username AND groupname LIKE 'userdisconnected') THEN
        INSERT INTO usergroup(username, groupname, priority)
        VALUES (var_username, 'userdisconnected', 3);
      END IF;
*/
    ELSE
      IF NOT EXISTS( SELECT TRUE 
                       FROM usergroup 
                      WHERE username LIKE var_username 
                        AND groupname LIKE 'userdisconnected') THEN
        INSERT INTO usergroup(username, groupname, priority)
        VALUES (var_username, 'userdisconnected', 1);
      END IF;
    END IF;
  ELSE
    IF EXISTS (SELECT TRUE 
                 FROM username 
                WHERE username LIKE var_username) THEN
      IF var_username ~ '@vzw' THEN
        IF NOT EXISTS( SELECT TRUE 
                         FROM usergroup 
                        WHERE username LIKE var_username 
                          AND groupname LIKE 'SERVICE-vzwretail_wallgarden_cnione') THEN
            INSERT INTO usergroup(username, groupname, priority)
            VALUES (var_username, 'SERVICE-vzwretail_wallgarden_cnione', 2);
        END IF;
      ELSE
        IF NOT EXISTS( SELECT TRUE 
                         FROM usergroup 
                        WHERE username LIKE var_username 
                          AND groupname LIKE 'userdisconnected') THEN
            INSERT INTO usergroup(username, groupname, priority)
  	        VALUES (var_username, 'userdisconnected', 1);
        END IF;
      END IF;
	  END IF;
  END IF;

  var_return_row.result_code := true ;
  var_return_row.error_message := '' ;
  RETURN NEXT var_return_row ;
  RETURN ;

END ;
$_$;


ALTER FUNCTION csctoss.ops_api_user_suspend(text, text) OWNER TO csctoss_owner;

--
-- Name: ops_change_static_ip(integer, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_change_static_ip(integer, text, text) RETURNS ops_api_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
  par_line_id                   integer := $1;
  par_old_ip                    text := $2;
  par_new_ip                    text := $3;
  var_username                  text;
  var_old_rad_reply_id          integer;
  var_static_ip_pool_id_old     integer;
  var_static_ip_pool_id_new     integer;
  v_numrows                     integer;
  var_return_row                ops_api_retval%ROWTYPE;

  v_errmsg                      text;  

BEGIN

  IF par_line_id IS NULL
    OR par_old_ip IS NULL
    OR par_new_ip IS NULL
  THEN
      v_errmsg  := 'All or some of the input parameters are NULL or empty';
      RAISE EXCEPTION 'ERROR: No parameters';
  END IF;

  PERFORM public.set_change_log_staff_id(3);

  -- Get radius_username by line_id
  SELECT radius_username INTO var_username
  FROM line
  WHERE line_id = par_line_id
  AND end_date IS NULL
  LIMIT 1;

  IF NOT FOUND THEN
      v_errmsg := 'ERROR: radius_username not found on line table. [line_id=' || par_line_id || ']';
      RAISE EXCEPTION '';
  END IF;

  -- Get id of old IP
  SELECT id INTO var_old_rad_reply_id
  FROM radreply
  WHERE username = var_username
  AND attribute = 'Framed-IP-Address'
  AND value = par_old_ip
  LIMIT 1;

  IF NOT FOUND THEN
      v_errmsg := 'ERROR: Old IP address was not assigned in radreply table.';
      RAISE EXCEPTION '';
  END IF;

  -- Get id of static_ip_pool for new IP
  SELECT id INTO var_static_ip_pool_id_new
  FROM  static_ip_pool
  WHERE static_ip = par_new_ip
  AND is_assigned = false
  AND line_id IS NULL
  LIMIT 1
  FOR UPDATE;

  IF NOT FOUND THEN
      v_errmsg := 'ERROR: New IP address was not retrieved from static_ip_pool table.';
      RAISE EXCEPTION '';
  END IF;

  -- Get id of static_ip_pool for old IP
  SELECT id INTO var_static_ip_pool_id_old
  FROM  static_ip_pool
  WHERE static_ip = par_old_ip
  AND line_id IS NOT NULL
  LIMIT 1
  FOR UPDATE;

  IF NOT FOUND THEN
      v_errmsg := 'ERROR: Old IP address was not retrieved from static_ip_pool table.';
      RAISE EXCEPTION '';
  END IF;

  IF var_static_ip_pool_id_new IS NULL AND par_new_ip NOT LIKE '166.%' THEN
    v_errmsg := 'ERROR: New IP address is not available in static_ip_pool table.';
    RAISE EXCEPTION '';
  ELSE
    IF var_static_ip_pool_id_old IS NULL AND par_old_ip NOT LIKE '166.%' THEN
      v_errmsg := 'ERROR: Could not find old IP address in static_ip_pool table.';
      RAISE EXCEPTION '';
    ELSE
      --update old pool entry
      IF par_old_ip NOT LIKE '166.%' THEN
        v_errmsg := 'ERROR: Failure in update of old static_ip_pool';
        UPDATE static_ip_pool
           SET is_assigned = false
              ,line_id = NULL
         WHERE id = var_static_ip_pool_id_old
           AND static_ip = par_old_ip;

        GET DIAGNOSTICS v_numrows = ROW_COUNT;
        IF v_numrows = 0 THEN
            RAISE EXCEPTION '';
        END IF;

      END IF;

      --update new pool entry
      IF par_new_ip NOT LIKE '166.%' THEN
        v_errmsg := 'ERROR: Failure in update of new static_ip_pool';
        UPDATE static_ip_pool
           SET is_assigned = true
              ,line_id = par_line_id
         WHERE static_ip = par_new_ip;

        GET DIAGNOSTICS v_numrows = ROW_COUNT;
        IF v_numrows = 0 THEN
            RAISE EXCEPTION '';
        END IF;
      END IF;

      --update radreply
      v_errmsg := 'ERROR: Failure in update of new static_ip_pool';
      UPDATE radreply
         SET value = par_new_ip
       WHERE username = var_username
        AND id  = var_old_rad_reply_id;

      GET DIAGNOSTICS v_numrows = ROW_COUNT;
      IF v_numrows = 0 THEN
          RAISE EXCEPTION '';
      END IF;
    END IF;
  END IF;

  v_errmsg := 'Static IP address has been changed from ' || par_old_ip || ' to ' || par_new_ip || ' for line_id=' || par_line_id;

  var_return_row.result_code := true;
  var_return_row.error_message := v_errmsg;
  RETURN var_return_row;

EXCEPTION
  WHEN raise_exception THEN
      var_return_row.result_code := false;
      var_return_row.error_message:=v_errmsg;
      RAISE NOTICE 'rt_oss_rma: when raise_exception:  % ',v_errmsg;
      RETURN var_return_row;

  WHEN others THEN
      v_errmsg := 'Unknown error!';
      var_return_row.result_code := false;
      var_return_row.error_message := v_errmsg;
      RAISE NOTICE 'ERROR:  Unknown Error! ';
      RETURN var_return_row;
END;
$_$;


ALTER FUNCTION csctoss.ops_change_static_ip(integer, text, text) OWNER TO csctoss_owner;

--
-- Name: ops_change_static_ip_old(integer, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_change_static_ip_old(integer, text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_line_id                   integer := $1;
  par_old_ip                    text := $2;
  par_new_ip                    text := $3;
  var_username                  text;
  var_old_rad_reply_id          integer;
  var_static_ip_pool_id_old     integer;
  var_static_ip_pool_id_new     integer;
	

BEGIN
IF par_line_id IS NULL THEN
 RAISE EXCEPTION 'LINE ID CAN NOT BE NULL';
END IF;
IF par_old_ip IS NULL THEN
 RAISE EXCEPTION 'OLD IP CAN NOT BE NULL';
END IF;
IF par_new_ip IS NULL THEN
 RAISE EXCEPTION 'NEW IP CAN NOT BE NULL';
END IF;


PERFORM public.set_change_log_staff_id(3);

--get the line_id
SELECT 
radius_username 
INTO var_username
FROM line 
WHERE line_id = par_line_id 
AND end_date is null 
LIMIT 1;

IF var_username IS NULL THEN
	RAISE EXCEPTION 'ERROR USERNAME NOT FOUND';
END IF; 




SELECT 
id 
INTO var_old_rad_reply_id
FROM radreply 
WHERE username = var_username
AND attribute = 'Framed-IP-Address'
AND value = par_old_ip
LIMIT 1;



IF var_old_rad_reply_id IS NULL THEN
	RAISE EXCEPTION 'ERROR OLD IP WAS NOT ASSIGNED IN RADREPLY';
END IF; 


--get new id for static ip pool
SELECT 
 id
INTO
 var_static_ip_pool_id_new 
FROM  static_ip_pool 
WHERE static_ip = par_new_ip
AND is_assigned = false
AND line_id is null
LIMIT 1
FOR UPDATE;

--get old id for static ip pool
SELECT 
 id 
INTO
 var_static_ip_pool_id_old
FROM  static_ip_pool   
WHERE static_ip = par_old_ip
AND line_id is not null
LIMIT 1
FOR UPDATE;


IF var_static_ip_pool_id_new IS NULL THEN

 RAISE EXCEPTION 'NEW IP IS NOT AVALIBLE (STATIC_IP_POOL)';

ELSE
   IF var_static_ip_pool_id_old IS NULL THEN

     RAISE EXCEPTION 'COULD NOT FIND OLD IP (STATIC_IP_POOL)';

   ELSE
	--update old pool entry
	UPDATE 
         static_ip_pool 
        SET 
         is_assigned = false,
         line_id = null
        WHERE id = var_static_ip_pool_id_old
        AND static_ip = par_old_ip;

        --update new pool entry
        UPDATE 
         static_ip_pool 
        SET 
         is_assigned = true,
         line_id = par_line_id
        WHERE static_ip = par_new_ip;

	--update  radreply
	Update 
	 radreply 
	SET 
	 value = par_new_ip
	WHERE username = var_username
	AND id  = var_old_rad_reply_id;


	
   END IF;
	
END IF;

RETURN TRUE;
	
	

 END;
  $_$;


ALTER FUNCTION csctoss.ops_change_static_ip_old(integer, text, text) OWNER TO csctoss_owner;

--
-- Name: ops_change_static_ip_or_set(text, text, text, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_change_static_ip_or_set(text, text, text, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
--begin bens modification
  par_ident                   	text := $1;
  par_old_ip                    text := $2;
  par_new_ip                    text := $3;
  par_staff_id			integer := $4;

  var_username                  text;
  var_equipment_id		integer;
  var_line_id			integer;
  
  var_old_radreply_id          	integer;
  var_pool_id_old		integer;
  var_pool_id_new     		integer;
  ct_old_ip			integer;
  var_num_affected		integer;
	

BEGIN

  IF par_ident IS NULL THEN
   RAISE EXCEPTION 'Unique ID is a required value.';
  END IF;
  --IF par_old_ip IS NULL THEN
   --RAISE EXCEPTION 'OLD IP CAN NOT BE NULL';
  --END IF;
  IF par_new_ip IS NULL THEN
   RAISE EXCEPTION 'New Static IP is a required value.';
  END IF;

  PERFORM public.set_change_log_staff_id(par_staff_id);
  
  SELECT
    radius_username
  INTO
    var_username
  FROM line
  WHERE line_id = par_ident
  AND end_date is null;

  --if null at this point, then passed parameter should be unqiue identifier - and not line_id
  IF var_username IS NULL THEN
    --get equip id
    SELECT 
     equipment_id 
    INTO 
     var_equipment_id
    FROM unique_identifier
    WHERE value = par_ident;

    IF var_equipment_id IS NULL THEN
      RAISE EXCEPTION '[oss.ops_change_static_ip] ERROR: Cannot find equipment_id of passed identifier.';
    END IF;

    --get line_id
    SELECT 
     line_id
    INTO
     var_line_id
    FROM line_equipment
    WHERE equipment_id = var_equipment_id
    AND end_date is null;

    IF var_line_id IS NULL THEN
      RAISE EXCEPTION '[oss.ops_change_static_ip] ERROR: Cannot find line_id of passed identifier.';
    END IF;

    --get radius_username
    SELECT
     radius_username
    INTO
     var_username
    FROM line
    WHERE line_id = var_line_id
    AND end_date is null;
  
    --if empty at this point, then return error
    IF var_username IS NULL THEN
      RAISE EXCEPTION '[oss.ops_change_static_ip] ERROR: Cannot find username of passed identifier.';
    END IF;

  ELSE
    --line id is what was passed
    var_line_id = par_ident;  
  END IF; --end username is null

  --
  -- If Old IP was not passed to function,then make sure it dosent have one set
  --
  IF par_old_ip IS NULL THEN
    
    SELECT 
     count(*) 
    INTO
     ct_old_ip
    FROM  static_ip_pool   
    WHERE 1=1
    --AND static_ip = par_old_ip
    AND line_id = var_line_id
    AND is_assigned IS TRUE;

    IF ct_old_ip > 0 THEN
      RAISE EXCEPTION '[oss.ops_change_static_ip] ERROR: This device already has a static ip. You must supply the Old Static IP value.';
    END IF;
  END IF;
 
  --
  -- do updates/inserts
  --  
  IF par_old_ip IS NULL THEN
    --update static ip pool - new ip
    SELECT 
     id
    INTO
     var_pool_id_new 
    FROM  static_ip_pool 
    WHERE static_ip = par_new_ip
    AND is_assigned = false
    AND line_id is null
    LIMIT 1;

    IF var_pool_id_new IS NULL THEN
      RAISE EXCEPTION '[oss.ops_change_static_ip()] ERROR: Cannot find New Static IP in static_ip_pool table.';
    END IF;

    UPDATE 
     static_ip_pool 
    SET 
     is_assigned = true,
     line_id = var_line_id
    WHERE static_ip = par_new_ip;

    GET DIAGNOSTICS var_num_affected = ROW_COUNT;
    IF var_num_affected = 0 THEN
      RAISE EXCEPTION '[oss.ops_change_static_ip()] ERROR: Modifying Static IP failed.';
    END IF;

    INSERT INTO radreply 
     (username, attribute, op, value, priority) 
    VALUES 
     (var_username, 'Framed-IP-Address', '=', par_new_ip, 10);

    --daignose here
      
  ELSE
    SELECT 
     id
    INTO
     var_old_radreply_id
    FROM radreply 
    WHERE 1=1
    AND username = var_username
    AND attribute = 'Framed-IP-Address'
    AND value = par_old_ip
    LIMIT 1;

    IF var_old_radreply_id IS NULL THEN
      RAISE EXCEPTION '[oss.ops_change_static_ip()] ERROR: Cannot find Old Static IP in radreply table.';
    END IF;

    Update 
     radreply 
    SET 
     value = par_new_ip
    WHERE username = var_username
    AND id  = var_old_radreply_id;

    GET DIAGNOSTICS var_num_affected = ROW_COUNT;
    IF var_num_affected = 0 THEN
      RAISE EXCEPTION '[oss.ops_change_static_ip()] ERROR: Modifying Static IP failed.';
    END IF;

    SELECT 
     id
    INTO
     var_pool_id_new 
    FROM  static_ip_pool
    WHERE 1=1
    AND static_ip = par_new_ip
    AND is_assigned = false
    AND line_id is null
    LIMIT 1;

    IF var_pool_id_new IS NULL THEN
      RAISE EXCEPTION '[oss.ops_change_static_ip()] ERROR: Cannot find New Static IP in static_ip_pool table or it is already assigned to a device.';
    END IF;

    UPDATE 
     static_ip_pool 
    SET 
     is_assigned = true,
     line_id = var_line_id
    WHERE 1=1
    AND static_ip = par_new_ip
    AND id = var_pool_id_new;
    
    GET DIAGNOSTICS var_num_affected = ROW_COUNT;
    IF var_num_affected = 0 THEN
      RAISE EXCEPTION '[oss.ops_change_static_ip()] ERROR: Modifying Static IP failed.';
    END IF;    

    SELECT 
     id 
    INTO
     var_pool_id_old
    FROM  static_ip_pool   
    WHERE static_ip = par_old_ip
    AND line_id is not null
    LIMIT 1;

    IF var_pool_id_old IS NULL THEN
      RAISE EXCEPTION '[oss.ops_change_static_ip()] ERROR: Cannot find Old Static IP in static_ip_pool table.';
    END IF;

    UPDATE 
     static_ip_pool 
    SET 
     is_assigned = false,
     line_id = null
    WHERE id = var_pool_id_old
    AND static_ip = par_old_ip;

    GET DIAGNOSTICS var_num_affected = ROW_COUNT;
    IF var_num_affected = 0 THEN
      RAISE EXCEPTION '[oss.ops_change_static_ip()] ERROR: Modifying Static IP failed.';
    END IF;

  END IF; --end check old ip is null or not

RETURN true; 

END;
  $_$;


ALTER FUNCTION csctoss.ops_change_static_ip_or_set(text, text, text, integer) OWNER TO csctoss_owner;

--
-- Name: ops_get_config_status(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_get_config_status(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    par_config            text := $1;

    var_result            text;
    var_msg                text;

BEGIN
--====================================================================--
--CHECK PARAMS
--====================================================================--
  IF par_config IS NULL THEN
    var_msg = 'Not Current';
  END IF; 

--====================================================================--
--Check connection status 
--====================================================================--
IF (par_config IS NOT NULL) THEN
    IF (par_config = '') THEN
        var_msg = 'Not Current';
    ELSE
        SELECT default_status INTO var_result FROM csctoss.config 
        WHERE name LIKE '%' || par_config || '%';
        
        IF (var_result = '') IS NOT FALSE THEN
		var_msg = 'Not Current';
        ELSIF (var_result = 0) THEN
		var_msg = 'Not Current';
        ELSE
		var_msg = 'Current';
        END IF;    
    END IF;
        
END IF;

--RAISE NOTICE 'Value: %', result;

RETURN var_msg;

END;
$_$;


ALTER FUNCTION csctoss.ops_get_config_status(text) OWNER TO csctoss_owner;

--
-- Name: ops_get_connection_status(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_get_connection_status(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
  par_username        text := $1;

  var_result          text;
  var_msg             text;

BEGIN
  --====================================================================--
  -- Check parameters
  --====================================================================--
  IF par_username IS NULL THEN
    RAISE EXCEPTION 'OSS: THE USERNAME CANNOT BE NULL';
  END IF;

  --====================================================================--
  -- Check connection status
  --====================================================================--
  IF (SELECT true FROM usergroup WHERE username = par_username AND groupname = 'disconnected')
  THEN
      var_msg := 'Administratively disconnected';
  ELSEIF (SELECT true FROM usergroup WHERE username = par_username AND groupname = 'userdisconnected') THEN
      var_msg := 'Disconnected';
  ELSEIF (SELECT true FROM usergroup WHERE username = par_username AND groupname = 'SERVICE-vzwretail_wallgarden_cnione') THEN
      var_msg := 'Disconnected';
  ELSE
      var_msg := 'Active';
  END IF;

  --RAISE NOTICE 'Value: %', result;

  RETURN var_msg;
END;
$_$;


ALTER FUNCTION csctoss.ops_get_connection_status(text) OWNER TO csctoss_owner;

--
-- Name: ops_get_firmware_status(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_get_firmware_status(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
  par_firmware          text := $1;

  var_firmware_version  text;
  var_result            text;
  var_msg               text;
  rec_firmware          record;

BEGIN
--====================================================================--
--CHECK PARAMS
--====================================================================--
  IF par_firmware IS NULL THEN
    var_msg = 'Not Current';
  END IF; 

--====================================================================--
--Check connection status 
--====================================================================--
  IF (par_firmware IS NOT NULL) THEN
    IF (par_firmware = '') THEN
      var_msg = 'Not Current';
    ELSE
      IF par_firmware ~ ',' THEN
        var_firmware_version = substr(par_firmware, 1, strpos(par_firmware, ',') - 1);
        var_result = 0;
        FOR rec_firmware IN 
          select device_version, default_status
            from firmware
           where device_version ~ ','
        LOOP
          IF var_firmware_version = substr(rec_firmware.device_version, 1, strpos(rec_firmware.device_version, ',') - 1) THEN
            var_result = rec_firmware.default_status;
            EXIT;
          END IF;
        END LOOP ;
      ELSE
        var_firmware_version = par_firmware;

        SELECT default_status INTO var_result FROM csctoss.firmware 
        WHERE device_version LIKE '%' || var_firmware_version || '%'
        LIMIT 1;
          
      END IF;

      IF (var_result = '') IS NOT FALSE THEN
        var_msg = 'Not Current';
      ELSIF (var_result = 0) THEN
        var_msg = 'Not Current';
      ELSE
        var_msg = 'Current';
      END IF;    
    END IF;

  END IF;

  --RAISE NOTICE 'Value: %', result;

  RETURN var_msg;

END;
$_$;


ALTER FUNCTION csctoss.ops_get_firmware_status(text) OWNER TO csctoss_owner;

--
-- Name: ops_process_rma(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION ops_process_rma() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE

v_sql                   text;
v_email_text            text;
v_email_subj            text:='RMA Ticket# RT-99999';
v_email_recip           text:='dolson@cctus.com';
v_rt_ticket_id          integer;
v_rma_old_sn            text:='1234ABC';
v_rma_new_sn            text:='1234ABC';
v_rma_old_esn           text:='1234ABC';
v_rma_new_esn           text:='1234ABC';
v_rma_model             text:='1234ABC';
v_rma_number            text:='1234ABC';
v_rma_contact_name      text:='1234ABC';
v_rma_contact_address   text:='1234ABC';
v_rma_tracking_number   text:='1234ABC';
v_cursor                text;
c_rec                   record;

begin
      SELECT t.id into v_rt_ticket_id
      FROM rt3.tickets t
      join rt3.queues q on (q.id=t.queue and q.name ='RMA Customer' and q.disabled=0)
      WHERE 1=1
        and t.disabled=0
--        and rt3.objectcustomfieldvalues='??'     ---   will determine value for  RMA tyhpe
        and t.status='new'
        limit 1;
       RAISE NOTICE 'TICKET ID: %', v_rt_ticket_id;

      FOR c_rec in
      SELECT
      cfv.customfield,cf.name,cfv.content
      FROM
           rt3.objectcustomfieldvalues cfv
      join rt3.customfields cf on (cf.id = cfv.customfield )
      join rt3.tickets t on (t.id = cfv.objectid)
      WHERE 1=1
        and cfv.disabled=0
        and t.id=v_rt_ticket_id
       loop
          RAISE NOTICE 'custom field Id: % Name: % value: %',c_rec.customfield, c_rec.name,c_rec.content;
       end loop;

RAISE NOTICE 'got here: debug 200';

      v_rma_number:='RT-00000';
--      v_email_text:='here is the text';
      v_email_text:='Dear Ron,

The following replacement unit is being sent via FedEx 2nd Day Air for RMA# '|| v_rma_number||'

  Model:'||v_rma_model||
'
  S/N  :'|| v_rma_old_sn||
'
  ESN  :'|| v_rma_old_esn||
'
  Tracking #: '||v_rma_tracking_number||
'

The replacement unit is being shipped to this address:
'||
v_rma_contact_address || '

Per Contour RMA Policy:
   In order to waive the charge for the replacement
   unit, we must receive the following defective unit within 30 days of
   initial shipment of the replacement unit.

New Equipment:

  Model: '|| v_rma_model||
'
  S/N  : '|| v_rma_old_sn||
'
  ESN  : '|| v_rma_old_esn||'

We have provided a return label for the defective unit.

Thank you for your business.

Contour Networks
Customer Support: (866) 576-9933
shipping@contournetworks.com
support@contournetworks.com
';





      execute public.plsh_send_email(v_email_recip,v_email_subj,v_email_text);
      return true;
end;
 $$;


ALTER FUNCTION csctoss.ops_process_rma() OWNER TO csctoss_owner;

--
-- Name: oss_sync_ip_activity_fetch(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION oss_sync_ip_activity_fetch() RETURNS SETOF oss_sync_ip_activity_fetch_retval
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE

  var_start_ts         timestamp := current_timestamp - interval '26 hours' ;
  var_end_ts           timestamp := current_timestamp - interval '2 hours' ;

  var_sql              text ;
  var_return           oss_sync_ip_activity_fetch_retval ;

BEGIN

  var_sql := 'select acctstarttime::timestamp, acctstoptime::timestamp, framedipaddress, class
                from csctlog.master_radacct
               where acctstarttime  > '||quote_literal(var_start_ts)||'::timestamp
                 and (  acctstarttime > '||quote_literal(var_end_ts)||'::timestamp
                     or acctstoptime  > '||quote_literal(var_end_ts)||'::timestamp
                     or acctstoptime is null
                     )
            order by acctstarttime' ;

RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR var_return IN SELECT *
                      FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                        AS rec_type(acctstarttime   timestamp
                                   ,acctstoptime    timestamp
                                   ,framedipaddress inet
                                   ,class           varchar)
  LOOP

    RETURN NEXT var_return ;

  END LOOP ;

  RETURN ;

END ;
$$;


ALTER FUNCTION csctoss.oss_sync_ip_activity_fetch() OWNER TO csctoss_owner;

--
-- Name: FUNCTION oss_sync_ip_activity_fetch(); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION oss_sync_ip_activity_fetch() IS 'Function to dynamically fetch and return lines and most recent ip address.';


--
-- Name: oss_sync_line_mrac_fetch(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION oss_sync_line_mrac_fetch() RETURNS SETOF oss_sync_line_mrac_fetch_retval
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE

  var_start_date         date := current_date-2 ;
  var_end_date           date := current_date+1 ;

  var_sql                text ;
  var_return             oss_sync_line_mrac_fetch_retval ;

BEGIN

  var_sql := 'select master_radacctid, class::integer, acctstarttime, acctstoptime, framedipaddress
                from csctlog.master_radacct
               where 1=1
                 and acctstarttime >= '||quote_literal(var_start_date)||'
                 and acctstarttime <= '||quote_literal(var_end_date)||'
                 and master_radacctid in
                    (select max(master_radacctid)
                       from master_radacct
                      where class > ''0''
                        and class <> ''classtest''
                        and connectinfo_start is not null
                        and acctstarttime >= '||quote_literal(var_start_date)||'
                        and acctstarttime <= '||quote_literal(var_end_date)||'
                   group by class)' ;

RAISE NOTICE 'SQL: %', var_sql ;

  -- execute dynamic query over link and return results
  FOR var_return IN SELECT *
                      FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                        AS      rec_type(master_radacctid      bigint
                                        ,class                 integer
                                        ,acctstarttime         timestamp
                                        ,acctstoptime          timestamp
                                        ,framedipaddress       inet)
  LOOP

    RETURN NEXT var_return ;

  END LOOP ;

  RETURN ;

END ;
$$;


ALTER FUNCTION csctoss.oss_sync_line_mrac_fetch() OWNER TO csctoss_owner;

--
-- Name: FUNCTION oss_sync_line_mrac_fetch(); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION oss_sync_line_mrac_fetch() IS 'Function to dynamically fetch and return lines and most recent connection information.';


--
-- Name: otaps_monthly_usage_summary_func(character varying); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION otaps_monthly_usage_summary_func(in_date character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
usage_rec                    record;
v_pool_count                 numeric;
v_base_mb                    numeric;
v_pooled                     boolean;
v_tot_threshold              numeric:=0;
v_overage                    numeric(9,2):=0;
v_tot_usage                  numeric(9,2):=0;
v_prev_product_code          text:='initialize';
v_prev_billing_entity_id     integer:=999999999;
v_first_time                 boolean:=true;
v_row_count                  integer:=0;
v_row_tot_count              integer:=0;
v_count                      integer;
v_count_1                    integer;
v_count_2                    integer;
v_count_3                    integer;
v_count_4                    integer;
v_jbill_id                   integer;
v_usage_fee_text             text;
v_otaps_product_code         text;
v_carrier_product_code       text;
v_curr_beid	             text;
v_curr_carrier		     text;
v_curr_product_code		text;
v_prev_pooled                boolean;
v_prev_line_id             numeric;
v_prev_beid                integer;
v_prev_name                  varchar;
v_prev_jbill_id                 integer;
v_prev_otaps_product_code    text;
v_prev_total_usage_mb   numeric(9,2):=0;
--v_prev_total_usage           bigint:=0;
v_prev_total_usage           double precision:=0;
v_prev_prod_code             text;
v_prev_base_mb               numeric;
v_prev_pool_line_count         numeric:=0;
v_carrier_usage              numeric;


var_sql  text:='SELECT
       be.billing_entity_id
     , be.name
     , case
            when pooled then null
            else l.line_id
          end  as line_id
     ,prd.product_code as product_code
     ,pooled
     ,base_mb
     ,to_char(lud.usage_date,''yyyy-mm'') as usage_month
     ,sum(lud.acctinputoctets_utc) as input_octets
     ,sum(lud.acctoutputoctets_utc) as output_octets
     ,case 
         when radius_username like ''%uscc%'' then ''USCC''
         when radius_username like ''%vzw%'' then ''VERIZON''
         when radius_username like ''%sprint%'' then ''SPRINT''
     else
       ''unknown'' -- radius_username 
     end as carrier
     ,case
         when radius_username like ''%sprint%'' then ''sprint''
          when radius_username like ''%vzw%'' then ''vzw''
         when radius_username like ''%uscc%'' then ''uscc''
     else
       ''unknown'' 
     end as carrier_lc
  FROM
       line l,
       line_equipment le,
       product_overage_threshold pot,
       line_usage_day lud,
       plan_type pt,
       plan pln ,
       product prd,
       billing_entity be
       where 1=1
        and l.line_id=le.line_id
        and radius_username not in (''%VZW%'', ''%contour%'')
--         and be.billing_entity_id in (377, 221,181) 
         and pln.product_id=pot.product_id
         and pln.plan_type_id=pt.plan_type_id
         and pln.product_id=prd.product_id
         and l.line_id=pln.line_id
         and l.line_id=lud.line_id
         and l.billing_entity_id=be.billing_entity_id
         and to_char(usage_date,''yyyy-mm'')  = '||quote_literal(in_date)||
         ' group by
                  be.billing_entity_id,
                  be.name,
                  case
                      when pooled then null
                      else l.line_id
                  end
                  ,to_char(lud.usage_date,''yyyy-mm'')
                  ,product_code
                  ,pooled
                  ,base_mb
                  ,carrier
                  ,carrier_lc
          order by
                  be.billing_entity_id
                  ,product_code
                  ,case
                       when pooled then null
                       else l.line_id
                   end
                  ,carrier'
                  ;
begin
     raise notice 'Debug: 0001: starting ';
--   archive  all rows that contain the year/mo  passed to the function
     select count(*) into v_count_1 from csctoss.otaps_monthly_usage_summary
     where  usage_date  = in_date
       and  not archived;
     raise notice 'Debug: 0002: ';
     if v_count_1 > 0 then
         raise notice 'Usage rows with % usage date already exist- these rows will be archived prior to summary process',in_date;
         select count(*) into v_count_2 from csctoss.otaps_monthly_usage_summary 
         where  archived ;
         update csctoss.otaps_monthly_usage_summary set archived = true
         where  usage_date  = in_date;
         select count(*) into v_count_3 from csctoss.otaps_monthly_usage_summary
         where  archived;
         raise notice 'Debug: 0010: ';
         v_count_4:=v_count_3 - v_count_2;
         if  v_count_4 = v_count_1 then
             raise notice 'Archiving of % rows completed sucessfully',v_count_4;
             raise notice 'Summary process beginning';
         else
             raise notice 'Archiving of rows with % usage date was not sucessful- exiting function', in_date;
             return false;
         end if;
     else
        raise notice 'Summary process beginning';
     end if;
    
--raise notice 'Debug: 101:  SQL: %',var_sql;
--raise notice 'Debug: 1100: building the initial loop ';
   for usage_rec in execute var_sql

    loop

--raise notice 'Debug: 1105:  ';
        if  ( usage_rec.billing_entity_id <> v_prev_billing_entity_id 
             or usage_rec.product_code <> v_prev_prod_code 
             or usage_rec.line_id <> v_prev_line_id
            )
            and not v_first_time 
        then
            v_usage_fee_text:=null;
            v_tot_threshold:=v_prev_pool_line_count * v_prev_base_mb ;
            v_prev_total_usage_mb:= v_prev_total_usage / 1048576.0;
--raise notice 'Debug: 1105: v_prev_total_usage_mb: % v_tot_threshold: %',v_prev_total_usage_mb ,v_tot_threshold;
            if v_prev_total_usage_mb > v_tot_threshold 
            then
                v_overage:=v_prev_total_usage_mb - v_tot_threshold;
                if v_prev_pooled  then
                    v_usage_fee_text:='Data Overage Fee for '||v_prev_pool_line_count||' Pooled Lines';
--raise notice 'Debug: 1106: text: % ',v_usage_fee_text;
                else
                    v_usage_fee_text:='Data Overage Fee for Line '||v_prev_line_id;
--raise notice 'Debug: 1107: text: % ',v_usage_fee_text;
                end if;
            else
                v_overage:=0;
            end if;
--raise notice 'Debug: 1130: writing otaps overage record  ';
            insert into csctoss.otaps_monthly_usage_summary
               (create_timestamp,
                archived ,
                record_type,
                billing_entity_id ,
                billing_entity_name,
                jbilling_id,
                old_product_code,
                otaps_product_code,
                carrier_product_code,
                carrier,
                line_id ,
                usage_date ,
                base_mb,
                num_of_lines_in_pool,
                total_threshold,
                acctinputoctets,
                acctoutputoctets,
                total_usage,
                usage_overage,
                usage_fee_text,
                usage_source 
              )
           values 
              (
                current_timestamp,
                false,
                2,
                v_prev_billing_entity_id,
                v_prev_name,
                v_prev_jbill_id,
                v_prev_prod_code,
                v_prev_otaps_product_code,
                null, --v_carrier_product_code,
                null, --usage_rec.carrier,
                v_prev_line_id, -- usage_rec.line_id,
                in_date,
                v_prev_base_mb,
                v_prev_pool_line_count,
                v_tot_threshold ,
                null, --usage_rec.input_octets,
                null, --usage_rec.output_octets,
                v_prev_total_usage_mb ,
                v_overage,
                v_usage_fee_text,
                'oss line_usage_day table'
               );
             v_prev_pool_line_count:=0;
             v_prev_total_usage:=0;
             v_prev_total_usage_mb:=0;
       end if;
--   end of insert here
---     build current detail record
        select count(*) into v_count
            from csctoss.rating_engine_beid_trans rebt
            where 1=1
              and usage_rec.billing_entity_id = rebt.oss_beid ;
        if v_count > 0 then
            select jbill_id into v_jbill_id
            from csctoss.rating_engine_beid_trans rebt
            where 1=1
              and usage_rec.billing_entity_id = rebt.oss_beid ;
        else
             v_jbill_id:=null;
        end if;
--raise notice 'Debug: 1132:  ';
        v_count:=0;
        select count(*) into v_count
        from csctoss.otaps_product_code_translation pct
        where 1=1
          and usage_rec.product_code=pct.old_product_code
          and 
              (
               (usage_rec.carrier=pct.carrier )
               or
               (pct.carrier='any' )
              )
          and pct.otaps_product_code is not null;
        if v_count = 0 then
             v_otaps_product_code:=usage_rec.product_code;
             v_carrier_product_code:=usage_rec.product_code;
        else 
            select otaps_product_code ,carrier_internal_product_code into v_otaps_product_code,v_carrier_product_code
            from csctoss.otaps_product_code_translation pct
            where 1=1
              and usage_rec.product_code=pct.old_product_code
              and 
                 (
                  (usage_rec.carrier=pct.carrier )
                  or
                  (pct.carrier='any' )
                )
              and pct.otaps_product_code is not null;
        end if;
--raise notice 'Debug: 1350 ';
        if usage_rec.pooled
        then
                   select count(*) into v_pool_count
                   from plan pln,
                        product prd,
                        line l,
                        line_equipment le
                   where 1=1
                    and l.line_id = le.line_id
                    and l.line_id =  pln.line_id
                    and l.billing_entity_id = usage_rec.billing_entity_id
                    and  prd.product_code = usage_rec.product_code 
--
--                    and usage_rec.billing_entity_id = l.billing_entity_id
--                    and usage_rec.product_code = prd.product_code
--
                    and prd.product_id = pln.product_id
                    and  l.radius_username like '%'|| usage_rec.carrier_lc ||'%'
                    and le.end_date is null;
        else
                    v_pool_count:=1;
        end if;
--            v_carrier_usage:=((usage_rec.input_octets + usage_rec.output_octets) / 1048576);
--   write out the internal  be and carrier summary usage  record
--raise notice 'Debug: 1370: writing internal record ';
        insert into csctoss.otaps_monthly_usage_summary
               (create_timestamp,
                archived ,
                record_type,
                billing_entity_id ,
                billing_entity_name,
                jbilling_id,
                old_product_code,
                otaps_product_code,
                carrier_product_code,
                carrier,
                line_id ,
                usage_date ,
                base_mb,
                num_of_lines_in_pool,
                total_threshold,
                acctinputoctets,
                acctoutputoctets,
                total_usage,
                usage_overage,
                usage_fee_text,
                usage_source 
              )
        values 
              (
                current_timestamp,
                false,
                1,
                usage_rec.billing_entity_id,
                usage_rec.name,
                v_jbill_id,
                usage_rec.product_code,
                'n/a',  --                v_otaps_product_code,
                v_carrier_product_code,
                usage_rec.carrier,
                usage_rec.line_id,
                usage_rec.usage_month,
                usage_rec.base_mb,
                v_pool_count,
                null,                  --v_tot_threshold ,
                usage_rec.input_octets,
                usage_rec.output_octets,
                (usage_rec.input_octets + usage_rec.output_octets) / 1048576,
                null,
                null,
                'oss line_usage_day table'
               );
-- save current record info 
            v_prev_pool_line_count:=v_prev_pool_line_count + v_pool_count;
            v_prev_pooled:=usage_rec.pooled; 
            v_prev_base_mb:=usage_rec.base_mb;
            v_prev_line_id:=usage_rec.line_id;
--            v_prev_beid:=usage_rec.billing_entity_id;
            v_prev_billing_entity_id:=usage_rec.billing_entity_id;
            v_prev_name:=usage_rec.name;
            v_prev_jbill_id:=v_jbill_id;
            v_prev_prod_code:=usage_rec.product_code;
            v_prev_otaps_product_code:=v_otaps_product_code;
            v_prev_total_usage:=v_prev_total_usage + usage_rec.input_octets + usage_rec.output_octets;
            v_first_time:=false;
--
            v_row_count:=v_row_count+1;
            if v_row_count=500 then
              v_row_tot_count:=v_row_tot_count + v_row_count;
              raise notice 'rows inserted: %' ,v_row_tot_count;
              v_row_count:=0;
           end if;

--raise notice 'Debug: 1600: after insert ';
    end loop;
            v_usage_fee_text:=null;
            v_tot_threshold:=v_prev_pool_line_count * v_prev_base_mb ;
            v_prev_total_usage_mb:= v_prev_total_usage / 1048576.0;
            if v_prev_total_usage_mb > v_tot_threshold 
            then
                v_overage:=v_prev_total_usage_mb - v_tot_threshold;
                if v_prev_pooled  then
                    v_usage_fee_text:='Data Overage Fee for '||v_prev_pool_line_count||' Pooled Lines';
                else
                    v_usage_fee_text:='Data Overage Fee for Line '||v_prev_line_id;
                end if;
            else
                v_overage:=0;
            end if;
            insert into csctoss.otaps_monthly_usage_summary
               (create_timestamp,
                archived ,
                record_type,
                billing_entity_id ,
                billing_entity_name,
                jbilling_id,
                old_product_code,
                otaps_product_code,
                carrier_product_code,
                carrier,
                line_id ,
                usage_date ,
                base_mb,
                num_of_lines_in_pool,
                total_threshold,
                acctinputoctets,
                acctoutputoctets,
                total_usage,
                usage_overage,
                usage_fee_text,
                usage_source 
              )
           values 
              (
                current_timestamp,
                false,
                2,
                v_prev_billing_entity_id,
                v_prev_name,
                v_prev_jbill_id,
                v_prev_prod_code,
                v_prev_otaps_product_code,
                null, --v_carrier_product_code,
                null, --usage_rec.carrier,
                v_prev_line_id, -- usage_rec.line_id,
                in_date,
                v_prev_base_mb,
                v_prev_pool_line_count,
                v_tot_threshold ,
                null, --usage_rec.input_octets,
                null, --usage_rec.output_octets,
                v_prev_total_usage_mb ,
                v_overage,
                v_usage_fee_text,
                'oss line_usage_day table'
               );
         v_row_tot_count:=v_row_tot_count + v_row_count + 1;
         raise notice 'total rows inserted: %' ,v_row_tot_count;
return true;
/*
  exception 
      when others then
      return false;
*/
END;
  $$;


ALTER FUNCTION csctoss.otaps_monthly_usage_summary_func(in_date character varying) OWNER TO csctoss_owner;

--
-- Name: perform_bulk_cancellation_test(text, text[]); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION perform_bulk_cancellation_test(text, text[]) RETURNS SETOF perform_bulk_cancellation_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
  par_type		TEXT:=$1 ;
  par_values		ALIAS FOR $2 ;
  --add user staff_id for future
--
  var_return		perform_bulk_cancellation_retval;
  var_result 	text;
  var_result2	text;
  text_var1 	text;
  text_var2 	text;
  text_var3 	text;
  var_equipment_id	INTEGER;
BEGIN
  set client_min_messages to NOTICE;

  FOR i IN 1 .. array_upper(par_values, 1) LOOP --
    --get equipment_id
    SELECT
     equipment_id
    INTO 
     var_equipment_id
    FROM csctoss.unique_identifier
    WHERE 1=1
    AND value = par_values[i] ;
    
    SELECT * INTO var_result,var_result2 FROM csctoss.ops_api_expire_new(par_values[i])	;

    var_return.equipment_id = var_equipment_id ;
    var_return.identifier = par_values[i] ;
    var_return.result = var_result ;
    var_return.msg = var_result2 ;
    
  RAISE NOTICE 'var_result = %' , var_result ;  
  RAISE NOTICE 'var_result2 = %' , var_result2 ;  

    RETURN NEXT var_return ;
    
  END LOOP;  

  RETURN ;

  --RETURN true;
  
END ;

$_$;


ALTER FUNCTION csctoss.perform_bulk_cancellation_test(text, text[]) OWNER TO csctoss_owner;

--
-- Name: plan_log_pre_update(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION plan_log_pre_update() RETURNS "trigger"
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
   -- Not sure if this scenario would happen.
   IF (NEW.plan_id <> OLD.plan_id) THEN
      RAISE EXCEPTION 'You can not change the plan id - Tried plan id % as %', OLD.plan_id, NEW.plan_id;
   END IF;

   --IF (NEW.length_days <> OLD.length_days) THEN 
   --   INSERT INTO plan_log (plan_id, days_added, comment)
   --   VALUES (NEW.plan_id, NEW.length_days - OLD.length_days, 'Length days change: SET length_days = ' ||NEW.length_days);
   --END IF;

   IF (NEW.prepaid_balance <> OLD.prepaid_balance) THEN
      INSERT INTO plan_log (plan_id, minutes_added, comment)
      VALUES (NEW.plan_id, NEW.prepaid_balance - OLD.prepaid_balance, 'Prepaid_balance: SET prepaid_balance = ' ||NEW.prepaid_balance);
   END IF;

   RETURN NEW;

END;
$$;


ALTER FUNCTION csctoss.plan_log_pre_update() OWNER TO csctoss_owner;

--
-- Name: FUNCTION plan_log_pre_update(); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION plan_log_pre_update() IS 'Logs record in plan_log table';


--
-- Name: radcheck_updater(text, character); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION radcheck_updater(text, character) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_primary_key       	text    := $1 ;
  par_change_type       	char(1) := $2 ;

  var_sql               	text ;

  sysparm_rec			record ;
  radcheck_rec			record ;

BEGIN

  -- dynamically build sql statement based on change type and execute
  IF par_change_type = 'D' THEN

    -- build string for deletes
    var_sql := 'delete from radcheck where id = '||par_primary_key::integer ;

  ELSE

    SELECT INTO radcheck_rec * FROM csctoss.radcheck WHERE id = par_primary_key::integer ;
    IF NOT FOUND THEN RETURN FALSE ; END IF ;

    -- build string for inserts
    IF par_change_type = 'I' THEN
      var_sql := 'INSERT INTO radcheck
                            ( id
                            , username
                            , attribute
                            , op
                            , value )
                VALUES ( ' || radcheck_rec.id || ','
                           || quote_literal(radcheck_rec.username) || ','
                           || quote_literal(radcheck_rec.attribute) || ','
                           || quote_literal(radcheck_rec.op) || ','
                           || CASE WHEN radcheck_rec.value = ''
                                   THEN quote_literal('')
                                   ELSE quote_literal(radcheck_rec.value) END || ')' ;

    -- build string for updates
    ELSIF par_change_type = 'U' THEN
      var_sql := 'UPDATE radcheck
                     SET username =        ' || quote_literal(radcheck_rec.username) || '
                        ,attribute =       ' || quote_literal(radcheck_rec.attribute) || '
                        ,op =              ' || quote_literal(radcheck_rec.op) || '
                        ,value =           ' || CASE WHEN radcheck_rec.value = '' 
                                                     THEN quote_literal('') 
                                                     ELSE quote_literal(radcheck_rec.value) END || '
                  WHERE  id =              ' || radcheck_rec.id ;

    END IF ;

  END IF ;

  -- now loop through appropriate rows again in system_parameter table performing the actual statement
  FOR sysparm_rec IN SELECT hostname, ip_address
                       FROM csctoss.system_parameter
                      WHERE repl_flag = TRUE
  LOOP

    BEGIN

      PERFORM public.dblink_exec(sysparm_rec.hostname, var_sql, TRUE) ;

    EXCEPTION WHEN OTHERS THEN PERFORM csctoss.replication_failure_insert
                                             (sysparm_rec.hostname
                                             ,sysparm_rec.ip_address
                                             ,'radcheck'
                                             ,par_primary_key
                                             ,par_change_type
                                             ,var_sql) ;
    END ;

  END LOOP ;

  RETURN TRUE ;

END;
$_$;


ALTER FUNCTION csctoss.radcheck_updater(text, character) OWNER TO slony;

--
-- Name: FUNCTION radcheck_updater(text, character); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION radcheck_updater(text, character) IS 'Updater based function to replicate radcheck data changes from change_log.';


--
-- Name: radgroupcheck_updater(text, character); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION radgroupcheck_updater(text, character) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_primary_key               text    := $1 ;
  par_change_type               char(1) := $2 ;

  var_sql                       text ;

  var_radius_server_group	text ;

  sysparm_rec			record ;
  radgroupcheck_rec		record ;

BEGIN

  -- dynamically build sql statement based on change type and execute
  IF par_change_type = 'D' THEN

    -- build string for deletes
    var_sql := 'delete from radgroupcheck where id = '||par_primary_key::integer ;

  ELSE

    SELECT INTO radgroupcheck_rec * FROM csctoss.radgroupcheck WHERE id = par_primary_key::integer ;
    IF NOT FOUND THEN RETURN FALSE ; END IF ;

    -- build string for inserts
    IF par_change_type = 'I' THEN
      var_sql := 'INSERT INTO radgroupcheck
                            ( id
                            , groupname
                            , attribute
                            , op
                            , value )
                VALUES ( ' || radgroupcheck_rec.id || ','
                           || quote_literal(radgroupcheck_rec.groupname) || ','
                           || quote_literal(radgroupcheck_rec.attribute) || ','
                           || quote_literal(radgroupcheck_rec.op) || ','
                           || quote_literal(radgroupcheck_rec.value) || ')' ;

    -- build string for updates
    ELSIF par_change_type = 'U' THEN
      var_sql := 'UPDATE radgroupcheck
                     SET groupname = ' || quote_literal(radgroupcheck_rec.groupname) || '
                        ,attribute = ' || quote_literal(radgroupcheck_rec.attribute) || '
                        ,op =        ' || quote_literal(radgroupcheck_rec.op) || '
                        ,value =     ' || quote_literal(radgroupcheck_rec.value) || '
                  WHERE  id =        ' || radgroupcheck_rec.id ;


    END IF ;

  END IF ;

  -- now loop through appropriate rows again in system_parameter table performing the actual statement
  FOR sysparm_rec IN SELECT hostname, ip_address
                       FROM csctoss.system_parameter
                      WHERE repl_flag = TRUE
  LOOP

    BEGIN

      PERFORM public.dblink_exec(sysparm_rec.hostname, var_sql, TRUE) ;

    EXCEPTION WHEN OTHERS THEN PERFORM csctoss.replication_failure_insert
                                             (sysparm_rec.hostname
                                             ,sysparm_rec.ip_address
                                             ,'radgroupcheck'
                                             ,par_primary_key
                                             ,par_change_type
                                             ,var_sql) ;
    END ;

  END LOOP ;

  RETURN TRUE ;

END;
$_$;


ALTER FUNCTION csctoss.radgroupcheck_updater(text, character) OWNER TO slony;

--
-- Name: FUNCTION radgroupcheck_updater(text, character); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION radgroupcheck_updater(text, character) IS 'Updater based function to replicate radgroupcheck data changes from change_log.';


--
-- Name: radgroupreply_updater(text, character); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION radgroupreply_updater(text, character) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_primary_key               text    := $1 ;
  par_change_type               char(1) := $2 ;

  var_sql                       text ;

  var_radius_server_group	text ;

  sysparm_rec			record ;
  radgroupreply_rec		record ;

BEGIN

  -- dynamically build sql statement based on change type and execute
  IF par_change_type = 'D' THEN

    -- build string for deletes
    var_sql := 'delete from radgroupreply where id = '||par_primary_key::integer ;

  ELSE

    SELECT INTO radgroupreply_rec * FROM csctoss.radgroupreply WHERE id = par_primary_key::integer ;
    IF NOT FOUND THEN RETURN FALSE ; END IF ;

    -- build string for inserts
    IF par_change_type = 'I' THEN
      var_sql := 'INSERT INTO radgroupreply
                            ( id
                            , groupname
                            , attribute
                            , op
                            , value )
                VALUES ( ' || radgroupreply_rec.id || ','
                           || quote_literal(radgroupreply_rec.groupname) || ','
                           || quote_literal(radgroupreply_rec.attribute) || ','
                           || quote_literal(radgroupreply_rec.op) || ','
                           || quote_literal(radgroupreply_rec.value) || ')' ;

    -- build string for updates
    ELSIF par_change_type = 'U' THEN
      var_sql := 'UPDATE radgroupreply
                     SET groupname = ' || quote_literal(radgroupreply_rec.groupname) || '
                        ,attribute = ' || quote_literal(radgroupreply_rec.attribute) || '
                        ,op =        ' || quote_literal(radgroupreply_rec.op) || '
                        ,value =     ' || quote_literal(radgroupreply_rec.value) || '
                  WHERE  id =        ' || radgroupreply_rec.id ;


    END IF ;

  END IF ;

  -- now loop through appropriate rows again in system_parameter table performing the actual statement
  FOR sysparm_rec IN SELECT hostname, ip_address
                       FROM csctoss.system_parameter
                      WHERE repl_flag = TRUE
  LOOP

    BEGIN

      PERFORM public.dblink_exec(sysparm_rec.hostname, var_sql, TRUE) ;

    EXCEPTION WHEN OTHERS THEN PERFORM csctoss.replication_failure_insert
                                             (sysparm_rec.hostname
                                             ,sysparm_rec.ip_address
                                             ,'radgroupreply'
                                             ,par_primary_key
                                             ,par_change_type
                                             ,var_sql) ;
    END ;

  END LOOP ;

  RETURN TRUE ;

END;
$_$;


ALTER FUNCTION csctoss.radgroupreply_updater(text, character) OWNER TO slony;

--
-- Name: FUNCTION radgroupreply_updater(text, character); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION radgroupreply_updater(text, character) IS 'Updater based function to replicate radgroupreply data changes from change_log.';


--
-- Name: radius_updater(); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION radius_updater() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE

  var_conn_string		text ;
  var_last_change_log_id	bigint ;
  var_max_change_log_id		bigint ;
  var_prev_primary_key          text := 'x' ;
  var_prev_change_type          text := 'y' ;
  var_sql			text ;

  var_attribute_type_kounter	integer := 0 ;
  var_attribute_kounter		integer := 0 ;
  var_groupname_kounter		integer := 0 ;
  var_nas_kounter		integer := 0 ;
  var_radcheck_kounter		integer := 0 ;
  var_radgroupcheck_kounter	integer := 0 ;
  var_radreply_kounter		integer := 0 ;
  var_radgroupreply_kounter	integer := 0 ;
  var_usergroup_kounter		integer := 0 ;
  var_username_kounter		integer := 0 ;

  rec_sysparm			record ;
  rec_change_log		record ;

BEGIN

  -- get the last change_log_id and max change_log_id
  SELECT last_change_log_id INTO var_last_change_log_id FROM csctoss.last_change_log ;
  SELECT MAX(change_log_id) INTO var_max_change_log_id FROM csctoss.change_log ;

  IF var_last_change_log_id IS NULL THEN
    RETURN NEXT 'ERROR: LAST_CHANGE_LOG_ID IS NULL' ;
    RETURN ;
  ELSIF var_max_change_log_id IS NULL THEN
    RETURN NEXT 'ERROR: MAX_CHANGE_LOG_ID IS NULL (LAST:'||var_last_change_log_id||')' ;
    RETURN ;
  ELSIF var_last_change_log_id > var_max_change_log_id THEN
    RETURN NEXT 'ERROR: LAST_CHANGE_LOG_ID GREATER THAN MAX_CHANGE_LOG_ID (LAST:'||var_last_change_log_id||' MAX:'||var_max_change_log_id||')' ;
    RETURN ;
  ELSIF var_last_change_log_id = var_max_change_log_id THEN
    RETURN NEXT 'SUCCESS: ('||var_last_change_log_id::text||' to '||var_max_change_log_id::text||')' ;
    RETURN ;
  END IF ;

  -- build connection string and open a connection for each replicated host
  FOR rec_sysparm IN SELECT * FROM csctoss.system_parameter WHERE repl_flag = TRUE
  LOOP

    -- build the string for each
    var_conn_string := 'hostaddr='||rec_sysparm.ip_address||
                          ' port='||rec_sysparm.repl_port||
                        ' dbname='||rec_sysparm.repl_target_db||
                          ' user='||rec_sysparm.repl_target_username||
                      ' password='||rec_sysparm.repl_target_password||'' ;

    -- disconnect in case already open, then open a connection named for each hostname
    BEGIN
      PERFORM public.dblink_disconnect(rec_sysparm.hostname) ;
    EXCEPTION WHEN OTHERS THEN NULL ;
    END ;

    PERFORM public.dblink_connect(rec_sysparm.hostname, var_conn_string) ;

  END LOOP ;

  -- get all change log information sorted by change_log_id
  FOR rec_change_log IN SELECT change_log_id
                              ,table_name
                              ,rtrim(substr(table_name,instr(table_name,'"',1,3)+1,100),'"')||'_updater' as function_call
                              ,change_type
                              ,primary_key
                          FROM csctoss.change_log clog
                         WHERE change_log_id >  var_last_change_log_id
                           AND change_log_id <= var_max_change_log_id
                           AND table_name IN ('"csctoss"."attribute_type"'
                                             ,'"csctoss"."attribute"'
                                             ,'"csctoss"."groupname"'
                                             ,'"csctoss"."nas"'
                                             ,'"csctoss"."radcheck"'
                                             ,'"csctoss"."radgroupcheck"'
                                             ,'"csctoss"."radreply"'
                                             ,'"csctoss"."radgroupreply"'
                                             ,'"csctoss"."usergroup"'
                                             ,'"csctoss"."username"')
                                             
                      ORDER BY change_log_id
  LOOP

    -- make sure the primary key and/or change_type have changed, otherwise skip
    IF (var_prev_primary_key <> rec_change_log.primary_key OR
        var_prev_change_type <> rec_change_log.change_type) THEN

      -- dynamically call the appropriate updater routine with primary_key
      var_sql := 'SELECT * FROM csctoss.'||rec_change_log.function_call
                                        ||'('''||rec_change_log.primary_key
                                        ||''','''||rec_change_log.change_type||''')' ;
      EXECUTE var_sql ;

      -- increment the appropriate kounter
      IF    rec_change_log.table_name = '"csctoss"."attribute_type"' THEN var_attribute_type_kounter := var_attribute_type_kounter + 1;
      ELSIF rec_change_log.table_name = '"csctoss"."attribute"' THEN var_attribute_kounter := var_attribute_kounter + 1 ;
      ELSIF rec_change_log.table_name = '"csctoss"."groupname"' THEN var_groupname_kounter := var_groupname_kounter + 1 ;
      ELSIF rec_change_log.table_name = '"csctoss"."nas"' THEN var_nas_kounter := var_nas_kounter + 1 ;
      ELSIF rec_change_log.table_name = '"csctoss"."radcheck"' THEN var_radcheck_kounter := var_radcheck_kounter + 1 ;
      ELSIF rec_change_log.table_name = '"csctoss"."radgroupcheck"' THEN var_radgroupcheck_kounter := var_radgroupcheck_kounter + 1 ;
      ELSIF rec_change_log.table_name = '"csctoss"."radreply"' THEN var_radreply_kounter := var_radreply_kounter + 1 ;
      ELSIF rec_change_log.table_name = '"csctoss"."radgroupreply"' THEN var_radgroupreply_kounter := var_radgroupreply_kounter + 1 ;
      ELSIF rec_change_log.table_name = '"csctoss"."usergroup"' THEN var_usergroup_kounter := var_usergroup_kounter + 1 ;
      ELSIF rec_change_log.table_name = '"csctoss"."username"' THEN var_username_kounter := var_username_kounter + 1 ;
      END IF ;

      var_prev_primary_key := rec_change_log.primary_key ;
      var_prev_change_type := rec_change_log.change_type ;

    END IF ;

  END LOOP ;

  -- now go through system_parameter again and close the hostname named connections
  FOR rec_sysparm IN SELECT hostname
                       FROM csctoss.system_parameter
                      WHERE repl_flag = TRUE
  LOOP
    BEGIN
      PERFORM public.dblink_disconnect(rec_sysparm.hostname) ;
    EXCEPTION WHEN OTHERS THEN NULL ;
    END ;
  END LOOP ;

  -- update the last_change_log
  UPDATE csctoss.last_change_log SET last_change_log_id = var_max_change_log_id ;

  -- return each tables rows process if any
  IF var_attribute_type_kounter > 0 THEN
    RETURN NEXT var_attribute_type_kounter::text||' rows processed for table attribute_type' ;
  END IF ;
  IF var_attribute_kounter > 0 THEN
    RETURN NEXT var_attribute_kounter::text||' rows processed for table attribute' ;
  END IF ;
  IF var_groupname_kounter > 0 THEN
    RETURN NEXT var_groupname_kounter::text||' rows processed for table groupname' ;
  END IF ;
  IF var_nas_kounter > 0 THEN
    RETURN NEXT var_nas_kounter::text||' rows processed for table nas' ;
  END IF ;
  IF var_radcheck_kounter > 0 THEN
    RETURN NEXT var_radcheck_kounter::text||' rows processed for table radcheck' ;
  END IF ;
  IF var_radgroupcheck_kounter > 0 THEN
    RETURN NEXT var_radgroupcheck_kounter::text||' rows processed for table radgroupcheck' ;
  END IF ;
  IF var_radreply_kounter > 0 THEN
    RETURN NEXT var_radreply_kounter::text||' rows processed for table radreply' ;
  END IF ;
  IF var_radgroupreply_kounter > 0 THEN
    RETURN NEXT var_radgroupreply_kounter::text||' rows processed for table radgroupreply' ;
  END IF ;
  IF var_usergroup_kounter > 0 THEN
    RETURN NEXT var_usergroup_kounter::text||' rows processed for table usergroup' ;
  END IF ;
  IF var_username_kounter > 0 THEN
    RETURN NEXT var_username_kounter::text||' rows processed for table username' ;
  END IF ;

  -- echo SUCCESS, this will be what the cron job looks for
  RETURN NEXT 'SUCCESS: ('||var_last_change_log_id::text||' to '||var_max_change_log_id::text||')' ;
  RETURN ;

END;
$$;


ALTER FUNCTION csctoss.radius_updater() OWNER TO slony;

--
-- Name: FUNCTION radius_updater(); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION radius_updater() IS 'Master function which determines radius table changes from change_log and calls appropriate replication routines.';


--
-- Name: radius_updater(integer); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION radius_updater(integer) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_num_rows                  integer := $1 ;

  var_conn_string		text ;
  var_last_change_log_id	bigint ;
  var_max_change_log_id		bigint ;
  var_prev_primary_key          text := 'x' ;
  var_prev_change_type          text := 'y' ;
  var_sql			text ;

  var_attribute_type_kounter	integer := 0 ;
  var_attribute_kounter		integer := 0 ;
  var_groupname_kounter		integer := 0 ;
  var_nas_kounter		integer := 0 ;
  var_radcheck_kounter		integer := 0 ;
  var_radgroupcheck_kounter	integer := 0 ;
  var_radreply_kounter		integer := 0 ;
  var_radgroupreply_kounter	integer := 0 ;
  var_usergroup_kounter		integer := 0 ;
  var_username_kounter		integer := 0 ;

  sysparm_rec			record ;
  change_log_rec		record ;

BEGIN

  -- build connection string and open a connection for each replicated host
  FOR sysparm_rec IN SELECT * FROM csctoss.system_parameter WHERE repl_flag = TRUE
  LOOP

    -- build the string for each
    var_conn_string := 'hostaddr='||sysparm_rec.ip_address||
                          ' port='||sysparm_rec.repl_port||
                        ' dbname='||sysparm_rec.repl_target_db||
                          ' user='||sysparm_rec.repl_target_username||
                      ' password='||sysparm_rec.repl_target_password||'' ;

    -- disconnect in case already open, then open a connection named for each hostname
    BEGIN
      PERFORM public.dblink_disconnect(sysparm_rec.hostname) ;
    EXCEPTION WHEN OTHERS THEN NULL ;
    END ;

    PERFORM public.dblink_connect(sysparm_rec.hostname, var_conn_string) ;

  END LOOP ;

  -- get the last change_log_id and max change_log_id
  SELECT last_change_log_id INTO var_last_change_log_id FROM csctoss.last_change_log ;

  SELECT MAX(change_log_id) INTO var_max_change_log_id FROM csctoss.change_log WHERE change_log_id < var_last_change_log_id + par_num_rows ;

  RAISE NOTICE 'LAST: % -- MAX: %', var_last_change_log_id, var_max_change_log_id ;

  IF var_last_change_log_id >= var_max_change_log_id 
  AND (SELECT TRUE FROM csctoss.change_log WHERE change_log_id > var_max_change_log_id LIMIT 1) THEN
    UPDATE csctoss.last_change_log SET last_change_log_id = last_change_log_id + (par_num_rows-1) ;
    RETURN NEXT 'FAILURE: LAST_CHANGE_LOG_ID AUTO INCREMENTED' ;
    RETURN ;
  END IF ;

  -- get all change log information sorted by change_log_id
  FOR change_log_rec IN SELECT change_log_id
                              ,table_name
                              ,rtrim(substr(table_name,instr(table_name,'"',1,3)+1,100),'"')||'_updater' as function_call
                              ,change_type
                              ,primary_key
                          FROM csctoss.change_log clog
                         WHERE change_log_id >  var_last_change_log_id
                           AND change_log_id <= var_max_change_log_id
                           AND table_name IN ('"csctoss"."attribute_type"'
                                             ,'"csctoss"."attribute"'
                                             ,'"csctoss"."groupname"'
                                             ,'"csctoss"."nas"'
                                             ,'"csctoss"."radcheck"'
                                             ,'"csctoss"."radgroupcheck"'
                                             ,'"csctoss"."radreply"'
                                             ,'"csctoss"."radgroupreply"'
                                             ,'"csctoss"."usergroup"'
                                             ,'"csctoss"."username"')
                                             
                      ORDER BY change_log_id
  LOOP

    -- make sure the primary key and/or change_type have changed, otherwise skip
    IF (var_prev_primary_key <> change_log_rec.primary_key OR
        var_prev_change_type <> change_log_rec.change_type) THEN

      -- dynamically call the appropriate updater routine with primary_key
      var_sql := 'SELECT * FROM csctoss.'||change_log_rec.function_call
                                        ||'('''||change_log_rec.primary_key
                                        ||''','''||change_log_rec.change_type||''')' ;
      EXECUTE var_sql ;

      -- increment the appropriate kounter
      IF    change_log_rec.table_name = '"csctoss"."attribute_type"' THEN var_attribute_type_kounter := var_attribute_type_kounter + 1;
      ELSIF change_log_rec.table_name = '"csctoss"."attribute"' THEN var_attribute_kounter := var_attribute_kounter + 1 ;
      ELSIF change_log_rec.table_name = '"csctoss"."groupname"' THEN var_groupname_kounter := var_groupname_kounter + 1 ;
      ELSIF change_log_rec.table_name = '"csctoss"."nas"' THEN var_nas_kounter := var_nas_kounter + 1 ;
      ELSIF change_log_rec.table_name = '"csctoss"."radcheck"' THEN var_radcheck_kounter := var_radcheck_kounter + 1 ;
      ELSIF change_log_rec.table_name = '"csctoss"."radgroupcheck"' THEN var_radgroupcheck_kounter := var_radgroupcheck_kounter + 1 ;
      ELSIF change_log_rec.table_name = '"csctoss"."radreply"' THEN var_radreply_kounter := var_radreply_kounter + 1 ;
      ELSIF change_log_rec.table_name = '"csctoss"."radgroupreply"' THEN var_radgroupreply_kounter := var_radgroupreply_kounter + 1 ;
      ELSIF change_log_rec.table_name = '"csctoss"."usergroup"' THEN var_usergroup_kounter := var_usergroup_kounter + 1 ;
      ELSIF change_log_rec.table_name = '"csctoss"."username"' THEN var_username_kounter := var_username_kounter + 1 ;
      END IF ;

      var_prev_primary_key := change_log_rec.primary_key ;
      var_prev_change_type := change_log_rec.change_type ;

    END IF ;

  END LOOP ;

  -- now go through system_parameter again and close the hostname named connections
  FOR sysparm_rec IN SELECT hostname
                       FROM csctoss.system_parameter
                      WHERE repl_flag = TRUE
  LOOP
    BEGIN
      PERFORM public.dblink_disconnect(sysparm_rec.hostname) ;
    EXCEPTION WHEN OTHERS THEN NULL ;
    END ;
  END LOOP ;

  -- update the last_change_log
  UPDATE csctoss.last_change_log SET last_change_log_id = var_max_change_log_id ;

  -- return each tables rows process if any
  IF var_attribute_type_kounter > 0 THEN
    RETURN NEXT var_attribute_type_kounter::text||' rows processed for table attribute_type' ;
  END IF ;
  IF var_attribute_kounter > 0 THEN
    RETURN NEXT var_attribute_kounter::text||' rows processed for table attribute' ;
  END IF ;
  IF var_groupname_kounter > 0 THEN
    RETURN NEXT var_groupname_kounter::text||' rows processed for table groupname' ;
  END IF ;
  IF var_nas_kounter > 0 THEN
    RETURN NEXT var_nas_kounter::text||' rows processed for table nas' ;
  END IF ;
  IF var_radcheck_kounter > 0 THEN
    RETURN NEXT var_radcheck_kounter::text||' rows processed for table radcheck' ;
  END IF ;
  IF var_radgroupcheck_kounter > 0 THEN
    RETURN NEXT var_radgroupcheck_kounter::text||' rows processed for table radgroupcheck' ;
  END IF ;
  IF var_radreply_kounter > 0 THEN
    RETURN NEXT var_radreply_kounter::text||' rows processed for table radreply' ;
  END IF ;
  IF var_radgroupreply_kounter > 0 THEN
    RETURN NEXT var_radgroupreply_kounter::text||' rows processed for table radgroupreply' ;
  END IF ;
  IF var_usergroup_kounter > 0 THEN
    RETURN NEXT var_usergroup_kounter::text||' rows processed for table usergroup' ;
  END IF ;
  IF var_username_kounter > 0 THEN
    RETURN NEXT var_username_kounter::text||' rows processed for table username' ;
  END IF ;

  -- echo SUCCESS, this will be what the cron job looks for
  RETURN NEXT 'SUCCESS: ('||var_last_change_log_id::text||' to '||var_max_change_log_id::text||')' ;
  RETURN ;

END;
$_$;


ALTER FUNCTION csctoss.radius_updater(integer) OWNER TO slony;

--
-- Name: FUNCTION radius_updater(integer); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION radius_updater(integer) IS 'Master function which determines radius table changes from change_log and calls appropriate replication routines.';


--
-- Name: radreply_pre_insert_update(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION radreply_pre_insert_update() RETURNS "trigger"
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE

  var_value             text ;
  var_old_username      text ;
  var_old_vrf           text ;
  var_new_username      text ;
  var_new_vrf           text ;

BEGIN
  -- class validation - make sure no more than one username per class
  IF NEW.attribute = 'Class' THEN
    IF TG_OP = 'INSERT' THEN

      -- make sure this username not already assigned
      SELECT username 
        INTO var_old_username 
        FROM csctoss.radreply
       WHERE attribute = 'Class' 
         AND value = NEW.value ;
      IF FOUND THEN
        RAISE EXCEPTION 'Class (Line ID) % already assigned to Username %.', NEW.value, var_old_username ;
      END IF ;

    -- make sure this username not already assigned a class
    SELECT value
      INTO var_value
      FROM csctoss.radreply
     WHERE username = NEW.username
       AND attribute = 'Class'
       AND value <> NEW.value ;
    IF FOUND THEN
      RAISE EXCEPTION 'Username % already assigned Class (Line ID) %.', NEW.username, var_value ;
    END IF ;

    ELSIF TG_OP = 'UPDATE' AND NEW.value <> OLD.value THEN

      -- make sure this class not already assigned
      SELECT username 
        INTO var_old_username 
        FROM csctoss.radreply
       WHERE attribute = 'Class' 
         AND value = NEW.value ;
      IF FOUND THEN
        RAISE EXCEPTION 'Class (Line ID) % already assigned to Username %.', NEW.value, var_old_username ;
      END IF ;

    END IF ;
  END IF ;

  -- framed ip address validation
  IF NEW.attribute = 'Framed-IP-Address' THEN
/*
    IF INSTR(NEW.value,' ',1,1) <> 0 THEN
      RAISE EXCEPTION 'New value for Framed-IP-Address contains one or more blank spaces. Please remove blank spaces and try again.' ;
    END IF ;
*/

    -- check to see if this username already assigned a static ip
    IF TG_OP = 'INSERT' THEN

      SELECT INTO var_value value
        FROM csctoss.radreply
       WHERE attribute = 'Framed-IP-Address'
         AND op = '='
         AND username = NEW.username ;

      IF FOUND THEN
        RAISE EXCEPTION 'Username % already assigned Framed-IP-Address %', NEW.username, var_value ;
      END IF ;

      -- Check to see if an IP address already exists in radreply table.
      IF ((SELECT count(*) FROM csctoss.radreply rr JOIN csctoss.usergroup ug ON (rr.username = ug.username)
          WHERE 1 = 1
          AND rr.attribute = 'Framed-IP-Address'
          AND rr.value = NEW.value
          AND ug.groupname = (SELECT groupname FROM usergroup ug2 WHERE ug2.username = NEW.username)) >= 1)
      THEN
        RAISE EXCEPTION 'IP Address [%] already exists in same groupname.', NEW.value ;
      END IF;

    END IF ;

 /*   -- Check if a new IP address is already assigned in static_ip_pool table.
    raise NOTICE '=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=';
    raise NOTICE 'In trigger function radreply_pre_insert_update(). Event=%', TG_OP;
    raise NOTICE 'NEW.attribute=%, NEW.value=%', NEW.attribute, NEW.value;
    raise NOTICE '=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=';
    if (select count(*) from csctoss.static_ip_pool where is_assigned = true and static_ip = NEW.value) = 0 then
        RAISE EXCEPTION 'Requested Framed-IP-Address % is NOT assigned in static_ip_address table.', NEW.value ;
    end if;
*/
    -- if ip address not currently assigned to any username then allow and exit
    SELECT INTO var_old_username username
      FROM csctoss.radreply
     WHERE attribute = 'Framed-IP-Address'
       AND op = '='
       AND value = NEW.value ;

    IF NOT FOUND THEN RETURN NEW ; END IF ;

    -- existing username found, fetch associated vrf
/*
    SELECT INTO var_old_vrf SUBSTR(rgre.value, INSTR(rgre.value,'ip vrf forwarding',1,1)+18)
      FROM csctoss.usergroup ugrp
      JOIN csctoss.radgroupreply rgre USING (groupname)
     WHERE rgre.value like '%ip vrf forwarding%'
       AND ugrp.username = var_old_username ;
*/
    SELECT INTO var_old_vrf SUBSTR(rgre.value, length('lcp:interface-config#1=ip vrf forwarding  '))
      FROM csctoss.usergroup ugrp
      JOIN csctoss.radgroupreply rgre USING (groupname)
     WHERE rgre.value like '%ip vrf forwarding%'
       AND ugrp.username = var_old_username ;

    IF NOT FOUND THEN RETURN NEW ; END IF ;

    -- now get the vrf for the new radreply record
/*
    SELECT INTO var_new_vrf SUBSTR(rgre.value,INSTR(rgre.value,'ip vrf forwarding',1,1)+18)
      FROM csctoss.usergroup ugrp
      JOIN csctoss.radgroupreply rgre USING (groupname)
     WHERE rgre.value like '%ip vrf forwarding%'
       AND ugrp.username = NEW.username ;
*/
    SELECT INTO var_new_vrf SUBSTR(rgre.value, length('lcp:interface-config#1=ip vrf forwarding  '))
      FROM csctoss.usergroup ugrp
      JOIN csctoss.radgroupreply rgre USING (groupname)
     WHERE rgre.value like '%ip vrf forwarding%'
       AND ugrp.username = NEW.username ;
    IF NOT FOUND THEN RETURN NEW ; END IF ;

RAISE NOTICE 'Old Username: %  Old VRF: %', var_old_username, var_old_vrf ;
RAISE NOTICE 'New Username: %  New VRF: %', var_new_username, var_new_vrf ;

    -- both usernames have vrf, compare them
    IF var_old_vrf = var_new_vrf THEN
      RAISE EXCEPTION 'Username % already assigned Framed-IP-Address % for %', var_old_username, NEW.value, var_old_vrf ;
    END IF ;

  END IF ;

  RETURN NEW ;

END ;
$$;


ALTER FUNCTION csctoss.radreply_pre_insert_update() OWNER TO csctoss_owner;

--
-- Name: FUNCTION radreply_pre_insert_update(); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION radreply_pre_insert_update() IS 'Trigger on radreply table to validate static ip addresses before insert or update.';


--
-- Name: radreply_updater(text, character); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION radreply_updater(text, character) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_primary_key               text    := $1 ;
  par_change_type               char(1) := $2 ;

  var_sql                       text ;

  var_radius_server_group	text ;

  sysparm_rec			record ;
  radreply_rec			record ;

BEGIN

  -- dynamically build sql statement based on change type and execute
  IF par_change_type = 'D' THEN

    -- build string for deletes
    var_sql := 'delete from radreply where id = '||par_primary_key::integer ;

  ELSE

    SELECT INTO radreply_rec * FROM csctoss.radreply WHERE id = par_primary_key::integer ;
    IF NOT FOUND THEN RETURN FALSE ; END IF ;

    -- build string for inserts
    IF par_change_type = 'I' THEN
      var_sql := 'INSERT INTO radreply
                            ( id
                            , username
                            , attribute
                            , op
                            , value
                            , priority )
                VALUES ( ' || radreply_rec.id || ','
                           || quote_literal(radreply_rec.username) || ','
                           || quote_literal(radreply_rec.attribute) || ','
                           || quote_literal(radreply_rec.op) || ','
                           || CASE WHEN radreply_rec.value = ''
                                   THEN quote_literal('')
                                   ELSE quote_literal(radreply_rec.value) END || ','
                           || radreply_rec.priority || ')' ;

    -- build string for updates
    ELSIF par_change_type = 'U' THEN
      var_sql := 'UPDATE radreply
                     SET username =        ' || quote_literal(radreply_rec.username) || '
                        ,attribute =       ' || quote_literal(radreply_rec.attribute) || '
                        ,op =              ' || quote_literal(radreply_rec.op) || '
                        ,value =           ' || CASE WHEN radreply_rec.value = '' THEN quote_literal('') ELSE quote_literal(radreply_rec.value) END || '
                        ,priority =        ' || radreply_rec.priority || '
                  WHERE  id =              ' || radreply_rec.id ;


    END IF ;

  END IF ;

  -- now loop through appropriate rows again in system_parameter table performing the actual statement
  FOR sysparm_rec IN SELECT hostname, ip_address
                       FROM csctoss.system_parameter
                      WHERE repl_flag = TRUE
  LOOP

    BEGIN

      PERFORM public.dblink_exec(sysparm_rec.hostname, var_sql, TRUE) ;

    EXCEPTION WHEN OTHERS THEN PERFORM csctoss.replication_failure_insert
                                             (sysparm_rec.hostname
                                             ,sysparm_rec.ip_address
                                             ,'radreply'
                                             ,par_primary_key
                                             ,par_change_type
                                             ,var_sql) ;
    END ;

  END LOOP ;

  RETURN TRUE ;

END;
$_$;


ALTER FUNCTION csctoss.radreply_updater(text, character) OWNER TO slony;

--
-- Name: FUNCTION radreply_updater(text, character); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION radreply_updater(text, character) IS ' Updater based function to replicate radreply data changes from change_log.';


--
-- Name: random_string(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION random_string(integer) RETURNS text
    LANGUAGE sql
    AS $_$
SELECT array_to_string(
    ARRAY (
        SELECT substring(
            '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
            FROM (ceil(random()*62))::int FOR 1
        )
        FROM generate_series(1, $1)
    ),
    ''
)
$_$;


ALTER FUNCTION csctoss.random_string(integer) OWNER TO csctoss_owner;

--
-- Name: register_prepaid_user_ui(text, text, boolean, text, text, text, text, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION register_prepaid_user_ui(text, text, boolean, text, text, text, text, text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_first_name          text      := $1 ;
  par_last_name           text      := $2 ;
  par_opt_in_flag         boolean   := $3 ;
  par_email_address       text      := $4 ;
  par_line1               text      := $5 ;
  par_city                text      := $6 ;
  par_state_code          text      := $7 ;
  par_postal_code         text      := $8 ;
  par_phone_number        text      := $9 ;

  var_billing_entity_name text ;
  var_billing_entity_id   integer ;
  var_address_id          integer ;
  var_username            text ;
  var_line_id             integer ;

BEGIN

  -- we need some kind of name, just deal with the rest if null
  IF par_first_name IS NULL AND par_last_name IS NULL THEN
    RETURN 'ERROR: First and last name cannot both be null.' ;
  ELSE
    var_billing_entity_name := COALESCE(par_first_name,'')||' '||COALESCE(par_last_name,'') ;
  END IF ;

  -- validate state code
  IF par_state_code IS NULL THEN
    RETURN 'ERROR: State Code cannot be null.' ;
  ELSE
    PERFORM * FROM csctoss.state_code WHERE state_code = par_state_code ;
    IF NOT FOUND THEN 
      RETURN 'ERROR: State Code '||par_state_code||' is invalid.' ;
    END IF ;
  END IF ;

  -- get the billing_entity_id and address_id
  SELECT nextval('billing_entity_billing_entity_id_seq') INTO var_billing_entity_id ;
  SELECT nextval('address_address_id_seq') INTO var_address_id ;

  PERFORM public.set_change_log_staff_id(1) ;

  -- insert the billing_entity record
  INSERT INTO csctoss.billing_entity
             (billing_entity_id
             ,parent_billing_entity_id
             ,name
             ,url
             ,billing_entity_type
             ,opt_in_flag)
      VALUES (var_billing_entity_id
             ,(select billing_entity_id from csctoss.billing_entity where name = 'SPRINT PREPAID PARENT')
             ,var_billing_entity_name
             ,COALESCE(par_email_address,'')
             ,'CONSUMER'
             ,COALESCE(par_opt_in_flag,FALSE)) ;

  -- insert the address record
  INSERT INTO csctoss.address
             (address_id
             ,line1
             ,city
             ,state_code
             ,postal_code)
      VALUES (var_address_id
             ,COALESCE(par_line1,'')
             ,COALESCE(par_city,'')
             ,par_state_code
             ,COALESCE(par_postal_code,'')) ;

  -- insert the billing_entity_address record
  INSERT INTO csctoss.billing_entity_address
             (billing_entity_id
             ,address_type
             ,address_id)
      VALUES (var_billing_entity_id
             ,'BILLING'
             ,var_address_id) ;

  -- update the username table for the billing_entity_id
  SELECT username
    INTO var_username
    FROM csctoss.username
   WHERE SUBSTR(username,1,10) = par_phone_number
    LIMIT 1 ;

RAISE NOTICE 'Username: %', var_username ;

  IF NOT FOUND THEN
    RETURN 'Phone Number '||par_phone_number||' has no matching username in username table.' ;
  ELSE
    UPDATE csctoss.username
       SET billing_entity_id = var_billing_entity_id
     WHERE username = var_username ;
  END IF ;

  -- update the line table with billing_entity_id and billing_entity_address_id
  SELECT line_id
    INTO var_line_id
    FROM csctoss.line
   WHERE line.radius_username = var_username
ORDER BY start_date DESC
   LIMIT 1 ;

RAISE NOTICE 'Line ID: %', var_line_id ;

  IF NOT FOUND THEN
    RETURN 'ERROR: Phone Number '||par_phone_number||' has no matching radius_username in line table.' ;
  ELSE
    UPDATE csctoss.line
       SET billing_entity_id         = var_billing_entity_id
          ,billing_entity_address_id = var_address_id
     WHERE line_id = var_line_id ;
  END IF ;

  RETURN 'SUCCESS' ;

END ;

$_$;


ALTER FUNCTION csctoss.register_prepaid_user_ui(text, text, boolean, text, text, text, text, text, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION register_prepaid_user_ui(text, text, boolean, text, text, text, text, text, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION register_prepaid_user_ui(text, text, boolean, text, text, text, text, text, text) IS 'Registers a prepaid user from Contour eCommerce site based provided credit card authorization data.';


--
-- Name: replication_failure_insert(text, text, text, text, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION replication_failure_insert(text, text, text, text, text, text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
BEGIN

  INSERT INTO csctoss.replication_failure
             (hostname
             ,ip_address
             ,failed_table
             ,failed_primary_key
             ,failed_action
             ,sql_statement)
      VALUES ($1
             ,$2
             ,$3
             ,$4
             ,$5
             ,$6) ;

  RETURN TRUE ;

END ;

$_$;


ALTER FUNCTION csctoss.replication_failure_insert(text, text, text, text, text, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION replication_failure_insert(text, text, text, text, text, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION replication_failure_insert(text, text, text, text, text, text) IS 'Inserts a row into replication_failure table with values passed from failed trigger function in table_name.';


--
-- Name: rma_device_info(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION rma_device_info(text) RETURNS SETOF rma_device_info_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_esn_hex                   text := $1;
  var_equipment_id              integer;
  var_line_id                   integer;
  var_serial                 	text;
  var_model 			text;
  var_return               	rma_device_info_retval;

BEGIN
  
  IF par_esn_hex = '' THEN
    RAISE EXCEPTION 'Input ESN HEX Is Null. Please enter a value ';
  ELSE
    -- Get the equipment id.
    SELECT equipment_id INTO var_equipment_id
    FROM unique_identifier
    WHERE unique_identifier_type = 'ESN HEX'
    AND value = par_esn_hex;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'ESN HEX value doesnt exists';
    END IF;
  END IF;

  -- Retrieve Serial number
  SELECT value INTO var_serial
  FROM unique_identifier
    WHERE unique_identifier_type = 'SERIAL NUMBER'
  AND equipment_id = var_equipment_id;

  IF NOT FOUND THEN
      RAISE EXCEPTION 'Serial Number value doesnt exists';
  END IF;

  --Retrieve device model
  SELECT model_number1 INTO var_model
  FROM equipment AS e
  LEFT OUTER JOIN equipment_model AS em ON em.equipment_model_id = e.equipment_model_id
  WHERE equipment_id = var_equipment_id; 
  

  var_return.model = var_model;
  var_return.esn = par_esn_hex;
  var_return.serial = var_serial;
  RETURN NEXT var_return;
  RETURN;
  --RETURN var_return;

END;
$_$;


ALTER FUNCTION csctoss.rma_device_info(text) OWNER TO csctoss_owner;

--
-- Name: rt_field_updater(integer, integer, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION rt_field_updater(ticketid integer, fieldid integer, value text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE


BEGIN
raise notice 'in updater';
raise notice 'params: % % %',ticketId,fieldId,value;

         IF EXISTS
                   (SELECT TRUE from rt3.objectcustomfieldvalues
                              WHERE objectcustomfieldvalues.objectid =ticketId
                                AND customfield=fieldId AND disabled=0)
         THEN
             UPDATE rt3.objectcustomfieldvalues
                   set     --content=value,
                       lastupdatedby=83842,
                       lastupdated= current_timestamp::timestamp without time zone,
                       disabled=1
             WHERE  objectid =ticketId
                         AND customfield=fieldId
                         AND disabled=0;
             RAISE NOTICE 'Disable of current row was sucessful';
         END IF;
         RAISE NOTICE 'Inserting row into objectcustomfieldvalues';
         INSERT INTO rt3.objectcustomfieldvalues
                 (
                        customfield,
                        objecttype,
                        objectid,
                        sortorder,
                        content,
                        creator,
                        created,
                        lastupdatedby,
                        lastupdated,
                        disabled
                  )
                  VALUES
                  (
                        fieldId,
                        'RT::Ticket' ,
                        ticketId,
                        0,
                        value,
                        83842,
                        current_timestamp::timestamp without time zone,
                        83842,
                        current_timestamp::timestamp without time zone,
                        0
                   );
        RETURN TRUE;
EXCEPTION
            WHEN OTHERS  THEN
--            RAISE EXCEPTION 'Custom field value update failure: %:%:%', ticketId, fieldId, value ;
            RETURN FALSE;
END;
 $$;


ALTER FUNCTION csctoss.rt_field_updater(ticketid integer, fieldid integer, value text) OWNER TO csctoss_owner;

--
-- Name: rt_oss_rma(text, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION rt_oss_rma(text, text, text) RETURNS oss_rma_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_retval            oss_rma_retval%ROWTYPE;

BEGIN
    select * INTO v_retval from rt_oss_rma($1, $2, $3, false);
    RETURN v_retval;

END;  
$_$;


ALTER FUNCTION csctoss.rt_oss_rma(text, text, text) OWNER TO csctoss_owner;

--
-- Name: rt_oss_rma(text, text, text, boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION rt_oss_rma(text, text, text, boolean) RETURNS oss_rma_retval
    LANGUAGE plpgsql
    AS $_$
declare
--
in_old_esn              text   :=$1;
in_new_esn              text   :=$2;
in_tracking_number      text   :=$3;
par_bypass_jbilling     boolean := $4;
v_static_ip             boolean;
c_staff_id              integer:=3;
v_result                integer;
v_return                text;
v_ip_return             text;
v_tab                   text;
v_in_count              integer;
v_esnhex                text;
v_username_lgth         integer;
v_old_username          text;
v_new_username          text;
v_new_groupname         text;
v_old_groupname         text;
v_rma_groupname         text;
v_old_mod_ext_id        integer;
v_new_mod_ext_id        integer;
v_beid                  integer;
v_bename                text;
v_line_id               text;
v_oequipid              integer;
v_old_model             text;
v_new_model             text;
v_nequipid              integer;
v_old_ip                text;
v_new_ip                text;
v_carrier               text;
v_priority              integer;
v_notes                 text;
v_lstrtdat              date;
v_lenddat               text;
v_lestrtdat             text;
v_leenddat              text;
v_return_text           text;
v_return_boolean        boolean;
v_old_sn                text;
v_new_sn                text;
v_numrows               integer;
v_count                 integer;
v_value                 text;
v_value2                text;
v_sql                   text;
v_retval                oss_rma_retval%ROWTYPE;
v_rma_so_num            text;
v_errmsg                text;

v_tmp                   text;

BEGIN

    SET client_min_messages to NOTICE;

    RAISE NOTICE '-----------  IN RT_OSS_RMA FUNCTION NOW  ---------------------------';

    v_errmsg:='Unable to set change_log_staff_id';
    RAISE NOTICE 'rt_oss_rma: setting change_log_staff_id';

    SELECT * INTO v_result FROM public.set_change_log_staff_id(c_staff_id);
    IF
        v_result = -1  or v_result=c_staff_id
    THEN
        RAISE NOTICE 'rt_oss_rma:  change_log_staff_id has been set';
    ELSE
        RAISE exception '';
    END IF;

--
    RAISE NOTICE 'rt_oss_rma: looking for new ESN in UI table: %',in_new_esn;
    v_errmsg:='New ESN: '||in_new_esn||' not found in UI table';
    SELECT count(*)  into v_count
    from unique_identifier ui
    where 1=1
       and  ui.unique_identifier_type = 'ESN HEX'
       and ui.value = in_new_esn;
    IF v_count = 0
    THEN
        RAISE NOTICE '%',v_errmsg;
        RAISE EXCEPTION '';
    END IF;

--
    v_errmsg:='Replacement ESN cannot be currently active in line_equipment table';
    SELECT count(*) into v_count
        FROM unique_identifier ui
        JOIN line_equipment le ON (ui.equipment_id = le.equipment_id)
        where 1=1
           and ui.unique_identifier_type = 'ESN HEX'
           and ui.value = in_new_esn
           AND le.end_date IS NULL
    ;
    IF v_count > 0 then
         RAISE NOTICE 'TEST FAILED: %',v_errmsg;
         RAISE EXCEPTION '';
    END IF;
--
    
    v_errmsg:='Replacement ESN cannot have todays date as end_date in line_equipment table';    
    SELECT count(*) into v_count
        FROM unique_identifier ui
        JOIN line_equipment le ON (ui.equipment_id = le.equipment_id)
        where 1=1
           and ui.unique_identifier_type = 'ESN HEX'
           and ui.value = in_new_esn
           AND le.end_date = current_date;

    IF v_count > 0 then
         RAISE NOTICE 'TEST FAILED: %',v_errmsg;
         RAISE EXCEPTION '';
    END IF;
--
    v_errmsg:='Original ESN must be present in line_equipment with a null end date';
    SELECT count(*) into v_count
    FROM unique_identifier ui
    JOIN line_equipment le ON (ui.equipment_id = le.equipment_id)
    where 1=1
      and  ui.unique_identifier_type = 'ESN HEX'
      and ui.value = in_old_esn
      AND le.end_date IS NULL ;
--
    IF v_count = 0 then
       RAISE NOTICE 'TEST FAILED: %',v_errmsg;
       RAISE EXCEPTION '';
    END IF;
--
    v_errmsg:='Original ESN must be associated with an active line in line_equipment table';
    SELECT
        ui.value ,
        l.radius_username ,
        be.billing_entity_id ,
        be.name ,
        l.line_id ,
        ui.equipment_id ,
        l.start_date ,
        l.end_date ,
        le.start_date ,
        le.end_date ,
        l.notes
    INTO
       v_esnhex,v_old_username,v_beid, v_bename,v_line_id,v_oequipid,v_lstrtdat,v_lenddat,v_lestrtdat,v_leenddat,v_notes
    FROM unique_identifier ui
       JOIN equipment eq ON (ui.equipment_id = eq.equipment_id)
       JOIN line_equipment le ON (ui.equipment_id = le.equipment_id)
       JOIN line l ON (le.line_id = l.line_id)
       JOIN billing_entity be ON (l.billing_entity_id = be.billing_entity_id)
       WHERE 1 = 1
       AND ui.unique_identifier_type = 'ESN HEX'
       AND ui.value = in_old_esn
       AND le.end_date IS NULL
       AND l.end_date IS NULL
       ;
     IF NOT FOUND THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
     END IF;
     RAISE NOTICE '-------------------------------------------------------------------------------------------------';
     RAISE NOTICE 'Billing Entity: %: %', v_beid,v_bename;
     RAISE NOTICE '-------------------------------------------------------------------------------------------------';
---

     v_errmsg:='A serial number for replacement equipment must be present in UI table';
     SELECT value INTO v_old_sn
     FROM unique_identifier
     WHERE 1=1
       AND equipment_id = v_oequipid
       AND unique_identifier_type = 'SERIAL NUMBER';

    IF NOT FOUND
    THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END IF;

    RAISE NOTICE 'rt_oss_rma: Verifying groupname present for old username';
    v_errmsg:='The groupname for the username of the original equipment must be present in usergroup table';
    SELECT groupname INTO v_old_groupname
    FROM usergroup
    WHERE username = v_old_username
    order by priority desc
    LIMIT 1;
    IF NOT FOUND THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END IF;

    SELECT value INTO v_old_ip
    FROM radreply
    WHERE username = v_old_username
      AND attribute = 'Framed-IP-Address';
    IF NOT FOUND THEN
          RAISE NOTICE 'Static ip address not present for old username: %',v_old_username;
    END IF;

--
    v_errmsg:='Replacement ESN must be present in unique identifier table - and the equipment_id must have a match in the equipment table';

    SELECT ui.equipment_id INTO v_nequipid
    FROM unique_identifier ui
    JOIN equipment eq ON (ui.equipment_id = eq.equipment_id)
    WHERE 1 = 1
    AND ui.unique_identifier_type = 'ESN HEX'
    AND ui.value = in_new_esn
    ;
    IF NOT FOUND THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END if;
--
    v_errmsg:='Model ID for the new equipment id does not exist.';
    SELECT model_number1,e.equipment_model_id into v_new_model,v_new_mod_ext_id
    FROM equipment e
    JOIN equipment_model em ON (e.equipment_model_id=em.equipment_model_id)
    WHERE 1=1
       AND e.equipment_id=v_nequipid;
    IF NOT FOUND
    THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END IF;

    v_errmsg:='Serial number for new equipment does not exist.';
    SELECT value INTO v_new_sn
     FROM unique_identifier
     WHERE 1=1
       and equipment_id = v_nequipid
       and unique_identifier_type = 'SERIAL NUMBER';
    IF NOT FOUND
    THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END IF;

    v_errmsg:='Serial number for old equipment does not exist.';
    SELECT value INTO v_old_sn
    FROM unique_identifier
    WHERE 1=1
       and equipment_id = v_oequipid
       and unique_identifier_type = 'SERIAL NUMBER';
    IF NOT FOUND
    THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END IF;
    RAISE NOTICE 'rt_oss_rma:  Serial number found for original esn: % equip id: %', in_old_esn,v_oequipid;
--
    v_errmsg:='Carrier for new equipment does not exist.';
    SELECT carrier INTO v_carrier
    FROM equipment e
    JOIN equipment_model em ON (e.equipment_model_id = em.equipment_model_id)
    WHERE 1=1
      AND e.equipment_id = v_nequipid;
    IF NOT FOUND
    THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END IF;
--
    v_errmsg:='username for new equipment does not exist.';
    IF v_carrier != 'USCC' THEN
        select length(value) INTO v_username_lgth
          from unique_identifier ui 
         where ui.equipment_id = v_nequipid
           AND ui.unique_identifier_type = 'MDN';

        SELECT username INTO v_new_username
        FROM username u,
             unique_identifier ui
        WHERE 1=1
             AND substring(u.username FROM 1 FOR v_username_lgth) = ui.value
             AND ui.equipment_id=v_nequipid
             AND ui.unique_identifier_type = 'MDN'
--             AND u.end_date = to_date('2999-12-31','yyyy-mm-dd')
             ;
    ELSE
        select length(value) INTO v_username_lgth
          from unique_identifier ui 
         where ui.equipment_id = v_nequipid
           AND ui.unique_identifier_type = 'MIN';

        SELECT username INTO v_new_username
        FROM username u,
        unique_identifier ui
        WHERE 1=1
          AND substring(u.username FROM 1 FOR v_username_lgth) = ui.value
          AND ui.equipment_id=v_nequipid
          AND ui.unique_identifier_type = 'MIN'
--          AND u.end_date = to_date('2999-12-31','yyyy-mm-dd')
        ;
    END IF;
    IF NOT FOUND THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END IF;

    v_errmsg:='Obtain groupname for new equipment';
    SELECT groupname INTO v_new_groupname
    FROM groupname_default gd
    WHERE 1=1
      AND gd.carrier = v_carrier
      AND gd.billing_entity_id = v_beid;
--
    IF NOT FOUND THEN
       If v_carrier in ('SPRINT','USCC') THEN
           v_new_groupname:='SERVICE-private_atm';
           v_static_ip:=false;
       ELSE
           v_new_groupname:='SERVICE-vzwretail_cnione';
           v_static_ip:=true;
       END IF;
    ELSE
        v_static_ip:=true;
    END IF;

--
      RAISE NOTICE '----- Begin Function data ----------';
      RAISE NOTICE 'old ESN           : %',in_old_esn;
      RAISE NOTICE 'old ip            : %',v_old_ip;
      RAISE NOTICE 'old username      : %',v_old_username;
      RAISE NOTICE 'old groupname     : %',v_old_groupname;
      RAISE NOTICE 'old equipment id  : %',v_oequipid;
      RAISE NOTICE 'old model         : %',v_old_model;
      RAISE NOTICE 'new ESN           : %',in_new_esn;
      RAISE NOTICE 'new equipment id  : %',v_nequipid;
      RAISE NOTICE 'new model         : %',v_new_model;
      RAISE NOTICE 'carrier           : %',v_carrier;
      RAISE NOTICE 'billing entity    : %',v_beid;
      RAISE NOTICE 'billing entity nm : %',v_bename;
      RAISE NOTICE 'new username      : %',v_new_username;
      RAISE NOTICE 'new groupname     : %',v_new_groupname;
      RAISE NOTICE 'static ip?        : %',v_static_ip;
      RAISE NOTICE '----- End of Function data ----------';

      v_errmsg:='Update line equipment to set end date on Original equipment';
      RAISE NOTICE 'Update line_equipment for equipment_id: %',v_oequipid;
      UPDATE line_equipment set end_date = current_date
      where 1=1
        and equipment_id = v_oequipid
        and line_id = v_line_id
        and end_date is null;
      GET DIAGNOSTICS v_numrows = ROW_COUNT;
      IF v_numrows = 0 THEN
          RAISE NOTICE 'Update failed: %',v_errmsg;
          RAISE EXCEPTION '';
      END IF;
      RAISE NOTICE 'DIAG v_numrows: %',v_numrows;
--
      v_errmsg:='Unassign old static IP in static_ip_pool';
      IF v_old_ip IS NOT null
      THEN
          UPDATE static_ip_pool
             SET is_assigned = false,
             line_id = null
          WHERE 1=1
            AND static_ip = v_old_ip;
          GET DIAGNOSTICS v_numrows = ROW_COUNT;
          IF v_numrows = 0 THEN
              RAISE NOTICE 'Update failed: %',v_errmsg;
              RAISE EXCEPTION '';
          END IF;
     END IF;

     v_errmsg:='Delete rows from radreply for old username';
     DELETE FROM radreply
     WHERE  username = v_old_username;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     RAISE NOTICE 'Deleted % rows related to old username(%) rows from radreply % ',v_numrows,v_old_username;

     DELETE FROM radcheck WHERE  username = v_old_username;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     RAISE NOTICE 'Deleted % rows related to old username  from radcheck: % ',v_numrows;

--
     DELETE FROM radcheck WHERE  username = v_new_username;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     RAISE NOTICE 'Deleted % rows related to new username from radcheck: % ',v_numrows;

     v_rma_groupname:=
      ( CASE
           WHEN v_carrier = 'VZW'
            THEN 'SERVICE-rma_vzwretail_cnione'
           ELSE
              'SERVICE-rma_uscc_sprint'
         END
      );
      v_errmsg:='Obtaining priority for RMA groupname from groupname table';
      SELECT  priority FROM groupname INTO v_priority
      WHERE 1=1
        and groupname =v_rma_groupname ;
      IF NOT FOUND then
          RAISE NOTICE 'Select failed: %',v_errmsg;
          RAISE EXCEPTION  '';
      END IF;

--
      v_errmsg:='Update usergroup and priority for old username';
      v_sql:= 'UPDATE usergroup SET groupname ='||v_rma_groupname||' , priority='||v_priority ||' WHERE 1=1 AND username='||v_old_username;
      RAISE NOTICE 'this sql: %',v_sql;
      UPDATE usergroup SET groupname = v_rma_groupname , priority=v_priority
      WHERE 1=1
        AND username=v_old_username;
      GET DIAGNOSTICS v_numrows = ROW_COUNT;
      IF v_numrows <> 1 then
          RAISE NOTICE 'Update failed: %',v_errmsg;
          RAISE EXCEPTION  '';
      END IF;

--   get the priority for the new usergroup
      v_errmsg:='Obtaining priority for new groupname from groupname table';
      SELECT  priority FROM groupname INTO v_priority
      WHERE 1=1
        AND groupname = v_new_groupname ;

      GET DIAGNOSTICS v_numrows = ROW_COUNT;
      IF v_numrows <> 1 then
          RAISE NOTICE 'Select failed: %',v_errmsg;
          RAISE EXCEPTION  '';
      END IF;

--     Replace  new username data in usergroup table
--     First delete the old data  then insert the new data
      v_errmsg:='Replacing username data in usergroup table for new username';

      DELETE FROM usergroup
      where 1=1
        and username = v_new_username
/*
        and (
             groupname ='disconnected'
             or
             groupname like '%-inventory'
             or
             groupname like '%-private_atme
             or
             groupname like '%-private_atme
            )
*/
;
      RAISE NOTICE 'Deletion completed- now beginning insert of new usergroup data for username: %',v_new_username;

      INSERT into usergroup
            (username,groupname,priority)
      values
            (v_new_username,v_new_groupname,v_priority);
--

     v_errmsg:='Update line with new username and line_label';
     UPDATE line SET radius_username = v_new_username, line_label = in_new_esn
     WHERE line_id = v_line_id;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     IF v_numrows <> 1 THEN
          RAISE NOTICE 'UPDATE Failed: %',v_errmsg;
          RAISE EXCEPTION  '';
     END IF;

     SELECT end_date INTO v_tmp FROM line_equipment WHERE line_id = v_line_id AND equipment_id = v_oequipid;
     RAISE NOTICE '[rt_oss_rma] BEFORE INSERT into line_equipment: line_id=%, old_equipment_id=%, new_equipment_id=%, end_date=%', v_line_id, v_oequipid, v_nequipid, v_tmp;

--         INSERT into line_equipment
     v_errmsg:='INSERT FAILED for new row into line_equipment with new equipment id for line';
     INSERT INTO line_equipment
         ( SELECT v_line_id::integer,v_nequipid::integer,current_date,
                  null,billing_entity_address_id,ship_date,install_date,installed_by
           from line_equipment le
           where 1=1
             and le.line_id=v_line_id
             and le.equipment_id=v_oequipid
             and le.end_date =current_date);
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     IF v_numrows <> 1 then
          RAISE NOTICE 'INSERT Failed: %',v_errmsg;
          RAISE EXCEPTION  '';
     END IF;

    RAISE NOTICE '[rt_oss_rma] Inserted into line_equipment succeeded.';

    -- Insert csctoss.equipment_warranty record.

    RAISE NOTICE 'Processing equipment_warranty for new equipment id: %', v_nequipid;
    IF NOT EXISTS (SELECT * FROM equipment_warranty ew WHERE ew.equipment_id = v_nequipid)
    THEN
        RAISE NOTICE 'INSERT equipment_warranty: v_nequipid: %, start_date=%, model id=%'
                     , v_nequipid, v_lstrtdat, v_new_mod_ext_id;
        v_errmsg:='Insert/update failed for equipment_warranty, equipment_id';
        INSERT INTO equipment_warranty
        SELECT v_nequipid
              ,v_lstrtdat
              ,v_lstrtdat + (ewr.num_of_months::text || ' month')::interval
        FROM equipment_warranty_rule ewr
        WHERE ewr.equipment_model_id = v_new_mod_ext_id;
        GET DIAGNOSTICS v_numrows = ROW_COUNT;
        IF v_numrows <> 1 then
          RAISE NOTICE 'INSERT failed: %',v_errmsg;
          RAISE EXCEPTION  '';
        END IF;
    END IF;
--     assign a static ip if requested
    IF v_static_ip
    THEN
        RAISE NOTICE 'Calling function ops_api_static_ip(%,%,%,%,%)',v_carrier, v_new_groupname, v_new_username, v_line_id, v_beid;
        SELECT * into v_new_ip 
          from ops_api_static_ip_assign(v_carrier::text, 
                                        v_new_groupname::text, 
                                        v_new_username::text, 
                                        v_line_id::integer, 
                                        v_beid::integer);
        RAISE NOTICE 'ops_api_static_ip return: %', v_new_ip;
        IF substring(v_new_ip from 1 for 3) = 'ERR'
        THEN 
            v_errmsg := v_new_ip
            RAISE NOTICE '%', v_new_ip;
            RAISE EXCEPTION '';
        END IF;
    ELSE
       v_errmsg:='Insert into radreply with config variables';
       INSERT INTO radreply(username, attribute, op, value, priority) VALUES (v_new_username, 'Class', '=', v_line_id, 10);
       GET DIAGNOSTICS v_numrows = ROW_COUNT;
       IF v_numrows <> 1 then
          RAISE NOTICE 'INSERT failed: %',v_errmsg;
          RAISE EXCEPTION  '';
       END IF;

    END IF;

    IF v_carrier = 'SPRINT' THEN
        v_value:='';
        v_value2:='ClearText-Password';
    ELSIF
        v_carrier = 'USCC' THEN
        v_value:='CP@11U$ers';
        v_value2:='ClearText-Password';
    ELSIF
        v_carrier = 'VZW' THEN
        v_value:='Accept';
        v_value2:='Auth-Type';
    ELSIF
        v_carrier = 'VODAFONE' THEN
        v_value:='Accept';
        v_value2:='Auth-Type';
    ELSE
        v_errmsg:='Determine config for radcheck table';
        RAISE NOTICE 'Failed: %',v_errmsg;
        RAISE EXCEPTION  '';
    END IF;

    v_errmsg:='Insert radius config data into radcheck for new_username';
    INSERT into radcheck (username,attribute,op,value) VALUES (v_new_username,v_value2,':=',v_value);
    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    IF v_numrows <> 1 then
        RAISE NOTICE 'INSERT Failed: %',v_errmsg;
        RAISE EXCEPTION  '';
    END IF;

    v_errmsg:='Insert radius config data into radcheck for old_username';
    INSERT into radcheck (username,attribute,op,value) VALUES (v_old_username,v_value2,':=',v_value);
    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    IF v_numrows <> 1 then
        RAISE NOTICE 'INSERT Failed: %',v_errmsg;
        RAISE EXCEPTION  '';
    END IF;

    v_errmsg:='Set billing entity for old usename to 2';
    UPDATE username
        SET billing_entity_id = 2,
--            end_date=current_date ,
            enabled=false
    WHERE 1=1
     AND username = v_old_username;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     IF v_numrows <> 1
     then
        RAISE NOTICE 'UPDATE Failed: %',v_errmsg;
        RAISE EXCEPTION  '';
     END IF;
--
    v_errmsg:='Update username for new equipment';
    UPDATE username
           SET  billing_entity_id=v_beid,
                notes=v_notes,
                primary_service=false,
                enabled=true
    WHERE 1=1
      AND username = v_new_username;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     IF v_numrows = 0 THEN
        RAISE NOTICE 'UPDATE Failed: %',v_errmsg;
        RAISE EXCEPTION  '';
     END IF;
    RAISE NOTICE 'rt_oss_rma: Sucessfully updated new username  ';

    SELECT model_number1 into v_old_model
    FROM equipment e
    JOIN equipment_model em ON (e.equipment_model_id=em.equipment_model_id)
    WHERE 1=1
    AND e.equipment_id=v_oequipid;

     --
    IF (par_bypass_jbilling = FALSE) THEN
        RAISE NOTICE 'Calling Jbilling to get Product Name (internal number) from item table.';

        v_sql:= 'SELECT * from oss.rt_jbilling_rma('
                    || v_beid
                    ||' , '
                    || v_new_mod_ext_id
                    ||' , '
                    ||quote_literal(in_old_esn)
                    ||' , '
                    ||quote_literal(in_new_esn)
                    ||' , '
                    ||quote_literal(v_new_sn)
                    ||' , '
                    ||quote_literal(v_new_username)
                    ||','
                    ||v_line_id
                    ||','
                    ||quote_literal(in_tracking_number)
                    ||')'  ;

        RAISE NOTICE '-----------  calling jbilling_rma ------------------------------------- ';
        RAISE NOTICE ' the sql to call jbilling_rma: %', v_sql;
        v_errmsg:='Failure within or when calling the rt_jbilling_rma() function';
    --
        SELECT rec_type.so_number INTO v_rma_so_num
        FROM public.dblink(fetch_jbilling_conn(), v_sql) AS rec_type (so_number text);
--
        RAISE NOTICE 'rt_oss_rma: Returned from Jbilling: %', v_rma_so_num ;
    END IF;

    v_retval.old_model:=v_old_model;
    v_retval.old_sn:=v_old_sn;
    v_retval.new_sn:=v_new_sn;
    v_retval.billing_entity_id:=v_beid;
    v_retval.old_equip_id:=v_oequipid;
    v_retval.new_equip_id:=v_nequipid;
    v_retval.new_model:=v_new_model;
    v_retval.rma_so_num:=v_rma_so_num;
    v_retval.line_id:=v_line_id;
    v_retval.carrier:=v_carrier;
    v_retval.username:=v_new_username;
    v_retval.old_username:=v_old_username;
    v_retval.groupname:=v_new_groupname;
    v_retval.message:='Success';

----

    RETURN v_retval;
    RAISE NOTICE '-----------  exiting rt_oss_rma function now  ---------------------------';
EXCEPTION
        WHEN raise_exception THEN
           v_retval.message:=v_errmsg;
           RAISE NOTICE 'rt_oss_rma: when raise_exception:  % ',v_errmsg;
           RETURN v_retval;

        WHEN others THEN
           v_retval.message:=v_errmsg;
           RAISE NOTICE 'rt_oss_rma: when others:  ';
           RAISE NOTICE 'rt_oss_rma: % ',v_errmsg;
           RETURN v_retval;
END;
$_$;


ALTER FUNCTION csctoss.rt_oss_rma(text, text, text, boolean) OWNER TO csctoss_owner;

--
-- Name: rt_oss_rma_oss_only(text, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION rt_oss_rma_oss_only(text, text, text) RETURNS oss_rma_retval
    LANGUAGE plpgsql
    AS $_$
declare
--
in_old_esn              text   :=$1;
in_new_esn              text   :=$2;
in_tracking_number      text   :=$3;
v_static_ip             boolean;
c_staff_id              integer:=3;
v_result                integer;
v_return                text;
v_ip_return             text;
v_tab                   text;
v_in_count              integer;
v_esnhex                text;
v_old_username          text;
v_new_username          text;
v_new_groupname         text;
v_old_groupname         text;
v_rma_groupname         text;
v_old_mod_ext_id        integer;
v_new_mod_ext_id        integer;
v_beid                  integer;
v_bename                text;
v_line_id               text;
v_oequipid              text;
v_old_model             text;
v_new_model             text;
v_nequipid              text;
v_old_ip                text;
v_new_ip                text;
v_carrier               text;
v_priority              integer;
v_notes                 text;
v_lstrtdat              text;
v_lenddat               text;
v_lestrtdat             text;
v_leenddat              text;
v_return_text           text;
v_return_boolean        boolean;
v_old_sn                text;
v_new_sn                text;
v_numrows               integer;
v_count                 integer;
v_value                 text;
v_value2                text;
v_sql                  text;
v_retval                oss_rma_retval%ROWTYPE;
v_rma_so_num            text;
v_errmsg                text;

v_tmp                   text;

BEGIN

    SET client_min_messages to NOTICE;

    RAISE NOTICE '-----------  IN RT_OSS_RMA_OSS_ONLY FUNCTION NOW  ---------------------------';


    v_errmsg:='Unable to set change_log_staff_id';
    RAISE NOTICE 'rt_oss_rma: setting change_log_staff_id';

    SELECT * INTO v_result FROM public.set_change_log_staff_id(c_staff_id);
    IF
        v_result = -1  or v_result=c_staff_id
    THEN
        RAISE NOTICE 'rt_oss_rma:  change_log_staff_id has been set';
    ELSE
        RAISE exception '';
    END IF;
--
    RAISE NOTICE 'rt_oss_rma: looking for new ESN in UI table: %',in_new_esn;
    v_errmsg:='New ESN: '||in_new_esn||' not found in UI table';
    SELECT count(*)  into v_count
    from unique_identifier ui
    where 1=1
       and  ui.unique_identifier_type = 'ESN HEX'
       and ui.value = in_new_esn;
    IF v_count = 0
    THEN
        RAISE NOTICE '%',v_errmsg;
        RAISE EXCEPTION '';
    END IF;

--
    v_errmsg:='Replacement ESN cannot be currently active in line_equipment table';
    SELECT count(*) into v_count
        FROM unique_identifier ui
        JOIN line_equipment le ON (ui.equipment_id = le.equipment_id)
        where 1=1
           and  ui.unique_identifier_type = 'ESN HEX'
           and ui.value = in_new_esn
           AND le.end_date IS NULL
    ;
    IF v_count > 0 then
         RAISE NOTICE 'TEST FAILED: %',v_errmsg;
         RAISE EXCEPTION '';
    END IF;
--
    v_errmsg:='Original ESN must be present in line_equipment with a null end date';
    SELECT count(*) into v_count
    FROM unique_identifier ui
    JOIN line_equipment le ON (ui.equipment_id = le.equipment_id)
    where 1=1
      and  ui.unique_identifier_type = 'ESN HEX'
      and ui.value = in_old_esn
      AND le.end_date IS NULL ;
--
    IF v_count = 0 then
       RAISE NOTICE 'TEST FAILED: %',v_errmsg;
       RAISE EXCEPTION '';
    END IF;
--
    v_errmsg:='Original ESN must be associated with an active line in line_equipment table';
    SELECT
        ui.value ,
        l.radius_username ,
        be.billing_entity_id ,
        be.name ,
        l.line_id ,
        ui.equipment_id ,
        l.start_date ,
        l.end_date ,
        le.start_date ,
        le.end_date ,
        l.notes
    INTO
       v_esnhex,v_old_username,v_beid, v_bename,v_line_id,v_oequipid,v_lstrtdat,v_lenddat,v_lestrtdat,v_leenddat,v_notes
    FROM unique_identifier ui
       JOIN equipment eq ON (ui.equipment_id = eq.equipment_id)
       JOIN line_equipment le ON (ui.equipment_id = le.equipment_id)
       JOIN line l ON (le.line_id = l.line_id)
       JOIN billing_entity be ON (l.billing_entity_id = be.billing_entity_id)
       WHERE 1 = 1
       AND ui.unique_identifier_type = 'ESN HEX'
       AND ui.value = in_old_esn
       AND le.end_date IS NULL
       AND l.end_date IS NULL
       ;
     IF NOT FOUND THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
     END IF;
     RAISE NOTICE '-------------------------------------------------------------------------------------------------';
     RAISE NOTICE 'Billing Entity: %: %', v_beid,v_bename;
     RAISE NOTICE '-------------------------------------------------------------------------------------------------';
---

     v_errmsg:='A serial number for replacement equipment must be present in UI table';
     SELECT value INTO v_old_sn
     FROM unique_identifier
     WHERE 1=1
       AND equipment_id = v_oequipid
       AND unique_identifier_type = 'SERIAL NUMBER';

    IF NOT FOUND
    THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END IF;

    RAISE NOTICE 'rt_oss_rma: Verifying groupname present for old username';
    v_errmsg:='The groupname for the username of the original equipment must be present in usergroup table';
    SELECT groupname INTO v_old_groupname
    FROM usergroup
    WHERE username = v_old_username
    order by priority desc
    LIMIT 1;
    IF NOT FOUND THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END IF;

    SELECT value INTO v_old_ip
    FROM radreply
    WHERE username = v_old_username
      AND attribute = 'Framed-IP-Address';
    IF NOT FOUND THEN
          RAISE NOTICE 'Static ip address not present for old username: %',v_old_username;
    END IF;

--
    v_errmsg:='Replacement ESN must be present in unique identifier table - and the equipment_id must have a match in the equipment table';

    SELECT ui.equipment_id INTO v_nequipid
    FROM unique_identifier ui
    JOIN equipment eq ON (ui.equipment_id = eq.equipment_id)
    WHERE 1 = 1
    AND ui.unique_identifier_type = 'ESN HEX'
    AND ui.value = in_new_esn
    ;
    IF NOT FOUND THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END if;
--
    v_errmsg:='Obtain the model ID of the replacement equipment';
    SELECT model_number1,e.equipment_model_id into v_new_model,v_new_mod_ext_id
    FROM equipment e
    JOIN equipment_model em ON (e.equipment_model_id=em.equipment_model_id)
    WHERE 1=1
       AND e.equipment_id=v_nequipid;
    IF NOT FOUND
    THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END IF;

    v_errmsg:='Obtaining serial number for new ESN';
    SELECT value INTO v_new_sn
     FROM unique_identifier
     WHERE 1=1
       and equipment_id = v_nequipid
       and unique_identifier_type = 'SERIAL NUMBER';
    IF NOT FOUND
    THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END IF;

    SELECT value INTO v_old_sn
    FROM unique_identifier
    WHERE 1=1
       and equipment_id = v_oequipid
       and unique_identifier_type = 'SERIAL NUMBER';
    IF NOT FOUND
    THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END IF;
    RAISE NOTICE 'rt_oss_rma:  Serial number found for original esn: % equip id: %', in_old_esn,v_oequipid;
--
    v_errmsg:='Obtain carrier for new equipment';
    SELECT carrier INTO v_carrier
    FROM equipment e
    JOIN equipment_model em ON (e.equipment_model_id = em.equipment_model_id)
    WHERE 1=1
      AND e.equipment_id = v_nequipid;
    IF NOT FOUND
    THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END IF;
--
    v_errmsg:='Obtain username for new equipment';
    IF v_carrier != 'USCC' THEN
        SELECT username INTO v_new_username
        FROM username u,
             unique_identifier ui
        WHERE 1=1
             AND substring(u.username FROM 1 FOR 10) = ui.value
             AND ui.equipment_id=v_nequipid
             AND ui.unique_identifier_type = 'MDN'
--             AND u.end_date = to_date('2999-12-31','yyyy-mm-dd')
             ;
    ELSE
        SELECT username INTO v_new_username
        FROM username u,
        unique_identifier ui
        WHERE 1=1
          AND substring(u.username FROM 1 FOR 10) = ui.value
          AND ui.equipment_id=v_nequipid
          AND ui.unique_identifier_type = 'MIN'
--          AND u.end_date = to_date('2999-12-31','yyyy-mm-dd')
        ;
    END IF;
    IF NOT FOUND THEN
        RAISE NOTICE 'TEST FAILED: %',v_errmsg;
        RAISE EXCEPTION '';
    END IF;

    v_errmsg:='Obtain groupname for new equipment';
    SELECT groupname INTO v_new_groupname
    FROM groupname_default gd
    WHERE 1=1
      AND gd.carrier = v_carrier
      AND gd.billing_entity_id = v_beid;
--
    IF NOT FOUND THEN
       If v_carrier in ('SPRINT','USCC') THEN
           v_new_groupname:='SERVICE-private_atm';
           v_static_ip:=false;
       ELSE
           v_new_groupname:='SERVICE-vzwretail_cnione';
           v_static_ip:=true;
       END IF;
    ELSE
        v_static_ip:=true;
    END IF;

--
      RAISE NOTICE '----- Begin Function data ----------';
      RAISE NOTICE 'old ESN           : %',in_old_esn;
      RAISE NOTICE 'old ip            : %',v_old_ip;
      RAISE NOTICE 'old username      : %',v_old_username;
      RAISE NOTICE 'old groupname     : %',v_old_groupname;
      RAISE NOTICE 'old equipment id  : %',v_oequipid;
      RAISE NOTICE 'old model         : %',v_old_model;
      RAISE NOTICE 'new ESN           : %',in_new_esn;
      RAISE NOTICE 'new equipment id  : %',v_nequipid;
      RAISE NOTICE 'new model         : %',v_new_model;
      RAISE NOTICE 'carrier           : %',v_carrier;
      RAISE NOTICE 'billing entity    : %',v_beid;
      RAISE NOTICE 'billing entity nm : %',v_bename;
      RAISE NOTICE 'new username      : %',v_new_username;
      RAISE NOTICE 'new groupname     : %',v_new_groupname;
      RAISE NOTICE 'static ip?        : %',v_static_ip;
      RAISE NOTICE '----- End of Function data ----------';

      v_errmsg:='Update line equipment to set end date on Original equipment';
      UPDATE line_equipment set end_date = current_date
      where 1=1
        and equipment_id = v_oequipid
  and line_id = v_line_id
        and end_date is null;
      GET DIAGNOSTICS v_numrows = ROW_COUNT;
      IF v_numrows = 0 THEN
          RAISE NOTICE 'Update failed: %',v_errmsg;
          RAISE EXCEPTION '';
      END IF;
--
      v_errmsg:='Unassign old static IP in static_ip_pool';
      IF v_old_ip IS NOT null
      THEN
          UPDATE static_ip_pool
             SET is_assigned = false,
             line_id = null
          WHERE 1=1
            AND static_ip = v_old_ip;
          GET DIAGNOSTICS v_numrows = ROW_COUNT;
          IF v_numrows = 0 THEN
              RAISE NOTICE 'Update failed: %',v_errmsg;
              RAISE EXCEPTION '';
          END IF;
     END IF;

     v_errmsg:='Delete rows from radreply for old username';
     DELETE FROM radreply
     WHERE  username = v_old_username;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     RAISE NOTICE 'Deleted % rows related to old username(%) rows from radreply % ',v_numrows,v_old_username;

     DELETE FROM radcheck WHERE  username = v_old_username;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     RAISE NOTICE 'Deleted % rows related to old username  from radcheck: % ',v_numrows;

--
     DELETE FROM radcheck WHERE  username = v_new_username;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     RAISE NOTICE 'Deleted % rows related to new username from radcheck: % ',v_numrows;

     v_rma_groupname:=
      ( CASE
           WHEN v_carrier = 'VZW'
            THEN 'SERVICE-rma_vzwretail_cnione'
           ELSE
              'SERVICE-rma_uscc_sprint'
         END
      );
      v_errmsg:='Obtaining priority for RMA groupname from groupname table';
      SELECT  priority FROM groupname INTO v_priority
      WHERE 1=1
        and groupname =v_rma_groupname ;
      IF NOT FOUND then
          RAISE NOTICE 'Select failed: %',v_errmsg;
          RAISE EXCEPTION  '';
      END IF;

--
      v_errmsg:='Update usergroup and priority for old username';
      v_sql:= 'UPDATE usergroup SET groupname ='||v_rma_groupname||' , priority='||v_priority ||' WHERE 1=1 AND username='||v_old_username;
      RAISE NOTICE 'this sql: %',v_sql;
      UPDATE usergroup SET groupname = v_rma_groupname , priority=v_priority
      WHERE 1=1
        AND username=v_old_username;
      GET DIAGNOSTICS v_numrows = ROW_COUNT;
      IF v_numrows <> 1 then
          RAISE NOTICE 'Update failed: %',v_errmsg;
          RAISE EXCEPTION  '';
      END IF;

--   get the priority for the new usergroup
      v_errmsg:='Obtaining priority for new groupname from groupname table';
      SELECT  priority FROM groupname INTO v_priority
      WHERE 1=1
        AND groupname = v_new_groupname ;

      GET DIAGNOSTICS v_numrows = ROW_COUNT;
      IF v_numrows <> 1 then
          RAISE NOTICE 'Select failed: %',v_errmsg;
          RAISE EXCEPTION  '';
      END IF;

--     Replace  new username data in usergroup table
--     First delete the old data  then insert the new data
      v_errmsg:='Replacing username data in usergroup table for new username';

      DELETE FROM usergroup
      where 1=1
        and username = v_new_username
/*
        and (
             groupname ='disconnected'
             or
             groupname like '%-inventory'
             or
             groupname like '%-private_atme
             or
             groupname like '%-private_atme
            )
*/
;
       RAISE NOTICE 'Deletion completed- now beginning insert of new usergroup data for username: %',v_new_username;

      INSERT into usergroup
            (username,groupname,priority)
      values
            (v_new_username,v_new_groupname,v_priority);
--

     v_errmsg:='Update line with new username and line_label';
     UPDATE line SET radius_username = v_new_username, line_label = in_new_esn
     WHERE line_id = v_line_id;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     IF v_numrows <> 1 THEN
          RAISE NOTICE 'UPDATE Failed: %',v_errmsg;
          RAISE EXCEPTION  '';
     END IF;

     SELECT end_date INTO v_tmp FROM line_equipment WHERE line_id = v_line_id AND equipment_id = v_oequipid;
     RAISE NOTICE '[rt_oss_rma] BEFORE INSERT into line_equipment: line_id=%, old_equipment_id=%, new_equipment_id=%, end_date=%', v_line_id, v_oequipid, v_nequipid, v_tmp;

--         INSERT into line_equipment
     v_errmsg:='Insert new row into ine_equipment with new equipment id for line';
     INSERT INTO line_equipment
         ( SELECT v_line_id::integer,v_nequipid::integer,current_date,
                  null,billing_entity_address_id,ship_date,install_date,installed_by
           from line_equipment le
           where 1=1
             and le.line_id=v_line_id
             and le.equipment_id=v_oequipid
             and le.end_date =current_date);
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     IF v_numrows <> 1 then
          RAISE NOTICE 'INSERT Failed: %',v_errmsg;
          RAISE EXCEPTION  '';
     END IF;

     RAISE NOTICE '[rt_oss_rma] Inserted into line_equipment succeeded. Move on to static IP handling.';

--     assign a static ip if requested
    IF v_static_ip
    THEN
        v_errmsg:='Call static_ip_assign to assign new static IP for new equipment';
        SELECT * into v_new_ip from
        ops_api_static_ip_assign(v_carrier::text, v_new_groupname::text, v_new_username::text, v_line_id::integer, v_beid::integer);
        RAISE NOTICE 'ops_api_static_ip return: %', v_new_ip;
        IF v_new_ip is null
        then
           RAISE NOTICE 'Call to function failed: %',v_errmsg;
           RAISE EXCEPTION  '';
        END IF;
    ELSE
       v_errmsg:='Insert into radreply with config variables';
       INSERT INTO radreply(username, attribute, op, value, priority) VALUES (v_new_username, 'Class', '=', v_line_id, 10);
       GET DIAGNOSTICS v_numrows = ROW_COUNT;
       IF v_numrows <> 1 then
          RAISE NOTICE 'INSERT failed: %',v_errmsg;
          RAISE EXCEPTION  '';
       END IF;

    END IF;

    IF v_carrier = 'SPRINT' THEN
        v_value:='';
        v_value2:='ClearText-Password';
    ELSIF
        v_carrier = 'USCC' THEN
        v_value:='CP@11U$ers';
        v_value2:='ClearText-Password';
    ELSIF
        v_carrier = 'VZW' THEN
        v_value:='Accept';
        v_value2:='Auth-Type';
    ELSE
        v_errmsg:='Determine config for radcheck table';
        RAISE NOTICE 'Failed: %',v_errmsg;
        RAISE EXCEPTION  '';
    END IF;

    v_errmsg:='Insert radius config data into radcheck for new_username';
    INSERT into radcheck (username,attribute,op,value) VALUES (v_new_username,v_value2,':=',v_value);
    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    IF v_numrows <> 1 then
        RAISE NOTICE 'INSERT Failed: %',v_errmsg;
        RAISE EXCEPTION  '';
    END IF;

    v_errmsg:='Insert radius config data into radcheck for old_username';
    INSERT into radcheck (username,attribute,op,value) VALUES (v_old_username,v_value2,':=',v_value);
    GET DIAGNOSTICS v_numrows = ROW_COUNT;
    IF v_numrows <> 1 then
        RAISE NOTICE 'INSERT Failed: %',v_errmsg;
        RAISE EXCEPTION  '';
    END IF;

    v_errmsg:='Set billing entity for old usename to 2';
    UPDATE username
        SET billing_entity_id = 2,
--            end_date=current_date ,
            enabled=false
    WHERE 1=1
     AND username = v_old_username;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     IF v_numrows <> 1
     then
        RAISE NOTICE 'UPDATE Failed: %',v_errmsg;
        RAISE EXCEPTION  '';
     END IF;
--
    v_errmsg:='Update username for new equipment';
    UPDATE username
           SET  billing_entity_id=v_beid,
                notes=v_notes,
                primary_service=false,
                enabled=true
    WHERE 1=1
      AND username = v_new_username;
     GET DIAGNOSTICS v_numrows = ROW_COUNT;
     IF v_numrows = 0 THEN
        RAISE NOTICE 'UPDATE Failed: %',v_errmsg;
        RAISE EXCEPTION  '';
     END IF;
    RAISE NOTICE 'rt_oss_rma: Sucessfully updated new username  ';

    SELECT model_number1 into v_old_model
    FROM equipment e
    JOIN equipment_model em ON (e.equipment_model_id=em.equipment_model_id)
    WHERE 1=1
    AND e.equipment_id=v_oequipid;
     --

     v_sql:= 'SELECT * from oss.rt_jbilling_rma('
                || v_beid
                ||' , '
                || v_new_mod_ext_id
                ||' , '
                ||quote_literal(in_old_esn)
                ||' , '
                ||quote_literal(in_new_esn)
                ||' , '
                ||quote_literal(v_new_sn)
                ||' , '
                ||quote_literal(v_new_username)
                ||','
                ||v_line_id
                ||','
                ||quote_literal(in_tracking_number)
                ||')'  ;

    RAISE NOTICE '-----------  calling jbilling_rma ------------------------------------- ';
    RAISE NOTICE ' the sql to call jbilling_rma: %', v_sql;
/*
    v_errmsg:='Failure within or when calling the rt_jbilling_rma() function';
--
    SELECT rec_type.so_number INTO v_rma_so_num
    FROM public.dblink(fetch_jbilling_conn(), v_sql) AS rec_type (so_number text);
--
    RAISE NOTICE 'rt_oss_rma: Returned from Jbilling: %', v_rma_so_num ;
*/
        v_retval.old_model:=v_old_model;
        v_retval.old_sn:=v_old_sn;
        v_retval.new_sn:=v_new_sn;
        v_retval.billing_entity_id:=v_beid;
        v_retval.old_equip_id:=v_oequipid;
        v_retval.new_equip_id:=v_nequipid;
        v_retval.new_model:=v_new_model;
       -- v_retval.rma_so_num:=v_rma_so_num;
        v_retval.line_id:=v_line_id;
        v_retval.carrier:=v_carrier;
        v_retval.username:=v_new_username;
        v_retval.old_username:=v_old_username;
        v_retval.groupname:=v_new_groupname;
        v_retval.message:='Success';

----

    RETURN v_retval;
    RAISE NOTICE '-----------  exiting rt_oss_rma function now  ---------------------------';
EXCEPTION
        WHEN raise_exception THEN
           v_retval.message:=v_errmsg;
           RAISE NOTICE 'rt_oss_rma_oss_only: when raise_exception:%',v_errmsg;
           RETURN v_retval;

        WHEN others THEN
           v_retval.message:=v_errmsg;
           RAISE NOTICE 'rt_oss_rma_oss_only: when others: ';
           RAISE NOTICE 'rt_oss_rma_oss_only: %',v_errmsg;
           RETURN v_retval;
END;
$_$;


ALTER FUNCTION csctoss.rt_oss_rma_oss_only(text, text, text) OWNER TO csctoss_owner;

--
-- Name: rt_processing(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION rt_processing() RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE

v_sql                   text;
v_email_text            text;
v_email_subj            text;
--v_email_recip           text:='dba@cctus.com,support@contournetworks.com';
--v_email_recip           text:='dolson@cctus.com,tstovicek.com';
v_email_recip           text:='dba@cctus.com,support@contournetworks.com';
v_dba_recip             text:='yshibuya@j-com.co.jp';
v_rt_ticket_id          integer;
v_cursor                text;
v_old_sn                text:=null;
v_new_sn                text:=null;
v_old_username          text:=null;
v_company_name          text:=null;
v_model                 text:=null;
v_shipping_contact_name text:=null;
v_contact_city          text:=null;
v_shipping_address      text:=null;
v_shipping_address_2    text:=null;
v_shipping_zip          text:=null;
v_contact_state         text:=null;
v_contact_email         text:=null;
v_rma_status            text:=null;
v_original_esn          text:=null;
v_replacement_esn       text:=null;
v_tracking_num          text:=null;
v_return_tracking_num   text:='Testing testing';
v_return_boolean        boolean;
v_so_num                text:=null;
v_city                  text:=null;
v_state                 text:=null;
v_line_id               text:=null;
v_product_id            integer;
v_billing_entity_id     integer;
v_retval                oss_rma_retval%ROWTYPE;
v_return                oss_rma_retval%ROWTYPE;
v_return_text           text;
c2_rec                  record;
c1_rec                  record;
v_name                  text;
v_content               text;
v_field                 integer:=0;
v_numrows               integer:=0;
v_ticket_count          integer:=0;
v_rma_queue             numeric;
v_rt_status_customfield_id    numeric;
v_exception_msg         text;
v_errmsg                text;
v_status_updated        boolean:=false;
v_post_rma_completed    boolean:=false;
--
BEGIN
    SELECT q.id into v_rma_queue
    FROM rt3.queues q
    WHERE 1=1
      AND q.name ='RMA Customer' and q.disabled=0
    ;
    select cf.id into v_rt_status_customfield_id
    FROM rt3.customfields cf
    WHERE name like 'RMA Status%'
    ;
--    RAISE NOTICE 'rma queue : %  status cf: %', v_rma_queue,v_rt_status_customfield_id;

    FOR c1_rec IN
       SELECT t.id  as "t_id",
             cfv.customfield,
             cfv.content,
             cfv.id as "cfv_id",
             t.status,
             cfv.content as "RMA Status"
       FROM rt3.tickets t
       JOIN rt3.objectcustomfieldvalues cfv on (t.id = cfv.objectid
                                                AND cfv.customfield=v_rt_status_customfield_id
                                                AND cfv.content='Ready'
                                                AND cfv.disabled=0)
       WHERE 1=1
         AND t.disabled=0
--         AND t.status = 'new'
         AND t.status in ( 'new','open')
         AND  t.queue=17 
       ORDER by t_id
       LIMIT 1
    LOOP
       v_ticket_count:=1;
       RAISE NOTICE '--------------------------------------------------------------------';
       RAISE NOTICE 'PROCESSING RMA TICKET ID: %', c1_rec.t_id;
       RAISE NOTICE '--------------------------------------------------------------------';
       v_errmsg:=null;
           FOR c2_rec in
           SELECT
              cfv.customfield,
              cf.name,
              cfv.content,
              cfv.id
           FROM
               rt3.objectcustomfieldvalues cfv
           JOIN rt3.customfields cf on (cf.id = cfv.customfield )
           JOIN rt3.tickets t on (t.id = cfv.objectid)
           WHERE 1=1
             AND cfv.disabled=0
             AND c1_rec.t_id = t.id
             ORDER BY 1
           LOOP
              IF 1=1 THEN         -- c2_rec.customfield IN (4,5,10,11,12,20,36,38,64,65,66,70,99) THEN
                   v_content:=rpad(c2_rec.content||' : '||c2_rec.id,30);
                   v_name:=rpad(c2_rec.name,30);
                   v_field:=lpad(c2_rec.customfield::text,2);
                   IF    c2_rec.customfield =  4 THEN v_contact_city:=          c2_rec.content  ; --RAISE NOTICE 'D:01';
                   ELSIF c2_rec.customfield =  5 THEN v_contact_state:=         c2_rec.content  ;-- RAISE NOTICE 'D:02';
                   ELSIF c2_rec.customfield = 12 THEN v_shipping_address:=      c2_rec.content  ;--RAISE NOTICE 'D:05';
                   ELSIF c2_rec.customfield = 20 THEN v_rma_status:=            c2_rec.content  ;--RAISE NOTICE 'D:06';
                   ELSIF c2_rec.customfield = 36 THEN v_tracking_num:=          c2_rec.content  ;--RAISE NOTICE 'D:07';
                   ELSIF c2_rec.customfield = 38 THEN v_original_esn:=          c2_rec.content  ;--RAISE NOTICE 'D:08';
                   ELSIF c2_rec.customfield = 64 THEN v_shipping_contact_name:= c2_rec.content  ;--RAISE NOTICE 'D:09';
                   ELSIF c2_rec.customfield = 65 THEN v_replacement_esn:=       c2_rec.content  ;--RAISE NOTICE 'D:10';
                   ELSIF c2_rec.customfield = 66 THEN v_shipping_zip:=          c2_rec.content  ;--RAISE NOTICE 'D:11';
                   ELSIF c2_rec.customfield = 70 THEN v_shipping_address_2:=    c2_rec.content  ;--RAISE NOTICE 'D:12';
                   ELSIF c2_rec.customfield = 76 THEN v_return_tracking_num:=   c2_rec.content  ;--RAISE NOTICE 'D:07';
                   ELSIF c2_rec.customfield = 78 THEN v_contact_email:=         c2_rec.content  ;-- RAISE NOTICE 'D:04';
                   ELSE
                        NULL;
                   END IF;
                   RAISE NOTICE 'custom field Id: % % %',v_field, v_name,v_content;
              END IF;
           END LOOP;
--     debug stuff untill fields are addeed to rma ticket

--

           v_errmsg:='This RMA ticket is missing required information:';

           IF v_original_esn            is null THEN v_errmsg:=v_errmsg||' Original ESN';        RAISE EXCEPTION '';END IF;
           IF v_replacement_esn         is null THEN v_errmsg:=v_errmsg||' New ESN';             RAISE EXCEPTION '';END IF;
           IF v_tracking_num            is null THEN v_errmsg:=v_errmsg||' Tracking Number';     RAISE EXCEPTION '';END IF;
           IF v_return_tracking_num     is null THEN v_errmsg:=v_errmsg||' Return Tracking Number';  RAISE EXCEPTION '';END IF;
           IF v_shipping_contact_name   is null THEN v_errmsg:=v_errmsg||' Shipping Contact Nm'; RAISE EXCEPTION '';END IF;
           IF v_contact_city            is null THEN v_errmsg:=v_errmsg||' City';                RAISE EXCEPTION '';END IF;
           IF v_contact_state           is null THEN v_errmsg:=v_errmsg||' State';               RAISE EXCEPTION '';END IF;
           IF v_shipping_address        is null THEN v_errmsg:=v_errmsg||' Address 1';           RAISE EXCEPTION '';END IF;
           IF v_shipping_zip            is null THEN v_errmsg:=v_errmsg||' Zip Code';            RAISE EXCEPTION '';END IF;
           IF v_contact_email           is null THEN v_errmsg:=v_errmsg||' Email';               RAISE EXCEPTION '';END IF;
        IF 1=1 THEN
--       call the rt_oss_rma function

              RAISE NOTICE '-----------  Calling rt_oss_rma function now  ----------------------';
              RAISE NOTICE 'variables: %: %:%',v_original_esn,v_replacement_esn,v_tracking_num;

              v_errmsg:='Error occurred during processing of rt_oss_rma function ';
               RAISE NOTICE 'Calling: select * from csctoss.rt_oss_rma(''%'',''%'', ''%''); ', v_original_esn,v_replacement_esn,v_tracking_num;

              SELECT * into v_return
              FROM csctoss.rt_oss_rma(v_original_esn, v_replacement_esn, v_tracking_num);
              RAISE NOTICE '-----------  Returning  from rt_oss_rma function now  ----------------';
--
              v_errmsg:=v_return.message;
              IF v_errmsg <> 'Success' THEN
                   v_errmsg:=v_return.message;
                   RAISE EXCEPTION '';
              ELSE
                BEGIN
                   v_errmsg:='RMA processing Successful- Failure occurred while updating RT status: ';
                   select * into v_return_boolean from RT_field_updater( c1_rec.t_id, 20, 'Processed');
                   IF NOT v_return_boolean  THEN
                       RAISE EXCEPTION '';
                   END IF;
                   v_status_updated:=true;
--
                   v_errmsg:='RMA processing Successful- Failure occurred while updating RT: Unable to update RMA SO# in RMA ticket';
                   select * into v_return_boolean from RT_field_updater( c1_rec.t_id, 71, v_return.rma_so_num);
                   v_errmsg:='RMA processing Successful- Failure occurred while updating RT: Unable to update line_id in RMA ticket';
--
                   select * into v_return_boolean from RT_field_updater( c1_rec.t_id, 24, v_return.line_id);
                   IF NOT v_return_boolean  THEN RAISE EXCEPTION ''; END IF;
--
                   v_errmsg:='RMA processing Successful- Failure occurred while updating RT: Unable to update Old sn in RMA ticket';
                   select * into v_return_boolean from RT_field_updater( c1_rec.t_id, 75, v_return.old_sn);
                   IF NOT v_return_boolean  THEN RAISE EXCEPTION ''; END IF;
    --
                   v_errmsg:='RMA processing Successful- Failure occurred while updating RT:Unable to update New sn in RMA ticket';
                   select * into v_return_boolean from RT_field_updater( c1_rec.t_id, 74, v_return.new_sn);
                   IF NOT v_return_boolean  THEN RAISE EXCEPTION ''; END IF;
    --
                   v_errmsg:='RMA processing Successful- Failure occurred while updating RT: Unable to update Old Model in RMA ticket';
                   select * into v_return_boolean from RT_field_updater( c1_rec.t_id, 73, v_return.old_model);
                   IF NOT v_return_boolean  THEN RAISE EXCEPTION ''; END IF;
    --
                   v_errmsg:='RMA processing Successful- Failure occurred while updating RT: Unable to update New Model in RMA ticket';
                   select * into v_return_boolean from RT_field_updater( c1_rec.t_id, 72, v_return.new_model);
                   IF NOT v_return_boolean  THEN RAISE EXCEPTION ''; END IF;
    --
                   v_errmsg:='RMA processing Successful- Failure occurred while updating RT: Unable to update New Username in RMA ticket';
                   select * into v_return_boolean from RT_field_updater( c1_rec.t_id, 77, v_return.username);
                   IF NOT v_return_boolean  THEN RAISE EXCEPTION ''; END IF;
--
                   v_errmsg:='RMA processing Successful- Failure occurred while updating RT: Unable to update Old Username in RMA ticket';
                   select * into v_return_boolean from RT_field_updater( c1_rec.t_id, 68, v_return.old_username);
                   IF NOT v_return_boolean  THEN RAISE EXCEPTION ''; END IF;
    --
                   v_errmsg:='RMA processing Successful- Failure occurred while updating RT: Unable to update Groupname in RMA ticket';
                   select * into v_return_boolean from RT_field_updater( c1_rec.t_id, 69, v_return.groupname);
                   IF NOT v_return_boolean  THEN RAISE EXCEPTION ''; END IF;
 --
     --
                   RAISE NOTICE 'ORIGINAL ESN         :%'   ,v_original_esn;
                   RAISE NOTICE 'REPLACEMENT ESN      :%'   ,v_replacement_esn;
                   RAISE NOTICE 'OLD EQUIP ID         :%'   ,v_return.old_equip_id;
                   RAISE NOTICE 'OLD MODEL            :%'   ,v_return.old_model;
                   RAISE NOTICE 'OLD SN               :%'   ,v_return.old_sn;
                   RAISE NOTICE 'OLD USERNAME         :%'   ,v_return.old_username;
                   RAISE NOTICE 'NEW EQUIP ID         :%'   ,v_return.new_equip_id;
                   RAISE NOTICE 'NEW MODEL            :%'   ,v_return.new_model;
                   RAISE NOTICE 'NEW SN               :%'   ,v_return.new_sn;
                   RAISE NOTICE 'CARRIER              :%'   ,v_return.carrier;
                   RAISE NOTICE 'LINE                 :%'   ,v_return.line_id;
                   RAISE NOTICE 'NEW USERNAME         :%'   ,v_return.username;
                   RAISE NOTICE 'NEW GROUPNAME        :%'   ,v_return.groupname;
                   RAISE NOTICE 'BILLING ENTITY ID    :%'   ,v_return.billing_entity_id;
                   RAISE NOTICE 'RMA ORDER #          :%'   ,v_return.rma_so_num;
--   send email to dba team
                   v_email_subj:='[DBA NOTICE ] RMA Ticket# RT-'||c1_rec.t_id;
                   v_email_text:=chr(10);
                   v_email_text:=v_email_text||rpad('ORIGINAL ESN:',30)||v_original_esn;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||rpad('REPLACEMENT ESN:',30)||v_replacement_esn;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||rpad('OLD EQUIP ID:',30)||v_return.old_equip_id;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||rpad('OLD MODEL:',30)||v_return.old_model;

                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||rpad('OLD SN:',30)||v_return.old_sn;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||rpad('NEW EQUIP ID:',30)||v_return.new_equip_id;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||rpad('NEW MODEL:',30)||v_return.new_model;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||rpad('NEW SN:',30)||v_return.new_sn;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||rpad('CARRIER: ',30)||v_return.carrier;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||rpad('LINE:',30)||v_return.line_id;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||rpad('NEW USERNAME:',30)||v_return.username;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||rpad('NEW GROUPNAME:',30)||v_return.groupname;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||rpad('BILLING ENTITY ID:',30)||v_return.billing_entity_id;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'RMA ORDER #          : '||v_return.rma_so_num;
                   RAISE NOTICE 'dba email text: %',v_email_text;

                   PERFORM public.plsh_send_email(v_dba_recip,v_email_subj,v_email_text);


                   v_email_subj:='[CCE TEAM NOTICE] RMA Ticket# RT-'||c1_rec.t_id;

                   v_email_text:='---------------------------------   CCE TEAM   ------------------------------------';
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'Please verify that the RMA processed correctly. If sucessful, please cut and paste ';
                   v_email_text:=v_email_text||'the text below into a new email. Send the email to the address contained in ';
                   v_email_text:=v_email_text||'the text.';
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'I recommend that you use a font such as Courier New to make column alignment more readable';
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'--------------------------------------------------------------------------------------';
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'Dear '||v_shipping_contact_name||',';
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'A replacement unit is being sent via FedEx 2nd Day Air for RMA# ';
                   v_email_text:=v_email_text||c1_rec.t_id||' to the following address:';
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||lpad(rpad(v_shipping_contact_name,30),32);
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||lpad(rpad(v_shipping_address,30),32);
                   v_email_text:=v_email_text||chr(10);
                   IF v_shipping_address_2 IS NOT NULL THEN
                       v_email_text:=v_email_text||lpad(rpad(v_shipping_address_2,30),32);
                       v_email_text:=v_email_text||chr(10);
                   END IF;
                   v_email_text:=v_email_text||lpad(rpad(trim(trailing from v_contact_city)||', '
                                   ||v_contact_state||' '||v_shipping_zip,40),42);
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||lpad(rpad(v_contact_email,30),32);
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'Original Equipment:';
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'   Model      : '||  v_return.old_model;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'   S/N        : '|| v_return.old_sn;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'   ESN        : '|| v_original_esn;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'   Return Tracking # : '|| v_return_tracking_num;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'New Equipment:';
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'   Model      : '|| v_return.new_model;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'   S/N        : '|| v_return.new_sn;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'   ESN        : '|| v_replacement_esn;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'   Tracking # : '||v_tracking_num;
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'Per Contour RMA Policy:';
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'In order to waive the charge for the replacement unit, we must receive the ';
                   v_email_text:=v_email_text||'defective unit within 30 days of initial shipment of the replacement unit.  ';
                   v_email_text:=v_email_text||'Please note that we have provided a return shipping label for the defective unit.';
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'Thank you for your business.';
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'Contour Networks';
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'Customer Support: (866) 576-9933';
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'shipping@contournetworks.com';
                   v_email_text:=v_email_text||chr(10);
                   v_email_text:=v_email_text||'support@contournetworks.com';
                   v_email_text:=v_email_text||chr(10);
/*
*/
                   RAISE NOTICE '---------  RMA EMAIL TEXT -----------------------------------------';
                   RAISE NOTICE '%',v_email_text;
                   RAISE NOTICE '-----------END OF RMA EMAIL TEXT -----------------------------------';
                   v_post_rma_completed:=true;

                   PERFORM public.plsh_send_email(v_email_recip,v_email_subj,v_email_text);
                   RAISE NOTICE '      The RMA email was sent sucessfully ';
                   RAISE NOTICE '--------------------------------------------------------------------';
                   RAISE NOTICE '    COMPLETED PROCESSING RMA TICKET ID: %', c1_rec.t_id;
                   RAISE NOTICE '--------------------------------------------------------------------';
                EXCEPTION
                 WHEN OTHERS THEN
                     IF v_status_updated THEN
                          RAISE NOTICE 'RMA processing completed sucessfully but email processing failed';
                      ELSE
                          v_email_subj:='RMA Ticket# RT-'||c1_rec.t_id;
                          v_email_text:='RMA processing was sucessful but for some reason the app was unable to update RMA status';
                          v_email_text:=v_email_text||char(10);
                          v_email_text:=v_email_text||v_errmsg;
                          v_email_text:=v_email_text||char(10);
                          v_email_text:=v_email_text||'NOTIFY DBA TEAM TO INVESTIGATE THIS ERROR';
                          PERFORM public.plsh_send_email(v_email_recip,v_email_subj,v_email_text);
                      END IF;
                      RETURN 'Success';
                 END;
              END IF;
        END IF;
     END LOOP;
IF v_ticket_count = 1 THEN
    RETURN 'Success';
ELSE
    RETURN 'ZERO TICKETS TO PROCESS';
END IF;
EXCEPTION
   WHEN OTHERS THEN
       RAISE NOTICE '--------------------------------------------------------------------';
       RAISE NOTICE 'RMA PROCESSING FAILED FOR TICKET: %', c1_rec.t_id;
       RAISE NOTICE 'In rt_processing function  exception block:';
       RAISE NOTICE '   : %',v_errmsg;
       RAISE NOTICE 'Setting RT ticket RMA status to ''Failure'' ';
       v_email_subj:='[CCE TEAM NOTICE] RMA Ticket# RT-'||c1_rec.t_id ||'- FAILURE';
       v_email_text:='--------------   RT RMA Processing Failure ---------------';
       v_email_text:=v_email_text||chr(10);
       v_email_text:=v_email_text||chr(10);
       v_email_text:=v_email_text||v_errmsg;
       v_sql:='select * from RT_field_updater('||c1_rec.t_id||', 20,'||quote_literal('Failure')||')';
--       RAISE NOTICE 'Updater sql: %',v_sql;
       SELECT thisboolean INTO v_return_boolean
       FROM public.dblink('hostaddr=127.0.0.1  dbname=csctoss port=5450 user=postgres',v_sql)
--       FROM public.dblink(v_sql)
             AS rec_type (thisboolean boolean);
       IF  NOT v_return_boolean  THEN
           RAISE NOTICE 'Unable to update RT ticket status- Contact DBA team ';
           v_email_text:=v_email_text||chr(10);
           v_email_text:=v_email_text||chr(10);
           v_email_text:=v_email_text||'Unable to update RT ticket status- Contact DBA team ';
           v_email_text:=v_email_text||chr(10);
           v_email_text:=v_email_text||chr(10);
       ELSE
           RAISE NOTICE 'Sucessful update of RT ticket RMA status';
       END IF;
       v_email_text:=v_email_text||chr(10);
       v_email_text:=v_email_text||chr(10);
       v_email_text:=v_email_text||'Sent from RMA processing function on csctoss: rt_processing()';

       PERFORM public.plsh_send_email(v_email_recip,v_email_subj,v_email_text);
       RAISE NOTICE '--------------------------------------------------------------------';

       RAISE EXCEPTION 'FAILURE TO PROCESS RT# : %', c1_rec.t_id;
END;
 $$;


ALTER FUNCTION csctoss.rt_processing() OWNER TO csctoss_owner;

--
-- Name: set_encrypt_key(integer, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION set_encrypt_key(integer, text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
	par_contract_id		ALIAS FOR $1 ;
	par_encrypt_key		ALIAS FOR $2 ;
	par_pin_code		ALIAS FOR $3 ;
	v_result			boolean DEFAULT FALSE ;
	v_counter			int ;
BEGIN
	IF par_contract_id IS NULL
	OR par_encrypt_key IS NULL
	OR par_pin_code IS NULL THEN
		v_result := FALSE ;
	ELSE
		SELECT COUNT(*)
		INTO   v_counter
		FROM   csctoss.cc_encrypt_key
		WHERE  contract_id = par_contract_id ;

		IF v_counter = 0 THEN
			INSERT INTO cc_encrypt_key (contract_id, phone_number, encryption_key, pin_code)
			VALUES (par_contract_id, NULL, par_encrypt_key, par_pin_code) ;

			v_result := TRUE ;
		ELSIF v_counter = 1 THEN
			UPDATE csctoss.cc_encrypt_key
			SET    encryption_key = par_encrypt_key
				, pin_code     = par_pin_code
			WHERE  contract_id = par_contract_id ;

			v_result := TRUE ;
		ELSE
			v_result := FALSE ;
		END IF ;
	END IF ;

	RETURN v_result ;

EXCEPTION WHEN OTHERS THEN
	RETURN v_result ;
END ;
$_$;


ALTER FUNCTION csctoss.set_encrypt_key(integer, text, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION set_encrypt_key(integer, text, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION set_encrypt_key(integer, text, text) IS 'Store encryption key PIN code for b-Market using the contract ID.';


--
-- Name: set_encrypt_key(text, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION set_encrypt_key(text, text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
	par_phone_number	ALIAS FOR $1 ;
	par_encrypt_key		ALIAS FOR $2 ;
	par_pin_code		ALIAS FOR $3 ;
	v_result			boolean DEFAULT FALSE ;
	v_counter			int ;
BEGIN
	IF par_phone_number IS NULL
	OR par_encrypt_key IS NULL
	OR par_pin_code IS NULL THEN
		v_result := FALSE ;
	ELSE
		SELECT COUNT(*)
		INTO   v_counter
		FROM   cc_encrypt_key
		WHERE  phone_number = par_phone_number ;

		IF v_counter = 0 THEN
			INSERT INTO cc_encrypt_key (contract_id, phone_number, encryption_key, pin_code)
			VALUES (NULL, par_phone_number, par_encrypt_key, par_pin_code) ;

			v_result := TRUE ;
		ELSIF v_counter = 1 THEN
			UPDATE csctoss.cc_encrypt_key
			SET    encryption_key = par_encrypt_key
				, pin_code     = par_pin_code
			WHERE  phone_number = par_phone_number ;

			v_result := TRUE ;
		ELSE
			v_result := FALSE ;
		END IF ;
	END IF ;

	RETURN v_result ;

EXCEPTION WHEN OTHERS THEN
	RETURN v_result ;
return ;
END ;
$_$;


ALTER FUNCTION csctoss.set_encrypt_key(text, text, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION set_encrypt_key(text, text, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION set_encrypt_key(text, text, text) IS 'Store encryption key and PIN code for b-Market using the phone number.';


--
-- Name: set_plan_acct_start_date(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION set_plan_acct_start_date() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE

  var_kounter			integer ;
  var_accounting_start_date	date ;

  rec_plan			record ;

BEGIN

  PERFORM public.set_change_log_staff_id(3) ;

  -- just do a mass update for non TB plans with null accounting_start_date
  UPDATE csctoss.plan
     SET accounting_start_date = start_date
   WHERE plan_type_id <> 2
     AND line_id IS NOT NULL
     AND accounting_start_date IS NULL ;

  GET DIAGNOSTICS var_kounter := ROW_COUNT ;
  RETURN NEXT var_kounter::text || ' Non-TB plans mass updated on ' || current_date::text ;
  
  -- cursor processing for TB plans with null accounting_start_date
  FOR rec_plan IN SELECT plan_id
                        ,plan_type_id
                        ,product_id
                        ,line_id
                        ,start_date
                        ,accounting_start_date
                    FROM csctoss.plan
                   WHERE plan_type_id = 2 		-- Telecom Battery
                     AND accounting_start_date IS NULL
                ORDER BY line_id
                        ,plan_id
  LOOP

    var_accounting_start_date := NULL ;

    -- if previous plan exists for this line, this is extension, set accounting_start_date to plan start_date
    IF (SELECT COUNT(*)
          FROM csctoss.plan
         WHERE line_id = rec_plan.line_id
           AND plan_type_id = 2				-- Telecom Battery
           AND plan_id < rec_plan.plan_id) > 0 THEN

      var_accounting_start_date := rec_plan.start_date ;

      RETURN NEXT 'Plan ID '|| rec_plan.plan_id::text || ' is an extension. Accounting start date set to plan start date.' ;

    ELSE
               
      -- query master_radacct for the fourth successful login
      SELECT *
        INTO var_accounting_start_date
        FROM public.dblink((select * from csctoss.fetch_csctlog_conn())
                          ,'SELECT acctstarttime::date
                              FROM csctlog.master_radacct
                             WHERE class = '||quote_literal(rec_plan.line_id::text)||'
                               AND acctstarttime >= '||quote_literal(rec_plan.start_date)||'
                          ORDER BY master_radacctid
                             LIMIT 1
                            OFFSET 3')
          AS rec_type(accounting_start_date date) ;

      -- if fourth accounting record found, set accounting_start_date equal to acctstarttime date
      IF FOUND THEN

        -- if the fourth accounting record greater than plan start_date + 30 days, reset it
        IF var_accounting_start_date > rec_plan.start_date + INTERVAL '30 days' THEN
          var_accounting_start_date := rec_plan.start_date + INTERVAL '30 days' ;
          RETURN NEXT 'Plan ID ' || rec_plan.plan_id::text || ' 4th accounting record exceeds interval. Accounting start date set to plan start_date + 30' ;
        ELSE
          RETURN NEXT 'Plan ID ' || rec_plan.plan_id::text || ' accounting start date set to 4th accounting record date.' ;
        END IF ;

      ELSIF rec_plan.start_date + INTERVAL '30 days' >= current_date THEN

        -- update accounting_start_date to plan start_date + 30 if 30 days since plan.start_date
        var_accounting_start_date := rec_plan.start_date + INTERVAL '30 days' ;

        RETURN NEXT 'Plan ID ' || rec_plan.plan_id::text || ' accounting start date set to 30 days after plan start date.' ;

      END IF ;

    END IF ;

    -- perform the conditional update
    IF var_accounting_start_date IS NOT NULL THEN
      UPDATE csctoss.plan
         SET accounting_start_date = var_accounting_start_date
       WHERE plan_id = rec_plan.plan_id ;
    ELSE
      RETURN NEXT 'Plan ID ' || rec_plan.plan_id::text || ' did not qualify for any conditions. Accounting start date is NULL.' ;
    END IF ;

  END LOOP ;

  RETURN NEXT 'SUCCESS' ;
  RETURN ;

END ;
$$;


ALTER FUNCTION csctoss.set_plan_acct_start_date() OWNER TO csctoss_owner;

--
-- Name: FUNCTION set_plan_acct_start_date(); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION set_plan_acct_start_date() IS 'Function to identify null plan.accounting_start_date and set accordingly based on product and business rules.';


--
-- Name: shipment_check_dates(date, date, date); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION shipment_check_dates(date, date, date) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
BEGIN

  -- 1=date_sent, 2=expected_delivery_date, 3=actual_received_date
  IF $2 IS NOT NULL AND $2 < $1 THEN
    RAISE EXCEPTION 'Expected Delivery Date (%) cannot be before Date Sent (%).', $2, $1 ;
  END IF ;

  IF $3 IS NOT NULL AND $3 < $1 THEN
    RAISE EXCEPTION 'Actual Received Date (%) cannot be before Date Sent (%).', $3, $1 ;
  END IF ;

  RETURN TRUE ;
END ;

$_$;


ALTER FUNCTION csctoss.shipment_check_dates(date, date, date) OWNER TO csctoss_owner;

--
-- Name: FUNCTION shipment_check_dates(date, date, date); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION shipment_check_dates(date, date, date) IS 'Check constraint function shipment table to verify valid dates.';


--
-- Name: shipment_equipment_end_date(integer, integer, date); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION shipment_equipment_end_date(integer, integer, date) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
BEGIN
  IF $3 IS NULL THEN
    PERFORM * FROM csctoss.shipment_equipment
             WHERE shipment_id <> $1
               AND equipment_id = $2
               AND end_date IS NULL ;
    IF FOUND THEN
      RETURN FALSE ;
    END IF ;
  END IF ;
  RETURN TRUE ;
END ;
$_$;


ALTER FUNCTION csctoss.shipment_equipment_end_date(integer, integer, date) OWNER TO csctoss_owner;

--
-- Name: smrac_loader(); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION smrac_loader() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE

  var_conn_string               text ;
  var_last_start_radacctid      bigint ;
  var_max_start_radacctid       bigint ;
  var_last_stop_radacctid       bigint ;
  var_max_stop_radacctid        bigint ;
  var_sql                       text ;
  var_kount                     integer ;

  rec_sysparm                   record ;

BEGIN

  -- get connection info for radius hosts which should replicate radacct data
  FOR rec_sysparm IN SELECT *
                       FROM csctoss.system_parameter
                      WHERE sprint_flag
                   ORDER BY hostname
  LOOP

    var_conn_string := 'hostaddr='||rec_sysparm.ip_address||
                          ' port='||rec_sysparm.repl_port|| 
                        ' dbname='||rec_sysparm.repl_target_db||
                          ' user='||rec_sysparm.repl_target_username||
                      ' password='||rec_sysparm.repl_target_password ;

    -- get last start and stop radacctid
    SELECT * --start_radacctid, stop_radacctid
      INTO var_last_start_radacctid, var_last_stop_radacctid
      FROM public.dblink(var_conn_string
                        ,'select start_radacctid, stop_radacctid from radiusdb.radacct_tracker')
        AS rec_type(last_start_radacctid bigint
                   ,last_stop_radacctid  bigint) ;

    IF var_last_start_radacctid IS NULL OR var_last_stop_radacctid IS NULL THEN
      RETURN NEXT 'ERROR: '||rec_sysparm.hostname||' Last Start or Stop Radacctid is NULL.' ;
      RETURN ;
    END IF ;

  -- get the max start and stop radacctid
  SELECT *
    INTO var_max_start_radacctid
    FROM public.dblink(var_conn_string
                      ,'select MAX(radacctid) FROM radiusdb.radacct_start')
      AS rec_type(max_start_radacctid bigint) ;

  SELECT *
    INTO var_max_stop_radacctid
    FROM public.dblink(var_conn_string
                      ,'select MAX(radacctid) FROM radiusdb.radacct_stop')
      AS rec_type(max_stop_radacctid bigint) ;

  --var_max_start_radacctid := var_last_start_radacctid + 1000 ;
  --var_max_stop_radacctid  := var_last_stop_radacctid  + 1000 ;

  IF var_max_start_radacctid IS NULL OR var_max_stop_radacctid IS NULL THEN
    RETURN NEXT 'ERROR: '||rec_sysparm.hostname||' Max Start or Stop Radacctid is NULL.' ;
    RETURN ;
  END IF ;

  -- mass insert the starts
  BEGIN
    INSERT INTO csctoss.sprint_master_radacct
               (radacctid
               ,source_hostname
               ,acctstatustype
               ,acctsessionid
               ,acctuniqueid
               ,username
               ,realm
               ,nasipaddress
               ,nasportid
               ,nasporttype
               ,acctstarttime
               ,acctstoptime
               ,acctsessiontime
               ,acctauthentic
               ,connectinfo_start
               ,connectinfo_stop
               ,acctinputoctets
               ,acctoutputoctets
               ,calledstationid
               ,callingstationid
               ,acctterminatecause
               ,servicetype
               ,framedprotocol
               ,framedipaddress
               ,acctstartdelay
               ,acctstopdelay
               ,xascendsessionsvrkey
               ,tunnelclientendpoint
               ,nasidentifier
               ,class
               ,_3gpp2homeagentipaddress
               ,_3gpp2pcfipaddress
               ,_3gpp2bsid
               ,_3gpp2userid
               ,_3gpp2serviceoption
               ,_3gpp2iptechnology
               ,_3gpp2airlinkrecordtype
               ,_3gpp2attr41
               ,_3gpp2airlinksequencenumber
               ,_3gpp2numberactivetransitions
               ,_3gpp2receivedhdlcoctets
               ,_3gpp2correlationid
               ,_3gpp2esn
               ,_3gpp2foreignagentaddress
               ,_3gpp2forwardfchmuxoption
               ,_3gpp2reversefchmuxoption
               ,_3gpp2forwardtraffictype
               ,_3gpp2reversetraffictype
               ,_3gpp2forwardfchrc
               ,_3gpp2reversefchrc
               ,_3gpp2lastuseractivitytime)
    SELECT * 
      FROM public.dblink(var_conn_string
         ,'SELECT radacctid
                 ,'||quote_literal(rec_sysparm.hostname)||'
                 ,'||quote_literal('START')||'
                 ,acctsessionid
                 ,acctuniqueid
                 ,username
                 ,realm
                 ,nasipaddress
                 ,nasportid
                 ,nasporttype
                 ,acctstarttime
                 ,acctstoptime
                 ,acctsessiontime
                 ,acctauthentic
                 ,connectinfo_start
                 ,connectinfo_stop
                 ,acctinputoctets
                 ,acctoutputoctets
                 ,calledstationid
                 ,callingstationid
                 ,acctterminatecause
                 ,servicetype
                 ,framedprotocol
                 ,framedipaddress
                 ,acctstartdelay
                 ,acctstopdelay
                 ,xascendsessionsvrkey
                 ,tunnelclientendpoint
                 ,nasidentifier
                 ,class
                 ,_3gpp2homeagentipaddress
                 ,_3gpp2pcfipaddress
                 ,_3gpp2bsid
                 ,_3gpp2userid
                 ,_3gpp2serviceoption
                 ,_3gpp2iptechnology
                 ,_3gpp2airlinkrecordtype
                 ,_3gpp2attr41
                 ,_3gpp2airlinksequencenumber
                 ,_3gpp2numberactivetransitions
                 ,_3gpp2receivedhdlcoctets
                 ,_3gpp2correlationid
                 ,_3gpp2esn
                 ,_3gpp2foreignagentaddress
                 ,_3gpp2forwardfchmuxoption
                 ,_3gpp2reversefchmuxoption
                 ,_3gpp2forwardtraffictype
                 ,_3gpp2reversetraffictype
                 ,_3gpp2forwardfchrc
                 ,_3gpp2reversefchrc
                 ,_3gpp2lastuseractivitytime
             FROM radiusdb.radacct_start
            WHERE radacctid >  '||var_last_start_radacctid||'
              AND radacctid <= '||var_max_start_radacctid||'
         ORDER BY radacctid')
               AS rec_type(radacctid                      bigint
                          ,source_hostname                text
                          ,acctstatustype                 varchar(20)
                          ,acctsessionid                  varchar(32)
                          ,acctuniqueid                   varchar(32)
                          ,username                       varchar(64)
                          ,realm                          varchar(64)
                          ,nasipaddress                   inet
                          ,nasportid                      varchar(15)
                          ,nasporttype                    varchar(32)
                          ,acctstarttime                  timestamp with time zone
                          ,acctstoptime                   timestamp with time zone
                          ,acctsessiontime                bigint
                          ,acctauthentic                  varchar(32)
                          ,connectinfo_start              varchar(50)
                          ,connectinfo_stop               varchar(50)
                          ,acctinputoctets                bigint
                          ,acctoutputoctets               bigint
                          ,calledstationid                varchar(50)
                          ,callingstationid               varchar(50)
                          ,acctterminatecause             varchar(32)
                          ,servicetype                    varchar(32)
                          ,framedprotocol                 varchar(32)
                          ,framedipaddress                inet
                          ,acctstartdelay                 bigint
                          ,acctstopdelay                  bigint
                          ,xascendsessionsvrkey           varchar(10)
                          ,tunnelclientendpoint           inet
                          ,nasidentifier                  varchar(32)
                          ,class                          varchar(128)
                          ,_3gpp2homeagentipaddress       inet
                          ,_3gpp2pcfipaddress             inet
                          ,_3gpp2bsid                     varchar(50)
                          ,_3gpp2userid                   varchar(15)
                          ,_3gpp2serviceoption            varchar(15)
                          ,_3gpp2iptechnology             varchar(15)
                          ,_3gpp2airlinkrecordtype        varchar(15)
                          ,_3gpp2attr41                   varchar(128)
                          ,_3gpp2airlinksequencenumber    varchar(15)
                          ,_3gpp2numberactivetransitions  varchar(15)
                          ,_3gpp2receivedhdlcoctets       varchar(15)
                          ,_3gpp2correlationid            varchar(32)
                          ,_3gpp2esn                      varchar(32)
                          ,_3gpp2foreignagentaddress      inet
                          ,_3gpp2forwardfchmuxoption      varchar(15)
                          ,_3gpp2reversefchmuxoption      varchar(15)
                          ,_3gpp2forwardtraffictype       varchar(15)
                          ,_3gpp2reversetraffictype       varchar(15)
                          ,_3gpp2forwardfchrc             varchar(15)
                          ,_3gpp2reversefchrc             varchar(15)
                          ,_3gpp2lastuseractivitytime     varchar(128)) ;
    EXCEPTION
      WHEN OTHERS THEN RETURN NEXT 'ERROR: OTHERS exception (START) from '||rec_sysparm.hostname ;
    END ;

  -- mass insert the stops
  BEGIN
    INSERT INTO csctoss.sprint_master_radacct
               (radacctid
               ,source_hostname
               ,acctstatustype
               ,acctsessionid
               ,acctuniqueid
               ,username
               ,realm
               ,nasipaddress
               ,nasportid
               ,nasporttype
               ,acctstarttime
               ,acctstoptime
               ,acctsessiontime
               ,acctauthentic
               ,connectinfo_start
               ,connectinfo_stop
               ,acctinputoctets
               ,acctoutputoctets
               ,calledstationid
               ,callingstationid
               ,acctterminatecause
               ,servicetype
               ,framedprotocol
               ,framedipaddress
               ,acctstartdelay
               ,acctstopdelay
               ,xascendsessionsvrkey
               ,tunnelclientendpoint
               ,nasidentifier
               ,class
               ,_3gpp2homeagentipaddress
               ,_3gpp2pcfipaddress
               ,_3gpp2bsid
               ,_3gpp2userid
               ,_3gpp2serviceoption
               ,_3gpp2iptechnology
               ,_3gpp2airlinkrecordtype
               ,_3gpp2attr41
               ,_3gpp2airlinksequencenumber
               ,_3gpp2numberactivetransitions
               ,_3gpp2receivedhdlcoctets
               ,_3gpp2correlationid
               ,_3gpp2esn
               ,_3gpp2foreignagentaddress
               ,_3gpp2forwardfchmuxoption
               ,_3gpp2reversefchmuxoption
               ,_3gpp2forwardtraffictype
               ,_3gpp2reversetraffictype
               ,_3gpp2forwardfchrc
               ,_3gpp2reversefchrc
               ,_3gpp2lastuseractivitytime)
    SELECT * 
      FROM public.dblink(var_conn_string
         ,'SELECT radacctid
                 ,'||quote_literal(rec_sysparm.hostname)||'
                 ,'||quote_literal('STOP')||'
                 ,acctsessionid
                 ,acctuniqueid
                 ,username
                 ,realm
                 ,nasipaddress
                 ,nasportid
                 ,nasporttype
                 ,acctstarttime
                 ,acctstoptime
                 ,acctsessiontime
                 ,acctauthentic
                 ,connectinfo_start
                 ,connectinfo_stop
                 ,acctinputoctets
                 ,acctoutputoctets
                 ,calledstationid
                 ,callingstationid
                 ,acctterminatecause
                 ,servicetype
                 ,framedprotocol
                 ,framedipaddress
                 ,acctstartdelay
                 ,acctstopdelay
                 ,xascendsessionsvrkey
                 ,tunnelclientendpoint
                 ,nasidentifier
                 ,class
                 ,_3gpp2homeagentipaddress
                 ,_3gpp2pcfipaddress
                 ,_3gpp2bsid
                 ,_3gpp2userid
                 ,_3gpp2serviceoption
                 ,_3gpp2iptechnology
                 ,_3gpp2airlinkrecordtype
                 ,_3gpp2attr41
                 ,_3gpp2airlinksequencenumber
                 ,_3gpp2numberactivetransitions
                 ,_3gpp2receivedhdlcoctets
                 ,_3gpp2correlationid
                 ,_3gpp2esn
                 ,_3gpp2foreignagentaddress
                 ,_3gpp2forwardfchmuxoption
                 ,_3gpp2reversefchmuxoption
                 ,_3gpp2forwardtraffictype
                 ,_3gpp2reversetraffictype
                 ,_3gpp2forwardfchrc
                 ,_3gpp2reversefchrc
                 ,_3gpp2lastuseractivitytime
             FROM radiusdb.radacct_stop
            WHERE radacctid >  '||var_last_stop_radacctid||'
              AND radacctid <= '||var_max_stop_radacctid||'
         ORDER BY radacctid')
               AS rec_type(radacctid                      bigint
                          ,source_hostname                text
                          ,acctstatustype                 varchar(20)
                          ,acctsessionid                  varchar(32)
                          ,acctuniqueid                   varchar(32)
                          ,username                       varchar(64)
                          ,realm                          varchar(64)
                          ,nasipaddress                   inet
                          ,nasportid                      varchar(15)
                          ,nasporttype                    varchar(32)
                          ,acctstarttime                  timestamp with time zone
                          ,acctstoptime                   timestamp with time zone
                          ,acctsessiontime                bigint
                          ,acctauthentic                  varchar(32)
                          ,connectinfo_start              varchar(50)
                          ,connectinfo_stop               varchar(50)
                          ,acctinputoctets                bigint
                          ,acctoutputoctets               bigint
                          ,calledstationid                varchar(50)
                          ,callingstationid               varchar(50)
                          ,acctterminatecause             varchar(32)
                          ,servicetype                    varchar(32)
                          ,framedprotocol                 varchar(32)
                          ,framedipaddress                inet
                          ,acctstartdelay                 bigint
                          ,acctstopdelay                  bigint
                          ,xascendsessionsvrkey           varchar(10)
                          ,tunnelclientendpoint           inet
                          ,nasidentifier                  varchar(32)
                          ,class                          varchar(128)
                          ,_3gpp2homeagentipaddress       inet
                          ,_3gpp2pcfipaddress             inet
                          ,_3gpp2bsid                     varchar(50)
                          ,_3gpp2userid                   varchar(15)
                          ,_3gpp2serviceoption            varchar(15)
                          ,_3gpp2iptechnology             varchar(15)
                          ,_3gpp2airlinkrecordtype        varchar(15)
                          ,_3gpp2attr41                   varchar(128)
                          ,_3gpp2airlinksequencenumber    varchar(15)
                          ,_3gpp2numberactivetransitions  varchar(15)
                          ,_3gpp2receivedhdlcoctets       varchar(15)
                          ,_3gpp2correlationid            varchar(32)
                          ,_3gpp2esn                      varchar(32)
                          ,_3gpp2foreignagentaddress      inet
                          ,_3gpp2forwardfchmuxoption      varchar(15)
                          ,_3gpp2reversefchmuxoption      varchar(15)
                          ,_3gpp2forwardtraffictype       varchar(15)
                          ,_3gpp2reversetraffictype       varchar(15)
                          ,_3gpp2forwardfchrc             varchar(15)
                          ,_3gpp2reversefchrc             varchar(15)
                          ,_3gpp2lastuseractivitytime     varchar(128)) ;
    EXCEPTION
      WHEN OTHERS THEN RETURN NEXT 'ERROR: OTHERS exception (STOP) from '||rec_sysparm.hostname ;
    END ;

    -- update the radacct_tracker table on the remote database
    BEGIN
      var_sql := 'UPDATE radiusdb.radacct_tracker 
                     SET start_radacctid = '||var_max_start_radacctid||'
                        ,stop_radacctid  = '||var_max_stop_radacctid ;
      PERFORM * FROM public.dblink_exec(var_conn_string, var_sql) ;
    EXCEPTION
      WHEN OTHERS THEN RETURN NEXT 'ERROR: '||rec_sysparm.hostname||' Update Max Radacctid Failed.' ;
                       --RETURN ;
    END ;

  END LOOP ;

  RETURN NEXT (var_max_start_radacctid - var_last_start_radacctid)::text || ' START radacct_start rows processed from ' || rec_sysparm.hostname ||
            ' ('||var_last_start_radacctid::text||' to '||var_max_start_radacctid::text ||')' ;

  RETURN NEXT (var_max_stop_radacctid - var_last_stop_radacctid)::text || ' STOP radacct_stop rows processed from ' || rec_sysparm.hostname ||
            ' ('||var_last_stop_radacctid::text||' to '||var_max_stop_radacctid::text ||')' ;

  RETURN NEXT 'SUCCESS' ;
  RETURN ;

END ;

$$;


ALTER FUNCTION csctoss.smrac_loader() OWNER TO slony;

--
-- Name: FUNCTION smrac_loader(); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION smrac_loader() IS 'Replicates all sprint radacct records from distributed Sprint radius servers to central log database.';


--
-- Name: soup_sn_derive_bent(); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION soup_sn_derive_bent() RETURNS SETOF text
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE

  var_bent_name     text ;
  var_sql           text ;
  rec_sode          record ;

BEGIN

  FOR rec_sode IN SELECT did, serial_number
                      FROM csctoss.soup_device
                     WHERE serial_number IS NOT NULL 
                       AND serial_number <> ''
  LOOP

    -- determine billing entity name and build sql
    SELECT bent.name
      INTO var_bent_name
      FROM unique_identifier uniq
      JOIN line_equipment lieq USING (equipment_id)
      JOIN line USING (line_id)
      JOIN billing_entity bent USING (billing_entity_id)
     WHERE uniq.unique_identifier_type = 'SERIAL NUMBER'
       AND uniq.value = rec_sode.serial_number
       AND lieq.start_date <= current_date
  ORDER BY lieq.start_date desc
     LIMIT 1 ;

    IF NOT FOUND THEN
      RETURN NEXT 'ERROR: Soup Serial Number '||rec_sode.serial_number||' does not exist or is unassigned in OSS.' ;
    ELSE
      var_sql := 'UPDATE device SET description = '||quote_literal(var_bent_name)||' WHERE did = '||rec_sode.did||';' ;
      RETURN NEXT var_sql ;
    END IF ;

  END LOOP ;

  RETURN ;

END ;

$$;


ALTER FUNCTION csctoss.soup_sn_derive_bent() OWNER TO slony;

--
-- Name: soup_update_from_oss(); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION soup_update_from_oss() RETURNS SETOF text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE

  var_kounter       integer := 0 ;
  var_sql           text ;
  rec_data          record ;

BEGIN

  -- check for successful load of soup_update_from_oss table from soup server
  IF (select count(*) from csctoss.soup_update_from_oss where d_did = -1) = 0 THEN
    RETURN NEXT 'ERROR: Soup Update From OSS table did not LOAD successfully. Halting execution.' ;
    RETURN ;
  END IF ;
  DELETE FROM csctoss.soup_update_from_oss WHERE d_did = -1 ;

  -- check for successful load of soup_group_info table from soup server
  IF (select count(*) from csctoss.soup_group_info where gid = -1) = 0 THEN
    RETURN NEXT 'ERROR: Soup Group Info table did not LOAD successfully. Halting execution.' ;
    RETURN ;
  END IF ;
  DELETE FROM csctoss.soup_group_info WHERE gid = -1 ;

  -- backfill equipment_id based on FULL mac address
  UPDATE csctoss.soup_update_from_oss
     SET oss_equipment_id =
        (select equipment_id
           from csctoss.unique_identifier
          where unique_identifier_type = 'MAC ADDRESS'
            and value = d_eui)
   WHERE oss_equipment_id is null ;

  -- backfill equipment_id based on partial (last 6 chars) of mac address
  UPDATE csctoss.soup_update_from_oss
     SET oss_equipment_id =
        (select equipment_id
           from csctoss.unique_identifier
          where unique_identifier_type = 'MAC ADDRESS'
            and value = substr(d_eui,7,6))
   WHERE oss_equipment_id is null ;

  -- backfill equipment_id based on serial number
  UPDATE csctoss.soup_update_from_oss
     SET oss_equipment_id =
        (select equipment_id
           from csctoss.unique_identifier
          where unique_identifier_type = 'SERIAL NUMBER'
            and value = d_serial_number)
   WHERE oss_equipment_id IS NULL ;

  -- backfill line_id based on line_equipment
  UPDATE csctoss.soup_update_from_oss
     SET oss_line_id =
        (select line_id
           from csctoss.line_equipment
          where equipment_id = oss_equipment_id
            and end_date is null)
   WHERE oss_equipment_id IS NOT NULL ;

  -- backfill billing_entity_id and name
  UPDATE csctoss.soup_update_from_oss
     SET oss_billing_entity_id = 
        (select billing_entity_id
           from csctoss.line
          where line_id = oss_line_id)
   WHERE oss_line_id IS NOT NULL ;

  UPDATE csctoss.soup_update_from_oss
     SET oss_billing_entity_name = 
        (select name
           from csctoss.billing_entity
          where billing_entity_id = oss_billing_entity_id)
   WHERE oss_billing_entity_id IS NOT NULL ;

  -- handle new billing entities not present in soup_group_info table
  FOR rec_data IN SELECT name FROM csctoss.billing_entity WHERE COALESCE(parent_billing_entity_id,1) > 0
                  EXCEPT
                  SELECT name FROM csctoss.soup_group_info
  LOOP
    var_sql := 'INSERT INTO group_info (aid, name) VALUES (1,'||quote_literal(rec_data.name)||');' ;
    RETURN NEXT var_sql ;
    var_kounter := var_kounter + 1 ;
  END LOOP ;

  RETURN NEXT 'STATS: '||var_kounter::text||' rows inserted into group_info table.' ;
  RETURN NEXT '' ;
  var_kounter := 0 ;

  -- if soup_update_from_oss table d_description = oss_billing_entity_name then mark as PROCESSED
  UPDATE csctoss.soup_update_from_oss
     SET status = 'PROCESSED'
   WHERE d_description IS NOT NULL
     AND oss_billing_entity_name IS NOT NULL
     AND d_description = oss_billing_entity_name ;

  -- first handle soup nulls
  FOR rec_data IN SELECT d_did, d_description, oss_billing_entity_name
                    FROM csctoss.soup_update_from_oss
                   WHERE d_description IS NULL
                     AND oss_billing_entity_name IS NOT NULL
  LOOP
    var_sql := 'UPDATE device SET description = '||quote_literal(rec_data.oss_billing_entity_name)||' WHERE did = '||rec_data.d_did||';' ;
    RETURN NEXT var_sql ;
    var_kounter := var_kounter + 1 ;
    UPDATE csctoss.soup_update_from_oss
       SET status = 'PROCESSED'
     WHERE d_did = rec_data.d_did ;
  END LOOP ;

  RETURN NEXT 'STATS: '||var_kounter::text||' rows updated where SOUP Billing Entity was NULL.' ;
  RETURN NEXT '' ;
  var_kounter := 0 ;
  
  -- now handle oss nulls
  FOR rec_data IN SELECT d_did, d_description, oss_billing_entity_name
                    FROM csctoss.soup_update_from_oss
                   WHERE d_description IS NOT NULL
                     AND oss_billing_entity_name IS NULL
  LOOP
    var_sql := 'UPDATE device SET description = NULL WHERE did = '||rec_data.d_did||';' ;
    RETURN NEXT var_sql ;
    var_kounter := var_kounter + 1 ;
    UPDATE csctoss.soup_update_from_oss
       SET status = 'PROCESSED'
     WHERE d_did = rec_data.d_did ;
  END LOOP ;

  RETURN NEXT 'STATS: '||var_kounter::text||' rows updated where OSS Billing Entity was NULL.' ;
  RETURN NEXT '' ;
  var_kounter := 0 ;
  
  -- now handle rows where soup bent <> oss bent
  FOR rec_data IN SELECT d_did, d_description, oss_billing_entity_name
                    FROM csctoss.soup_update_from_oss
                   WHERE d_description IS NOT NULL
                     AND oss_billing_entity_name IS NOT NULL
                     AND d_description <> oss_billing_entity_name
  LOOP
    var_sql := 'UPDATE device SET description = '||quote_literal(rec_data.oss_billing_entity_name)||' WHERE did = '||rec_data.d_did||';' ;
    RETURN NEXT var_sql ;
    var_kounter := var_kounter + 1 ;
    UPDATE csctoss.soup_update_from_oss
       SET status = 'PROCESSED'
     WHERE d_did = rec_data.d_did ;
  END LOOP ;

  RETURN NEXT 'STATS: '||var_kounter::text||' rows updated where SOUP Billing Entity disagreed with OSS Billing Entity.' ;
  RETURN NEXT '' ;
  var_kounter := 0 ;

  -- finally report the errors and counts
  FOR rec_data IN SELECT d_did, d_eui, COALESCE(d_serial_number,'NULL') as d_serial_number, COALESCE(oss_equipment_id,0) as oss_equipment_id
                    FROM csctoss.soup_update_from_oss
                   WHERE status = 'LOAD'
  LOOP
    RETURN NEXT 'INCOMPLETE: Soup Device ID '||rec_data.d_did::text||' / EUI '||rec_data.d_eui||' / SN '||rec_data.d_serial_number||' unmatched or unassigned in OSS.' ;
    var_kounter := var_kounter + 1 ;
  END LOOP ;

  RETURN NEXT 'STATS: '||var_kounter::text||' incomplete, unmatched or unassigned devices in SOUP.' ;
  RETURN NEXT '' ;
  RETURN NEXT 'SUCCESS' ;
  RETURN ;

END ;

$$;


ALTER FUNCTION csctoss.soup_update_from_oss() OWNER TO slony;

--
-- Name: FUNCTION soup_update_from_oss(); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION soup_update_from_oss() IS 'Daily function to update soup device table with oss billing entity name and new billing entities.';


--
-- Name: sprint_roaming_by_date_range(date, date); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION sprint_roaming_by_date_range(date, date) RETURNS SETOF sprint_roaming_by_date_range_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_start_date                date    := $1 ;
  par_end_date                  date    := $2 ;
  par_partial_ip                text ; -- := $3 ;

  var_view                      text ;
  var_sql                       text ;
  var_return                    sprint_roaming_by_date_range_retval ;

BEGIN

  -- validate parameters
  IF par_start_date IS NULL OR par_end_date IS NULL THEN
    RAISE EXCEPTION 'Start Date and End Date are required parameters.' ;
  ELSIF par_end_date < par_start_date THEN
    RAISE EXCEPTION 'Start Date must be before or equal to End Date.' ;
  END IF ;

  -- evaluate the partial ip
  IF par_partial_ip IS NULL THEN
    par_partial_ip := '68.28%' ;
  ELSE
    par_partial_ip := par_partial_ip||'%' ;
  END IF ;

  -- truncate the existing table contents
  EXECUTE 'truncate table csctoss.sprint_roaming_load' ;

  -- populate the load table from csctlog database over dblink
  INSERT INTO csctoss.sprint_roaming_load
  SELECT * FROM public.dblink((select * from csctoss.fetch_csctlog_conn())
                             ,'SELECT username
                                     ,class
                                     ,acctstarttime
                                     ,host(_3gpp2foreignagentaddress)::text
                                     ,host(framedipaddress)::text
                                 FROM csctlog.sprint_master_radacct
                                WHERE acctstarttime >= ' || quote_literal(par_start_date) || '
                                  AND acctstarttime <= ' || quote_literal(par_end_date) || '
                                  AND _3gpp2foreignagentaddress::text NOT LIKE ' || quote_literal(par_partial_ip) || '')
             AS rec_type(username                    text
                        ,smrac_line_id               text
                        ,acctstarttime               timestamp
                        ,_3gpp2foreignagentaddress   text
                        ,framedipaddress             text) ;

  -- now using a join to the view return all roaming sessions with ancillary data
  FOR var_return IN SELECT srld.username
                          ,unam.billing_entity_id
                          ,bent.name as billing_entity_name
                          ,line.line_id
                          ,lieq.equipment_id
                          ,(select value 
                              from csctoss.unique_identifier 
                             where equipment_id = lieq.equipment_id 
                               and unique_identifier_type = 'ESN HEX') as esn_hex
                          ,(select value 
                              from unique_identifier 
                             where equipment_id = lieq.equipment_id 
                               and unique_identifier_type = 'SERIAL NUMBER') as serial_number
                          ,srld.smrac_line_id
                          ,srld.acctstarttime
                          ,srld._3gpp2foreignagentaddress
                          ,srld.framedipaddress
                      FROM csctoss.sprint_roaming_load srld
                      JOIN csctoss.username unam using (username)
                      JOIN csctoss.billing_entity bent using (billing_entity_id)
                      JOIN csctoss.line on (line.radius_username = unam.username and line.billing_entity_id = unam.billing_entity_id)
                      JOIN csctoss.line_equipment lieq on (line.line_id = lieq.line_id)
                     WHERE lieq.end_date is null
  LOOP
    RETURN NEXT var_return ;
  END LOOP ;

  EXECUTE 'truncate table csctoss.sprint_roaming_load' ;

  RETURN ;

END ;
$_$;


ALTER FUNCTION csctoss.sprint_roaming_by_date_range(date, date) OWNER TO csctoss_owner;

--
-- Name: FUNCTION sprint_roaming_by_date_range(date, date); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION sprint_roaming_by_date_range(date, date) IS 'Returns Sprint roaming accounting sessions for given date range.';


--
-- Name: sprint_time_left(text); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION sprint_time_left(text) RETURNS integer
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $_$
DECLARE

  par_username      text := COALESCE($1,'NULL') ;
  var_conn_string   text ;
  var_curr_seconds  integer ;
  var_time_left     integer ;
  rec_mrac          record ;
  rec_sysparm       record ;

BEGIN

  -- validate username
  PERFORM TRUE
     FROM csctoss.username
    WHERE par_username <> 'NULL'
      AND username = par_username
    LIMIT 1 ;

  IF NOT FOUND THEN
    RAISE NOTICE 'ERROR: Username % is invalid.', par_username ;
    var_curr_seconds := 0 ;
  ELSE

    -- get latest accounting record for this username
    SELECT *
      INTO rec_mrac
      FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),
                         'SELECT acctstoptime
                                ,EXTRACT(EPOCH FROM (current_timestamp-acctstarttime))::integer as curr_seconds
                            FROM csctlog.master_radacct
                           WHERE username = '||quote_literal(par_username)||'
                             AND acctstarttime > (current_timestamp - interval ''1 day'')
                        ORDER BY master_radacctid DESC
                           LIMIT 1')
        AS rec_type(acctstoptime timestamptz
                   ,curr_seconds integer) ;

    RAISE NOTICE 'curr_seconds: %', rec_mrac.curr_seconds ;

    IF NOT FOUND OR rec_mrac.acctstoptime IS NOT NULL THEN
      RAISE NOTICE 'Active session for username % does not exist.', par_username ;
      var_curr_seconds := 0 ;
    ELSE
      var_curr_seconds := rec_mrac.curr_seconds ;
    END IF ;

  END IF ;

  -- connect to denrad08 for jci radius data
  SELECT * INTO rec_sysparm FROM csctoss.system_parameter WHERE hostname = 'denrad08' ;

  var_conn_string := 'hostaddr='||rec_sysparm.ip_address||
                        ' port='||rec_sysparm.repl_port||
                      ' dbname='||rec_sysparm.repl_target_db||
                        ' user='||rec_sysparm.repl_target_username||
                    ' password='||rec_sysparm.repl_target_password||'' ;

  -- exec query over dblink to get time remaining from radius
  SELECT *
    INTO var_time_left
    FROM public.dblink(var_conn_string
                      ,'select coalesce(pptm.time_remaining,0)
                          from radius.login logn
               left outer join radius.prepaid_time pptm using (contract_id)
                         where logn.login_name = '||quote_literal(par_username))
      AS rec_type(time_remaining integer) ;

  RAISE NOTICE 'var_time_left: %', var_time_left ;

  IF var_time_left > 0 THEN
    var_time_left := (var_time_left * 60) - var_curr_seconds ;
    IF var_time_left < 0 THEN var_time_left := 0; END IF ;
  END IF  ;

  RETURN var_time_left ;

END ;

$_$;


ALTER FUNCTION csctoss.sprint_time_left(text) OWNER TO slony;

--
-- Name: FUNCTION sprint_time_left(text); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION sprint_time_left(text) IS 'Returns the time left in seconds for a device by summing JCI Radius prepaid_time.time_remaining + current session time.';


--
-- Name: static_ip_desc(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION static_ip_desc(text) RETURNS SETOF static_ip_desc_type
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $_$
DECLARE
  var_ip_row                  RECORD;
  var_return_row              static_ip_desc_type%ROWTYPE;
  var_ip_desc                 text;

BEGIN

var_ip_desc = $1;
RAISE NOTICE 'var_ip_desc=%', var_ip_desc;

FOR var_ip_row IN
  SELECT a.id
        ,a.static_ip
        ,a.carrier_id
        ,b.carrier as carrier_name
        ,a.groupname
        ,a.billing_entity_id
        ,c.name as billing_name
    FROM static_ip_pool a
   INNER JOIN static_ip_carrier_def b on a.carrier_id = b.carrier_def_id
    LEFT OUTER JOIN billing_entity c ON a.billing_entity_id = c.billing_entity_id
   WHERE a.static_ip ~ var_ip_desc
   ORDER BY a.static_ip
   LOOP
      var_return_row.id = var_ip_row.id;
      var_return_row.static_ip = var_ip_row.static_ip;
      var_return_row.carrier_id = var_ip_row.carrier_id;
      var_return_row.carrier_name = var_ip_row.carrier_name;
      var_return_row.groupname = var_ip_row.groupname;
      var_return_row.billing_entity_id = var_ip_row.billing_entity_id;
      var_return_row.billing_name = var_ip_row.billing_name;
      RETURN NEXT var_return_row;
   END LOOP;
              
RAISE NOTICE 'Finished Function';
RETURN;

END ;
$_$;


ALTER FUNCTION csctoss.static_ip_desc(text) OWNER TO csctoss_owner;

--
-- Name: static_ip_pool_pre_delete_update(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION static_ip_pool_pre_delete_update() RETURNS "trigger"
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN

 IF TG_OP = 'DELETE' THEN 

   RAISE EXCEPTION 'Static IP values cannot be deleted.'; 

 ELSIF TG_OP = 'UPDATE' THEN 

  -- dont alow static_ip updates 
  IF NEW.static_ip <> OLD.static_ip THEN
    RAISE EXCEPTION 'Cannot update Static IP.' ;
  END IF ;

  -- dont allow groupname to change
  IF NEW.groupname <> OLD.groupname THEN
    RAISE EXCEPTION 'Cannot update Groupname.' ;
  END IF ;

  -- dont allow billing_entity_id to change
  IF NEW.billing_entity_id <> OLD.billing_entity_id THEN
    RAISE EXCEPTION 'Cannot update Billing Entity ID.' ;
  END IF ;

  -- dont allow carrier_id to change
   IF NEW.carrier_id <> OLD.carrier_id THEN 
      RAISE EXCEPTION 'Cannot update carrier id.';
   END IF ;

END IF;

  RETURN NEW ;

END ;
$$;


ALTER FUNCTION csctoss.static_ip_pool_pre_delete_update() OWNER TO csctoss_owner;

--
-- Name: static_ip_radreply_sync(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION static_ip_radreply_sync() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE

  var_ip_row                  RECORD;
  var_rr_id                   integer;
  var_line_id                 integer;
  var_rr_value                text;
 
BEGIN

  RAISE NOTICE 'Entering Function.';

  FOR var_ip_row IN
  SELECT rr.id, rr.value, line.line_id
    from radreply rr
    JOIN line on rr.username = line.radius_username
   where rr.attribute = 'Framed-IP-Address'
     and rr.value IN
         (select static_ip
            from static_ip_pool
           where is_assigned = FALSE)
  LOOP
     var_rr_id = var_ip_row.id;
     var_line_id = var_ip_row.line_id;
     var_rr_value = var_ip_row.value;

     UPDATE static_ip_pool
        SET is_assigned = TRUE
           ,line_id = var_line_id
      WHERE static_ip = var_rr_value;

     RETURN NEXT var_ip_row;
  END LOOP;
  RAISE NOTICE 'Finished Function';
  RETURN;
    --RETURN COALESCE(var_conn_string,'ERROR retrieving connection information for portal.') ;
END ;

$$;


ALTER FUNCTION csctoss.static_ip_radreply_sync() OWNER TO csctoss_owner;

--
-- Name: term_request_by_hour_new(boolean); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION term_request_by_hour_new(boolean) RETURNS SETOF hourly_report_record_type
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  sw_is_set			   boolean:=$1;

  var_sql                          text ;
  var_return                       text ;
  var_sql_yesterday		   text;
  var_sql_today			   text;

  ar_count_spr                     integer;
  ne_count_spr                     integer;
  ss_count_spr                     integer;

  ar_count_usc                     integer;
  ne_count_usc                     integer;
  ss_count_usc                     integer;

  ar_count_vzw                     integer;
  ne_count_vzw                     integer;
  ss_count_vzw                     integer;

  first_time_sw                    integer :=1;
  prev_hour                        text;
  rec_usage                        record ;


  current_record                   hourly_report_record_type;
  
  ar_count_spr_total               integer;
  ne_count_spr_total               integer;
  ss_count_spr_total               integer;

  ar_count_usc_total               integer;
  ne_count_usc_total               integer;
  ss_count_usc_total               integer;

  ar_count_vzw_total               integer;
  ne_count_vzw_total               integer;
  ss_count_vzw_total               integer;

  date_to_use			   date;
  
BEGIN
  -- dynamically build the sql statement
  ar_count_spr_total := 0;
  ne_count_spr_total := 0;
  ss_count_spr_total := 0;

  ar_count_usc_total := 0;
  ne_count_usc_total := 0;
  ss_count_usc_total := 0;

  ar_count_vzw_total := 0;
  ne_count_vzw_total := 0;
  ss_count_vzw_total := 0;


  current_record.ar_count_spr := 0;
  current_record.ne_count_spr := 0;
  current_record.ss_count_spr := 0;

  current_record.ar_count_usc := 0;
  current_record.ne_count_usc := 0;
  current_record.ss_count_usc := 0;

  current_record.ar_count_vzw := 0;
  current_record.ne_count_vzw := 0;
  current_record.ss_count_vzw := 0;

       
	var_sql_yesterday:=
		'select *
                from
                (
                select
                        to_char(acctstarttime::timestamp,''HH24''),
                ( case when username LIKE ''%uscc%'' then ''USCC''
                       when username LIKE ''%vzw%'' then ''VZW''
                        else ''SPRINT'' end
                 ) as  thisname,
                        acctterminatecause,
                        count(*)
                from master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
                where acctstarttime::date = current_date-1
                and acctsessiontime IS NOT NULL
                AND class IS NOT NULL
                and  (username LIKE ''%uscc%''
                or
                username like  ''%sprint%''
                or
                username like  ''%vzw%''
                )
                and acctterminatecause in ( ''Admin-Reset'',''NAS-Error'')
                group by
                        to_char(acctstarttime::timestamp,''HH24''),
                ( case when username LIKE ''%uscc%'' then ''USCC''
                       when username LIKE ''%vzw%'' then ''VZW''
                        else ''SPRINT'' end),
                        acctterminatecause
                --order by 1,2;
                union
                select
                        to_char(acctstarttime::timestamp,''HH24''),
                ( case when username LIKE ''%uscc%'' then ''USCC''
                       when username LIKE ''%vzw%'' then ''VZW''
                        else ''SPRINT'' end
                 ) as  thisname,
                        ''S/S''  as ss,
                        count(*)
                from master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
                where acctstarttime::date = current_date-1
                and acctsessiontime IS NOT NULL
                AND class IS NOT NULL
                and  (username LIKE ''%uscc%''
                or
                username like  ''%sprint%''
                or
                username like  ''%vzw%''
                )
                AND acctsessiontime <= 1
                group by
                        to_char(acctstarttime::timestamp,''HH24''),
                        ( case when username LIKE ''%uscc%'' then ''USCC''
                               when username LIKE ''%vzw%'' then ''VZW''
                        else ''SPRINT'' end),
                        ss
                ) result
                order by 1,2,3 ';

        RAISE NOTICE 'SQL: %', var_sql ;

  
	var_sql_today:=
		'select *
                from
                (
                select
                        to_char(acctstarttime::timestamp,''HH24''),
                ( case when username LIKE ''%uscc%'' then ''USCC''
                       when username LIKE ''%vzw%'' then ''VZW''
                        else ''SPRINT'' end
                 ) as  thisname,
                        acctterminatecause,
                        count(*)
                from master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
                where acctstarttime::date = current_date
                and acctsessiontime IS NOT NULL
                AND class IS NOT NULL
                and  (username LIKE ''%uscc%''
                or
                username like  ''%sprint%''
                or
                username like  ''%vzw%''
                )
                and acctterminatecause in ( ''Admin-Reset'',''NAS-Error'')
                group by
                        to_char(acctstarttime::timestamp,''HH24''),
                ( case when username LIKE ''%uscc%'' then ''USCC''
                       when username LIKE ''%vzw%'' then ''VZW''
                        else ''SPRINT'' end),
                        acctterminatecause
                --order by 1,2;
                union
                select
                        to_char(acctstarttime::timestamp,''HH24''),
                ( case when username LIKE ''%uscc%'' then ''USCC''
                       when username LIKE ''%vzw%'' then ''VZW''
                        else ''SPRINT'' end
                 ) as  thisname,
                        ''S/S''  as ss,
                        count(*)
                from master_radacct_'||TO_CHAR(current_date-1,'YYYYMM')||'
                where acctstarttime::date = current_date
                and acctsessiontime IS NOT NULL
                AND class IS NOT NULL
                and  (username LIKE ''%uscc%''
                or
                username like  ''%sprint%''
                or
                username like  ''%vzw%''
                )
                AND acctsessiontime <= 1
                group by
                        to_char(acctstarttime::timestamp,''HH24''),
                        ( case when username LIKE ''%uscc%'' then ''USCC''
                               when username LIKE ''%vzw%'' then ''VZW''
                        else ''SPRINT'' end),
                        ss
                ) result
                order by 1,2,3 ';

        RAISE NOTICE 'SQL: %', var_sql ;

  --determine wether to run previous day results or todays results, based on parameter passed
  if (sw_is_set)
  then
        var_sql := var_sql_today;
  else
        var_sql := var_sql_yesterday;

  end if;


  -- execute dynamic query over link and return results
  FOR rec_usage IN SELECT *
                     FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql)
                       AS       rec_type(hour                  varchar
                                        ,thisname              text
                                        ,acctterminatecause    text
                                        ,count                 integer)
  LOOP
    current_record.this_space := '--';
    if first_time_sw = 1
    then
       first_time_sw:=0;
       prev_hour:=rec_usage.hour;
       current_record.hour:=rec_usage.hour;
    end if;
    if rec_usage.hour <>  prev_hour
    then
         RETURN NEXT current_record;
         prev_hour:=rec_usage.hour;
         current_record.hour:=rec_usage.hour;
    end if;
    if rec_usage.thisname = 'SPRINT'
        then
                if rec_usage.acctterminatecause = 'Admin-Reset'
                then
                        current_record.ar_count_spr  = rec_usage.count;
			ar_count_spr_total := ar_count_spr_total + rec_usage.count;
                elsif rec_usage.acctterminatecause = 'NAS-Error'
                    then
                        current_record.ne_count_spr = rec_usage.count;
		  	ne_count_spr_total = ne_count_spr_total +  rec_usage.count;
                else
                     current_record.ss_count_spr = rec_usage.count;
                     ss_count_spr_total = ss_count_spr_total + rec_usage.count;
                end if;
    end if;

    if rec_usage.thisname = 'VZW'
        then
                if rec_usage.acctterminatecause = 'Admin-Reset'
                then
                        current_record.ar_count_vzw  = rec_usage.count;
			ar_count_vzw_total := ar_count_vzw_total + rec_usage.count;
                elsif rec_usage.acctterminatecause = 'NAS-Error'
                    then
                        current_record.ne_count_vzw = rec_usage.count;
		  	ne_count_vzw_total = ne_count_vzw_total +  rec_usage.count;
                else
                     current_record.ss_count_vzw = rec_usage.count;
                     ss_count_vzw_total = ss_count_vzw_total + rec_usage.count;
                end if;
        else
                if rec_usage.acctterminatecause = 'Admin-Reset'
                then
                        current_record.ar_count_usc = rec_usage.count;
 			ar_count_usc_total =ar_count_usc_total + rec_usage.count;
                elsif rec_usage.acctterminatecause = 'NAS-Error'
                then
                        current_record.ne_count_usc = rec_usage.count;
			ne_count_usc_total = ne_count_usc_total +  rec_usage.count;
                else
                        current_record.ss_count_usc = rec_usage.count;
 			ss_count_usc_total = ss_count_usc_total +  rec_usage.count;
                end if;
    end if;
  END LOOP ;

-- prints last record

  RETURN NEXT current_record;

  current_record.hour:= 'Totals: ';
  current_record.ar_count_spr := ar_count_spr_total;
  current_record.ne_count_spr := ne_count_spr_total;
  current_record.ss_count_spr := ss_count_spr_total;
  current_record.this_space   := '--';
  current_record.ar_count_usc := ar_count_usc_total;
  current_record.ne_count_usc := ne_count_usc_total;
  current_record.ss_count_usc := ss_count_usc_total;
  current_record.this_space   := '--';
  current_record.ar_count_vzw := ar_count_vzw_total;
  current_record.ne_count_vzw := ne_count_vzw_total;
  current_record.ss_count_vzw := ss_count_vzw_total;


  RETURN NEXT current_record;
  -- return a blank line
  RETURN  ;

  RAISE NOTICE 'SQL: %', var_sql ;

END ;
$_$;


ALTER FUNCTION csctoss.term_request_by_hour_new(boolean) OWNER TO csctoss_owner;

--
-- Name: FUNCTION term_request_by_hour_new(boolean); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION term_request_by_hour_new(boolean) IS 'Simple function to produce report of Termination Requests by hour .';


--
-- Name: test_insert_static_ip_ranges(text, text, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION test_insert_static_ip_ranges(text, text, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_groupname           text := $1;
  par_carrier             text := $2;
  par_billing_entity_id   integer := $3;
  var_uniqid_row          RECORD;
  var_static_ip           text ;
  var_return              text;
  var_carrier_id          integer;

BEGIN

   IF par_groupname = '' OR par_carrier = '' OR par_billing_entity_id IS NULL THEN 

      RAISE EXCEPTION ' Input parameters are null.';

   ELSE 

       SELECT carrier_def_id INTO var_carrier_id 
       FROM static_ip_carrier_def 
       WHERE carrier = par_carrier; 

   END IF;
    
     FOR var_uniqid_row IN SELECT ip FROM ip_ranges

       LOOP 
 
             var_static_ip := var_uniqid_row.ip; 

           IF NOT EXISTS ( SELECT static_ip FROM static_ip_pool WHERE static_ip = var_static_ip AND groupname = par_groupname AND is_assigned = 'TRUE' ) THEN 

              IF ( par_carrier = 'VZW' ) THEN 

                  INSERT INTO static_ip_pool(static_ip, groupname, is_assigned, carrier_id, billing_entity_id)
                    VALUES (var_static_ip, par_groupname, 'FALSE', var_carrier_id, par_billing_entity_id);       

                   var_return := 'Insertion was succesful for '|| var_static_ip;

              ELSE 

                  INSERT INTO static_ip_pool(static_ip, groupname, is_assigned, carrier_id)
                    VALUES (var_static_ip, par_groupname, 'FALSE', var_carrier_id); 
           
                   var_return := 'Insertion was succesful for '|| var_static_ip;

              END IF; 

           ELSE 
                
              DELETE FROM ip_ranges WHERE ip = var_static_ip; 
       
           END IF;

       END LOOP;
           
RETURN var_return; 

  END ;

$_$;


ALTER FUNCTION csctoss.test_insert_static_ip_ranges(text, text, integer) OWNER TO csctoss_owner;

--
-- Name: test_line_equipment_unique_ids_info(text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION test_line_equipment_unique_ids_info(text, text) RETURNS SETOF ops_api_line_equipment_unique_ids_info_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_type                    text      := $1;
  par_value                   text      := $2;
  var_billing_entity_id       integer;
  var_unique_identifier_type  text;
  var_equipment_id            integer;
  var_line_id                 integer;
  var_equipment_type        text;
  var_serial_number           text;
  var_esn_hex                 text;
  var_esn_dec               text;
  var_min                     text;
  var_mdn                     text;
  var_mac_address             text;
  var_uniqid_row              RECORD;
  v_query                     text;
  var_return_row              ops_api_line_equipment_unique_ids_info_retval%ROWTYPE;

BEGIN
    RAISE NOTICE 'Entering Function';
  
  IF LENGTH(TRIM(COALESCE(par_value, ''))) = 0  AND par_type = '' THEN 

      RAISE EXCEPTION 'Input Values are Null.';
  
  ELSIF par_type = '' THEN 
   
       RAISE EXCEPTION 'Type is Null. Enter either Unique_Identifier OR Billing_Entity_ID for Input Type.';

  
  ELSIF par_value = '' THEN 

       RAISE EXCEPTION 'Value is Null. Enter the Unique_Identifier Value or Billing_Entity_ID value.';  

  END IF;

      -- Validate parameters.
   IF par_type = 'Unique_Identifier' THEN 

        v_query := 'SELECT ui.equipment_id AS equipment_id,
                           eq.equipment_type AS equipment_type
                    FROM unique_identifier ui 
                    JOIN equipment eq ON(ui.equipment_id = eq.equipment_id)
                    WHERE ui.unique_identifier_type IN (''ESN HEX'', ''ESN DEC'', ''MDN'', ''MIN'', ''SERIAL NUMBER'', ''MAC ADDRESS'', ''ESN HEX1'', ''ESN HEX2'', ''ESN DEC1'', ''ESN DEC2'', ''MIN1'', ''MIN2'', ''MDN1'', ''MDN2'')
                    AND ui.value LIKE ' ||quote_literal('%'||par_value||'%')|| 'GROUP BY  ui.equipment_id, eq.equipment_type LIMIT 100';
                      
   ELSIF par_type = 'Billing_Entity_ID' THEN  
   
    var_billing_entity_id := (par_value)::integer;
           
      v_query :=  'SELECT  line.line_id AS line_id,
                                 lieq.equipment_id AS equipment_id,
                     eq.equipment_type AS equipment_type
                     FROM line 
                     JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
                     JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
                     WHERE line.billing_entity_id = '||(var_billing_entity_id)||'LIMIT 100';
                     
 END IF;

     FOR var_uniqid_row IN EXECUTE v_query 
  
       LOOP 

      var_equipment_id := var_uniqid_row.equipment_id ;
      --var_line_id := var_uniqid_row.line_id;  
      var_equipment_type := var_uniqid_row.equipment_type;        
      
-- Retrieve Serial Number and Mac Address for the obtained Equipment_Id Value. These are unique for all types of equipments.

     SELECT uid1.value INTO var_serial_number FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'SERIAL NUMBER'::text;
     SELECT uid1.value INTO var_mac_address FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MAC ADDRESS'::text;

    IF var_equipment_type = 'ROUTER' THEN 
      -- Get all unique_identifier values for a Router
      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;
      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;
      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;
      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text;

    ELSIF var_equipment_type = 'CARD' THEN 
      -- Get the unique_identifiers for the equipment type Card. 
      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;
      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;
      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;
      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text; 

    ELSIF var_equipment_type = 'MODULE' THEN 
      -- Get the unique_identifiers for the equipment_type Module.
      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;
      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;
      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;
      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text; 

    END IF;

   FOR var_return_row IN 
     SELECT line.line_id,  
        CASE 
             WHEN line.active_flag  = 't' THEN 'TRUE'::text 
             WHEN line.active_flag  = 'f' THEN 'FALSE'::text
             ELSE 'N/A'::text 
        END AS active, line.line_assignment_type, lieq.start_date AS line_assignment_start,
        lieq.end_date AS line_assignment_end, eqmo.carrier, line.billing_entity_id, 
        CASE
             WHEN line.billing_entity_id IS NOT NULL THEN 
                 ( SELECT billing_entity.name
                   FROM billing_entity
                   WHERE billing_entity.billing_entity_id = line.billing_entity_id)
             ELSE NULL::text
        END AS billing_entity, equp.equipment_id, equp.equipment_type, eqmo.model_number1, var_esn_hex, var_esn_dec, 
        var_mac_address, var_serial_number, var_mdn, var_min, '', '', '', '', '', '', '', '',
        eqst.equipment_status_type, line.ip_pool, 
        CASE
             WHEN line.radius_username IS NOT NULL THEN 
                  COALESCE(( SELECT radreply.value
                  FROM radreply
                  WHERE radreply.attribute::text = 'Framed-IP-Address'::text AND radreply.username::text = line.radius_username), 'N/A'::text::character varying)
             ELSE 'N/A'::character varying
        END AS static_ip_address, 
       (SELECT count(*)::integer AS count
        FROM bp_billing_equipment_assignment bbea
        WHERE bbea.line_id = line.line_id AND 'now'::text::date >= bbea.start_date::date 
        AND 'now'::text::date <= COALESCE(bbea.end_date::date::timestamp without time zone, 'now'::text::date + '1 day'::interval)) 
        AS number_active_charges
     FROM equipment equp
     JOIN equipment_type eqty ON eqty.equipment_type = equp.equipment_type
     JOIN equipment_model eqmo ON eqmo.equipment_model_id = equp.equipment_model_id
     LEFT JOIN equipment_status eqst ON eqst.equipment_id = equp.equipment_id
     LEFT JOIN line_equipment lieq ON lieq.equipment_id = equp.equipment_id
     LEFT JOIN line ON line.line_id = lieq.line_id 
     WHERE equp.equipment_id = var_equipment_id 
     --AND line.line_id = var_line_id
    
  LOOP

      RETURN NEXT var_return_row;

   END LOOP;      
  
  IF (var_equipment_type = 'MULTI_NETWORK ROUTER') THEN

    FOR var_return_row IN 
      
         SELECT line.line_id,  
                CASE 
                      WHEN line.active_flag  = 't' THEN 'TRUE'::text 
                      WHEN line.active_flag  = 'f' THEN 'FALSE'::text
                      ELSE 'N/A'::text 
                END AS active, line.line_assignment_type, lieq.start_date AS line_assignment_start,
                lieq.end_date AS line_assignment_end, eqmo.carrier, line.billing_entity_id, 
                CASE
                      WHEN line.billing_entity_id IS NOT NULL THEN 
                           ( SELECT billing_entity.name
                             FROM billing_entity
                             WHERE billing_entity.billing_entity_id = line.billing_entity_id)
                      ELSE NULL::text
                END AS billing_entity, equp.equipment_id, equp.equipment_type, eqmo.model_number1, var_esn_hex, var_esn_dec, 
                var_mac_address, var_serial_number, var_mdn, var_min, 
               (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN HEX1'::text) AS esn_hex1,
               (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN HEX2'::text) AS esn_hex2,
               (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN DEC1'::text) AS esn_dec1,
               (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN DEC2'::text) AS esn_dec2,
               (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MIN1'::text) AS min1,
               (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MIN2'::text) AS min2,
               (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MDN1'::text) AS mdn1,  
               (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MDN2'::text) AS mdn2,
                eqst.equipment_status_type, line.ip_pool, 
                CASE
                      WHEN line.radius_username IS NOT NULL THEN 
                           COALESCE(( SELECT radreply.value
                                      FROM radreply
                                      WHERE radreply.attribute::text = 'Framed-IP-Address'::text AND radreply.username::text = line.radius_username), 'N/A'::text::character varying)
                      ELSE 'N/A'::character varying
                END AS static_ip_address, 
               (SELECT count(*)::integer AS count
                FROM bp_billing_equipment_assignment bbea
                WHERE bbea.line_id = line.line_id AND 'now'::text::date >= bbea.start_date::date 
                AND 'now'::text::date <= COALESCE(bbea.end_date::date::timestamp without time zone, 'now'::text::date + '1 day'::interval)) 
                AS number_active_charges
         FROM equipment equp
         JOIN equipment_type eqty ON eqty.equipment_type = equp.equipment_type
         JOIN equipment_model eqmo ON eqmo.equipment_model_id = equp.equipment_model_id
         LEFT JOIN equipment_status eqst ON eqst.equipment_id = equp.equipment_id
         LEFT JOIN line_equipment lieq ON lieq.equipment_id = equp.equipment_id
         LEFT JOIN line ON line.line_id = lieq.line_id 
         WHERE equp.equipment_id = var_equipment_id 
         --AND line.line_id = var_line_id
         
  LOOP

      RETURN NEXT var_return_row;

   END LOOP;
  
END IF;

END LOOP;
 
  RAISE NOTICE 'Finished Function.';

  RETURN;

END ;
$_$;


ALTER FUNCTION csctoss.test_line_equipment_unique_ids_info(text, text) OWNER TO csctoss_owner;

--
-- Name: test_ops_api_line_plan_product_info(text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION test_ops_api_line_plan_product_info(text, text) RETURNS SETOF ops_api_line_plan_product_info_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_type                    text      := $1;
  par_value                   text      := $2;
  var_equipment_id            integer;
  var_line_id                 integer;
  var_equipment_type	      text;
  var_serial_number           text;
  var_esn_hex                 text;
  var_esn_dec	              text;
  var_min                     text;
  var_mdn                     text;
  var_mac_address             text;
  var_uniqid_row              RECORD;
  v_query                     text;
  var_billing_entity_id       integer;
  var_return_row              ops_api_line_plan_product_info_retval%ROWTYPE;

BEGIN
    RAISE NOTICE 'Entering Function';
	
  IF LENGTH(TRIM(COALESCE(par_value, ''))) = 0  AND par_type = '' THEN 
      
      RAISE EXCEPTION 'Input Values Are Null.';

  ELSIF par_type = '' THEN  

     RAISE EXCEPTION 'Input type is null. Please enter either Unique_Identifier or Line_ID or Username or Static IP Address or Billing_Entity_ID.';

  
  ELSIF par_value = '' THEN 

      RAISE EXCEPTION 'Input value is null. Please enter values for either Unique_Identifier or Line_ID or Username or Static IP Address or Billing_Entity_ID.';

 END IF;
      -- Validate parameters.
   IF par_type = 'Unique_Identifier' THEN 
       
          v_query := 'SELECT ui.equipment_id AS equipment_id,
                           eq.equipment_type AS equipment_type,
                           lieq.line_id AS line_id
                    FROM unique_identifier ui 
                    JOIN equipment eq ON(ui.equipment_id = eq.equipment_id)
                    JOIN line_equipment lieq ON (ui.equipment_id = lieq.equipment_id)
                    WHERE ui.unique_identifier_type IN (''ESN HEX'', ''ESN DEC'', ''MDN'', ''MIN'', ''SERIAL NUMBER'', ''MAC ADDRESS'', 
					                                    ''ESN HEX1'', ''ESN HEX2'', ''ESN DEC1'', ''ESN DEC2'', ''MIN1'', ''MIN2'', ''MDN1'', ''MDN2'')
                    AND ui.value LIKE ' ||quote_literal(par_value||'%')|| 'GROUP BY  ui.equipment_id, eq.equipment_type, lieq.line_id LIMIT 100';
   
	 ELSIF par_type = 'Line_ID' THEN  
	 
	  var_line_id := (par_value)::integer;
           
	    v_query :=  'SELECT  line.line_id AS line_id,
		                 lieq.equipment_id AS equipment_id,
		                 eq.equipment_type AS equipment_type
                         FROM line 
                         JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
                         JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
                         WHERE line.line_id = '||(var_line_id)||'';
					 
	  ELSIF par_type = 'Username' THEN 
	  
	    v_query := 'SELECT line.line_id AS line_id,
		                   lieq.equipment_id AS equipment_id,
		                   eq.equipment_type AS equipment_type
                        FROM line 
                        JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
                        JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
                        WHERE line.radius_username LIKE '||quote_literal(par_value||'%')||'LIMIT 100';
        
	  ELSIF par_type = 'Static IP Address' THEN 
       
        v_query := 'SELECT line.line_id AS line_id,
                           lieq.equipment_id AS equipment_id,
                           eq.equipment_type AS equipment_type
                    FROM radreply 
                    JOIN line ON (radreply.username = line.radius_username)
                    JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
                    JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
                    WHERE radreply.attribute::text = ''Framed-IP-Address''::text
                    AND radreply.value = '||quote_literal(par_value);

       
          ELSIF par_type = 'Billing_Entity_ID' THEN  
	 
	  var_billing_entity_id := (par_value)::integer;
           
	    v_query :=  'SELECT  line.line_id AS line_id,
                                 lieq.equipment_id AS equipment_id,
		                 eq.equipment_type AS equipment_type
                     FROM line 
                     JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
                     JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
                     WHERE line.billing_entity_id = '||(var_billing_entity_id)||'LIMIT 100';
 END IF;

     FOR var_uniqid_row IN EXECUTE v_query 
	
       LOOP 

             var_equipment_id := var_uniqid_row.equipment_id ;
             var_line_id := var_uniqid_row.line_id;  
             var_equipment_type := var_uniqid_row.equipment_type;        
              
-- Retrieve Serial Number and Mac Address for the obtained Equipment_Id Value. These are unique for all types of equipments.

     SELECT uid1.value INTO var_serial_number FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'SERIAL NUMBER'::text;
	 
     SELECT uid1.value INTO var_mac_address FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MAC ADDRESS'::text;

   IF var_equipment_type = 'ROUTER' THEN 
	
      -- Get all unique_identifier values for a Router
	  
      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;
	  
      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;
	  
      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text;
	  
      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text;
	  
    ELSIF var_equipment_type = 'CARD' THEN 
	
      -- Get the unique_identifiers for the equipment type Card. 
	  
      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;
	  
      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;
	  
      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text;
	  
      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text; 
	  
    ELSIF var_equipment_type = 'MODULE' THEN 
	
      -- Get the unique_identifiers for the equipment_type Module.
	  
      SELECT uid1.value INTO var_esn_hex FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN HEX'::text;
	  
      SELECT uid1.value INTO var_esn_dec FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'ESN DEC'::text;
	  
      SELECT uid1.value INTO var_mdn FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MDN'::text;
	  
      SELECT uid1.value INTO var_min FROM unique_identifier uid1 WHERE uid1.equipment_id = var_equipment_id AND uid1.unique_identifier_type = 'MIN'::text; 
	  
    END IF;

   FOR var_return_row IN 
     SELECT 
	   CASE
               WHEN line.billing_entity_id IS NOT NULL THEN 
                   ( SELECT billing_entity.name
                     FROM billing_entity
                     WHERE billing_entity.billing_entity_id = line.billing_entity_id)
               ELSE NULL::text
           END AS customer_name, line.line_id, 
	   CASE 
               WHEN line.billing_entity_address_id IS NOT NULL THEN 
	            (SELECT  locn.location_label 
		     FROM billing_entity_location_label locn 
		     WHERE locn.billing_entity_address_id = line.billing_entity_address_id
                     AND locn.location_label_type = 'USER DEFINED')
	       ELSE NULL::text
	    END AS location, line.line_label, line.radius_username, line.notes, line.active_flag,
            pt.plan_type_desc AS plan_type, plan.comment AS plan_comment, prd.product_code, 
            plan.start_date, plan.end_date, plan.length_days, plan.prepaid_unit, 
            plan.prepaid_allowance, plan.prepaid_balance, eqm.model_description AS model,
            eqm.model_number1 AS model_number, eq.equipment_type, 
	   (SELECT eqm1.model_number1 FROM equipment_model eqm1 
            WHERE eqm1.equipment_model_id = eqm.embedded_equipment_model_id) AS Embedded_Model,
	    var_esn_hex, var_esn_dec, var_mdn, var_min, var_serial_number, var_mac_address
    FROM line 
    LEFT JOIN plan ON (line.line_id = plan.line_id)
    LEFT JOIN plan_type pt ON (plan.plan_type_id = pt.plan_type_id)
    LEFT JOIN product prd ON ( plan.product_id = prd.product_id)
    JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
    JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
    JOIN equipment_model eqm ON ( eq.equipment_model_id = eqm.equipment_model_id)
    WHERE line.line_id = var_line_id
    AND lieq.end_date IS NULL
    AND eq.equipment_id = var_equipment_id

    LOOP

         RETURN NEXT var_return_row;

    END LOOP;

  IF ( var_equipment_type = 'MULTI_NETWORK ROUTER') THEN       
  
   FOR var_return_row IN 
  
      SELECT 
	   CASE
               WHEN line.billing_entity_id IS NOT NULL THEN 
                   ( SELECT billing_entity.name
                     FROM billing_entity
                     WHERE billing_entity.billing_entity_id = line.billing_entity_id)
               ELSE NULL::text
           END AS customer_name, line.line_id, 
	   CASE 
               WHEN line.billing_entity_address_id IS NOT NULL THEN 
	            (SELECT  locn.location_label 
		     FROM billing_entity_location_label locn 
		     WHERE locn.billing_entity_address_id = line.billing_entity_address_id
                     AND locn.location_label_type = 'USER DEFINED')
	       ELSE NULL::text
	    END AS location, line.line_label, line.radius_username, line.notes, line.active_flag,
            pt.plan_type_desc AS plan_type, plan.comment AS plan_comment, prd.product_code, 
            plan.start_date, plan.end_date, plan.length_days, plan.prepaid_unit, 
            plan.prepaid_allowance, plan.prepaid_balance, eqm.model_description AS model,
            eqm.model_number1 AS model_number, eq.equipment_type, 
	   (SELECT eqm1.model_number1 FROM equipment_model eqm1 
            WHERE eqm1.equipment_model_id = eqm.embedded_equipment_model_id) AS Embedded_Model,
	    var_esn_hex, var_esn_dec, var_mdn, var_min, var_serial_number, var_mac_address
          ,(SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN HEX1'::text) AS esn_hex1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN DEC1'::text) AS esn_dec1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MDN1'::text) AS mdn1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MIN1'::text) AS min1,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN HEX2'::text) AS esn_hex2,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'ESN DEC2'::text) AS esn_dec2,
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MDN2'::text) AS mdn2,	
          (SELECT uid1.value FROM unique_identifier uid1 WHERE uid1.line_id = line.line_id AND uid1.unique_identifier_type = 'MIN2'::text) AS min2
    FROM line 
    LEFT JOIN plan ON (line.line_id = plan.line_id)
    LEFT JOIN plan_type pt ON (plan.plan_type_id = pt.plan_type_id)
    LEFT JOIN product prd ON ( plan.product_id = prd.product_id)
    JOIN line_equipment lieq ON (line.line_id = lieq.line_id)
    JOIN equipment eq ON (lieq.equipment_id = eq.equipment_id)
    JOIN equipment_model eqm ON ( eq.equipment_model_id = eqm.equipment_model_id)
    WHERE line.line_id = var_line_id
    AND eq.equipment_id = var_equipment_id

    LOOP

         RETURN NEXT var_return_row;
 
    END LOOP;


END IF;

 END LOOP;
 
  RAISE NOTICE 'Finished Function.';

    RETURN;
END ;
$_$;


ALTER FUNCTION csctoss.test_ops_api_line_plan_product_info(text, text) OWNER TO csctoss_owner;

--
-- Name: test_update_ip(integer, text, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION test_update_ip(integer, text, text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE

   par_line_id            integer := $1; 
   par_username           text    := $2;
   par_groupname          text    := $3;
   par_carrier            text    := $4;
   var_static_ip          text;
   var_carrier_id         integer;
   var_return             text;
   

BEGIN 

        PERFORM public.set_change_log_staff_id(3) ;

   	IF ( par_line_id IS NULL and par_username = '' and par_groupname = '' ) THEN 

            RAISE EXCEPTION 'Input parameters are null.';

        ELSIF NOT EXISTS (SELECT TRUE FROM radreply WHERE username = par_username AND attribute = 'Framed-IP-Address') THEN
          
            -- Retrieve Carrier ID
            SELECT carrier_id INTO var_carrier_id
            FROM static_ip_pool 
            WHERE carrier_id = (SELECT carrier_def_id FROM static_ip_carrier_def WHERE carrier = par_carrier) LIMIT 1;

            --Retrieve first available Static IP
            SELECT static_ip INTO var_static_ip
            FROM static_ip_pool
            WHERE groupname = par_groupname
            AND is_assigned = 'FALSE'
            AND carrier_id = var_carrier_id
            --AND line_id IS NULL
            ORDER BY static_ip
            LIMIT 1;
             
              IF (var_static_ip = '') THEN 

                   var_return := 'No available static ip for this groupname.'; 
              ELSE 

                   INSERT INTO radreply(username, attribute, op, value, priority)
			 VALUES (par_username, 'Framed-IP-Address', '=', var_static_ip::text, 10);

                   UPDATE static_ip_pool SET is_assigned = 'TRUE',
                                             line_id = par_line_id
                   WHERE static_ip = var_static_ip 
                   AND groupname = par_groupname
                   AND carrier_id = var_carrier_id;
            
                   var_return := 'IP is assigned to radreply table and updated in static ip pool.';
             
              END IF;

       ELSE 

              var_return := 'IP already exists for the username in radreply table.';

       END IF;

            
 RETURN var_return;

END;
$_$;


ALTER FUNCTION csctoss.test_update_ip(integer, text, text, text) OWNER TO csctoss_owner;

--
-- Name: test_update_line(integer, integer, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION test_update_line(integer, integer, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE

   par_line_id            integer := $1; 
   par_equipment_id       integer := $2;
   par_username           text    := $3;
   var_return             text;
   

BEGIN 

        PERFORM public.set_change_log_staff_id(3) ;

   	IF ( par_line_id IS NULL AND par_equipment_id IS NULL ) THEN 

            RAISE EXCEPTION 'Input parameters are null.';

        ELSIF ( SELECT TRUE FROM line_equipment WHERE line_id = par_line_id and equipment_id = par_equipment_id and end_date IS NOT NULL) THEN 

           IF ( SELECT TRUE FROM line WHERE line_id = par_line_id and radius_username = par_username and end_date IS NULL ) THEN 

                 UPDATE line SET line_label = NULL, 
                                 end_date = current_date,
                                 radius_username = NULL               
                 WHERE line_id = par_line_id; 
              
                 var_return := 'Update is done successfully for the line.';

           ELSE 
                     
                  var_return := 'Line is already end dated and no update is necessary.';

           END IF;

           
       ELSE 
  
               var_return := 'This line is currently active in line_equipment table.';
       END IF;

            
 RETURN var_return;

END;
$_$;


ALTER FUNCTION csctoss.test_update_line(integer, integer, text) OWNER TO csctoss_owner;

--
-- Name: unique_id(integer, text); Type: FUNCTION; Schema: csctoss; Owner: postgres
--

CREATE FUNCTION unique_id(integer, text) RETURNS unique_id_retval
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $_$
DECLARE
    par_unique_type                    integer  := $1;
    par_value                          text     := $2;
    var_row                            RECORD;
    v_line_id                          integer;
    v_equipment_id                     integer;
    v_radius_username                  text;
    v_uim_value                        text;
    v_uis_value                        text;
    v_uie_value                        text;
    var_sql                            VARCHAR;
    var_mac                            text     := 'MAC ADDRESS';
    var_sn                             text     := 'SERIAL NUMBER';
    var_esn                            text     := 'ESN HEX';
    var_retval                         unique_id_retval%ROWTYPE;

BEGIN
  
  var_sql := 'select l.line_id
                ,le.equipment_id
                ,l.radius_username
                ,uim.value as uim
                ,uis.value as uis 
                ,uie.value as uie 
                ,NULL
            from line_equipment le
            join line l on l.line_id = le.line_id';

  var_sql := var_sql || ' join unique_identifier uim on le.equipment_id = uim.equipment_id and uim.unique_identifier_type = ';
  var_sql := var_sql || quote_literal(var_mac);
  var_sql := var_sql || ' join unique_identifier uis on le.equipment_id = uis.equipment_id and uis.unique_identifier_type = ';
  var_sql := var_sql || quote_literal(var_sn);
  var_sql := var_sql || ' join unique_identifier uie on le.equipment_id = uie.equipment_id and uie.unique_identifier_type = ';
  var_sql := var_sql || quote_literal(var_esn);

--  var_sql := var_sql || ' where ' || CASE WHEN par_unique_type = 1 
--                                    THEN 'uim.value = %L' 
--                                  WHEN par_unique_type = 2
--                                    THEN 'uis.value = %L'
--                                  ELSE 'uie.value = %L'
--                             END;
  var_sql := var_sql || ' where ' || CASE WHEN par_unique_type = 1 
                                    THEN 'uim.value = ' 
                                  WHEN par_unique_type = 2
                                    THEN 'uis.value = '
                                  ELSE 'uie.value = '
                             END;
  var_sql := var_sql || quote_literal(par_value);

--  EXECUTE format(var_sql) INTO unique_id_retval;
--  EXECUTE var_sql INTO unique_id_retval;

  FOR var_row IN
    EXECUTE var_sql
  LOOP
    var_retval.line_id         =  var_row.line_id;
    var_retval.equipment_id    =  var_row.equipment_id;
    var_retval.radius_username =  var_row.radius_username;
    var_retval.uim_value       =  var_row.uim;
    var_retval.uis_value       =  var_row.uis; 
    var_retval.uie_value       =  var_row.uie;
    var_retval.message         =  'Success';
--    RETURN var_return_row;
  END LOOP;

--   REUTRN;

--  var_retval.message          := 'Success';

  RETURN var_retval;

END ;
$_$;


ALTER FUNCTION csctoss.unique_id(integer, text) OWNER TO postgres;

--
-- Name: unique_identifier_record_delete(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION unique_identifier_record_delete() RETURNS "trigger"
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN

  IF public.get_change_log_staff_id() = -1 THEN
    PERFORM public.set_change_log_staff_id(3);
  END IF ;

  INSERT INTO unique_identifier_history
             (insert_or_update_or_delete
             ,equipment_id
             ,unique_identifier_type
             ,value
             ,notes
             ,date_created 
             ,date_modified
             )
      VALUES ('D'
              ,OLD.equipment_id
             ,OLD.unique_identifier_type
             ,OLD.value
             ,OLD.notes
             ,OLD.date_created 
             ,OLD.date_modified
           );

  RETURN OLD;

END;
$$;


ALTER FUNCTION csctoss.unique_identifier_record_delete() OWNER TO csctoss_owner;

--
-- Name: unique_identifier_record_insert(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION unique_identifier_record_insert() RETURNS "trigger"
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN

  IF public.get_change_log_staff_id() = -1 THEN
    PERFORM public.set_change_log_staff_id(3);
  END IF ;

  INSERT INTO unique_identifier_history
             (insert_or_update_or_delete
             ,equipment_id
             ,unique_identifier_type
             ,value
             ,notes
             ,date_created 
             ,date_modified
             )
      VALUES ('I'
              ,NEW.equipment_id
             ,NEW.unique_identifier_type
             ,NEW.value
             ,NEW.notes
             ,NEW.date_created 
             ,NEW.date_modified
           );

  RETURN NEW;

END;
$$;


ALTER FUNCTION csctoss.unique_identifier_record_insert() OWNER TO csctoss_owner;

--
-- Name: unique_identifier_record_update(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION unique_identifier_record_update() RETURNS "trigger"
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN

  IF public.get_change_log_staff_id() = -1 THEN
    PERFORM public.set_change_log_staff_id(3);
  END IF ;

  INSERT INTO unique_identifier_history
             (insert_or_update_or_delete
             ,equipment_id
             ,unique_identifier_type
             ,value
             ,notes
             ,date_created 
             ,date_modified
             )
      VALUES ('U'
              ,OLD.equipment_id
             ,OLD.unique_identifier_type
             ,OLD.value
             ,OLD.notes
             ,OLD.date_created 
             ,OLD.date_modified
           );

  RETURN NEW;

END;
$$;


ALTER FUNCTION csctoss.unique_identifier_record_update() OWNER TO csctoss_owner;

--
-- Name: universal_get_limit_wrapper(text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION universal_get_limit_wrapper(text) RETURNS universal_get_limit_retval
    LANGUAGE plpgsql STRICT SECURITY DEFINER
    AS $_$
DECLARE
	i_username				text := $1 ;
	v_counter				INTEGER ;
	v_line_id				INTEGER ;
	v_plan_id				INTEGER ;
	v_plan_type_id			INTEGER ;
	v_contract_plan			INTEGER ;
	v_billing_entity_type	TEXT ;
	v_found					BOOLEAN := TRUE ;
	v_is_expired			BOOLEAN := FALSE ;
	v_is_registered			BOOLEAN := FALSE ;
	v_prod_match			BOOLEAN := TRUE ;

	-- accumulators for future plans
	-- v_acc_days				INTEGER := 0 ;
	v_acc_minutes			INTEGER := 0 ;
	vr_future_plan			RECORD ;

	vr_return			universal_get_limit_retval ;
BEGIN
	-- ------------------------------------------------------------
	-- Set current month
	-- ------------------------------------------------------------
	vr_return.this_month := SUBSTR(current_date::TEXT,1,8) || '01' ;

	-- ------------------------------------------------------------
	-- Get the Line ID
	-- ------------------------------------------------------------
	SELECT "value"
	INTO   v_line_id
	FROM   csctoss.radreply
	WHERE  attribute = 'Class'
	AND    username = i_username ;

	IF v_line_id IS NULL THEN
		v_found := FALSE;
	END IF ;

	IF v_found = TRUE THEN
		-- ------------------------------------------------------------
		-- Determine contract_plan type
		-- ------------------------------------------------------------
		SELECT current_plan_id
		INTO   v_plan_id
		FROM   csctoss.line
		WHERE  line_id = v_line_id ;

		-- If the line has no current plan, we will use the last
		-- available plan
		IF v_plan_id IS NULL THEN
			v_is_expired = TRUE ;

			SELECT MAX(plan_id)
			INTO   v_plan_id
			FROM   csctoss.plan
			WHERE  line_id = v_line_id ;
		END IF ;

		SELECT plan_type_id
		INTO   v_plan_type_id
		FROM   csctoss.plan
		WHERE  plan_id = v_plan_id ;

		IF v_plan_type_id = 8 THEN
			v_contract_plan := 16 ;
		ELSE
			v_contract_plan := 0 ;
		END IF ;

		-- Check for expired product code
		SELECT COUNT(*)
		INTO   v_counter
		FROM   csctoss.plan
		       , csctoss.product AS prod
		WHERE  plan_id = v_plan_id
		AND    prod.product_id = plan.product_id
		AND    prod.product_code LIKE '%EXPIRED%' ;

		IF v_counter > 0 THEN
			v_is_expired := TRUE ;
		END IF ;

		-- ------------------------------------------------------------
		-- Populate record based on contract_plan type
		-- ------------------------------------------------------------

		-- Doccica HOURS products get minutes remaining.
		IF v_contract_plan = 16 THEN
			SELECT prepaid_balance
			INTO   vr_return.time_expires
			FROM   csctoss.plan
			WHERE  plan_id = v_plan_id ;
		END IF ;
 
		-- All products return end date
		-- Use most recent plan that does not have an end_date (if exists) and the length days
		SELECT COUNT(*)
		INTO   v_counter
		FROM   csctoss.plan
		WHERE  end_date IS NULL
		AND    line_id = v_line_id ;

		IF v_counter > 0 THEN
			-- At least one plan without an end_date exists
			-- Use the earliest plan without an end_date in case there are
			-- future plans in the plan queue
			SELECT start_date + length_days + 1
			INTO   vr_return.term_expires
			FROM   csctoss.plan
			WHERE  end_date IS NULL
			AND    plan_id = (SELECT MIN(plan_id)
							  FROM   csctoss.plan
							  WHERE  end_date IS NULL
							  AND    line_id = v_line_id)
			AND    line_id = v_line_id ;
		ELSE
			-- No plans without an end date exist, use end_date from last plan
			SELECT end_date
			INTO   vr_return.term_expires
			FROM   csctoss.plan
			WHERE  plan_id = (SELECT MAX(plan_id)
							  FROM   plan
							  WHERE  line_id = v_line_id)
			AND    line_id = v_line_id ;
		END IF ;

		-- Check for user registration
		SELECT is_user_registered
		INTO   v_is_registered
		FROM   csctoss.is_user_registered(i_username) ;

		IF v_is_registered THEN
			vr_return.user_registration := 1 ;
		ELSE
			vr_return.user_registration := 0 ;
		END IF ;

		-- ------------------------------------------------------------
		-- process any future plans
		--
		-- Note: Need to determine how to handle null end dates if they
		--       exist.
		-- ------------------------------------------------------------
		FOR vr_future_plan IN
			SELECT plan_id
				   , plan_type_id
				   , product_id
				   , COALESCE(end_date,current_date + 30) - start_date AS length_days
				   , prepaid_balance
			FROM   csctoss.plan
			WHERE  line_id = v_line_id
			AND    plan_id > v_plan_id
			ORDER BY plan_id
		LOOP
			-- Note: If we support multiple compatible plan types, need to add more
			--       logic here.
			IF vr_future_plan.plan_type_id = v_plan_type_id THEN
				v_prod_match := TRUE ;
			ELSE
				v_prod_match := FALSE ;
			END IF ;

			-- ------------------------------------------------------------
			-- If products match, check for additional minutes
			-- ------------------------------------------------------------
			IF v_prod_match THEN
				-- add minutes if products match
				v_acc_minutes := v_acc_minutes + vr_future_plan.prepaid_balance ;
			END IF ;
		END LOOP ;

		-- If minutes were accumulted, add them
		IF v_acc_minutes >= 0 AND v_acc_minutes IS NOT NULL THEN
			vr_return.time_expires := vr_return.time_expires + v_acc_minutes ;
		ELSE
			vr_return.time_expires := 0 ;
		END IF ;
		-- ------------------------------------------------------------
		-- END process future plans
		-- ------------------------------------------------------------
	ELSE
		-- Line ID not found
		vr_return.term_expires := '2010-07-01'::DATE ;
		vr_return.time_expires := 0 ;
		vr_return.user_registration := 0 ;
		v_contract_plan := 0 ;
	END IF ; -- check for line id

	-- All products return the contract_plan value
	vr_return.contract_plan  := v_contract_plan ;


   RETURN vr_return ;
END ;
$_$;


ALTER FUNCTION csctoss.universal_get_limit_wrapper(text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION universal_get_limit_wrapper(text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION universal_get_limit_wrapper(text) IS '$Id: universal_get_limit_wrapper.sql,v 1.4 2010/09/14 23:26:41 ktaylor Exp $ Created for Sprint Local Doccica based on code originally written for universalGetLimit in Japan';


--
-- Name: update_broadcast_message(integer, integer, text, date, date, text, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION update_broadcast_message(integer, integer, text, date, date, text, text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
 DECLARE 
 
       par_broadcast_id                       integer := $1;
       par_broadcast_message_group_id         integer := $2;
       par_created_by                         text := $3;
       par_start_date                         date := $4;
       par_end_date                           date := $5;
       par_subject                            text := $6;
       par_broadcast_message                  text := $7;
       par_message_priority                   text := $8;
       var_message_priority_id                integer;
       var_return                             text;
       
 BEGIN 
 
       IF par_broadcast_id IS NULL 
       AND par_broadcast_message_group_id IS NULL 
       AND par_created_by = ''
       AND par_start_date IS NULL  
       AND par_end_date IS NULL
       AND par_subject = ''
       AND par_broadcast_message = ''
       AND par_message_priority = '' THEN 
 
          RAISE EXCEPTION 'ERROR: All Input Values are Null.';
           
       ELSIF par_start_date > par_end_date OR par_end_date > (par_start_date + '30 days'::interval) THEN
 
           RAISE EXCEPTION 'Start Date is greater than end date or end date is more than 30 days of start date';
        
       ELSE 
             
           IF par_message_priority != '' THEN 
 
              SELECT message_priority_id 
              INTO var_message_priority_id 
              FROM message_priority
              WHERE message_priority = par_message_priority;

          END IF;
 
           UPDATE broadcast_message_data SET create_timestamp = now(),
                                             created_by = par_created_by,
                                             message_start_date = par_start_date, 
                                             message_end_date = par_end_date,
                                             subject = par_subject,
                                             broadcast_message = par_broadcast_message,
                                             message_priority_id = var_message_priority_id 
           WHERE broadcast_id = par_broadcast_id 
           AND broadcast_message_group_id = par_broadcast_message_group_id;
         
             IF NOT FOUND THEN 
 
                 RAISE EXCEPTION 'Update of the fields Failed!';
          
             END IF; 
        
        END IF;
                                             
  var_return := 'All the fields are updated successfully';
  RETURN var_return;
               

END;
$_$;


ALTER FUNCTION csctoss.update_broadcast_message(integer, integer, text, date, date, text, text, text) OWNER TO csctoss_owner;

--
-- Name: update_equipment_model(integer, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION update_equipment_model(integer, text) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE

 par_equipment_id                integer := $1;
 par_model_name                  text    := $2;
 var_old_equipment_model_id      integer; 
 var_new_equipment_model_id      integer;
 var_return                      text;

BEGIN

  PERFORM public.set_change_log_staff_id(3) ;

  IF ( par_equipment_id IS NULL AND par_model_name = '') THEN 

      RAISE EXCEPTION 'Input values are Null. Please enter a value.';
  
  ELSIF (par_equipment_id IS NULL ) THEN 

      RAISE EXCEPTION 'Equipment_ID value is NULL. Please enter a value.';

  ELSIF ( par_model_name = '') THEN 

      RAISE EXCEPTION 'Model name is Null. Please enter a value.';

  ELSE 

     -- Check if the equipment id exists 

     IF EXISTS ( SELECT TRUE FROM equipment WHERE equipment_id = par_equipment_id) THEN 

        SELECT equipment_model_id INTO var_old_equipment_model_id
        FROM equipment 
        WHERE equipment_id = par_equipment_id; 

         IF NOT FOUND THEN 
 
             var_return := 'Old equipment model doesnt exists.';
             RETURN NEXT var_return;
             RETURN; 
         
         END IF; 
 
            -- Validate the model_name 
       
             SELECT equipment_model_id INTO var_new_equipment_model_id 
             FROM equipment_model
             WHERE model_number1 = par_model_name; 

              IF ( var_old_equipment_model_id != var_new_equipment_model_id ) THEN 

                  -- Update equipment model id in equipment table 

                   UPDATE equipment SET equipment_model_id = var_new_equipment_model_id 
                   WHERE equipment_id = par_equipment_id; 

                     IF NOT FOUND THEN 
 
                          var_return := 'Update Failed.';
                          RETURN NEXT var_return;
                          RETURN; 
                     
                     END IF;

               END IF;
     
         END IF;

    END IF;       

 var_return := 'Updated successfully.';
 RETURN NEXT var_return;
 RETURN; 

END;

$_$;


ALTER FUNCTION csctoss.update_equipment_model(integer, text) OWNER TO csctoss_owner;

--
-- Name: update_groupname_verizon_lines(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION update_groupname_verizon_lines() RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE

  var_uniqid_row              RECORD;
  var_username                text;
  var_attribute               text;
  var_value                   text;
  var_groupname               text;

BEGIN

  PERFORM public.set_change_log_staff_id(3) ;

  RAISE NOTICE 'Entering Function.';

  FOR var_uniqid_row IN SELECT rr.username, rr.attribute, 
                               rr.value, ug.groupname
                        FROM radreply rr
                        JOIN usergroup ug ON (rr.username = ug.username)
                        WHERE rr.username LIKE '%@vzw3g.com'
                        AND rr.attribute LIKE 'Framed-IP-Address'
                        AND ( rr.value::inet <<= inet '10.80.0.0/13' OR rr.value::inet <<= inet '10.88.0.0/13' )
                        AND ug.groupname NOT LIKE 'SERVICE-vzw%'
						
          LOOP 
            
               var_username := var_uniqid_row.username;
	       var_attribute := var_uniqid_row.attribute;
	       var_value := var_uniqid_row.value;
	       var_groupname := var_uniqid_row.groupname;
                 
                IF var_username = '' OR var_attribute = '' OR var_value = '' OR var_groupname = '' THEN 
                  
                    RAISE EXCEPTION 'The username/attribute/value/groupname is Null. Hence the values cant be updated.';
               
                ELSE 			   
                
		      IF ( var_value::inet <<= inet '10.80.0.0./13') THEN 
			
			   UPDATE usergroup SET groupname = 'SERVICE-vzw_pool1' 
			   WHERE username = var_username;
					
		      ELSIF ( var_value::inet <<= inet '10.88.0.0./13' ) THEN 
					 
                              UPDATE usergroup SET groupname = 'SERVICE-vzw_pool2'
                              WHERE username = var_username;
						 
		      ELSE 
					 
			     RAISE EXCEPTION 'Update Failed as the IP range doesnt fall under Verizon.';
						 
		      END IF;
					
		END IF;
               
          END LOOP;
       
	   RAISE NOTICE 'Finished Function';

	   RETURN 'The changes are done on usergroup table.';

  END ;

$$;


ALTER FUNCTION csctoss.update_groupname_verizon_lines() OWNER TO csctoss_owner;

--
-- Name: update_ips_pool(text, text[], text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION update_ips_pool(text, text[], text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
 DECLARE 

        par_groupname                     text := $1;
        par_username                      ALIAS FOR $2;
        par_carrier                       text := $3;  
        var_static_ip                     text; 
        var_line_id                       integer;
        var_return                        text;
        var_username                      text;
        var_ip                       text;

BEGIN 

     PERFORM public.set_change_log_staff_id(3) ;

     IF par_groupname = '' AND par_carrier = '' THEN 

          RAISE EXCEPTION 'ERROR: All Input Values are Null.'; 
 
     ELSIF array_lower(par_username, 1) IS NULL THEN 

          RAISE EXCEPTION 'Username Array is Null.';

     END IF; 

     FOR i IN array_lower(par_username, 1)..array_upper(par_username,1)

       LOOP

            var_username := '';
            var_username := par_username[i]; 

             IF EXISTS( SELECT * FROM radreply WHERE username = var_username AND attribute = 'Framed-IP-Address') THEN

                   SELECT value INTO var_ip FROM radreply
                   WHERE username = var_username AND attribute = 'Framed-IP-Address'; 

                   UPDATE static_ip_pool SET is_assigned = FALSE, line_id = NULL
	           WHERE static_ip = var_ip AND groupname = par_groupname;

                   DELETE FROM radreply WHERE username = var_username AND attribute = 'Framed-IP-Address';

               ELSE
                      
                    RAISE EXCEPTION 'No static ip is assigned.';

              END IF; 
             
           --END IF; 
       
        END LOOP; 

 var_return := 'Static ips have been deleted.';
 RETURN var_return; 

END; 
$_$;


ALTER FUNCTION csctoss.update_ips_pool(text, text[], text) OWNER TO csctoss_owner;

--
-- Name: update_line_label(integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION update_line_label(integer) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE

  var_current_line_label      text;
  var_correct_line_label      text;
  par_line_id                 integer := $1;
  var_return_row              text;

BEGIN

  PERFORM public.set_change_log_staff_id(257) ;

  IF par_line_id IS NULL THEN 

      var_return_row := 'Input parameters are null.';
      RETURN NEXT var_return_row;
      RETURN;
  
 ELSE
  
        SELECT l.line_label, uniq.value 
        INTO var_current_line_label, 
             var_correct_line_label
        FROM line l
        JOIN line_equipment lieq ON (l.line_id = lieq.line_id)
        JOIN unique_identifier uniq ON (lieq.equipment_id = uniq.equipment_id)
        WHERE lieq.end_date IS NULL 
        AND uniq.unique_identifier_type LIKE 'ESN HEX'
        AND l.line_id = par_line_id;

           UPDATE line SET line_label = var_correct_line_label WHERE line_id = par_line_id AND line_label = var_current_line_label;             
                                      
                  IF NOT FOUND THEN 

                      RAISE EXCEPTION 'Update Failed';
                 END IF;
         
         
  
  END IF;       
     var_return_row := 'Update done';
         RETURN NEXT var_return_row;
         RETURN;
END;

$_$;


ALTER FUNCTION csctoss.update_line_label(integer) OWNER TO csctoss_owner;

--
-- Name: update_line_label_all(date, date); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION update_line_label_all(date, date) RETURNS SETOF update_line_label_all_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_start_date              date := $1;
  par_end_date                date := $2;
  var_current_line_label      text;
  var_correct_line_label      text;
  var_line_id                 integer;
  var_uniqid_row              RECORD;
  v_query                     text;
  var_return_row              update_line_label_all_retval%ROWTYPE;

BEGIN

  PERFORM public.set_change_log_staff_id(257) ;

  RAISE NOTICE 'Entering Function.';

  IF par_start_date IS NULL AND par_end_date IS NULL THEN 

      var_return_row := 'Input parameters are null.';
      RETURN NEXT var_return_row;
      RETURN;
  
  END IF;
  
   IF par_start_date >= par_end_date THEN 
 
      var_return_row := 'Input parameters are not consistent.';
      RETURN NEXT var_return_row;
      RETURN;

   
     END IF;

      FOR var_uniqid_row IN SELECT l.line_id, l.line_label, uniq.value
                            FROM line l
                            JOIN line_equipment lieq ON (l.line_id = lieq.line_id)
                            JOIN unique_identifier uniq ON (lieq.equipment_id = uniq.equipment_id)
                            WHERE lieq.end_date IS NULL
                            AND uniq.unique_identifier_type = 'ESN HEX'
                            AND l.start_date >= (par_start_date)::date
                            AND l.start_date <= (par_end_date)::date
                            AND l.line_label <> uniq.value

          LOOP 
            
               var_line_id := var_uniqid_row.line_id;
               var_current_line_label := var_uniqid_row.line_label;
               var_correct_line_label := var_uniqid_row.value;
                     
               UPDATE line SET line_label = var_correct_line_label WHERE line_id = var_line_id AND line_label = var_current_line_label;
              
               FOR var_return_row IN 
                        
                   SELECT l.line_id, l.line_label, uniq.value
                    FROM line l
                  JOIN line_equipment lieq ON (l.line_id = lieq.line_id)
                  JOIN unique_identifier uniq ON (lieq.equipment_id = uniq.equipment_id)
                  WHERE lieq.end_date IS NULL 
                  AND uniq.unique_identifier_type LIKE 'ESN HEX'
                  AND l.line_id = var_line_id
 
                  LOOP 
      
                     RETURN NEXT var_return_row;
 
               END LOOP;
               END LOOP;
       
              RAISE NOTICE 'Finished Function';

	     RETURN;

  END ;

$_$;


ALTER FUNCTION csctoss.update_line_label_all(date, date) OWNER TO csctoss_owner;

--
-- Name: update_radcheck_verizon_lines(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION update_radcheck_verizon_lines() RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE

  var_uniqid_row              RECORD;
  v_query                     text;
  var_username                text;
  var_attribute               text;

BEGIN

  PERFORM public.set_change_log_staff_id(3) ;

  RAISE NOTICE 'Entering Function.';

  FOR var_uniqid_row IN SELECT username, attribute 
                        FROM radcheck
                        WHERE username LIKE '%@vzw3g.com'
			AND attribute LIKE 'ClearText-Password'
						
          LOOP 
            
               var_username := var_uniqid_row.username;
	       var_attribute := var_uniqid_row.attribute;
                 
                IF var_username = '' OR var_attribute = '' THEN 
                  
                    RAISE EXCEPTION 'No username or attribute exists for the verizon realm.';
               
                ELSIF NOT EXISTS ( SELECT TRUE FROM radcheck WHERE attribute = 'Auth-Type' AND username = var_username ) THEN 
                
		    INSERT INTO radcheck (username, attribute, op, value) 
                        VALUES (var_username, 'Auth-Type', ':=', 'Accept');				
               
 	             DELETE FROM radcheck 
                     WHERE username = var_username 
		     AND attribute = var_attribute;
					 
                ELSE 

                     DELETE FROM radcheck WHERE username = var_username AND attribute = var_attribute; 

		END IF;
               
          END LOOP;
       
      RAISE NOTICE 'Finished Function';

  RETURN 'The changes are done on radcheck table.';

  END ;

$$;


ALTER FUNCTION csctoss.update_radcheck_verizon_lines() OWNER TO csctoss_owner;

--
-- Name: update_static_ip_line_beid(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION update_static_ip_line_beid() RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  
  var_be_id                   INTEGER;
  var_line_id                 INTEGER;
  var_username                TEXT;
  var_static_ip               TEXT;
  var_sip_line_id             INTEGER;
  var_sip_beid                INTEGER;
  var_uniqid_row              RECORD; 

BEGIN

  PERFORM public.set_change_log_staff_id(3) ;

  RAISE NOTICE 'Entering Function.';

  FOR var_uniqid_row IN SELECT be.billing_entity_id AS beid,
                               line.line_id AS line_id,
                               line.radius_username AS radius_username,
                               rr.value AS radreply_ip_address,
                               sip.line_id AS sip_line_id,
                               sip.billing_entity_id AS sip_beid
                        FROM billing_entity be 
                        JOIN line ON (be.billing_entity_id = line.billing_entity_id) 
                        JOIN line_equipment le ON (le.line_id = line.line_id) 
                        JOIN radreply rr ON (rr.username = line.radius_username AND rr.attribute = 'Framed-IP-Address')
                        LEFT OUTER JOIN static_ip_pool sip ON (sip.static_ip = rr.value) 
                        WHERE le.end_date IS NULL 
                         AND sip.billing_entity_id IS NOT NULL AND (
                        (be.billing_entity_id = sip.billing_entity_id) = FALSE
                        OR
                        (line.line_id = sip.line_id) = FALSE
                        )
						
        LOOP 
            
               var_be_id := var_uniqid_row.beid;
               var_line_id := var_uniqid_row.line_id;
               var_username := var_uniqid_row.radius_username;
               var_static_ip := var_uniqid_row.radreply_ip_address;
               var_sip_line_id := var_uniqid_row.sip_line_id; 
               var_sip_beid := var_uniqid_row.sip_beid;
                 
               IF ( (var_line_id <> var_sip_line_id) ) THEN 

                 UPDATE static_ip_pool SET line_id = var_line_id WHERE static_ip = var_static_ip; --AND line_id = var_sip_line_id; 

               ELSIF (var_be_id <> var_sip_beid ) THEN 
 
                  UPDATE static_ip_pool SET billing_entity_id = var_be_id WHERE static_ip = var_static_ip;
               
              END IF;
          END LOOP;
       
      RAISE NOTICE 'Finished Function';

  RETURN 'Line id and beid are updated.' ;

  END ;

$$;


ALTER FUNCTION csctoss.update_static_ip_line_beid() OWNER TO csctoss_owner;

--
-- Name: update_unique_identifier_value(integer, text, text, text); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION update_unique_identifier_value(integer, text, text, text) RETURNS SETOF ops_api_retval
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_equipment_id              int  := $1 ;
  par_unique_identifier_type    text := $2 ;
  par_old_value                 text := $3 ;
  par_new_value                 text := $4 ;
  v_numrows                     integer;
  var_return_row                ops_api_retval%ROWTYPE;

  v_errmsg                      text;

BEGIN

  PERFORM public.set_change_log_staff_id(3) ;

  -- Validate parameters.
  PERFORM true
    FROM unique_identifier
   WHERE equipment_id = par_equipment_id
     AND unique_identifier_type = par_unique_identifier_type
     AND value = par_old_value ;

  IF NOT FOUND THEN
    v_errmsg := 'Old value does not exist.';
    RAISE EXCEPTION '';
  END IF ;

  IF ( SELECT TRUE 
         FROM unique_identifier 
        WHERE unique_identifier_type = par_unique_identifier_type
          AND value = par_new_value ) THEN
    v_errmsg := 'Unique identifier type ' || par_unique_identifier_type || ' with value ' || par_new_value || ' already exists';
    RAISE EXCEPTION '';
  END IF;

  -- Just update unique identifier value from old to new.
  UPDATE csctoss.unique_identifier
     SET value = par_new_value
   WHERE equipment_id = par_equipment_id
     AND unique_identifier_type = par_unique_identifier_type
     AND value = par_old_value ;

  GET DIAGNOSTICS v_numrows = ROW_COUNT;
  IF v_numrows = 0 THEN
    v_errmsg := 'Update Failed!';
    RAISE EXCEPTION '';
  END IF;

  var_return_row.result_code := true ;
  var_return_row.error_message := 'Successful Update!' ;
  RETURN NEXT var_return_row ;
  RETURN ;

EXCEPTION
  WHEN raise_exception THEN
    var_return_row.result_code := false;
    var_return_row.error_message:=v_errmsg;
    RAISE NOTICE 'rt_oss_rma: when raise_exception:  % ',v_errmsg;
    RETURN NEXT var_return_row;
    RETURN;

  WHEN others THEN
    v_errmsg := 'Unknown error!';
    var_return_row.result_code := false;
    var_return_row.error_message := v_errmsg;
    RAISE NOTICE 'OTHER EXCEPTION:  %', v_errmsg;
    RETURN NEXT var_return_row;
    RETURN;

END ;
$_$;


ALTER FUNCTION csctoss.update_unique_identifier_value(integer, text, text, text) OWNER TO csctoss_owner;

--
-- Name: FUNCTION update_unique_identifier_value(integer, text, text, text); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION update_unique_identifier_value(integer, text, text, text) IS 'Function to update unique_identifier.value.';


--
-- Name: usage_monthly_summary_func(character varying); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION usage_monthly_summary_func(in_date character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
usage_rec                    record;
v_pool_count                 numeric;
v_base_mb                    numeric;
v_pooled                     boolean;
v_tot_threshold              numeric;
v_overage                    numeric(9,2);
v_tot_usage                  numeric(9,2);
v_prev_product_code          text:='initialize';
v_prev_billing_entity_id     integer:=999999999;
v_first_time                 boolean:=true;
v_row_count                  integer:=0;
v_row_tot_count              integer:=0;
v_count                      integer;
v_count_1                    integer;
v_count_2                    integer;
v_count_3                    integer;
v_count_4                    integer;
v_jbill_id                   integer;
v_usage_fee_text             text;

var_sql  text:='SELECT
       be.billing_entity_id
     , be.name
     , case
            when pooled then null
            else l.line_id
          end
     ,prd.product_code
     ,to_char(lud.usage_date,''yyyy-mm'') as usage_month
     ,sum(lud.acctinputoctets_utc) as input_octets
     ,sum(lud.acctoutputoctets_utc) as output_octets
  FROM
       line l,
       product_overage_threshold pot,
       line_usage_day lud,
       plan_type pt,
       plan pln ,
       product prd,
       billing_entity be
       where 1=1
         and pln.product_id=pot.product_id
         and pln.plan_type_id=pt.plan_type_id
         and pln.product_id=prd.product_id
         and l.line_id=pln.line_id
         and l.line_id=lud.line_id
         and l.billing_entity_id=be.billing_entity_id
         and to_char(usage_date,''yyyy-mm'')  = '||quote_literal(in_date)||
         ' group by
                  be.billing_entity_id,
                  be.name,
                  case
                      when pooled then null
                      else l.line_id
                  end
                  ,to_char(lud.usage_date,''yyyy-mm'')
                  ,product_code
          order by
                  be.billing_entity_id
                  ,product_code
                  ,case
                       when pooled then null
                       else l.line_id
                   end'
                  ;
begin
--   archive  all rows that contain the year/mo  passed to the function
     select count(*) into v_count_1 from csctoss.usage_monthly_summary 
     where  usage_date  = in_date
       and  not archived;
     if v_count_1 > 0 then
         raise notice 'Usage rows with % usage date already exist- these rows will be archived prior to summary process',in_date;
         select count(*) into v_count_2 from csctoss.usage_monthly_summary 
         where  archived ;
         update csctoss.usage_monthly_summary set archived = true
         where  usage_date  = in_date;
         select count(*) into v_count_3 from csctoss.usage_monthly_summary 
         where  archived;
         v_count_4:=v_count_3 - v_count_2;
         if  v_count_4 = v_count_1 then
             raise notice 'Archiving of % rows completed sucessfully',v_count_4;
             raise notice 'Summary process beginning';
         else
             raise notice 'Archiving of rows with % usage date was not sucessful- exiting function', in_date;
             return false;
         end if;
     else
        raise notice 'Summary process beginning';
     end if;
    
   for usage_rec in execute var_sql

    loop
        v_usage_fee_text:=null;
        select base_mb, pooled into v_base_mb, v_pooled
           from product prd,
           product_overage_threshold pot
           where 1=1 
             and product_code =usage_rec.product_code
             and prd.product_id = pot.product_id;
        if v_pooled then
            select count(*) into v_pool_count
            from plan pln,
                 product prd,
                 line l,
                 line_equipment le
            where 1=1
             and l.billing_entity_id=usage_rec.billing_entity_id
             and l.line_id = le.line_id
             and prd.product_code=usage_rec.product_code
             and prd.product_id = pln.product_id
             and l.line_id =  pln.line_id
--             and pln.end_date is null ;
               and le.end_date is null;
            else
               v_pool_count:=1;
           end if;
        v_tot_threshold:=v_pool_count * v_base_mb ;
        v_tot_usage:=((usage_rec.input_octets + usage_rec.output_octets) / 1048576);
        if v_tot_usage > v_tot_threshold then
             v_overage:=v_tot_usage - v_tot_threshold;
             if v_pooled  then
                v_usage_fee_text:='Data Overage Fee for Pooled Lines';
             else
                v_usage_fee_text:='Data Overage Fee for Line '||usage_rec.line_id;
             end if;
        else
             v_overage:=0;
        end if;
        select count(*) into v_count
        from csctoss.rating_engine_beid_trans rebt
        where 1=1
          and usage_rec.billing_entity_id = rebt.oss_beid ;
        if v_count > 0 then
            select jbill_id into v_jbill_id
            from csctoss.rating_engine_beid_trans rebt
            where 1=1
              and usage_rec.billing_entity_id = rebt.oss_beid ;
        else
             v_jbill_id:=null;
        end if;

       insert into csctoss.usage_monthly_summary
               (create_timestamp,
                archived ,
                billing_entity_id ,
                billing_entity_name,
                jbilling_id,
                product_code,
                line_id ,
                usage_date ,
                base_mb,
                num_of_lines_in_pool,
                total_threshold,
                acctinputoctets,
                acctoutputoctets,
                total_usage,
                usage_overage,
                usage_fee_text,
                usage_source 
              )
       values (
                current_timestamp,
                false,
                usage_rec.billing_entity_id,
                usage_rec.name,
                v_jbill_id,
                usage_rec.product_code,
                usage_rec.line_id,
                usage_rec.usage_month,
                v_base_mb,
                v_pool_count,
                v_tot_threshold ,
                usage_rec.input_octets,
                usage_rec.output_octets,
                (usage_rec.input_octets + usage_rec.output_octets) / 1048576,
                v_overage,
                v_usage_fee_text,
                'oss line_usage_day table'
               );
          v_row_count:=v_row_count+1;

          if v_row_count=500 then
              v_row_tot_count:=v_row_tot_count + v_row_count;
              raise notice 'rows inserted: %' ,v_row_tot_count;
              v_row_count:=0;
          end if;

    end loop;
         v_row_tot_count:=v_row_tot_count + v_row_count;
         raise notice 'total rows inserted: %' ,v_row_tot_count;
return true;
exception 
      when others then
      return false;
END;
  $$;


ALTER FUNCTION csctoss.usage_monthly_summary_func(in_date character varying) OWNER TO csctoss_owner;

--
-- Name: usage_overage_detection(integer, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION usage_overage_detection(integer, integer) RETURNS SETOF text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE

  par_threshold_hours     integer := $1 ;
  par_line_id             integer := $2 ;

  var_interval            interval;
  var_start_timestamp     timestamp ;
  var_end_timestamp       timestamp ;
  var_sql                 text ;

  var_line_rec            record ;
  var_overage_records     record ;

BEGIN

  -- Check parameters
  IF par_threshold_hours IS NULL THEN
    RETURN NEXT 'ERROR: Threshold hours required.' ;
    RETURN ;
  ELSE
    var_interval := par_threshold_hours || ' hours' ;
    var_start_timestamp := current_timestamp::timestamp(0) - var_interval ;
    var_end_timestamp := current_timestamp::timestamp(0) ;
  END IF ;

  IF par_line_id IS NOT NULL THEN
    PERFORM * FROM csctoss.line WHERE line_id = par_line_id ;
    IF NOT FOUND THEN
      RETURN NEXT 'ERROR: Line ID '||par_line_id::text||' does not exist.' ;
      RETURN ;
    END IF ;
  END IF ;

  PERFORM public.set_change_log_staff_id(9) ; -- Billing Engine user
  RETURN NEXT '[From=' || var_start_timestamp || ' To=' || var_end_timestamp || ']';
  RAISE NOTICE 'Calculation Term [% - %]', var_start_timestamp, var_end_timestamp ;


  -- Delete past 30 days rows
  DELETE FROM csctoss.line_usage_overage_calc
        WHERE usage_calc_end_timestamp < (current_timestamp - '30 days'::interval) ;


  -- Truncate and populate usage_overage_calc table with data based on given hours to capture all possible usage.
  EXECUTE 'TRUNCATE TABLE csctoss.usage_overage_calc' ;
  var_sql := 'INSERT INTO csctoss.usage_overage_calc
                   SELECT *
                     FROM public.dblink((SELECT * FROM csctoss.fetch_csctlog_conn())
                      ,''SELECT class
                               ,acctstarttime
                               ,acctstoptime
                               ,acctsessiontime
                               ,acctinputoctets
                               ,acctoutputoctets
                           FROM csctlog.master_radacct
                          WHERE class > \'\'0\'\'
                            AND acctstoptime >= \''||quote_literal(var_start_timestamp)||'\'
                            AND acctstoptime <  \''||quote_literal(var_end_timestamp)||'\'
                            AND acctstoptime IS NOT NULL'')
                       AS       rec_type(class            text
                                        ,acctstarttime    timestamptz
                                        ,acctstoptime     timestamptz
                                        ,acctsessiontime  bigint
                                        ,acctinputoctets  bigint
                                        ,acctoutputoctets bigint)' ;

  EXECUTE var_sql ;

  -- Do all calculations and work from the temp table
  FOR var_line_rec IN
          SELECT line.line_id,
                 'AAA' AS preferred_timezone,
                 SUM(COALESCE(EXTRACT(EPOCH FROM uclc.acctstoptime),0)) -
                 SUM(COALESCE(EXTRACT(EPOCH FROM uclc.acctstarttime),0)) AS time_connected,
                 SUM(COALESCE(uclc.acctsessiontime,0)) AS acctsessiontime,
                 SUM(COALESCE(uclc.acctinputoctets,0)) AS acctinputoctets,
                 SUM(COALESCE(uclc.acctoutputoctets,0)) AS acctoutputoctets,
                 SUM(COALESCE(uclc.acctinputoctets,0) + COALESCE(uclc.acctoutputoctets,0)) AS accttotaloctets,
                 SUM(COALESCE(uclc.acctinputoctets,0) + COALESCE(uclc.acctoutputoctets,0)) / 1024 / 1024 AS accttotaloctets_mb,
                 MAX(bent.name) AS billing_entity_name,
                 MAX(line.radius_username) AS username,
                 MAX(prd.product_code) AS product_code,
                 MAX(prd.base_mb) AS base_mb,
                 MAX(prd.alert_threshold_mb) AS alert_threshold_mb,
                 bool_or(prd.pooled) AS pooled_product,
                 COUNT(*) AS rowcount
            FROM csctoss.line
            JOIN csctoss.billing_entity bent USING (billing_entity_id)
            JOIN csctoss.plan USING (line_id)
            JOIN csctoss.product_overage_threshold_vw prd USING (product_id)
            JOIN csctoss.usage_overage_calc uclc ON (line.line_id::varchar = uclc.class)
           WHERE 1=1
             AND uclc.acctstoptime at time zone 'UTC' >= var_start_timestamp
             AND uclc.acctstoptime at time zone 'UTC' <  var_end_timestamp
        GROUP BY line.line_id,
                 bent.preferred_timezone
          HAVING TRUNC(((SUM(COALESCE(uclc.acctinputoctets,0) + COALESCE(uclc.acctoutputoctets,0))) / 1024 / 1024)) >= MAX(prd.alert_threshold_mb)

           UNION

          SELECT line.line_id,
                 bent.preferred_timezone,
                 SUM(COALESCE(EXTRACT(EPOCH FROM uclc.acctstoptime),0)) -
                 SUM(COALESCE(EXTRACT(EPOCH FROM uclc.acctstarttime),0)) AS time_connected,
                 SUM(COALESCE(uclc.acctsessiontime,0)) AS acctsessiontime,
                 SUM(COALESCE(uclc.acctinputoctets,0)) AS acctinputoctets,
                 SUM(COALESCE(uclc.acctoutputoctets,0)) AS acctoutputoctets,
                 SUM(COALESCE(uclc.acctinputoctets,0) + COALESCE(uclc.acctoutputoctets,0)) AS accttotaloctets,
                 SUM(COALESCE(uclc.acctinputoctets,0) + COALESCE(uclc.acctoutputoctets,0)) / 1024 / 1024 AS accttotaloctets_mb,
                 MAX(bent.name) AS billing_entity_name,
                 MAX(line.radius_username) AS username,
                 MAX(prd.product_code) AS product_code,
                 MAX(prd.base_mb) AS base_mb,
                 MAX(prd.alert_threshold_mb) AS alert_threshold_mb,
                 bool_or(prd.pooled) AS pooled_product,
                 COUNT(*) AS rowcount
            FROM csctoss.line
            JOIN csctoss.billing_entity bent USING (billing_entity_id)
            JOIN csctoss.plan USING (line_id)
            JOIN csctoss.product_overage_threshold_vw prd USING (product_id)
            JOIN csctoss.usage_overage_calc uclc ON (line.line_id::varchar = uclc.class)
           WHERE 1=1
             AND uclc.acctstoptime at time zone bent.preferred_timezone >= var_start_timestamp
             AND uclc.acctstoptime at time zone bent.preferred_timezone <  var_end_timestamp
        GROUP BY line.line_id,
                 bent.preferred_timezone
          HAVING TRUNC(((SUM(COALESCE(uclc.acctinputoctets,0) + COALESCE(uclc.acctoutputoctets,0))) / 1024 / 1024)) >= MAX(prd.alert_threshold_mb)

        ORDER BY line_id,
                 preferred_timezone

  LOOP

    -- Make sure this is a valid line id
    PERFORM TRUE FROM csctoss.line WHERE line_id::varchar = var_line_rec.line_id ;

    IF NOT FOUND THEN
      RETURN NEXT 'ERROR: No corresponding Line Id found for MRAD Class '||var_line_rec.line_id||'.' ;
    ELSE

      -- This is a UTC record
      IF var_line_rec.preferred_timezone = 'AAA' THEN

        -- Populate the line record for given usage date for UTC values
        INSERT INTO csctoss.line_usage_overage_calc
                   (line_id
                   ,timezone
                   ,usage_calc_start_timestamp
                   ,usage_calc_end_timestamp
                   ,billing_entity_name
                   ,username
                   ,product_code
                   ,pooled_product
                   ,alert_threshold_mb
                   ,time_connected_utc
                   ,acctsessiontime_utc
                   ,acctinputoctets_utc
                   ,acctoutputoctets_utc
                   ,rowcount_utc)
            VALUES (var_line_rec.line_id
                   ,'UTC'
                   ,var_start_timestamp
                   ,var_end_timestamp
                   ,var_line_rec.billing_entity_name
                   ,var_line_rec.username
                   ,var_line_rec.product_code
                   ,var_line_rec.pooled_product
                   ,var_line_rec.alert_threshold_mb
                   ,var_line_rec.time_connected
                   ,var_line_rec.acctsessiontime
                   ,var_line_rec.acctinputoctets
                   ,var_line_rec.acctoutputoctets
                   ,var_line_rec.rowcount) ;
      ELSE

        -- This is a tz record, do an update and trap failure, then transform into an insert
        UPDATE csctoss.line_usage_overage_calc
           SET timezone             = var_line_rec.preferred_timezone
              ,time_connected_tz    = var_line_rec.time_connected
              ,acctsessiontime_tz   = var_line_rec.acctsessiontime
              ,acctinputoctets_tz   = var_line_rec.acctinputoctets
              ,acctoutputoctets_tz  = var_line_rec.acctoutputoctets
              ,rowcount_tz          = var_line_rec.rowcount
         WHERE line_id              = var_line_rec.line_id
           AND usage_calc_start_timestamp::timestamp(0) = var_start_timestamp::timestamp(0)
           AND usage_calc_end_timestamp::timestamp(0) = var_end_timestamp::timestamp(0) ;

        IF NOT FOUND THEN
          -- Perform and insert for the entire record based on tz values
          INSERT INTO csctoss.line_usage_overage_calc
                     (line_id
                     ,timezone
                     ,usage_calc_start_timestamp
                     ,usage_calc_end_timestamp
                     ,billing_entity_name
                     ,username
                     ,product_code
                     ,pooled_product
                     ,alert_threshold_mb
                     ,time_connected_utc
                     ,acctsessiontime_utc
                     ,acctinputoctets_utc
                     ,acctoutputoctets_utc
                     ,rowcount_utc
                     ,time_connected_tz
                     ,acctsessiontime_tz
                     ,acctinputoctets_tz
                     ,acctoutputoctets_tz
                     ,rowcount_tz)
              VALUES (var_line_rec.line_id
                     ,var_line_rec.preferred_timezone
                     ,var_start_timestamp
                     ,var_end_timestamp
                     ,var_line_rec.billing_entity_name
                     ,var_line_rec.username
                     ,var_line_rec.product_code
                     ,var_line_rec.pooled_product
                     ,var_line_rec.alert_threshold_mb
                     ,0
                     ,0
                     ,0
                     ,0
                     ,0
                     ,var_line_rec.time_connected
                     ,var_line_rec.acctsessiontime
                     ,var_line_rec.acctinputoctets
                     ,var_line_rec.acctoutputoctets
                     ,var_line_rec.rowcount) ;
        END IF ;
      END IF ;
    END IF ;
  END LOOP ;


  --
  -- Returns all usage overage records.
  --
  RETURN NEXT 'line_id' ||
             ',billing_entity_name' ||
             ',username' ||
             ',product_code' ||
             ',pooled_product' ||
             ',alert_threshold_mb' ||
             ',acct_total_volume_mb' ||
             ',time_connected_utc' ||
             ',acctsessiontime_utc' ||
             ',acctinputoctets_utc' ||
             ',acctoutputoctets_utc' ||
             ',rowcount_utc' ;

  FOR var_overage_records IN
    SELECT line_id,
           billing_entity_name,
           username,
           product_code,
           CASE WHEN pooled_product = true THEN 'Pooled'::text ELSE 'NotPooled'::text END AS pooled_product,
           alert_threshold_mb,
           TRUNC(((COALESCE(acctinputoctets_utc,0) + COALESCE(acctoutputoctets_utc,0)) / 1024 / 1024)) AS acct_total_volume_mb,
           time_connected_utc,
           acctsessiontime_utc,
           acctinputoctets_utc,
           acctoutputoctets_utc,
           rowcount_utc
      FROM csctoss.line_usage_overage_calc
     WHERE TRUNC(((COALESCE(acctinputoctets_utc,0) + COALESCE(acctoutputoctets_utc,0)) / 1024 / 1024)) >= alert_threshold_mb
       AND usage_calc_end_timestamp::timestamp(0) = var_end_timestamp::timestamp(0)
  LOOP

    RETURN NEXT var_overage_records ;
  END LOOP ;

  RETURN NEXT 'SUCCESS' ;
  RETURN ;

END;
$_$;


ALTER FUNCTION csctoss.usage_overage_detection(integer, integer) OWNER TO csctoss_owner;

--
-- Name: FUNCTION usage_overage_detection(integer, integer); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION usage_overage_detection(integer, integer) IS 'This function detects usage overage customers based on gived hours.';


--
-- Name: usage_overage_detection2(integer, integer); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION usage_overage_detection2(integer, integer) RETURNS SETOF text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE

  par_threshold_hours     integer := $1 ;
  par_line_id             integer := $2 ;

  var_interval            interval;
  var_start_timestamp     timestamp ;
  var_end_timestamp       timestamp ;
  var_sql                 text ;

  var_line_rec            record ;
  var_overage_records     record ;

BEGIN

  -- Check parameters
  IF par_threshold_hours IS NULL THEN
    RETURN NEXT 'ERROR: Threshold hours required.' ;
    RETURN ;
  ELSE
    var_interval := par_threshold_hours || ' hours' ;
    var_start_timestamp := current_timestamp::timestamp(0) - var_interval ;
    var_end_timestamp := current_timestamp::timestamp(0) ;
  END IF ;

  IF par_line_id IS NOT NULL THEN
    PERFORM * FROM csctoss.line WHERE line_id = par_line_id ;
    IF NOT FOUND THEN
      RETURN NEXT 'ERROR: Line ID '||par_line_id::text||' does not exist.' ;
      RETURN ;
    END IF ;
  END IF ;

  PERFORM public.set_change_log_staff_id(9) ; -- Billing Engine user
  RETURN NEXT '[From=' || var_start_timestamp || ' To=' || var_end_timestamp || ']';
  RAISE NOTICE 'Calculation Term [% - %]', var_start_timestamp, var_end_timestamp ;


  -- Delete past 30 days rows
  DELETE FROM csctoss.line_usage_overage_calc
        WHERE usage_calc_end_timestamp < (current_timestamp - '30 days'::interval) ;


  -- Truncate and populate usage_overage_calc table with data based on given hours to capture all possible usage.
  EXECUTE 'TRUNCATE TABLE csctoss.usage_overage_calc' ;
  var_sql := 'INSERT INTO csctoss.usage_overage_calc
                   SELECT *
                     FROM public.dblink((SELECT * FROM csctoss.fetch_csctlog_conn())
                      ,''SELECT class
                               ,acctstarttime
                               ,acctstoptime
                               ,acctsessiontime
                               ,acctinputoctets
                               ,acctoutputoctets
                           FROM csctlog.master_radacct
                          WHERE class > \'\'0\'\'
                            AND acctstoptime >= \''||quote_literal(var_start_timestamp)||'\'
                            AND acctstoptime <  \''||quote_literal(var_end_timestamp)||'\'
                            AND acctstoptime IS NOT NULL'')
                       AS       rec_type(class            text
                                        ,acctstarttime    timestamptz
                                        ,acctstoptime     timestamptz
                                        ,acctsessiontime  bigint
                                        ,acctinputoctets  bigint
                                        ,acctoutputoctets bigint)' ;

  EXECUTE var_sql ;

  -- Do all calculations and work from the temp table
  FOR var_line_rec IN
          SELECT line.line_id,
                 'AAA' AS preferred_timezone,
                 SUM(COALESCE(EXTRACT(EPOCH FROM uclc.acctstoptime),0)) -
                 SUM(COALESCE(EXTRACT(EPOCH FROM uclc.acctstarttime),0)) AS time_connected,
                 SUM(COALESCE(uclc.acctsessiontime,0)) AS acctsessiontime,
                 SUM(COALESCE(uclc.acctinputoctets,0)) AS acctinputoctets,
                 SUM(COALESCE(uclc.acctoutputoctets,0)) AS acctoutputoctets,
                 SUM(COALESCE(uclc.acctinputoctets,0) + COALESCE(uclc.acctoutputoctets,0)) AS accttotaloctets,
                 SUM(COALESCE(uclc.acctinputoctets,0) + COALESCE(uclc.acctoutputoctets,0)) / 1024 / 1024 AS accttotaloctets_mb,
                 MAX(bent.name) AS billing_entity_name,
                 MAX(line.radius_username) AS username,
                 MAX(prd.product_code) AS product_code,
                 MAX(prd.base_mb) AS base_mb,
                 MAX(prd.alert_threshold_mb) AS alert_threshold_mb,
                 bool_or(prd.pooled) AS pooled_product,
                 COUNT(*) AS rowcount
            FROM csctoss.line
            JOIN csctoss.billing_entity bent USING (billing_entity_id)
            JOIN csctoss.plan USING (line_id)
            JOIN csctoss.product_overage_threshold_vw prd USING (product_id)
            JOIN csctoss.usage_overage_calc uclc ON (line.line_id::varchar = uclc.class)
           WHERE 1=1
             AND uclc.acctstoptime AT TIME ZONE 'UTC' >= var_start_timestamp
             AND uclc.acctstoptime AT TIME ZONE 'UTC' <  var_end_timestamp
             AND prd.pooled = FALSE
        GROUP BY line.line_id,
                 bent.preferred_timezone
          HAVING TRUNC(((SUM(COALESCE(uclc.acctinputoctets,0) + COALESCE(uclc.acctoutputoctets,0))) / 1024 / 1024)) > 0
          --HAVING TRUNC(((SUM(COALESCE(uclc.acctinputoctets,0) + COALESCE(uclc.acctoutputoctets,0))) / 1024 / 1024)) >= MAX(prd.alert_threshold_mb)

           UNION

          SELECT line.line_id,
                 bent.preferred_timezone,
                 SUM(COALESCE(EXTRACT(EPOCH FROM uclc.acctstoptime),0)) -
                 SUM(COALESCE(EXTRACT(EPOCH FROM uclc.acctstarttime),0)) AS time_connected,
                 SUM(COALESCE(uclc.acctsessiontime,0)) AS acctsessiontime,
                 SUM(COALESCE(uclc.acctinputoctets,0)) AS acctinputoctets,
                 SUM(COALESCE(uclc.acctoutputoctets,0)) AS acctoutputoctets,
                 SUM(COALESCE(uclc.acctinputoctets,0) + COALESCE(uclc.acctoutputoctets,0)) AS accttotaloctets,
                 SUM(COALESCE(uclc.acctinputoctets,0) + COALESCE(uclc.acctoutputoctets,0)) / 1024 / 1024 AS accttotaloctets_mb,
                 MAX(bent.name) AS billing_entity_name,
                 MAX(line.radius_username) AS username,
                 MAX(prd.product_code) AS product_code,
                 MAX(prd.base_mb) AS base_mb,
                 MAX(prd.alert_threshold_mb) AS alert_threshold_mb,
                 bool_or(prd.pooled) AS pooled_product,
                 COUNT(*) AS rowcount
            FROM csctoss.line
            JOIN csctoss.billing_entity bent USING (billing_entity_id)
            JOIN csctoss.plan USING (line_id)
            JOIN csctoss.product_overage_threshold_vw prd USING (product_id)
            JOIN csctoss.usage_overage_calc uclc ON (line.line_id::varchar = uclc.class)
           WHERE 1=1
             AND uclc.acctstoptime AT TIME ZONE bent.preferred_timezone >= var_start_timestamp
             AND uclc.acctstoptime AT TIME ZONE bent.preferred_timezone <  var_end_timestamp
             AND prd.pooled = FALSE
        GROUP BY line.line_id,
                 bent.preferred_timezone
          HAVING TRUNC(((SUM(COALESCE(uclc.acctinputoctets,0) + COALESCE(uclc.acctoutputoctets,0))) / 1024 / 1024)) > 0
          --HAVING TRUNC(((SUM(COALESCE(uclc.acctinputoctets,0) + COALESCE(uclc.acctoutputoctets,0))) / 1024 / 1024)) >= MAX(prd.alert_threshold_mb)

        ORDER BY line_id,
                 preferred_timezone

  LOOP

    -- Make sure this is a valid line id
    PERFORM TRUE FROM csctoss.line WHERE line_id::varchar = var_line_rec.line_id ;

    IF NOT FOUND THEN
      RETURN NEXT 'ERROR: No corresponding Line Id found for MRAD Class '||var_line_rec.line_id||'.' ;
    ELSE

      -- This is a UTC record
      IF var_line_rec.preferred_timezone = 'AAA' THEN

        -- Populate the line record for given usage date for UTC values
        INSERT INTO csctoss.line_usage_overage_calc
                   (line_id
                   ,timezone
                   ,usage_calc_start_timestamp
                   ,usage_calc_end_timestamp
                   ,billing_entity_name
                   ,username
                   ,product_code
                   ,pooled_product
                   ,alert_threshold_mb
                   ,time_connected_utc
                   ,acctsessiontime_utc
                   ,acctinputoctets_utc
                   ,acctoutputoctets_utc
                   ,rowcount_utc)
            VALUES (var_line_rec.line_id
                   ,'UTC'
                   ,var_start_timestamp
                   ,var_end_timestamp
                   ,var_line_rec.billing_entity_name
                   ,var_line_rec.username
                   ,var_line_rec.product_code
                   ,var_line_rec.pooled_product
                   ,var_line_rec.alert_threshold_mb
                   ,var_line_rec.time_connected
                   ,var_line_rec.acctsessiontime
                   ,var_line_rec.acctinputoctets
                   ,var_line_rec.acctoutputoctets
                   ,var_line_rec.rowcount) ;
      ELSE

        -- This is a tz record, do an update and trap failure, then transform into an insert
        UPDATE csctoss.line_usage_overage_calc
           SET timezone             = var_line_rec.preferred_timezone,
               time_connected_tz    = var_line_rec.time_connected,
               acctsessiontime_tz   = var_line_rec.acctsessiontime,
               acctinputoctets_tz   = var_line_rec.acctinputoctets,
               acctoutputoctets_tz  = var_line_rec.acctoutputoctets,
               rowcount_tz          = var_line_rec.rowcount
         WHERE line_id              = var_line_rec.line_id
           AND usage_calc_start_timestamp::timestamp(0) = var_start_timestamp::timestamp(0)
           AND usage_calc_end_timestamp::timestamp(0) = var_end_timestamp::timestamp(0) ;

        IF NOT FOUND THEN
          -- Perform and insert for the entire record based on tz values
          INSERT INTO csctoss.line_usage_overage_calc
                     (line_id,
                      timezone,
                      usage_calc_start_timestamp,
                      usage_calc_end_timestamp,
                      billing_entity_name,
                      username,
                      product_code,
                      pooled_product,
                      alert_threshold_mb,
                      time_connected_utc,
                      acctsessiontime_utc,
                      acctinputoctets_utc,
                      acctoutputoctets_utc,
                      rowcount_utc,
                      time_connected_tz,
                      acctsessiontime_tz,
                      acctinputoctets_tz,
                      acctoutputoctets_tz,
                      rowcount_tz)
              VALUES (var_line_rec.line_id,
                      var_line_rec.preferred_timezone,
                      var_start_timestamp,
                      var_end_timestamp,
                      var_line_rec.billing_entity_name,
                      var_line_rec.username,
                      var_line_rec.product_code,
                      var_line_rec.pooled_product,
                      var_line_rec.alert_threshold_mb,
                      0,
                      0,
                      0,
                      0,
                      0,
                      var_line_rec.time_connected,
                      var_line_rec.acctsessiontime,
                      var_line_rec.acctinputoctets,
                      var_line_rec.acctoutputoctets,
                      var_line_rec.rowcount) ;
        END IF ;
      END IF ;
    END IF ;
  END LOOP ;


  --
  -- Returns all usage overage records.
  --
  RETURN NEXT 'line_id' ||
             ',billing_entity_name' ||
             ',username' ||
             ',product_code' ||
             ',pooled_product' ||
             ',alert_threshold_mb' ||
             ',acct_total_volume_mb' ||
             ',time_connected_utc' ||
             ',acctsessiontime_utc' ||
             ',acctinputoctets_utc' ||
             ',acctoutputoctets_utc' ||
             ',rowcount_utc' ;

  -- Individual lines.
  FOR var_overage_records IN
    SELECT line_id,
           billing_entity_name,
           username,
           product_code,
           CASE WHEN pooled_product = true THEN 'Pooled'::text ELSE 'NotPooled'::text END AS pooled_product,
           alert_threshold_mb,
           TRUNC(((COALESCE(acctinputoctets_utc,0) + COALESCE(acctoutputoctets_utc,0)) / 1024 / 1024)) AS acct_total_volume_mb,
           time_connected_utc,
           acctsessiontime_utc,
           acctinputoctets_utc,
           acctoutputoctets_utc,
           rowcount_utc
      FROM csctoss.line_usage_overage_calc
     WHERE TRUNC(((COALESCE(acctinputoctets_utc,0) + COALESCE(acctoutputoctets_utc,0)) / 1024 / 1024)) >= alert_threshold_mb
       AND usage_calc_end_timestamp::timestamp(0) = var_end_timestamp::timestamp(0)
       AND pooled_product = false
  LOOP

    RETURN NEXT var_overage_records ;
  END LOOP ;


  -- Pooled lines.
  FOR var_overage_records IN
    SELECT MIN(line_id) AS line_id,
           billing_entity_name,
           NULL AS username,
           product_code,
           'Pooled'::text AS pooled_product,
           SUM(alert_threshold_mb) AS alert_threshold_mb,
           SUM(TRUNC(((COALESCE(acctinputoctets_utc,0) + COALESCE(acctoutputoctets_utc,0)) / 1024 / 1024))) AS acct_total_volume_mb,
           SUM(time_connected_utc) AS time_connected_utc,
           SUM(acctsessiontime_utc) AS acctsessiontime_utc,
           SUM(acctinputoctets_utc) AS acctinputoctets_utc,
           SUM(acctoutputoctets_utc) AS acctoutputoctets_utc,
           SUM(rowcount_utc) AS rowcount_utc
      FROM csctoss.line_usage_overage_calc
     WHERE TRUNC(((COALESCE(acctinputoctets_utc,0) + COALESCE(acctoutputoctets_utc,0)) / 1024 / 1024)) >= alert_threshold_mb
       AND usage_calc_end_timestamp::timestamp(0) = var_end_timestamp::timestamp(0)
       AND pooled_product = true
  GROUP BY billing_entity_name,
           product_code
    HAVING SUM(TRUNC(((COALESCE(acctinputoctets_utc,0) + COALESCE(acctoutputoctets_utc,0)) / 1024 / 1024))) >= SUM(alert_threshold_mb)

  LOOP

    RETURN NEXT var_overage_records ;
  END LOOP ;


  RETURN NEXT 'SUCCESS' ;
  RETURN ;

END;
$_$;


ALTER FUNCTION csctoss.usage_overage_detection2(integer, integer) OWNER TO csctoss_owner;

--
-- Name: FUNCTION usage_overage_detection2(integer, integer); Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON FUNCTION usage_overage_detection2(integer, integer) IS 'This function detects usage overage customers based on gived hours.';


--
-- Name: usergroup_updater(text, character); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION usergroup_updater(text, character) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE

  par_primary_key       	text    := $1 ;
  par_change_type       	char(1) := $2 ;

  var_sql               	text ;

  sysparm_rec			record ;
  usergroup_rec			record ;

BEGIN

  -- dynamically build sql statement based on change type and execute
  IF par_change_type = 'D' THEN

    -- build string for deletes
    var_sql := 'delete from usergroup where id = '||par_primary_key::integer ;

  ELSE

    SELECT INTO usergroup_rec * FROM csctoss.usergroup WHERE id = par_primary_key::integer ;
    IF NOT FOUND THEN RETURN FALSE ; END IF ;

    -- build string for inserts
    IF par_change_type = 'I' THEN
      var_sql := 'INSERT INTO usergroup
                            ( id
                            , username
                            , groupname
                            , priority)
                VALUES ( ' || usergroup_rec.id || ','
                           || quote_literal(usergroup_rec.username) || ','
                           || quote_literal(usergroup_rec.groupname) || ','
                           || usergroup_rec.priority || ')' ;

    -- build string for updates
    ELSIF par_change_type = 'U' THEN
      var_sql := 'UPDATE usergroup
                     SET username  = ' || quote_literal(usergroup_rec.username) || '
                        ,groupname = ' || quote_literal(usergroup_rec.groupname) || '
                        ,priority  = ' || usergroup_rec.priority || '
                   WHERE id        = ' || usergroup_rec.id ;


    END IF ;

  END IF ;

  -- now loop through appropriate rows again in system_parameter table performing the actual statement
  FOR sysparm_rec IN SELECT hostname, ip_address
                       FROM csctoss.system_parameter
                      WHERE repl_flag = TRUE
  LOOP

    BEGIN

      PERFORM public.dblink_exec(sysparm_rec.hostname, var_sql, TRUE) ;

    EXCEPTION WHEN OTHERS THEN PERFORM csctoss.replication_failure_insert
                                             (sysparm_rec.hostname
                                             ,sysparm_rec.ip_address
                                             ,'usergroup'
                                             ,par_primary_key
                                             ,par_change_type
                                             ,var_sql) ;
    END ;

  END LOOP ;

  RETURN TRUE ;

END;
$_$;


ALTER FUNCTION csctoss.usergroup_updater(text, character) OWNER TO slony;

--
-- Name: FUNCTION usergroup_updater(text, character); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION usergroup_updater(text, character) IS 'Updater based function to replicate usergroup data changes from change_log.';


--
-- Name: username_check(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION username_check() RETURNS SETOF my_type2
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
  c_staff_id              	integer:=3;
  var_myrow					my_type1%ROWTYPE;
  var_myrow2				my_type2%ROWTYPE;
  var_equipment_id			int;
  var_min_value				text;
  var_status				int;
  v_result                	integer;
  v_numrows               	integer;

BEGIN

--select * INTO v_result public.set_change_log_staff_id(c_staff_id);

FOR var_myrow IN 
  SELECT DISTINCT ui.equipment_id
      ,substring(l.radius_username,1,(position('@' IN l.radius_username) - 1))
      ,uim.value 
  FROM line l
  JOIN line_equipment le ON le.line_id = l.line_id
  JOIN unique_identifier ui ON le.equipment_id = ui.equipment_id
  JOIN unique_identifier uim ON le.equipment_id = uim.equipment_id AND uim.unique_identifier_type = 'MIN'
 WHERE l.end_date is NULL
   AND l.radius_username LIKE '%@uscc.net'
   AND substring(l.radius_username,1,(position('@' IN l.radius_username) - 1)) <> uim.value
 ORDER BY 2

	LOOP

		RAISE NOTICE 'EQUIPMENT_ID:    %', var_myrow.equip_id;
		RAISE NOTICE 'Username    :    %', var_myrow.rad_username;
		RAISE NOTICE 'UIM Value   :    %', var_myrow.uim_value;

		select equipment_id 
		      ,value
		  INTO var_equipment_id
		      ,var_min_value 
		  from unique_identifier 
		 where unique_identifier_type = 'MIN' 
		   and value = var_myrow.rad_username;

		var_myrow2.upd_equip_id 	:= var_myrow.equip_id;
		var_myrow2.correct_min		:= var_myrow.rad_username;
		var_myrow2.exist_min		:= var_myrow.uim_value;
		var_myrow2.related_equip_id := var_equipment_id;
		var_myrow2.related_min		:= var_min_value;

		RETURN NEXT var_myrow2;

	END LOOP;

RAISE NOTICE 'Finished Function';
RETURN;
END ;
$$;


ALTER FUNCTION csctoss.username_check() OWNER TO csctoss_owner;

--
-- Name: username_correct(); Type: FUNCTION; Schema: csctoss; Owner: csctoss_owner
--

CREATE FUNCTION username_correct() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  c_staff_id              	integer:=3;
  var_myrow					my_type1%ROWTYPE;
  var_status				int;
  v_result                	integer;
  v_numrows               	integer;

BEGIN

--select * INTO v_result public.set_change_log_staff_id(c_staff_id);

FOR var_myrow IN 
  SELECT DISTINCT ui.equipment_id
      ,substring(l.radius_username,1,(position('@' IN l.radius_username) - 1)) AS username
  FROM line l
  JOIN line_equipment le ON le.line_id = l.line_id
  JOIN unique_identifier ui ON le.equipment_id = ui.equipment_id
  JOIN unique_identifier uim ON le.equipment_id = uim.equipment_id AND uim.unique_identifier_type = 'MIN'
 WHERE l.end_date is NULL
   AND l.radius_username LIKE '%@uscc.net'
   AND substring(l.radius_username,1,(position('@' IN l.radius_username) - 1)) <> uim.value
 ORDER BY 1,2 limit 10

	LOOP
		RAISE NOTICE 'Equipment Id:  %', var_myrow.equip_id;
		RAISE NOTICE 'Username:      %', var_myrow.user_prefix;

	    UPDATE unique_identifier
	       SET value = var_myrow.user_prefix
	     WHERE equipment_id = var_myrow.equip_id
	       AND unique_identifier_type = 'MIN';

	    GET DIAGNOSTICS v_numrows = ROW_COUNT;
	    IF v_numrows = 0 THEN
	        RAISE NOTICE 'Update failed: %',var_myrow.user_prefix;
	    END IF;

	END LOOP;

RAISE NOTICE 'Finished Function';
RETURN 0;
END ;
$$;


ALTER FUNCTION csctoss.username_correct() OWNER TO csctoss_owner;

--
-- Name: username_updater(text, character); Type: FUNCTION; Schema: csctoss; Owner: slony
--

CREATE FUNCTION username_updater(text, character) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
  par_primary_key       text    := $1 ;
  par_change_type       char(1) := $2 ;
  var_cols              text ;
  var_vals              text ;
  var_sql              	text ;
  sysparm_rec		record ;
  username_rec		record ;
BEGIN
  -- dynamically build sql statement based on change type and execute
  IF par_change_type = 'D' THEN
    -- build string for deletes
    var_sql := 'delete from username where username = '||quote_literal(par_primary_key)||'' ;
  ELSE
    SELECT INTO username_rec * FROM csctoss.username WHERE username = par_primary_key ;
    IF NOT FOUND THEN RETURN FALSE ; END IF ;
    -- build string for inserts, only notes is nullable
    IF par_change_type = 'I' THEN
      var_cols := 'INSERT INTO username (username, billing_entity_id, primary_service, enabled, auth_pod, start_date, end_date, date_created ' ;
      var_vals := '     VALUES (' || quote_literal(username_rec.username)   || ','
                                  || username_rec.billing_entity_id         || ','
                                  || CASE WHEN username_rec.primary_service
                                          THEN quote_literal('TRUE')
                                          ELSE quote_literal('FALSE') END   || ','
                                  || CASE WHEN username_rec.enabled
                                          THEN quote_literal('TRUE')
                                          ELSE quote_literal('FALSE') END   || ','
                                  || CASE WHEN username_rec.auth_pod
                                          THEN quote_literal('TRUE')
                                          ELSE quote_literal('FALSE') END   || ','''
                                  || username_rec.start_date                || ''','''
                                  || username_rec.end_date                  || ''','''
                                  || username_rec.date_created              || '''' ;
      -- catenate notes if not null
      IF username_rec.notes IS NOT NULL THEN
        var_cols := var_cols || ', notes ' ;
        IF username_rec.notes = '' THEN
          var_vals := var_vals || ',' || quote_literal('') ;
        ELSE
          var_vals := var_vals || ',' || quote_literal(username_rec.notes) ;
        END IF ;
      END IF ;
      -- now catenate the cols and vals
      var_sql := var_cols || ') ' || var_vals || ') ' ;
    -- build string for updates, only notes is nullable
    ELSIF par_change_type = 'U' THEN
      var_sql := 'UPDATE username
                     SET billing_entity_id =   ' || username_rec.billing_entity_id || '
                        ,primary_service   =   ' || CASE WHEN username_rec.primary_service = TRUE THEN quote_literal('TRUE') ELSE quote_literal('FALSE') END || '
                        ,enabled           =   ' || CASE WHEN username_rec.enabled = TRUE THEN quote_literal('TRUE') ELSE quote_literal('FALSE') END || '
                        ,auth_pod          =   ' || CASE WHEN username_rec.auth_pod = TRUE THEN quote_literal('TRUE') ELSE quote_literal('FALSE') END || '
                        ,start_date        = ''' || username_rec.start_date || '''
                        ,end_date          = ''' || username_rec.end_date || '''
                        ,date_created      = ''' || username_rec.date_created || '''' ;
      -- catenate notes based on null or not null
      IF username_rec.notes IS NULL THEN
        var_sql := var_sql || ', notes = NULL ' ;
      ELSIF username_rec.notes = '' THEN
        var_sql := var_sql || ', notes = ' || quote_literal('') ;
      ELSE
        var_sql := var_sql || ', notes = ' || quote_literal(username_rec.notes) ;
      END IF ;
      -- tack on the where clause
      var_sql := var_sql || ' WHERE username = ' || quote_literal(username_rec.username) ;
    END IF ;
  END IF ;
  -- now loop through appropriate rows again in system_parameter table performing the actual statement
  FOR sysparm_rec IN SELECT hostname, ip_address
                       FROM csctoss.system_parameter
                      WHERE repl_flag = TRUE
  LOOP
    BEGIN
      PERFORM public.dblink_exec(sysparm_rec.hostname, var_sql, TRUE) ;
    EXCEPTION WHEN OTHERS THEN PERFORM csctoss.replication_failure_insert
                                             (sysparm_rec.hostname
                                             ,sysparm_rec.ip_address
                                             ,'username'
                                             ,par_primary_key
                                             ,par_change_type
                                             ,var_sql) ;
    END ;
  END LOOP ;
  RETURN TRUE ;
END;
$_$;


ALTER FUNCTION csctoss.username_updater(text, character) OWNER TO slony;

--
-- Name: FUNCTION username_updater(text, character); Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON FUNCTION username_updater(text, character) IS 'Updater based function to replicate username data changes from change_log.';


SET search_path = public, pg_catalog;

--
-- Name: change_log(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION change_log() RETURNS "trigger"
    LANGUAGE c SECURITY DEFINER
    AS 'changelogger', 'change_log';


ALTER FUNCTION public.change_log() OWNER TO postgres;

--
-- Name: database_size(name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION database_size(name) RETURNS bigint
    LANGUAGE c STRICT
    AS '$libdir/dbsize', 'database_size';


ALTER FUNCTION public.database_size(name) OWNER TO postgres;

--
-- Name: dblink(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink(text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text) OWNER TO postgres;

--
-- Name: dblink(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink(text, text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text, text) OWNER TO postgres;

--
-- Name: dblink(text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink(text, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text, boolean) OWNER TO postgres;

--
-- Name: dblink(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink(text, text, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text, text, boolean) OWNER TO postgres;

--
-- Name: dblink_build_sql_delete(text, int2vector, integer, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_build_sql_delete(text, int2vector, integer, text[]) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_build_sql_delete';


ALTER FUNCTION public.dblink_build_sql_delete(text, int2vector, integer, text[]) OWNER TO postgres;

--
-- Name: dblink_build_sql_insert(text, int2vector, integer, text[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_build_sql_insert(text, int2vector, integer, text[], text[]) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_build_sql_insert';


ALTER FUNCTION public.dblink_build_sql_insert(text, int2vector, integer, text[], text[]) OWNER TO postgres;

--
-- Name: dblink_build_sql_update(text, int2vector, integer, text[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_build_sql_update(text, int2vector, integer, text[], text[]) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_build_sql_update';


ALTER FUNCTION public.dblink_build_sql_update(text, int2vector, integer, text[], text[]) OWNER TO postgres;

--
-- Name: dblink_close(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_close(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text) OWNER TO postgres;

--
-- Name: dblink_close(text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_close(text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text, boolean) OWNER TO postgres;

--
-- Name: dblink_close(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_close(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text, text) OWNER TO postgres;

--
-- Name: dblink_close(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_close(text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text, text, boolean) OWNER TO postgres;

--
-- Name: dblink_connect(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_connect(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect(text) OWNER TO postgres;

--
-- Name: dblink_connect(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_connect(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect(text, text) OWNER TO postgres;

--
-- Name: dblink_connect_u(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_connect_u(text) RETURNS text
    LANGUAGE c STRICT SECURITY DEFINER
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect_u(text) OWNER TO postgres;

--
-- Name: dblink_connect_u(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_connect_u(text, text) RETURNS text
    LANGUAGE c STRICT SECURITY DEFINER
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect_u(text, text) OWNER TO postgres;

--
-- Name: dblink_current_query(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_current_query() RETURNS text
    LANGUAGE c
    AS '$libdir/dblink', 'dblink_current_query';


ALTER FUNCTION public.dblink_current_query() OWNER TO postgres;

--
-- Name: dblink_disconnect(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_disconnect() RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_disconnect';


ALTER FUNCTION public.dblink_disconnect() OWNER TO postgres;

--
-- Name: dblink_disconnect(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_disconnect(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_disconnect';


ALTER FUNCTION public.dblink_disconnect(text) OWNER TO postgres;

--
-- Name: dblink_exec(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_exec(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text) OWNER TO postgres;

--
-- Name: dblink_exec(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_exec(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text, text) OWNER TO postgres;

--
-- Name: dblink_exec(text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_exec(text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text, boolean) OWNER TO postgres;

--
-- Name: dblink_exec(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_exec(text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text, text, boolean) OWNER TO postgres;

--
-- Name: dblink_fetch(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_fetch(text, integer) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, integer) OWNER TO postgres;

--
-- Name: dblink_fetch(text, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_fetch(text, integer, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, integer, boolean) OWNER TO postgres;

--
-- Name: dblink_fetch(text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_fetch(text, text, integer) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, text, integer) OWNER TO postgres;

--
-- Name: dblink_fetch(text, text, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_fetch(text, text, integer, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, text, integer, boolean) OWNER TO postgres;

--
-- Name: dblink_get_pkey(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_get_pkey(text) RETURNS SETOF dblink_pkey_results
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_pkey';


ALTER FUNCTION public.dblink_get_pkey(text) OWNER TO postgres;

--
-- Name: dblink_open(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_open(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text) OWNER TO postgres;

--
-- Name: dblink_open(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_open(text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text, boolean) OWNER TO postgres;

--
-- Name: dblink_open(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_open(text, text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text, text) OWNER TO postgres;

--
-- Name: dblink_open(text, text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_open(text, text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text, text, boolean) OWNER TO postgres;

--
-- Name: get_change_log_staff_id(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION get_change_log_staff_id() RETURNS integer
    LANGUAGE c SECURITY DEFINER
    AS 'changelogger', 'get_change_log_staff_id';


ALTER FUNCTION public.get_change_log_staff_id() OWNER TO postgres;

--
-- Name: instr(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION instr(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
    pos integer;
BEGIN
    pos:= instr($1, $2, 1);
    RETURN pos;
END;
$_$;


ALTER FUNCTION public.instr(character varying, character varying) OWNER TO postgres;

--
-- Name: FUNCTION instr(character varying, character varying); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION instr(character varying, character varying) IS 'Function to mimic oracle instr function.';


--
-- Name: instr(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION instr(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
    string ALIAS FOR $1;
    string_to_search ALIAS FOR $2;
    beg_index ALIAS FOR $3;
    pos integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index > 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSE
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos > 0 THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    END IF;
END;
$_$;


ALTER FUNCTION public.instr(character varying, character varying, character varying) OWNER TO postgres;

--
-- Name: FUNCTION instr(character varying, character varying, character varying); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION instr(character varying, character varying, character varying) IS 'Function to mimic oracle instr function.';


--
-- Name: instr(character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION instr(character varying, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
    string ALIAS FOR $1;
    string_to_search ALIAS FOR $2;
    beg_index ALIAS FOR $3;
    occur_index ALIAS FOR $4;
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index > 0 THEN
        beg := beg_index;
        temp_str := substring(string FROM beg_index);

        FOR i IN 1..occur_index LOOP
            pos := position(string_to_search IN temp_str);

            IF i = 1 THEN
                beg := beg + pos - 1;
            ELSE
                beg := beg + pos;
            END IF;

            temp_str := substring(string FROM beg + 1);
        END LOOP;

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN beg;
        END IF;
    ELSE
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos > 0 THEN
                occur_number := occur_number + 1;

                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    END IF;
END;
$_$;


ALTER FUNCTION public.instr(character varying, character varying, integer, integer) OWNER TO postgres;

--
-- Name: FUNCTION instr(character varying, character varying, integer, integer); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION instr(character varying, character varying, integer, integer) IS 'Function to mimic oracle instr function.';


--
-- Name: ops_process_rma(); Type: FUNCTION; Schema: public; Owner: csctoss_owner
--

CREATE FUNCTION ops_process_rma() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE

v_sql                   text;
v_email_text            text;
v_email_subj            text;
v_email_recip           text:='dolson@cctus.com';
v_rt_ticket_id          integer;
v_cursor                text;
c_rec                   record;
v_old_sn		text:='N/A';
v_new_sn		text:='N/A';
v_company_name		text:='N/A';
v_model		        text:='N/A';
v_contact_name		text:='N/A';
v_contact_email		text:='N/A';
v_disposition_val	text:='N/A';
v_old_esn		text:='N/A';
v_new_esn		text:='N/A';
v_tracking_num		text:='N/A';
v_return_tracking_num	text:='N/A';
v_SO_num 		text:='N/A';
v_shipping_address      text:='N/A';
v_city                  text:='N/A';
v_state                  text:='N/A';
v_line_id               text:='N/A';

begin
      SELECT t.id into v_rt_ticket_id
      FROM rt3.tickets t
      join rt3.queues q on (q.id=t.queue and q.name ='RMA Customer' and q.disabled=0)
      WHERE 1=1
        and t.disabled=0
--        and rt3.objectcustomfieldvalues='??'     ---   will determine value for  RMA tyhpe
       and t.id=34247
--        and t.status='new'
      ;
       RAISE NOTICE 'TICKET ID: %', v_rt_ticket_id;

      FOR c_rec in
      SELECT
      cfv.customfield,cf.name,cfv.content
      FROM
           rt3.objectcustomfieldvalues cfv
      join rt3.customfields cf on (cf.id = cfv.customfield )
      join rt3.tickets t on (t.id = cfv.objectid)
      WHERE 1=1
        and cfv.disabled=0
        and t.id=v_rt_ticket_id
        order by 1
       loop
          IF c_rec.customfield = 2  THEN v_old_sn                            := c_rec.content ; END IF;
          IF c_rec.customfield = 3  THEN v_company_name                      := c_rec.content  ; END IF;
          IF c_rec.customfield = 4  THEN v_city                              := c_rec.content  ; END IF;
          IF c_rec.customfield = 5  THEN v_state                             := c_rec.content  ; END IF;
          IF c_rec.customfield = 8  THEN v_model                             := c_rec.content  ; END IF;
          IF c_rec.customfield = 10 THEN v_contact_name                      := c_rec.content  ; END IF;
          IF c_rec.customfield = 11 THEN v_contact_email                     := c_rec.content  ; END IF;
          IF c_rec.customfield = 12 THEN v_shipping_address                  := c_rec.content  ; END IF;
          IF c_rec.customfield = 13 THEN v_disposition_val                   := c_rec.content  ; END IF;
          IF c_rec.customfield = 23 THEN v_SO_num                            := c_rec.content  ; END IF;
          IF c_rec.customfield = 24 THEN v_line_id                           := c_rec.content  ; END IF;
          IF c_rec.customfield = 36 THEN v_tracking_num                      := c_rec.content  ; END IF;
          IF c_rec.customfield = 37 THEN v_old_esn                           := c_rec.content  ; END IF;

          RAISE NOTICE 'custom field Id: % % value: %',c_rec.customfield, c_rec.name,c_rec.content;
       end loop;


      v_email_text:='Dear '||v_contact_name||',

A replacement unit is being sent via FedEx 2nd Day Air for RMA# '|| v_rt_ticket_id||'
to the following address:
    '||rpad(v_contact_name,30)||'
    '|| rpad(v_shipping_address,30) || '
    '|| rpad(v_city,30)||'
    '|| rpad(v_state,30)||'

Returned Equipment:
  Model:'||v_model||
'
  S/N  :'|| v_old_sn||
'
  ESN  :'|| v_old_esn||
'
  Tracking #: '||v_return_tracking_num||

'||
New Equipment:
  Model: '|| v_model||
'
  S/N  : '|| v_new_sn||
'
  ESN  : '|| v_new_esn||
'
  Tracking #: '||v_tracking_num||
'

Per Contour RMA Policy:
In order to waive the charge for the replacement unit, we must receive the 
defective unit within 30 days of initial shipment of the replacement unit.  
We have provided a return label for the defective unit.

Thank you for your business.

Contour Networks
Customer Support: (866) 576-9933
shipping@contournetworks.com
support@contournetworks.com
';
v_email_subj:='RMA Ticket# RT-'||v_rt_ticket_id;

      perform public.plsh_send_email(v_email_recip,v_email_subj,v_email_text);
      return true;
end;
 $$;


ALTER FUNCTION public.ops_process_rma() OWNER TO csctoss_owner;

--
-- Name: packet_of_disconnect(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION packet_of_disconnect(text) RETURNS SETOF text
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $_$
DECLARE

  par_username_or_session      text := $1 ;

  var_sql                      text ;
  var_string                   text ;
  var_conn                     text ;
  var_return                   text ;
  var_found                    boolean := false ;

  rec_conn                     record ;
  rec_mrac                     record ;
  rec_lnsl                     record ;

BEGIN

  -- build sql dynamically based on username or session
  var_sql := 'SELECT username
                    ,acctsessionid
                    ,framedipaddress
                    ,xascendsessionsvrkey
                    ,nasidentifier
                FROM master_radacct 
               WHERE acctstoptime IS NULL
                 AND acctstarttime > (current_timestamp - interval ''1 day'')' ;

  IF par_username_or_session like '%@%' THEN
    var_sql := var_sql || ' AND username = '||quote_literal(par_username_or_session) ;
  ELSE
    var_sql := var_sql || ' AND acctsessionid = '||quote_literal(par_username_or_session) ;
  END IF ;

  var_sql := var_sql || ' ORDER BY master_radacctid DESC' ;

  --RETURN NEXT var_sql ;

  -- get relevent accounting records for this username or acctsessionid
  FOR rec_mrac IN 
    SELECT *
      FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),var_sql) 
        AS rec_type(username             varchar
                   ,acctsessionid        varchar
                   ,framedipaddress      inet
                   ,xascendsessionsvrkey varchar
                   ,nasidentifier        varchar)
  LOOP

    var_found := true ;

    IF rec_mrac.username like '%uscc%' THEN
      var_pos := ( select position('@' in rec_mrac.username ));
      var_username := (select substring(rec_mrac.username from 1 for var_pos)) || con_sprintname;  
    ELSE  
      var_username := rec_mrac.username;
    END IF;

    var_string := var_username                         ||','||
                  rec_mrac.acctsessionid               ||','||
                  host(rec_mrac.framedipaddress)::text ||','||
                  rec_mrac.xascendsessionsvrkey        ||','||
                  rec_mrac.nasidentifier ;

    -- get the lns connection information
    SELECT *
      INTO rec_lnsl
      FROM csctoss.lns_lookup
     WHERE upper(nasidentifier) = upper(rec_mrac.nasidentifier) ;

    IF NOT FOUND THEN
      RETURN NEXT 'RC1: ERROR' ;
      RETURN NEXT 'RC2:' ;
      RETURN NEXT 'RC3:' ;
      RETURN NEXT 'ERR: NAS Identifier '||rec_mrac.nasidentifier||' undefined in lns_lookup table.' ;
    ELSE
      var_conn := rec_lnsl.nasidentifier               ||','||
                  rec_lnsl.radclient_ip_address::text  ||','||
                  rec_lnsl.radclient_port::text        ||','||
                  rec_lnsl.radclient_password ;
    END IF ;

    -- call the plsh_pod(text,text) function and evaluate results
    BEGIN

      --RETURN NEXT 'STRING: '||var_string ;
      --RETURN NEXT 'LNS CONN: '||var_conn ;

      SELECT *
        INTO var_return
        FROM public.plsh_pod(var_string,var_conn) ;

      -- NEED TO DO SOMETHING HERE BESIDES THEN NULL !!!
      -- NEED TO DO SOMETHING HERE BESIDES THEN NULL !!!
      -- NEED TO DO SOMETHING HERE BESIDES THEN NULL !!!

    EXCEPTION
      WHEN OTHERS THEN NULL ; -- RETURN NEXT 'ERROR: '||var_return ;
    END ;

    -- return success regardless of function call
    RETURN NEXT 'RC1: SUCCESS' ;
    RETURN NEXT 'RC2: Username '||rec_mrac.username||' POD sent to '||rec_mrac.nasidentifier ;
    RETURN NEXT 'RC3: '||var_string ;
    RETURN NEXT 'ERR:' ; 
  
  END LOOP ;

  -- if no satisfying accounting records found then report it
  IF NOT var_found THEN
    RETURN NEXT 'RC1: ERROR' ;
    RETURN NEXT 'RC2:' ;
    RETURN NEXT 'RC3:' ;
    RETURN NEXT 'ERR: Username or Session '||COALESCE(par_username_or_session,'NULL')||' has no open accounting records last 24 hours.' ;
  END IF ;

  RETURN ;

END ;

$_$;


ALTER FUNCTION public.packet_of_disconnect(text) OWNER TO postgres;

--
-- Name: FUNCTION packet_of_disconnect(text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION packet_of_disconnect(text) IS 'Database function to validate pod request, pass to plsh_pod(text), evaluate and report results.';


--
-- Name: pg_database_size(oid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pg_database_size(oid) RETURNS bigint
    LANGUAGE c STRICT
    AS '$libdir/dbsize', 'pg_database_size';


ALTER FUNCTION public.pg_database_size(oid) OWNER TO postgres;

--
-- Name: pg_relation_size(oid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pg_relation_size(oid) RETURNS bigint
    LANGUAGE c STRICT
    AS '$libdir/dbsize', 'pg_relation_size';


ALTER FUNCTION public.pg_relation_size(oid) OWNER TO postgres;

--
-- Name: pg_size_pretty(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pg_size_pretty(bigint) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dbsize', 'pg_size_pretty';


ALTER FUNCTION public.pg_size_pretty(bigint) OWNER TO postgres;

--
-- Name: pg_tablespace_size(oid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pg_tablespace_size(oid) RETURNS bigint
    LANGUAGE c STRICT
    AS '$libdir/dbsize', 'pg_tablespace_size';


ALTER FUNCTION public.pg_tablespace_size(oid) OWNER TO postgres;

--
-- Name: plsh_pod(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plsh_pod(text) RETURNS text
    LANGUAGE plsh STABLE SECURITY DEFINER
    AS $_$
#!/bin/bash

BASEDIR=/home/postgres/dba/logs
LOGFILE=$BASEDIR/pod.`date +%Y%m%d`
ERRFILE=$BASEDIR/pod.err.`date +%Y%m%d`
TMPFILE=$BASEDIR/pod.tmp
CONFILE=$BASEDIR/pod.con
PODFILE=$BASEDIR/pod.dat

# make sure parameter passed
if [ $# != 2 ]; then
  echo "POD string and connection parameters required. Halting execution." >> $ERRFILE
  exit 1
fi
echo $1 > $TMPFILE
echo $2 > $CONFILE

# build the output file
echo "Acct-Session-Id=`cut -d ',' -f 1 $TMPFILE`"           > $PODFILE
echo "User-Name=`cut -d ',' -f 2 $TMPFILE`"                >> $PODFILE
echo "Framed-IP-Address=`cut -d ',' -f 3 $TMPFILE`"        >> $PODFILE

# trap nasidentifier (LNS) and convert to ip address for radclient call
LNS=`cut -d ',' -f 4 $TMPFILE`
LNS=`host $LNS | awk '{print $4}'`

# get the connection information
PORT=`cut -d ',' -f 3 $CONFILE`
PSWD=`cut -d ',' -f 4 $CONFILE`

# send the packet of disconnect
echo "START  : `date +%Y%m%d%H%M%S`"                                         >> $LOGFILE
echo "STRING : $1"                                                           >> $LOGFILE
echo "COMMAND: radclient -x -c 1 $LNS:$PORT -f $PODFILE disconnect $PSWD"    >> $LOGFILE
cat $PODFILE                                                                 >> $LOGFILE
radclient -x -c 1 $LNS:$PORT -f $PODFILE disconnect $PSWD
echo "--------------------end of pod report--------------------"             >> $LOGFILE

$_$;


ALTER FUNCTION public.plsh_pod(text) OWNER TO postgres;

--
-- Name: FUNCTION plsh_pod(text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION plsh_pod(text) IS 'Plsh function to issue a packet of disconnect from the O/S to appropriate LNS.';


--
-- Name: plsh_pod(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plsh_pod(text, text) RETURNS text
    LANGUAGE plsh STABLE SECURITY DEFINER
    AS $_$
#!/bin/bash

BASEDIR=/home/postgres/dba/logs
LOGFILE=$BASEDIR/pod.`date +%Y%m%d`
ERRFILE=$BASEDIR/pod.err.`date +%Y%m%d`
TMPFILE=$BASEDIR/pod.tmp
CONFILE=$BASEDIR/pod.con
PODFILE=$BASEDIR/pod.dat

# make sure parameter passed
if [ $# != 2 ]; then
  echo "POD string and connection parameters required. Halting execution." >> $ERRFILE
  exit 1
fi
echo $1 > $TMPFILE
echo $2 > $CONFILE

# build the output file
echo "Acct-Session-Id=`cut -d ',' -f 2 $TMPFILE`"           > $PODFILE
echo "User-Name=`cut -d ',' -f 1 $TMPFILE`"                >> $PODFILE
echo "Framed-IP-Address=`cut -d ',' -f 3 $TMPFILE`"        >> $PODFILE

# trap nasidentifier (LNS) and convert to ip address for radclient call
#LNS=`cut -d ',' -f 5 $TMPFILE`
#LNS=`host $LNS | awk '{print $4}'`

# get the connection information
LNS=`cut -d ',' -f 2 $CONFILE`
PORT=`cut -d ',' -f 3 $CONFILE`
PSWD=`cut -d ',' -f 4 $CONFILE`

# send the packet of disconnect
echo "START  : `date +%Y%m%d%H%M%S`"                                         >> $LOGFILE
echo "STRING : $1"                                                           >> $LOGFILE
echo "COMMAND: radclient -x -c 1 $LNS:$PORT -f $PODFILE disconnect $PSWD"    >> $LOGFILE
cat $PODFILE                                                                 >> $LOGFILE
radclient -x -c 1 $LNS:$PORT -f $PODFILE disconnect $PSWD
echo "--------------------end of pod report--------------------"             >> $LOGFILE

$_$;


ALTER FUNCTION public.plsh_pod(text, text) OWNER TO postgres;

--
-- Name: FUNCTION plsh_pod(text, text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION plsh_pod(text, text) IS 'Plsh function to issue a packet of disconnect from the O/S to appropriate LNS.';


--
-- Name: plsh_radclient_pod(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plsh_radclient_pod(text) RETURNS void
    LANGUAGE plsh STABLE SECURITY DEFINER
    AS $_$
#!/bin/bash
source /home/postgres/.bash_profile
cd /home/postgres/dba/logs/pod
FILESTAMP=`date +%Y%m%d%H%M%S`
LOGFILE=log/$1.$FILESTAMP
PACKETFILE=output/$1.$FILESTAMP

# make sure parameter passed
if [ $# != 1 ]; then
  echo "Username parameter required."                            > $LOGFILE
  exit 1
fi

# verify valid username
psql -A -t -q -U csctoss_owner -c "SELECT true
                                     FROM csctoss.master_radacct 
                                    WHERE username = '$1'
                                    LIMIT 1"                     > ./temp.txt
if [[ `cat ./temp.txt` != t ]]; then
  echo "Username $1 does not exist"                              > $LOGFILE
  rm -f ./temp.txt
  exit 2
fi
rm -f ./temp.txt

# get latest start with null end date for given username
psql -A -t -q -U csctoss_owner -c "SELECT username, acctsessionid, framedipaddress, nasidentifier, xascendsessionsvrkey
                                     FROM master_radacct
                                    WHERE username = '$1'
                                      AND acctstoptime IS NULL
                                 ORDER BY acctstarttime DESC
                                    LIMIT 1"                     > $LOGFILE

# make sure record returned
if [[ `cat $LOGFILE` != $1* ]]; then
  echo "Username $1 has no record with null acctstoptime"        > $LOGFILE
  exit 3
fi

# parse nasidentifier into variable for evaluation
NASIDENTIFIER=`cut -d '|' -f 4 $LOGFILE`

# build the output file
echo "Acct-Session-Id = `cut -d '|' -f 2 $LOGFILE`"                > $PACKETFILE
echo "User-Name = `cut -d '|' -f 1 $LOGFILE`"                     >> $PACKETFILE
echo "Framed-IP-Address = `cut -d '|' -f 3 $LOGFILE`"             >> $PACKETFILE
echo "X-Ascend-Session-Svr-Key = `cut -d '|' -f 5 $LOGFILE`"      >> $PACKETFILE

# determine whether to send to denver lens or atlanta lens
if [[ $NASIDENTIFIER == *DEN* ]]; then
  radclient -x 10.17.0.1:1700 -f $PACKETFILE disconnect CSCT80pod > $PACKETFILE.den.out &
elif [[ $NASIDENTIFIER == *ATL* ]]; then
  # atlanta
  radclient -x 10.16.0.1:1700 -f $PACKETFILE disconnect CSCT80pod > $PACKETFILE.atl.out &
else
  echo "Cannot Determine LENS"                                  >> $LOGFILE
  exit 4
fi

exit 0
$_$;


ALTER FUNCTION public.plsh_radclient_pod(text) OWNER TO postgres;

--
-- Name: FUNCTION plsh_radclient_pod(text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION plsh_radclient_pod(text) IS 'Comment';


--
-- Name: plsh_send_email(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plsh_send_email(text, text, text) RETURNS void
    LANGUAGE plsh
    AS $_$
#!/bin/bash

echo "$3" | mail -s "$2" "$1"

$_$;


ALTER FUNCTION public.plsh_send_email(text, text, text) OWNER TO postgres;

--
-- Name: FUNCTION plsh_send_email(text, text, text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION plsh_send_email(text, text, text) IS 'Function callable from database to send an email via the operating system mail command.';


--
-- Name: plsh_send_nsca(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plsh_send_nsca(text, text) RETURNS void
    LANGUAGE plsh
    AS $_$
#!/bin/bash

echo "$2" | /usr/local/bin/send_nsca -H "$1" -c /etc/nsca/send_nsca.cfg

$_$;


ALTER FUNCTION public.plsh_send_nsca(text, text) OWNER TO postgres;

--
-- Name: FUNCTION plsh_send_nsca(text, text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION plsh_send_nsca(text, text) IS 'Function callable from database to execute send_nsca nagios program via the operating system command.';


--
-- Name: relation_size(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION relation_size(text) RETURNS bigint
    LANGUAGE c STRICT
    AS '$libdir/dbsize', 'relation_size';


ALTER FUNCTION public.relation_size(text) OWNER TO postgres;

--
-- Name: replchk_attribute(text); Type: FUNCTION; Schema: public; Owner: slony
--

CREATE FUNCTION replchk_attribute(text) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_host_like     text := $1 ;
  var_conn_string   text ;
  sysparm_rec       record ;
  except_rec        record ;

BEGIN

  -- setup loop and connection strings for all replicated radius databases from system_parameter table
  FOR sysparm_rec IN SELECT * FROM csctoss.system_parameter WHERE repl_flag AND LOWER(hostname) LIKE par_host_like||'%' LOOP

    var_conn_string := 'hostaddr='||sysparm_rec.ip_address||
                          ' port='||sysparm_rec.repl_port||
                        ' dbname='||sysparm_rec.repl_target_db||
                          ' user='||sysparm_rec.repl_target_username||
                      ' password='||sysparm_rec.repl_target_password||'' ;

    -- execute the exception query outbound
    FOR except_rec IN SELECT * FROM
      (select attribute, attribute_type, description from csctoss.attribute
       except
       select * from public.dblink(var_conn_string, 'select * from radiusdb.attribute')
         as rec_type(attribute varchar, attribute_type varchar, description varchar)) AS outbound
    LOOP
      RETURN NEXT 'INBOUND '||sysparm_rec.hostname||' (attribute): '|| except_rec.attribute
                                                             ||' - '|| except_rec.attribute_type
                                                             ||' - '|| except_rec.description ;
    END LOOP ;

    -- execute the exception query inbound
    FOR except_rec IN SELECT * FROM
      (select * from public.dblink(var_conn_string, 'select * from radiusdb.attribute')
         as rec_type(attribute varchar, attribute_type varchar, description varchar)
       except
       select attribute, attribute_type, description from csctoss.attribute) AS inbound
    LOOP
      RETURN NEXT 'OUTBOUND '||sysparm_rec.hostname||' (attribute): '|| except_rec.attribute
                                                              ||' - '|| except_rec.attribute_type
                                                              ||' - '|| except_rec.description ;
    END LOOP ;

  END LOOP ;

  RETURN ;

END ;
$_$;


ALTER FUNCTION public.replchk_attribute(text) OWNER TO slony;

--
-- Name: FUNCTION replchk_attribute(text); Type: COMMENT; Schema: public; Owner: slony
--

COMMENT ON FUNCTION replchk_attribute(text) IS 'DB Link function to check replication between csctoss and radiusdb databases for attribute table.';


--
-- Name: replchk_attribute_type(text); Type: FUNCTION; Schema: public; Owner: slony
--

CREATE FUNCTION replchk_attribute_type(text) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_host_like     text := $1 ;
  var_conn_string   text ;
  sysparm_rec       record ;
  except_rec        record ;

BEGIN

  -- setup loop and connection strings for all replicated radius databases from system_parameter table
  FOR sysparm_rec IN SELECT * FROM csctoss.system_parameter WHERE repl_flag AND LOWER(hostname) LIKE par_host_like||'%' LOOP

RETURN NEXT sysparm_rec.hostname ;

    var_conn_string := 'hostaddr='||sysparm_rec.ip_address||
                          ' port='||sysparm_rec.repl_port||
                        ' dbname='||sysparm_rec.repl_target_db||
                          ' user='||sysparm_rec.repl_target_username||
                      ' password='||sysparm_rec.repl_target_password||'' ;

    -- execute the exception query outbound
    FOR except_rec IN SELECT * FROM
      (select attribute_type, description from csctoss.attribute_type
       except
       select * from public.dblink(var_conn_string, 'select * from radiusdb.attribute_type')
         as rec_type(attribute_type varchar, description varchar)) AS outbound
    LOOP
      RETURN NEXT 'OUTBOUND '||sysparm_rec.hostname||' (attribute_type): '|| except_rec.attribute_type
                                                                   ||' - '|| except_rec.description ;
    END LOOP ;

    -- execute the exception query inbound
    FOR except_rec IN SELECT * FROM
      (select * from public.dblink(var_conn_string, 'select * from radiusdb.attribute_type')
         as rec_type(attribute_type varchar, description varchar)
       except
       select attribute_type, description from csctoss.attribute_type) AS inbound
    LOOP
      RETURN NEXT 'INBOUND '||sysparm_rec.hostname||' (attribute_type): '|| except_rec.attribute_type
                                                                  ||' - '|| except_rec.description ;
    END LOOP ;

  END LOOP ;

  RETURN ;

END ;
$_$;


ALTER FUNCTION public.replchk_attribute_type(text) OWNER TO slony;

--
-- Name: FUNCTION replchk_attribute_type(text); Type: COMMENT; Schema: public; Owner: slony
--

COMMENT ON FUNCTION replchk_attribute_type(text) IS 'DB Link function to check replication between csctoss and radiusdb databases for attribute_type table.';


--
-- Name: replchk_groupname(text); Type: FUNCTION; Schema: public; Owner: slony
--

CREATE FUNCTION replchk_groupname(text) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_host_like     text := $1 ;
  var_conn_string   text ;
  sysparm_rec       record ;
  except_rec        record ;

BEGIN

  -- setup loop and connection strings for all replicated radius databases from system_parameter table
  FOR sysparm_rec IN SELECT * FROM csctoss.system_parameter WHERE repl_flag AND LOWER(hostname) LIKE par_host_like||'%' LOOP

    var_conn_string := 'hostaddr='||sysparm_rec.ip_address||
                          ' port='||sysparm_rec.repl_port||
                        ' dbname='||sysparm_rec.repl_target_db||
                          ' user='||sysparm_rec.repl_target_username||
                      ' password='||sysparm_rec.repl_target_password||'' ;

    -- execute the exception query outbound
    FOR except_rec IN SELECT * FROM
      (select groupname, priority, short_desc, long_desc, start_date, end_date from csctoss.groupname
       except
       select * from public.dblink(var_conn_string, 'select * from radiusdb.groupname')
         as rec_type(groupname varchar, priority integer, short_desc varchar, long_desc varchar, start_date date, end_date date)) AS outbound
    LOOP
      RETURN NEXT 'OUTBOUND '||sysparm_rec.hostname||' (groupname): '|| except_rec.groupname
                                                              ||' - '|| except_rec.priority::text
                                                              ||' - '|| except_rec.short_desc
                                                              ||' - '|| except_rec.long_desc
                                                              ||' - '|| except_rec.start_date::text
                                                              ||' - '|| except_rec.end_date::text ;
    END LOOP ;

    -- execute the exception query inbound
    FOR except_rec IN SELECT * FROM
      (select * from public.dblink(var_conn_string, 'select * from radiusdb.groupname')
         as rec_type(groupname varchar, priority integer, short_desc varchar, long_desc varchar, start_date date, end_date date)
       except
       select groupname, priority, short_desc, long_desc, start_date, end_date from csctoss.groupname) AS inbound
    LOOP
      RETURN NEXT 'INBOUND '||sysparm_rec.hostname||' (groupname): '|| except_rec.groupname
                                                             ||' - '|| except_rec.priority::text
                                                             ||' - '|| except_rec.short_desc 
                                                             ||' - '|| except_rec.long_desc
                                                             ||' - '|| except_rec.start_date::text
                                                             ||' - '|| except_rec.end_date::text ;
    END LOOP ;

  END LOOP ;

  RETURN ;

END ;
$_$;


ALTER FUNCTION public.replchk_groupname(text) OWNER TO slony;

--
-- Name: FUNCTION replchk_groupname(text); Type: COMMENT; Schema: public; Owner: slony
--

COMMENT ON FUNCTION replchk_groupname(text) IS 'DB Link function to check replication between csctoss and radiusdb databases for groupname table.';


--
-- Name: replchk_nas(text); Type: FUNCTION; Schema: public; Owner: slony
--

CREATE FUNCTION replchk_nas(text) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_host_like     text := $1 ;
  var_conn_string   text ;
  sysparm_rec       record ;
  except_rec        record ;

BEGIN

  -- setup loop and connection strings for all replicated radius databases from system_parameter table
  FOR sysparm_rec IN SELECT * FROM csctoss.system_parameter WHERE repl_flag AND LOWER(hostname) LIKE par_host_like||'%' LOOP

    var_conn_string := 'hostaddr='||sysparm_rec.ip_address||
                          ' port='||sysparm_rec.repl_port||
                        ' dbname='||sysparm_rec.repl_target_db||
                          ' user='||sysparm_rec.repl_target_username||
                      ' password='||sysparm_rec.repl_target_password||'' ;

    -- execute the exception query outbound
    FOR except_rec IN SELECT * FROM
      (select groupname, priority, short_desc, long_desc, start_date, end_date from csctoss.groupname
       except
       select * from public.dblink(var_conn_string, 'select * from radiusdb.groupname')
         as rec_type(groupname varchar, priority integer, short_desc varchar, long_desc varchar, start_date date, end_date date)) AS outbound
    LOOP
      RETURN NEXT 'OUTBOUND '||sysparm_rec.hostname||' (groupname): '|| except_rec.groupname
                                                              ||' - '|| except_rec.priority::text
                                                              ||' - '|| except_rec.short_desc
                                                              ||' - '|| except_rec.long_desc
                                                              ||' - '|| except_rec.start_date::text
                                                              ||' - '|| except_rec.end_date::text ;
    END LOOP ;

    -- execute the exception query inbound
    FOR except_rec IN SELECT * FROM
      (select * from public.dblink(var_conn_string, 'select * from radiusdb.groupname')
         as rec_type(groupname varchar, priority integer, short_desc varchar, long_desc varchar, start_date date, end_date date)
       except
       select groupname, priority, short_desc, long_desc, start_date, end_date from csctoss.groupname) AS inbound
    LOOP
      RETURN NEXT 'INBOUND '||sysparm_rec.hostname||' (groupname): '|| except_rec.groupname
                                                             ||' - '|| except_rec.priority::text
                                                             ||' - '|| except_rec.short_desc 
                                                             ||' - '|| except_rec.long_desc
                                                             ||' - '|| except_rec.start_date::text
                                                             ||' - '|| except_rec.end_date::text ;
    END LOOP ;

  END LOOP ;

  RETURN ;

END ;
$_$;


ALTER FUNCTION public.replchk_nas(text) OWNER TO slony;

--
-- Name: FUNCTION replchk_nas(text); Type: COMMENT; Schema: public; Owner: slony
--

COMMENT ON FUNCTION replchk_nas(text) IS 'DB Link function to check replication between csctoss and radiusdb databases for nas table.';


--
-- Name: replchk_radcheck(text); Type: FUNCTION; Schema: public; Owner: slony
--

CREATE FUNCTION replchk_radcheck(text) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_host_like     text := $1 ;
  var_conn_string   text ;
  sysparm_rec       record ;
  except_rec        record ;

BEGIN

  -- setup loop and connection strings for all replicated radius databases from system_parameter table
  FOR sysparm_rec IN SELECT * FROM csctoss.system_parameter WHERE repl_flag AND LOWER(hostname) LIKE par_host_like||'%' LOOP

    var_conn_string := 'hostaddr='||sysparm_rec.ip_address||
                          ' port='||sysparm_rec.repl_port||
                        ' dbname='||sysparm_rec.repl_target_db||
                          ' user='||sysparm_rec.repl_target_username||
                      ' password='||sysparm_rec.repl_target_password||'' ;

    -- execute the exception query outbound
    FOR except_rec IN SELECT * FROM
      (select id, username, attribute, op, value from csctoss.radcheck
       except
       select * from public.dblink(var_conn_string, 'select * from radiusdb.radcheck')
         as rec_type(id integer, username varchar, attribute varchar, op varchar, value varchar)) AS outbound
    LOOP
      RETURN NEXT 'OUTBOUND '||sysparm_rec.hostname||' (radcheck): '|| except_rec.id::text
                                                             ||' - '|| except_rec.username
                                                             ||' - '|| except_rec.attribute
                                                             ||' - '|| except_rec.op
                                                             ||' - '|| except_rec.value ;
    END LOOP ;

    -- execute the exception query inbound
    FOR except_rec IN SELECT * FROM
      (select * from public.dblink(var_conn_string, 'select * from radiusdb.radcheck')
         as rec_type(id integer, username varchar, attribute varchar, op varchar, value varchar)
       except
       select id, username, attribute, op, value from csctoss.radcheck) AS inbound
    LOOP
      RETURN NEXT 'INBOUND '||sysparm_rec.hostname||' (radcheck): '|| except_rec.id::text
                                                            ||' - '|| except_rec.username
                                                            ||' - '|| except_rec.attribute
                                                            ||' - '|| except_rec.op
                                                            ||' - '|| except_rec.value ;
    END LOOP ;

  END LOOP ;

  RETURN ;

END ;
$_$;


ALTER FUNCTION public.replchk_radcheck(text) OWNER TO slony;

--
-- Name: FUNCTION replchk_radcheck(text); Type: COMMENT; Schema: public; Owner: slony
--

COMMENT ON FUNCTION replchk_radcheck(text) IS 'DB Link function to check replication between csctoss and radiusdb databases for radcheck table.';


--
-- Name: replchk_radgroupcheck(text); Type: FUNCTION; Schema: public; Owner: slony
--

CREATE FUNCTION replchk_radgroupcheck(text) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_host_like     text := $1 ;
  var_conn_string   text ;
  sysparm_rec       record ;
  except_rec        record ;

BEGIN

  -- setup loop and connection strings for all replicated radius databases from system_parameter table
  FOR sysparm_rec IN SELECT * FROM csctoss.system_parameter WHERE repl_flag AND LOWER(hostname) LIKE par_host_like||'%' LOOP

    var_conn_string := 'hostaddr='||sysparm_rec.ip_address||
                          ' port='||sysparm_rec.repl_port||
                        ' dbname='||sysparm_rec.repl_target_db||
                          ' user='||sysparm_rec.repl_target_username||
                      ' password='||sysparm_rec.repl_target_password||'' ;

    -- execute the exception query outbound
    FOR except_rec IN SELECT * FROM
      (select id, groupname, attribute, op, value from csctoss.radgroupcheck
       except
       select * from public.dblink(var_conn_string, 'select * from radiusdb.radgroupcheck')
         as rec_type(id integer, groupname varchar, attribute varchar, op varchar, value varchar)) AS outbound
    LOOP
      RETURN NEXT 'OUTBOUND '||sysparm_rec.hostname||' (radgroupcheck): '|| except_rec.id::text
                                                                  ||' - '|| except_rec.groupname
                                                                  ||' - '|| except_rec.attribute
                                                                  ||' - '|| except_rec.op
                                                                  ||' - '|| except_rec.value ;
    END LOOP ;

    -- execute the exception query inbound
    FOR except_rec IN SELECT * FROM
      (select * from public.dblink(var_conn_string, 'select * from radiusdb.radgroupcheck')
         as rec_type(id integer, groupname varchar, attribute varchar, op varchar, value varchar)
       except
       select id, groupname, attribute, op, value from csctoss.radgroupcheck) AS inbound
    LOOP
      RETURN NEXT 'INBOUND '||sysparm_rec.hostname||' (radgroupcheck): '|| except_rec.id::text
                                                                 ||' - '|| except_rec.groupname
                                                                 ||' - '|| except_rec.attribute
                                                                 ||' - '|| except_rec.op
                                                                 ||' - '|| except_rec.value ;
    END LOOP ;

  END LOOP ;

  RETURN ;

END ;
$_$;


ALTER FUNCTION public.replchk_radgroupcheck(text) OWNER TO slony;

--
-- Name: FUNCTION replchk_radgroupcheck(text); Type: COMMENT; Schema: public; Owner: slony
--

COMMENT ON FUNCTION replchk_radgroupcheck(text) IS 'DB Link function to check replication between csctoss and radiusdb databases for radgroupcheck table.';


--
-- Name: replchk_radgroupreply(text); Type: FUNCTION; Schema: public; Owner: slony
--

CREATE FUNCTION replchk_radgroupreply(text) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_host_like     text := $1 ;
  var_conn_string   text ;
  sysparm_rec       record ;
  except_rec        record ;

BEGIN

  -- setup loop and connection strings for all replicated radius databases from system_parameter table
  FOR sysparm_rec IN SELECT * FROM csctoss.system_parameter WHERE repl_flag AND LOWER(hostname) LIKE par_host_like||'%' LOOP

    var_conn_string := 'hostaddr='||sysparm_rec.ip_address||
                          ' port='||sysparm_rec.repl_port||
                        ' dbname='||sysparm_rec.repl_target_db||
                          ' user='||sysparm_rec.repl_target_username||
                      ' password='||sysparm_rec.repl_target_password||'' ;

    -- execute the exception query outbound
    FOR except_rec IN SELECT * FROM
      (select id, groupname, attribute, op, value from csctoss.radgroupreply
       except
       select * from public.dblink(var_conn_string, 'select * from radiusdb.radgroupreply')
         as rec_type(id integer, groupname varchar, attribute varchar, op varchar, value varchar)) AS outbound
    LOOP
      RETURN NEXT 'OUTBOUND '||sysparm_rec.hostname||' (radgroupreply): '|| except_rec.id::text
                                                                  ||' - '|| except_rec.groupname
                                                                  ||' - '|| except_rec.attribute
                                                                  ||' - '|| except_rec.op
                                                                  ||' - '|| except_rec.value ;
    END LOOP ;

    -- execute the exception query inbound
    FOR except_rec IN SELECT * FROM
      (select * from public.dblink(var_conn_string, 'select * from radiusdb.radgroupreply')
         as rec_type(id integer, groupname varchar, attribute varchar, op varchar, value varchar)
       except
       select id, groupname, attribute, op, value from csctoss.radgroupreply) AS inbound
    LOOP
      RETURN NEXT 'INBOUND '||sysparm_rec.hostname||' (radgroupreply): '|| except_rec.id::text
                                                                 ||' - '|| except_rec.groupname
                                                                 ||' - '|| except_rec.attribute
                                                                 ||' - '|| except_rec.op
                                                                 ||' - '|| except_rec.value ;
    END LOOP ;

  END LOOP ;

  RETURN ;

END ;
$_$;


ALTER FUNCTION public.replchk_radgroupreply(text) OWNER TO slony;

--
-- Name: FUNCTION replchk_radgroupreply(text); Type: COMMENT; Schema: public; Owner: slony
--

COMMENT ON FUNCTION replchk_radgroupreply(text) IS 'DB Link function to check replication between csctoss and radiusdb databases for radgroupreply table.';


--
-- Name: replchk_radreply(text); Type: FUNCTION; Schema: public; Owner: slony
--

CREATE FUNCTION replchk_radreply(text) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_host_like     text := $1 ;
  var_conn_string   text ;
  sysparm_rec       record ;
  except_rec        record ;

BEGIN

  -- setup loop and connection strings for all replicated radius databases from system_parameter table
  FOR sysparm_rec IN SELECT * FROM csctoss.system_parameter WHERE repl_flag AND LOWER(hostname) LIKE par_host_like||'%' LOOP

    var_conn_string := 'hostaddr='||sysparm_rec.ip_address||
                          ' port='||sysparm_rec.repl_port||
                        ' dbname='||sysparm_rec.repl_target_db||
                          ' user='||sysparm_rec.repl_target_username||
                      ' password='||sysparm_rec.repl_target_password||'' ;

    -- execute the exception query outbound
    FOR except_rec IN SELECT * FROM
      (select id, username, attribute, op, value, priority from csctoss.radreply
       except
       select * from public.dblink(var_conn_string, 'select * from radiusdb.radreply')
         as rec_type(id integer, username varchar, attribute varchar, op varchar, value varchar, priority integer)) AS outbound
    LOOP
      RETURN NEXT 'OUTBOUND '||sysparm_rec.hostname||' (radreply): '|| except_rec.id::text
                                                             ||' - '|| except_rec.username
                                                             ||' - '|| except_rec.attribute
                                                             ||' - '|| except_rec.op
                                                             ||' - '|| except_rec.value
                                                             ||' - '|| except_rec.priority::text ;
    END LOOP ;

    -- execute the exception query inbound
    FOR except_rec IN SELECT * FROM
      (select * from public.dblink(var_conn_string, 'select * from radiusdb.radreply')
         as rec_type(id integer, username varchar, attribute varchar, op varchar, value varchar, priority integer)
       except
       select id, username, attribute, op, value, priority from csctoss.radreply) AS inbound
    LOOP
      RETURN NEXT 'INBOUND '||sysparm_rec.hostname||' (radreply): '|| except_rec.id::text
                                                            ||' - '|| except_rec.username
                                                            ||' - '|| except_rec.attribute
                                                            ||' - '|| except_rec.op
                                                            ||' - '|| except_rec.value 
                                                            ||' - '|| except_rec.priority::text ;
    END LOOP ;

  END LOOP ;

  RETURN ;

END ;
$_$;


ALTER FUNCTION public.replchk_radreply(text) OWNER TO slony;

--
-- Name: FUNCTION replchk_radreply(text); Type: COMMENT; Schema: public; Owner: slony
--

COMMENT ON FUNCTION replchk_radreply(text) IS 'DB Link function to check replication between csctoss and radiusdb databases for radreply table.';


--
-- Name: replchk_usergroup(text); Type: FUNCTION; Schema: public; Owner: slony
--

CREATE FUNCTION replchk_usergroup(text) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_host_like     text := $1 ;
  var_conn_string   text ;
  sysparm_rec       record ;
  except_rec        record ;

BEGIN

  -- setup loop and connection strings for all replicated radius databases from system_parameter table
  FOR sysparm_rec IN SELECT * FROM csctoss.system_parameter WHERE repl_flag AND LOWER(hostname) LIKE par_host_like||'%' LOOP

    var_conn_string := 'hostaddr='||sysparm_rec.ip_address||
                          ' port='||sysparm_rec.repl_port||
                        ' dbname='||sysparm_rec.repl_target_db||
                          ' user='||sysparm_rec.repl_target_username||
                      ' password='||sysparm_rec.repl_target_password||'' ;

    -- execute the exception query outbound
    FOR except_rec IN SELECT * FROM
      (select id, username, groupname, priority from csctoss.usergroup
       except
       select id, username, groupname, priority from public.dblink(var_conn_string, 'select id, username, groupname, priority from radiusdb.usergroup')
         as rec_type(id integer, username varchar, groupname varchar, priority integer)) AS outbound 
    LOOP
      RETURN NEXT 'OUTBOUND '||sysparm_rec.hostname||' (usergroup): '|| except_rec.id::text
                                                              ||' - '|| except_rec.username
                                                              ||' - '|| except_rec.groupname
                                                              ||' - '|| except_rec.priority::text ;
    END LOOP ;

    -- execute the exception query inbound
    FOR except_rec IN SELECT * FROM
      (select id, username, groupname, priority from public.dblink(var_conn_string, 'select id, username, groupname, priority from radiusdb.usergroup')
         as rec_type(id integer, username varchar, groupname varchar, priority integer)
       except
       select id, username, groupname, priority from csctoss.usergroup) AS inbound
    LOOP
      RETURN NEXT 'INBOUND '||sysparm_rec.hostname||' (usergroup): '|| except_rec.id::text
                                                             ||' - '|| except_rec.username
                                                             ||' - '|| except_rec.groupname
                                                             ||' - '|| except_rec.priority::text ;
    END LOOP ;

  END LOOP ;

  RETURN ;

END ;
$_$;


ALTER FUNCTION public.replchk_usergroup(text) OWNER TO slony;

--
-- Name: FUNCTION replchk_usergroup(text); Type: COMMENT; Schema: public; Owner: slony
--

COMMENT ON FUNCTION replchk_usergroup(text) IS 'DB Link function to check replication between csctoss and radiusdb databases for usergroup table.';


--
-- Name: replchk_username(text); Type: FUNCTION; Schema: public; Owner: slony
--

CREATE FUNCTION replchk_username(text) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE

  par_host_like     text := $1 ;
  var_conn_string   text ;
  sysparm_rec       record ;
  except_rec        record ;

BEGIN

  -- setup loop and connection strings for all replicated radius databases from system_parameter table
  FOR sysparm_rec IN SELECT * FROM csctoss.system_parameter WHERE repl_flag AND LOWER(hostname) LIKE par_host_like||'%' LOOP

    var_conn_string := 'hostaddr='||sysparm_rec.ip_address||
                          ' port='||sysparm_rec.repl_port||
                        ' dbname='||sysparm_rec.repl_target_db||
                          ' user='||sysparm_rec.repl_target_username||
                      ' password='||sysparm_rec.repl_target_password||'' ;

    -- execute the exception query outbound
    FOR except_rec IN SELECT * FROM
      (select username, billing_entity_id, primary_service, enabled, auth_pod, start_date, end_date, date_created from csctoss.username
       except
       select * from public.dblink(var_conn_string, 'select username, billing_entity_id, primary_service, enabled, auth_pod, start_date, end_date, date_created from radiusdb.username')
         as rec_type(username varchar, billing_entity_id integer, primary_service boolean, enabled boolean, auth_pod boolean,
                     start_date date, end_date date, date_created date)) AS outbound
    LOOP
      RETURN NEXT 'OUTBOUND '||sysparm_rec.hostname||' (username): '|| except_rec.username
                                                             ||' - '|| except_rec.billing_entity_id::text
                                                             ||' - '|| case when except_rec.primary_service then 'TRUE' else 'FALSE' end
                                                             ||' - '|| case when except_rec.enabled then 'TRUE' else 'FALSE' end
                                                             ||' - '|| case when except_rec.auth_pod then 'TRUE' else 'FALSE' end
                                                             ||' - '|| except_rec.start_date::text
                                                             ||' - '|| except_rec.end_date::text
                                                             ||' - '|| except_rec.date_created::text ;
    END LOOP ;

    -- execute the exception query inbound
    FOR except_rec IN SELECT * FROM
      (select * from public.dblink(var_conn_string, 'select username, billing_entity_id, primary_service, enabled, auth_pod, start_date, end_date, date_created from radiusdb.username')
         as rec_type(username varchar, billing_entity_id integer, primary_service boolean, enabled boolean, auth_pod boolean,
                     start_date date, end_date date, date_created date)
       except
       select username, billing_entity_id, primary_service, enabled, auth_pod, start_date, end_date, date_created from csctoss.username) AS inbound
    LOOP
      RETURN NEXT 'INBOUND '||sysparm_rec.hostname||' (username): '|| except_rec.username
                                                            ||' - '|| except_rec.billing_entity_id::text
                                                            ||' - '|| case when except_rec.primary_service then 'TRUE' else 'FALSE' end
                                                            ||' - '|| case when except_rec.enabled then 'TRUE' else 'FALSE' end
                                                            ||' - '|| case when except_rec.auth_pod then 'TRUE' else 'FALSE' end
                                                            ||' - '|| except_rec.start_date::text
                                                            ||' - '|| except_rec.end_date::text
                                                            ||' - '|| except_rec.date_created::text ;
    END LOOP ;

  END LOOP ;

  RETURN ;

END ;
$_$;


ALTER FUNCTION public.replchk_username(text) OWNER TO slony;

--
-- Name: FUNCTION replchk_username(text); Type: COMMENT; Schema: public; Owner: slony
--

COMMENT ON FUNCTION replchk_username(text) IS 'DB Link function to check replication between csctoss and radiusdb databases for username table.';


--
-- Name: set_change_log_staff_id(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION set_change_log_staff_id(integer) RETURNS integer
    LANGUAGE c SECURITY DEFINER
    AS 'changelogger', 'set_change_log_staff_id';


ALTER FUNCTION public.set_change_log_staff_id(integer) OWNER TO postgres;

--
-- Name: sprint_pod_expired(); Type: FUNCTION; Schema: public; Owner: slony
--

CREATE FUNCTION sprint_pod_expired() RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE

  var_conn_name          text := 'radius' ;
  var_conn_string        text ;
  var_string             text ;

  rec_sysparm            record ;
  rec_expired            record ;
  rec_mrac               record ;

BEGIN

  -- connect to denrad08 for jci radius data
  SELECT * INTO rec_sysparm FROM csctoss.system_parameter WHERE hostname = 'denrad08' ;

  var_conn_string := 'hostaddr='||rec_sysparm.ip_address||
                        ' port='||rec_sysparm.repl_port||
                      ' dbname='||rec_sysparm.repl_target_db||
                        ' user='||rec_sysparm.repl_target_username||
                    ' password='||rec_sysparm.repl_target_password||'' ;


  -- disconnect in case already open, then open a connection named for each hostname
  BEGIN
    PERFORM public.dblink_disconnect(var_conn_name) ;
  EXCEPTION WHEN OTHERS THEN NULL ;
  END ;

  -- connect and verify success
  BEGIN
    PERFORM public.dblink_connect(var_conn_name, var_conn_string) ;
  EXCEPTION WHEN OTHERS THEN
    RETURN NEXT 'ERROR: Connection Failed for '||var_conn_name ;
  END ;

  -- get list of contracts with null current_plan_id -> expired
  FOR rec_expired IN SELECT *
                       FROM public.dblink(var_conn_name
                                         ,'select distinct
                                                  contract.contract_id
                                                 ,contract.first_day
                                                 ,coalesce(current_plan_id, 0) as current_plan_id
                                                 ,card.phone_number
                                                 ,login.login_name as username
                                             from radius.contract
                                             join radius.card using (contract_id)
                                             join radius.plan using (contract_id)
                                             join radius.login using (contract_id)
                                            where plan.plan_type_id = 8
                                              and contract.current_plan_id is null')
                         AS rec_type
                           (contract_id     integer
                           ,first_day       date
                           ,current_plan_id integer
                           ,phone_number    text
                           ,username        text)
  LOOP

    -- for each expired card fetch last accounting record for evaluation
    SELECT *
      INTO rec_mrac
      FROM public.dblink((select * from csctoss.fetch_csctlog_conn()),
                         'SELECT master_radacctid
                                ,acctsessionid
                                ,username
                                ,framedipaddress
                                ,xascendsessionsvrkey
                                ,acctstarttime
                                ,acctstoptime
                                ,nasidentifier
                            FROM csctlog.master_radacct
                           WHERE username = '||quote_literal(rec_expired.username)||'
                             AND acctstarttime > current_timestamp - interval ''1 day''
                        ORDER BY master_radacctid DESC
                         LIMIT 1')
        AS rec_type(master_radacctid     bigint
                   ,acctsessionid        varchar
                   ,username             varchar
                   ,framedipaddress      inet
                   ,xascendsessionsvrkey varchar
                   ,acctstarttime        timestamptz
                   ,acctstoptime         timestamptz
                   ,nasidentifier        varchar) ;

    -- if null stop (active) determine whether expired group
    IF FOUND AND rec_mrac.acctstoptime IS NULL THEN
      IF (rec_mrac.framedipaddress << '10.47.130.0/24') THEN
        RETURN NEXT rec_mrac.username ||' connected to ATL walled garden using '||rec_mrac.framedipaddress::text ;
      ELSIF (rec_mrac.framedipaddress << '10.47.131.0/24') THEN
        RETURN NEXT rec_mrac.username ||' connected to DEN walled garden using '||rec_mrac.framedipaddress::text ;
      ELSE

        -- all conditions met, expired card connected return the pod string to stdout for capture
        RETURN NEXT 'Acct-Session-Id='||rec_mrac.acctsessionid||','||
                    'User-Name='||rec_mrac.username||','||
                    'Framed-IP-Address='||host(rec_mrac.framedipaddress)::text||','||
                    'X-Ascend-Session-Svr-Key='||rec_mrac.xascendsessionsvrkey||'#'||
                    'LENS='||rec_mrac.nasidentifier ;

      END IF ;
    END IF ;

  END LOOP ;

  RETURN ;

END ;

$$;


ALTER FUNCTION public.sprint_pod_expired() OWNER TO slony;

--
-- Name: FUNCTION sprint_pod_expired(); Type: COMMENT; Schema: public; Owner: slony
--

COMMENT ON FUNCTION sprint_pod_expired() IS 'Sprint packet of disconnect for expired devices that are still connected outside of walled garden.';


SET search_path = carrier, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: api_activity_log; Type: TABLE; Schema: carrier; Owner: carrier_owner; Tablespace: 
--

CREATE TABLE api_activity_log (
    api_activity_log bigint DEFAULT nextval('carrier.api_activity_log_api_activity_log_seq'::text) NOT NULL,
    request_timestamp timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    carrier text NOT NULL,
    line_id integer,
    device_identifier text,
    username text,
    result_code boolean NOT NULL,
    result_desc text DEFAULT ''::text,
    api_called text
);


ALTER TABLE carrier.api_activity_log OWNER TO carrier_owner;

--
-- Name: api_activity_log_api_activity_log_seq; Type: SEQUENCE; Schema: carrier; Owner: carrier_owner
--

CREATE SEQUENCE api_activity_log_api_activity_log_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE carrier.api_activity_log_api_activity_log_seq OWNER TO carrier_owner;

--
-- Name: api_activity_log_api_activity_log_seq; Type: SEQUENCE OWNED BY; Schema: carrier; Owner: carrier_owner
--

ALTER SEQUENCE api_activity_log_api_activity_log_seq OWNED BY api_activity_log.api_activity_log;


--
-- Name: app_config; Type: TABLE; Schema: carrier; Owner: carrier_owner; Tablespace: 
--

CREATE TABLE app_config (
    app_config_id integer DEFAULT nextval('carrier.app_config_app_config_id_seq'::text) NOT NULL,
    application text,
    environment text,
    config_key text NOT NULL,
    config_value text NOT NULL
);


ALTER TABLE carrier.app_config OWNER TO carrier_owner;

--
-- Name: app_config_app_config_id_seq; Type: SEQUENCE; Schema: carrier; Owner: carrier_owner
--

CREATE SEQUENCE app_config_app_config_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE carrier.app_config_app_config_id_seq OWNER TO carrier_owner;

--
-- Name: app_config_app_config_id_seq; Type: SEQUENCE OWNED BY; Schema: carrier; Owner: carrier_owner
--

ALTER SEQUENCE app_config_app_config_id_seq OWNED BY app_config.app_config_id;


--
-- Name: request; Type: TABLE; Schema: carrier; Owner: carrier_owner; Tablespace: 
--

CREATE TABLE request (
    request_id integer DEFAULT nextval('carrier.request_request_id_seq'::text) NOT NULL,
    request_prefix text NOT NULL,
    request_unique_id text NOT NULL,
    request_status_id integer NOT NULL,
    request_time timestamp without time zone DEFAULT now() NOT NULL,
    response_time timestamp without time zone,
    request_error boolean DEFAULT false,
    response_error boolean,
    request_type_id integer NOT NULL,
    request_carrier_id integer NOT NULL,
    request_raw text NOT NULL,
    response_raw_sync text,
    response_raw_async text,
    request_user text NOT NULL,
    order_error_message text
);


ALTER TABLE carrier.request OWNER TO carrier_owner;

--
-- Name: request_carrier; Type: TABLE; Schema: carrier; Owner: carrier_owner; Tablespace: 
--

CREATE TABLE request_carrier (
    request_carrier_id integer DEFAULT nextval('carrier.request_carrier_request_carrier_id_seq'::text) NOT NULL,
    request_carrier text NOT NULL
);


ALTER TABLE carrier.request_carrier OWNER TO carrier_owner;

--
-- Name: request_carrier_request_carrier_id_seq; Type: SEQUENCE; Schema: carrier; Owner: carrier_owner
--

CREATE SEQUENCE request_carrier_request_carrier_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE carrier.request_carrier_request_carrier_id_seq OWNER TO carrier_owner;

--
-- Name: request_carrier_request_carrier_id_seq; Type: SEQUENCE OWNED BY; Schema: carrier; Owner: carrier_owner
--

ALTER SEQUENCE request_carrier_request_carrier_id_seq OWNED BY request_carrier.request_carrier_id;


--
-- Name: request_request_id_seq; Type: SEQUENCE; Schema: carrier; Owner: carrier_owner
--

CREATE SEQUENCE request_request_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE carrier.request_request_id_seq OWNER TO carrier_owner;

--
-- Name: request_request_id_seq; Type: SEQUENCE OWNED BY; Schema: carrier; Owner: carrier_owner
--

ALTER SEQUENCE request_request_id_seq OWNED BY request.request_id;


--
-- Name: request_status; Type: TABLE; Schema: carrier; Owner: carrier_owner; Tablespace: 
--

CREATE TABLE request_status (
    request_status_id integer DEFAULT nextval('carrier.request_status_request_status_id_seq'::text) NOT NULL,
    request_status text NOT NULL
);


ALTER TABLE carrier.request_status OWNER TO carrier_owner;

--
-- Name: request_status_request_status_id_seq; Type: SEQUENCE; Schema: carrier; Owner: carrier_owner
--

CREATE SEQUENCE request_status_request_status_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE carrier.request_status_request_status_id_seq OWNER TO carrier_owner;

--
-- Name: request_status_request_status_id_seq; Type: SEQUENCE OWNED BY; Schema: carrier; Owner: carrier_owner
--

ALTER SEQUENCE request_status_request_status_id_seq OWNED BY request_status.request_status_id;


--
-- Name: request_type; Type: TABLE; Schema: carrier; Owner: carrier_owner; Tablespace: 
--

CREATE TABLE request_type (
    request_type_id integer DEFAULT nextval('carrier.request_type_request_type_id_seq'::text) NOT NULL,
    request_type text NOT NULL
);


ALTER TABLE carrier.request_type OWNER TO carrier_owner;

--
-- Name: request_type_request_type_id_seq; Type: SEQUENCE; Schema: carrier; Owner: carrier_owner
--

CREATE SEQUENCE request_type_request_type_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE carrier.request_type_request_type_id_seq OWNER TO carrier_owner;

--
-- Name: request_type_request_type_id_seq; Type: SEQUENCE OWNED BY; Schema: carrier; Owner: carrier_owner
--

ALTER SEQUENCE request_type_request_type_id_seq OWNED BY request_type.request_type_id;


SET search_path = csctoss, pg_catalog;

--
-- Name: billing_entity; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE billing_entity (
    billing_entity_id integer DEFAULT nextval('csctoss.billing_entity_billing_entity_id_seq'::text) NOT NULL,
    parent_billing_entity_id integer,
    name text NOT NULL,
    phone_number1 text DEFAULT ''::text NOT NULL,
    phone_number2 text,
    fax_number1 text,
    fax_number2 text,
    url text,
    preferred_timezone text DEFAULT 'EDT'::text NOT NULL,
    billing_entity_type text DEFAULT 'UNKNOWN'::text NOT NULL,
    opt_in_flag boolean DEFAULT false NOT NULL,
    CONSTRAINT billing_entity_timezone_ck CHECK (billing_entity_timezone(parent_billing_entity_id, preferred_timezone))
);


ALTER TABLE csctoss.billing_entity OWNER TO csctoss_owner;

--
-- Name: TABLE billing_entity; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE billing_entity IS 'An entity that pays for a line.';


--
-- Name: equipment; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment (
    equipment_id integer DEFAULT nextval('csctoss.equipment_equipment_id_seq'::text) NOT NULL,
    equipment_type text NOT NULL,
    equipment_model_id integer NOT NULL,
    receiving_lot_id integer,
    purchase_price numeric,
    sales_price numeric,
    enabled_flag boolean DEFAULT true NOT NULL,
    equipment_firmware_id integer
);


ALTER TABLE csctoss.equipment OWNER TO csctoss_owner;

--
-- Name: TABLE equipment; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE equipment IS 'Master equipment table tracking all pieces of equipment relative to the CSCTOSS system.';


--
-- Name: equipment_model; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment_model (
    equipment_model_id integer DEFAULT nextval('csctoss.equipment_model_equipment_model_id_seq'::text) NOT NULL,
    model_number1 text NOT NULL,
    model_number2 text,
    model_note text,
    model_description text,
    part_number text,
    make text,
    vendor text,
    provider_or_carrier text NOT NULL,
    source text,
    carrier text,
    lead_time_days integer DEFAULT 0 NOT NULL,
    embedded_equipment_model_id integer,
    web_protocol text DEFAULT 'http://'::text NOT NULL,
    web_port integer DEFAULT 80 NOT NULL,
    CONSTRAINT embedded_equipment_model_id_ck CHECK ((embedded_equipment_model_id <> equipment_model_id)),
    CONSTRAINT equipment_model_provider_or_carrier_ck CHECK (((provider_or_carrier = 'PROVIDER'::text) OR (provider_or_carrier = 'CARRIER'::text)))
);


ALTER TABLE csctoss.equipment_model OWNER TO csctoss_owner;

--
-- Name: TABLE equipment_model; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE equipment_model IS 'Defines equipment models for associating with individual pieces of equipment.';


--
-- Name: line; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE line (
    line_id integer DEFAULT nextval('csctoss.line_line_id_seq'::text) NOT NULL,
    calling_station_id text,
    line_assignment_type text NOT NULL,
    billing_entity_id integer NOT NULL,
    logical_apn text,
    disabled_apn text,
    contact_id integer,
    order_id integer,
    employee_id integer,
    billing_entity_address_id integer NOT NULL,
    active_flag boolean DEFAULT true NOT NULL,
    line_label text,
    start_date timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    end_date timestamp with time zone,
    date_created timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    radius_username text,
    radius_password text,
    radius_auth_type text,
    static_ip_address inet,
    ip_pool text,
    proxy_access text,
    session_timeout_seconds integer,
    idle_timeout_seconds integer,
    primary_dns inet,
    secondary_dns inet,
    current_plan_id integer,
    previous_line_id integer,
    notes text,
    additional_info text,
    CONSTRAINT line_previous_line_id_ck CHECK ((previous_line_id <> line_id)),
    CONSTRAINT line_radius_auth_type_ck CHECK (((radius_auth_type = 'CHAP'::text) OR (radius_auth_type = 'PAP'::text)))
);


ALTER TABLE csctoss.line OWNER TO csctoss_owner;

--
-- Name: TABLE line; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE line IS 'Defines a a line and all the characterstics for that line. Tied to intersection table line_equipment.';


--
-- Name: line_equipment; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE line_equipment (
    line_id integer NOT NULL,
    equipment_id integer NOT NULL,
    start_date date DEFAULT ('now'::text)::date NOT NULL,
    end_date date,
    billing_entity_address_id integer,
    ship_date date,
    install_date date,
    installed_by text
);


ALTER TABLE csctoss.line_equipment OWNER TO csctoss_owner;

--
-- Name: TABLE line_equipment; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE line_equipment IS 'Define directory names for SOUP server.';


--
-- Name: location_labels; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE location_labels (
    line_id integer NOT NULL,
    owner character varying DEFAULT ''::character varying,
    id character varying,
    name character varying DEFAULT ''::character varying,
    address character varying DEFAULT ''::character varying,
    processor character varying DEFAULT ''::character varying,
    fwver character varying,
    uptime integer
);


ALTER TABLE csctoss.location_labels OWNER TO csctoss_owner;

SET default_with_oids = true;

--
-- Name: radreply; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE radreply (
    id integer DEFAULT nextval('csctoss.radreply_id_seq'::text) NOT NULL,
    username character varying(64) DEFAULT ''::character varying NOT NULL,
    attribute character varying(64) DEFAULT ''::character varying NOT NULL,
    op character varying(2) DEFAULT '='::character varying NOT NULL,
    value character varying(253) DEFAULT ''::character varying NOT NULL,
    priority integer DEFAULT 10 NOT NULL
);


ALTER TABLE csctoss.radreply OWNER TO csctoss_owner;

--
-- Name: TABLE radreply; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE radreply IS 'Table structure for table radreply.';


SET default_with_oids = false;

--
-- Name: unique_identifier; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE unique_identifier (
    equipment_id integer NOT NULL,
    unique_identifier_type text NOT NULL,
    value text NOT NULL,
    notes text,
    date_created date DEFAULT ('now'::text)::date NOT NULL,
    date_modified date
);


ALTER TABLE csctoss.unique_identifier OWNER TO csctoss_owner;

--
-- Name: TABLE unique_identifier; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE unique_identifier IS 'Intersection table between equipment and unique_identifier_type storing all equipment unique identifiers.';


--
-- Name: usergroup; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE usergroup (
    id integer DEFAULT nextval('csctoss.usergroup_id_seq'::text) NOT NULL,
    username character varying(64) DEFAULT ''::character varying NOT NULL,
    groupname character varying(64) DEFAULT ''::character varying NOT NULL,
    priority integer DEFAULT 0 NOT NULL
);


ALTER TABLE csctoss.usergroup OWNER TO csctoss_owner;

--
-- Name: TABLE usergroup; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE usergroup IS 'Table structure for table usergroup.';


--
-- Name: active_lines_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW active_lines_vw AS
    SELECT be.billing_entity_id, be.name AS billing_entity_name, line.line_id, line.radius_username, (line.start_date)::date AS line_start_date, (line.end_date)::date AS line_end_date, le.equipment_id, le.start_date AS equip_start_date, le.end_date AS equip_end_date, (SELECT unique_identifier.value FROM unique_identifier WHERE ((le.equipment_id = unique_identifier.equipment_id) AND (unique_identifier.unique_identifier_type = 'SERIAL NUMBER'::text))) AS sn, (SELECT unique_identifier.value FROM unique_identifier WHERE ((le.equipment_id = unique_identifier.equipment_id) AND (unique_identifier.unique_identifier_type = 'MDN'::text))) AS mdn, (SELECT unique_identifier.value FROM unique_identifier WHERE ((le.equipment_id = unique_identifier.equipment_id) AND (unique_identifier.unique_identifier_type = 'MIN'::text))) AS min, (SELECT unique_identifier.value FROM unique_identifier WHERE ((le.equipment_id = unique_identifier.equipment_id) AND (unique_identifier.unique_identifier_type = 'ESN HEX'::text))) AS esn_hex, (SELECT unique_identifier.value FROM unique_identifier WHERE ((le.equipment_id = unique_identifier.equipment_id) AND (unique_identifier.unique_identifier_type = 'ESN DEC'::text))) AS esn_dec, em.model_number1 AS equipment_model, em.model_note, em.vendor, loc.id AS location_id, loc."owner" AS location_owner, loc.name AS location_name, loc.address AS location_address, loc.processor AS location_processor, array_to_string(ARRAY(SELECT usergroup.groupname FROM usergroup WHERE ((usergroup.username)::text = line.radius_username)), ':'::text) AS groupname, (SELECT radreply.value FROM radreply WHERE (((radreply.username)::text = line.radius_username) AND ((radreply.attribute)::text = 'Framed-IP-Address'::text))) AS static_ip_address, timezone('EST'::text, mrad.last_connected_timestamp_for_last30_days_est) AS last_connected_timestamp_for_last30_days_est, mrad.usage_mb_for_last30_days FROM ((((((billing_entity be JOIN line ON ((be.billing_entity_id = line.billing_entity_id))) JOIN line_equipment le ON ((line.line_id = le.line_id))) JOIN equipment eq ON ((le.equipment_id = eq.equipment_id))) JOIN equipment_model em ON ((eq.equipment_model_id = em.equipment_model_id))) LEFT JOIN location_labels loc ON ((loc.line_id = line.line_id))) LEFT JOIN public.dblink((SELECT fetch_csctlog_conn.fetch_csctlog_conn FROM fetch_csctlog_conn()), '\012SET TimeZone TO EST5EDT;\012SELECT\012  username,\012  MAX(acctstarttime::timestamp(0)) AS last_connected_timestamp_for_last30_days_est,\012  TRUNC(SUM(acctinputoctets + acctoutputoctets) / 1024 / 1024, 2) AS usage_mb_for_last30_days\012FROM csctlog.master_radacct mrad\012WHERE 1 = 1\012AND acctstarttime >= (now() - ''30 days''::INTERVAL)\012GROUP BY username\012'::text) mrad(username text, last_connected_timestamp_for_last30_days_est timestamp with time zone, usage_mb_for_last30_days numeric) ON ((line.radius_username = mrad.username))) WHERE (((1 = 1) AND (line.end_date IS NULL)) AND (le.end_date IS NULL));


ALTER TABLE csctoss.active_lines_vw OWNER TO csctoss_owner;

--
-- Name: address; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE address (
    address_id integer DEFAULT nextval('csctoss.address_address_id_seq'::text) NOT NULL,
    line1 text NOT NULL,
    line2 text,
    line3 text,
    line4 text,
    city text NOT NULL,
    state_code character(2) NOT NULL,
    postal_code text NOT NULL,
    latitude text,
    longitude text
);


ALTER TABLE csctoss.address OWNER TO csctoss_owner;

--
-- Name: TABLE address; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE address IS 'All addresses stored in the system for billing entities, contacts, vendors, etc.';


--
-- Name: address_address_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE address_address_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.address_address_id_seq OWNER TO csctoss_owner;

--
-- Name: address_address_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE address_address_id_seq OWNED BY address.address_id;


--
-- Name: address_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE address_type (
    address_type text NOT NULL,
    description text
);


ALTER TABLE csctoss.address_type OWNER TO csctoss_owner;

--
-- Name: TABLE address_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE address_type IS 'Lookup table defining the types of addresses.';


--
-- Name: agreement_table; Type: TABLE; Schema: csctoss; Owner: postgres; Tablespace: 
--

CREATE TABLE agreement_table (
    id integer DEFAULT nextval('csctoss.agreement_table_id_seq'::text) NOT NULL,
    condition smallint NOT NULL,
    billing_entity_id integer NOT NULL,
    time_stamp timestamp with time zone NOT NULL
);


ALTER TABLE csctoss.agreement_table OWNER TO postgres;

--
-- Name: agreement_table_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: postgres
--

CREATE SEQUENCE agreement_table_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.agreement_table_id_seq OWNER TO postgres;

--
-- Name: agreement_table_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: postgres
--

ALTER SEQUENCE agreement_table_id_seq OWNED BY agreement_table.id;


--
-- Name: alert_activity; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE alert_activity (
    alert_activity_id integer DEFAULT nextval('csctoss.alert_activity_alert_activity_id_seq'::text) NOT NULL,
    alert_definition_id integer NOT NULL,
    alert_status text DEFAULT 'OPEN'::text NOT NULL,
    created_timestamp timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    alert_timestamp timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    alert_count integer DEFAULT 0 NOT NULL,
    notes text DEFAULT ''::text NOT NULL,
    acctsessionid character varying(32),
    master_radacctid bigint,
    CONSTRAINT alert_activity_alert_status_ck CHECK ((((alert_status = 'OPEN'::text) OR (alert_status = 'WORKING'::text)) OR (alert_status = 'CLOSED'::text)))
);


ALTER TABLE csctoss.alert_activity OWNER TO csctoss_owner;

--
-- Name: TABLE alert_activity; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE alert_activity IS 'Tracks the actual alerts which have activated and queued. Then manages the status and when they are resolved and by whom. Offer alert history.';


--
-- Name: alert_activity_alert_activity_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE alert_activity_alert_activity_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.alert_activity_alert_activity_id_seq OWNER TO csctoss_owner;

--
-- Name: alert_activity_alert_activity_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE alert_activity_alert_activity_id_seq OWNED BY alert_activity.alert_activity_id;


--
-- Name: alert_definition; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE alert_definition (
    alert_definition_id integer DEFAULT nextval('csctoss.alert_definition_alert_definition_id_seq'::text) NOT NULL,
    alert_type_id integer NOT NULL,
    username text NOT NULL,
    enabled boolean DEFAULT true NOT NULL,
    check_interval_minutes integer DEFAULT 0 NOT NULL,
    bytes_ignore_threshold integer DEFAULT 0 NOT NULL,
    time_ignore_threshold text,
    time_notification_interval text,
    time_reconnect_interval text,
    nagios_server text,
    nagios_failure_text text,
    nagios_success_text text,
    nagios_unknown_text text,
    max_notifications_per_alert integer,
    max_incidents_per_day integer DEFAULT 1 NOT NULL,
    alert_subject text NOT NULL,
    alert_text text,
    CONSTRAINT alert_definition_max_notifications_per_alert_ck CHECK ((max_notifications_per_alert > 0))
);


ALTER TABLE csctoss.alert_definition OWNER TO csctoss_owner;

--
-- Name: TABLE alert_definition; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE alert_definition IS 'Governing table which defines the alerts for a given username. Central table to manage alerts.';


--
-- Name: alert_definition_alert_definition_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE alert_definition_alert_definition_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.alert_definition_alert_definition_id_seq OWNER TO csctoss_owner;

--
-- Name: alert_definition_alert_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE alert_definition_alert_definition_id_seq OWNED BY alert_definition.alert_definition_id;


--
-- Name: alert_definition_contact; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE alert_definition_contact (
    alert_definition_id integer NOT NULL,
    contact_id integer NOT NULL,
    enabled boolean DEFAULT true NOT NULL,
    send_email boolean DEFAULT false NOT NULL,
    send_text_to_phone boolean DEFAULT false NOT NULL,
    internal_external text NOT NULL,
    CONSTRAINT alert_definition_contact_internal_external_ck CHECK (((internal_external = 'INTERNAL'::text) OR (internal_external = 'EXTERNAL'::text)))
);


ALTER TABLE csctoss.alert_definition_contact OWNER TO csctoss_owner;

--
-- Name: TABLE alert_definition_contact; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE alert_definition_contact IS 'Intersection table combining an alert definition and the contacts whom should be notified.';


--
-- Name: alert_definition_snmp; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE alert_definition_snmp (
    alert_definition_id integer NOT NULL,
    hostname_or_ip text NOT NULL,
    community_string text,
    enabled boolean DEFAULT true NOT NULL
);


ALTER TABLE csctoss.alert_definition_snmp OWNER TO csctoss_owner;

--
-- Name: TABLE alert_definition_snmp; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE alert_definition_snmp IS 'Table to manage the snmp traps and messages for a given alert definition.';


--
-- Name: alert_priority; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE alert_priority (
    alert_priority_id integer NOT NULL,
    alert_priority_desc text NOT NULL
);


ALTER TABLE csctoss.alert_priority OWNER TO csctoss_owner;

--
-- Name: alert_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE alert_type (
    alert_type_id integer DEFAULT nextval('csctoss.alert_type_alert_type_id_seq'::text) NOT NULL,
    alert_type text NOT NULL,
    description text NOT NULL,
    oid text,
    value text
);


ALTER TABLE csctoss.alert_type OWNER TO csctoss_owner;

--
-- Name: TABLE alert_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE alert_type IS 'Lookup table defining the types of alerts for internal and external monitoring.';


--
-- Name: alert_type_alert_type_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE alert_type_alert_type_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.alert_type_alert_type_id_seq OWNER TO csctoss_owner;

--
-- Name: alert_type_alert_type_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE alert_type_alert_type_id_seq OWNED BY alert_type.alert_type_id;


--
-- Name: alert_usage_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE alert_usage_type (
    alert_type_id integer NOT NULL,
    alert_type text NOT NULL,
    alert_type_desc text NOT NULL
);


ALTER TABLE csctoss.alert_usage_type OWNER TO csctoss_owner;

--
-- Name: alerts; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE alerts (
    alert_id integer DEFAULT nextval('csctoss.alerts_alert_id_seq'::text) NOT NULL,
    line_id integer NOT NULL,
    usage_mb numeric NOT NULL,
    alert_message text NOT NULL,
    priority_id integer NOT NULL,
    alert_type_id integer NOT NULL,
    "timestamp" timestamp without time zone DEFAULT now() NOT NULL,
    alert_active boolean DEFAULT false NOT NULL
);


ALTER TABLE csctoss.alerts OWNER TO csctoss_owner;

--
-- Name: alerts_alert_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE alerts_alert_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.alerts_alert_id_seq OWNER TO csctoss_owner;

--
-- Name: alerts_alert_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE alerts_alert_id_seq OWNED BY alerts.alert_id;


--
-- Name: api_device_login; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE api_device_login (
    device_login_id integer DEFAULT nextval('csctoss.api_device_login_device_login_id_seq'::text) NOT NULL,
    login_type text NOT NULL,
    username_parameter text,
    password_parameter text,
    invalid_login_response text,
    parser_id integer
);


ALTER TABLE csctoss.api_device_login OWNER TO csctoss_owner;

--
-- Name: api_device_login_device_login_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE api_device_login_device_login_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.api_device_login_device_login_id_seq OWNER TO csctoss_owner;

--
-- Name: api_device_login_device_login_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE api_device_login_device_login_id_seq OWNED BY api_device_login.device_login_id;


--
-- Name: api_device_parser; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE api_device_parser (
    device_id integer NOT NULL,
    parser_id integer NOT NULL
);


ALTER TABLE csctoss.api_device_parser OWNER TO csctoss_owner;

--
-- Name: api_key; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE api_key (
    api_key_id integer DEFAULT nextval('csctoss.api_key_api_key_id_seq'::text) NOT NULL,
    billing_entity_id integer NOT NULL,
    api_key text NOT NULL,
    api_key_type text DEFAULT 'INTERNAL'::text NOT NULL,
    CONSTRAINT api_key_api_key_type_ck CHECK ((((api_key_type = 'INTERNAL'::text) OR (api_key_type = 'EXTERNAL'::text)) OR (api_key_type = 'MASTER'::text)))
);


ALTER TABLE csctoss.api_key OWNER TO csctoss_owner;

--
-- Name: TABLE api_key; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE api_key IS 'Table defining customer network API key information.';


--
-- Name: api_key_api_key_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE api_key_api_key_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.api_key_api_key_id_seq OWNER TO csctoss_owner;

--
-- Name: api_key_api_key_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE api_key_api_key_id_seq OWNED BY api_key.api_key_id;


--
-- Name: api_parser; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE api_parser (
    parser_id integer DEFAULT nextval('csctoss.api_parser_parser_id_seq'::text) NOT NULL,
    url text NOT NULL,
    method text NOT NULL,
    parameters text,
    parse_if_lite boolean DEFAULT true NOT NULL,
    description text
);


ALTER TABLE csctoss.api_parser OWNER TO csctoss_owner;

--
-- Name: api_parser_parser_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE api_parser_parser_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.api_parser_parser_id_seq OWNER TO csctoss_owner;

--
-- Name: api_parser_parser_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE api_parser_parser_id_seq OWNED BY api_parser.parser_id;


SET default_with_oids = true;

--
-- Name: api_request_log; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE api_request_log (
    api_request_id bigint NOT NULL,
    api_key character varying(255),
    api_name character varying(255),
    billing_entity_id integer,
    request_date timestamp with time zone,
    requestor_ip character varying(255),
    status character varying(255),
    status_reason character varying(255)
);


ALTER TABLE csctoss.api_request_log OWNER TO csctoss_owner;

--
-- Name: api_request_log_api_request_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE api_request_log_api_request_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.api_request_log_api_request_id_seq OWNER TO csctoss_owner;

SET default_with_oids = false;

--
-- Name: api_supported_device; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE api_supported_device (
    device_id integer DEFAULT nextval('csctoss.api_supported_device_device_id_seq'::text) NOT NULL,
    equipment_firmware_id integer NOT NULL,
    device_login_id integer NOT NULL
);


ALTER TABLE csctoss.api_supported_device OWNER TO csctoss_owner;

--
-- Name: api_supported_device_device_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE api_supported_device_device_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.api_supported_device_device_id_seq OWNER TO csctoss_owner;

--
-- Name: api_supported_device_device_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE api_supported_device_device_id_seq OWNED BY api_supported_device.device_id;


--
-- Name: app_config; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE app_config (
    app_config_id integer DEFAULT nextval('csctoss.app_config_app_config_id_seq'::text) NOT NULL,
    application text,
    environment text,
    config_key text NOT NULL,
    config_value text NOT NULL,
    CONSTRAINT app_config_environment_ck CHECK (((environment = 'ATLANTA'::text) OR (environment = 'DENVER'::text)))
);


ALTER TABLE csctoss.app_config OWNER TO csctoss_owner;

--
-- Name: TABLE app_config; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE app_config IS 'Table storing UI application configuration information and settings.';


--
-- Name: app_config_app_config_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE app_config_app_config_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.app_config_app_config_id_seq OWNER TO csctoss_owner;

--
-- Name: app_config_app_config_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE app_config_app_config_id_seq OWNED BY app_config.app_config_id;


--
-- Name: atm_processor; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE atm_processor (
    atm_processor text NOT NULL,
    description text
);


ALTER TABLE csctoss.atm_processor OWNER TO csctoss_owner;

--
-- Name: TABLE atm_processor; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE atm_processor IS 'Lookup table defining various atm processors.';


--
-- Name: attribute; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE attribute (
    attribute character varying(64) NOT NULL,
    attribute_type character varying(32) NOT NULL,
    description character varying(256)
);


ALTER TABLE csctoss.attribute OWNER TO csctoss_owner;

--
-- Name: TABLE attribute; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE attribute IS 'Utility table for building attribute values from partial values defined by engineering staff.';


--
-- Name: attribute_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE attribute_type (
    attribute_type character varying(32) NOT NULL,
    description character varying(128) NOT NULL
);


ALTER TABLE csctoss.attribute_type OWNER TO csctoss_owner;

--
-- Name: TABLE attribute_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE attribute_type IS 'Intersection table between api_supported_device and api_parser.';


--
-- Name: billing_entity_address; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE billing_entity_address (
    billing_entity_id integer NOT NULL,
    address_type text NOT NULL,
    address_id integer NOT NULL
);


ALTER TABLE csctoss.billing_entity_address OWNER TO csctoss_owner;

--
-- Name: TABLE billing_entity_address; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE billing_entity_address IS 'Intersection table associating addresses with contacts. Only one address type per contact.';


--
-- Name: billing_entity_billing_entity_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE billing_entity_billing_entity_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.billing_entity_billing_entity_id_seq OWNER TO csctoss_owner;

--
-- Name: billing_entity_billing_entity_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE billing_entity_billing_entity_id_seq OWNED BY billing_entity.billing_entity_id;


--
-- Name: billing_entity_download; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE billing_entity_download (
    billing_entity_id integer NOT NULL,
    file_name text NOT NULL,
    link_description text NOT NULL,
    mime_type text NOT NULL,
    file_type text NOT NULL,
    download_name text NOT NULL,
    create_date date NOT NULL,
    accounting_date date NOT NULL
);


ALTER TABLE csctoss.billing_entity_download OWNER TO csctoss_owner;

--
-- Name: TABLE billing_entity_download; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE billing_entity_download IS ' Files available for download in the Portal by Billing Entity.';


--
-- Name: billing_entity_fusio; Type: TABLE; Schema: csctoss; Owner: postgres; Tablespace: 
--

CREATE TABLE billing_entity_fusio (
    billing_entity_id integer,
    fusio_user text
);


ALTER TABLE csctoss.billing_entity_fusio OWNER TO postgres;

--
-- Name: billing_entity_location_label; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE billing_entity_location_label (
    billing_entity_address_id integer NOT NULL,
    location_label_type text NOT NULL,
    location_label text NOT NULL,
    notes text
);


ALTER TABLE csctoss.billing_entity_location_label OWNER TO csctoss_owner;

--
-- Name: TABLE billing_entity_location_label; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE billing_entity_location_label IS 'Intersection table used to manage the various location labels (internal, customer, etc) tied to an address_id for a equipment assignment.';


--
-- Name: billing_entity_product; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE billing_entity_product (
    billing_entity_id integer NOT NULL,
    product_id integer NOT NULL,
    service_groupname character varying(64) NOT NULL,
    expired_groupname character varying(64) DEFAULT 'disconnected'::character varying NOT NULL
);


ALTER TABLE csctoss.billing_entity_product OWNER TO csctoss_owner;

--
-- Name: TABLE billing_entity_product; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE billing_entity_product IS 'Intersection table mapping billing entities to products and default radius service and expired groupnames.';


--
-- Name: billing_entity_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE billing_entity_type (
    billing_entity_type text NOT NULL,
    description text NOT NULL
);


ALTER TABLE csctoss.billing_entity_type OWNER TO csctoss_owner;

--
-- Name: TABLE billing_entity_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE billing_entity_type IS 'Lookup table defining domains and username component for each carrier.';


--
-- Name: bp_aggregate_usage_plan; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_aggregate_usage_plan (
    bp_aggregate_usage_plan_id integer DEFAULT nextval('csctoss.bp_aggregate_usage_plan_bp_aggregate_usage_plan_id_seq'::text) NOT NULL,
    bp_billing_charge_usage_id integer NOT NULL,
    tier_number integer NOT NULL,
    tier_allotment bigint NOT NULL,
    cost_per_unit double precision NOT NULL,
    charge_unit text NOT NULL,
    bp_billing_discount_type text,
    discount_amount double precision,
    CONSTRAINT bp_aggregate_usage_plan_cost_per_unit_ck CHECK (bp_cost_per_unit_ck('bp_aggregate_usage_plan'::text, cost_per_unit, bp_billing_charge_usage_id)),
    CONSTRAINT bp_aggregate_usage_plan_cost_per_unit_value_ck CHECK ((cost_per_unit >= (0)::double precision)),
    CONSTRAINT bp_aggregate_usage_plan_tier_allotment_value_ck CHECK ((tier_allotment >= 0)),
    CONSTRAINT bp_aggregate_usage_plan_tier_number_value_ck CHECK ((tier_number > 0))
);


ALTER TABLE csctoss.bp_aggregate_usage_plan OWNER TO csctoss_owner;

--
-- Name: TABLE bp_aggregate_usage_plan; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_aggregate_usage_plan IS 'Detail for usage-based aggregate billing tiers';


--
-- Name: bp_aggregate_usage_plan_bp_aggregate_usage_plan_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE bp_aggregate_usage_plan_bp_aggregate_usage_plan_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.bp_aggregate_usage_plan_bp_aggregate_usage_plan_id_seq OWNER TO csctoss_owner;

--
-- Name: bp_aggregate_usage_plan_bp_aggregate_usage_plan_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE bp_aggregate_usage_plan_bp_aggregate_usage_plan_id_seq OWNED BY bp_aggregate_usage_plan.bp_aggregate_usage_plan_id;


--
-- Name: bp_allotment_adjustment_history; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_allotment_adjustment_history (
    bp_usage_allotment_id integer NOT NULL,
    change_date date NOT NULL,
    previous_allotment bigint NOT NULL,
    new_allotment bigint NOT NULL,
    changed_by text NOT NULL,
    change_description text NOT NULL
);


ALTER TABLE csctoss.bp_allotment_adjustment_history OWNER TO csctoss_owner;

--
-- Name: TABLE bp_allotment_adjustment_history; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_allotment_adjustment_history IS 'Track changes in usage allotments for master billing plans over time';


--
-- Name: bp_billing_calendar; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_billing_calendar (
    bp_billing_calendar_id integer DEFAULT nextval('csctoss.bp_billing_calendar_bp_billing_calendar_id_seq'::text) NOT NULL,
    description text NOT NULL
);


ALTER TABLE csctoss.bp_billing_calendar OWNER TO csctoss_owner;

--
-- Name: TABLE bp_billing_calendar; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_billing_calendar IS 'Billing calendar for billing cycles';


--
-- Name: bp_billing_calendar_bp_billing_calendar_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE bp_billing_calendar_bp_billing_calendar_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.bp_billing_calendar_bp_billing_calendar_id_seq OWNER TO csctoss_owner;

--
-- Name: bp_billing_calendar_bp_billing_calendar_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE bp_billing_calendar_bp_billing_calendar_id_seq OWNED BY bp_billing_calendar.bp_billing_calendar_id;


--
-- Name: bp_billing_period; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_billing_period (
    bp_billing_period_id integer DEFAULT nextval('csctoss.bp_billing_period_bp_billing_period_id_seq'::text) NOT NULL,
    bp_billing_calendar_id integer NOT NULL,
    name text NOT NULL,
    start_date date NOT NULL,
    end_date date NOT NULL
);


ALTER TABLE csctoss.bp_billing_period OWNER TO csctoss_owner;

--
-- Name: TABLE bp_billing_period; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_billing_period IS 'Billing periods for a billing calendar';


--
-- Name: bp_billing_calendar_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW bp_billing_calendar_vw AS
    SELECT cal.bp_billing_calendar_id, cal.description AS billing_calendar, per.bp_billing_period_id, per.name AS billing_period, per.start_date AS period_start_date, per.end_date AS period_end_date FROM bp_billing_calendar cal, bp_billing_period per WHERE (per.bp_billing_calendar_id = cal.bp_billing_calendar_id) ORDER BY cal.description, per.start_date;


ALTER TABLE csctoss.bp_billing_calendar_vw OWNER TO csctoss_owner;

--
-- Name: VIEW bp_billing_calendar_vw; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON VIEW bp_billing_calendar_vw IS 'Billing calendars with billing periods';


--
-- Name: bp_billing_charge; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_billing_charge (
    bp_billing_charge_id integer DEFAULT nextval('csctoss.bp_billing_charge_bp_billing_charge_id_seq'::text) NOT NULL,
    bp_master_billing_plan_id integer NOT NULL,
    bp_billing_charge_type text NOT NULL,
    internal_description text NOT NULL,
    print_description text NOT NULL,
    print_order integer DEFAULT 1000 NOT NULL,
    start_date date,
    end_date date,
    apply_sales_tax boolean DEFAULT true NOT NULL,
    apply_communication_tax boolean DEFAULT true NOT NULL,
    sales_order_number text,
    CONSTRAINT bp_billing_charge_onetime_date_required_ck CHECK (bp_billing_charge_onetime_dates_required(bp_billing_charge_type, start_date, end_date))
);


ALTER TABLE csctoss.bp_billing_charge OWNER TO csctoss_owner;

--
-- Name: TABLE bp_billing_charge; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_billing_charge IS 'Charge record for customer billing';


--
-- Name: bp_billing_charge_bp_billing_charge_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE bp_billing_charge_bp_billing_charge_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.bp_billing_charge_bp_billing_charge_id_seq OWNER TO csctoss_owner;

--
-- Name: bp_billing_charge_bp_billing_charge_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE bp_billing_charge_bp_billing_charge_id_seq OWNED BY bp_billing_charge.bp_billing_charge_id;


--
-- Name: bp_billing_charge_discount; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_billing_charge_discount (
    bp_billing_charge_discount_id integer DEFAULT nextval('csctoss.bp_billing_charge_discount_bp_billing_charge_discount_id_seq'::text) NOT NULL,
    bp_billing_charge_id integer NOT NULL,
    bp_billing_discount_type text NOT NULL,
    discount_amount double precision NOT NULL,
    description text NOT NULL,
    process_order integer DEFAULT 1 NOT NULL,
    start_date date,
    end_date date,
    CONSTRAINT bp_billing_charge_discount_date_window_ck CHECK (bp_billing_charge_discount_date_window(bp_billing_charge_id, start_date, end_date)),
    CONSTRAINT bp_billing_charge_discount_discount_amount_ck CHECK ((discount_amount > (0)::double precision)),
    CONSTRAINT bp_billing_charge_discount_process_order_ck CHECK ((process_order >= 0))
);


ALTER TABLE csctoss.bp_billing_charge_discount OWNER TO csctoss_owner;

--
-- Name: TABLE bp_billing_charge_discount; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_billing_charge_discount IS 'Detail for billing charges discounts';


--
-- Name: bp_billing_charge_discount_bp_billing_charge_discount_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE bp_billing_charge_discount_bp_billing_charge_discount_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.bp_billing_charge_discount_bp_billing_charge_discount_id_seq OWNER TO csctoss_owner;

--
-- Name: bp_billing_charge_discount_bp_billing_charge_discount_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE bp_billing_charge_discount_bp_billing_charge_discount_id_seq OWNED BY bp_billing_charge_discount.bp_billing_charge_discount_id;


--
-- Name: bp_billing_charge_onetime; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_billing_charge_onetime (
    bp_billing_charge_onetime_id integer DEFAULT nextval('csctoss.bp_billing_charge_onetime_bp_billing_charge_onetime_id_seq'::text) NOT NULL,
    bp_billing_charge_id integer NOT NULL,
    charge_amount double precision NOT NULL,
    CONSTRAINT bp_billing_charge_onetime_bp_billing_charge_id_ck CHECK (bp_check_billing_charge_id('ONE-TIME'::text, bp_billing_charge_id)),
    CONSTRAINT bp_billing_charge_onetime_charge_amount_value_ck CHECK ((charge_amount >= (0)::double precision))
);


ALTER TABLE csctoss.bp_billing_charge_onetime OWNER TO csctoss_owner;

--
-- Name: TABLE bp_billing_charge_onetime; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_billing_charge_onetime IS 'Detail for onetime billing charges';


--
-- Name: bp_billing_charge_onetime_bp_billing_charge_onetime_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE bp_billing_charge_onetime_bp_billing_charge_onetime_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.bp_billing_charge_onetime_bp_billing_charge_onetime_id_seq OWNER TO csctoss_owner;

--
-- Name: bp_billing_charge_onetime_bp_billing_charge_onetime_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE bp_billing_charge_onetime_bp_billing_charge_onetime_id_seq OWNED BY bp_billing_charge_onetime.bp_billing_charge_onetime_id;


--
-- Name: bp_billing_charge_static; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_billing_charge_static (
    bp_billing_charge_static_id integer DEFAULT nextval('csctoss.bp_billing_charge_static_bp_billing_charge_static_id_seq'::text) NOT NULL,
    bp_billing_charge_id integer NOT NULL,
    charge_amount double precision NOT NULL,
    bp_charge_frequency integer NOT NULL,
    prorate boolean DEFAULT false NOT NULL,
    equipment_related boolean DEFAULT true NOT NULL,
    CONSTRAINT bp_billing_charge_static_bp_billing_charge_id_ck CHECK (bp_check_billing_charge_id('STATIC'::text, bp_billing_charge_id)),
    CONSTRAINT bp_billing_charge_static_charge_amount_value_ck CHECK ((charge_amount >= (0)::double precision))
);


ALTER TABLE csctoss.bp_billing_charge_static OWNER TO csctoss_owner;

--
-- Name: TABLE bp_billing_charge_static; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_billing_charge_static IS 'Detail for static billing charges';


--
-- Name: bp_billing_charge_static_bp_billing_charge_static_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE bp_billing_charge_static_bp_billing_charge_static_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.bp_billing_charge_static_bp_billing_charge_static_id_seq OWNER TO csctoss_owner;

--
-- Name: bp_billing_charge_static_bp_billing_charge_static_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE bp_billing_charge_static_bp_billing_charge_static_id_seq OWNED BY bp_billing_charge_static.bp_billing_charge_static_id;


--
-- Name: bp_billing_charge_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_billing_charge_type (
    bp_billing_charge_type text NOT NULL,
    description text NOT NULL
);


ALTER TABLE csctoss.bp_billing_charge_type OWNER TO csctoss_owner;

--
-- Name: TABLE bp_billing_charge_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_billing_charge_type IS 'Types of charges for customer billing';


--
-- Name: bp_billing_charge_unit; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_billing_charge_unit (
    bp_billing_charge_unit text NOT NULL,
    description text NOT NULL
);


ALTER TABLE csctoss.bp_billing_charge_unit OWNER TO csctoss_owner;

--
-- Name: TABLE bp_billing_charge_unit; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_billing_charge_unit IS 'Units used for usage-based customer billing';


--
-- Name: bp_billing_charge_usage; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_billing_charge_usage (
    bp_billing_charge_usage_id integer DEFAULT nextval('csctoss.bp_billing_charge_usage_bp_billing_charge_usage_id_seq'::text) NOT NULL,
    bp_billing_charge_id integer NOT NULL,
    per_session boolean DEFAULT false NOT NULL,
    carrier text DEFAULT 'USCC'::text NOT NULL,
    cost_per_unit double precision,
    bp_billing_charge_unit text,
    CONSTRAINT bp_billing_charge_usage_bp_billing_charge_id_ck CHECK (bp_check_billing_charge_id('USAGE'::text, bp_billing_charge_id)),
    CONSTRAINT bp_billing_charge_usage_cost_per_unit_ck CHECK (bp_cost_per_unit_ck('bp_billing_charge_usage'::text, cost_per_unit, bp_billing_charge_usage_id)),
    CONSTRAINT bp_billing_charge_usage_cost_per_unit_value_ck CHECK ((cost_per_unit >= (0)::double precision))
);


ALTER TABLE csctoss.bp_billing_charge_usage OWNER TO csctoss_owner;

--
-- Name: TABLE bp_billing_charge_usage; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_billing_charge_usage IS 'Detail for usage-based billing charge';


--
-- Name: bp_billing_charge_usage_bp_billing_charge_usage_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE bp_billing_charge_usage_bp_billing_charge_usage_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.bp_billing_charge_usage_bp_billing_charge_usage_id_seq OWNER TO csctoss_owner;

--
-- Name: bp_billing_charge_usage_bp_billing_charge_usage_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE bp_billing_charge_usage_bp_billing_charge_usage_id_seq OWNED BY bp_billing_charge_usage.bp_billing_charge_usage_id;


--
-- Name: bp_master_billing_plan; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_master_billing_plan (
    bp_master_billing_plan_id integer DEFAULT nextval('csctoss.bp_master_billing_plan_bp_master_billing_plan_id_seq'::text) NOT NULL,
    billing_entity_id integer NOT NULL,
    start_date date NOT NULL,
    end_date date NOT NULL,
    bp_billing_calendar_id integer NOT NULL,
    description text NOT NULL,
    currency_id integer NOT NULL,
    anniversary_date date
);


ALTER TABLE csctoss.bp_master_billing_plan OWNER TO csctoss_owner;

--
-- Name: TABLE bp_master_billing_plan; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_master_billing_plan IS 'Top level table for a billing plan, i.e. a line.';


--
-- Name: bp_billing_charge_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW bp_billing_charge_vw AS
    SELECT bica.bp_billing_charge_id, bmp.bp_master_billing_plan_id, bica.bp_billing_charge_type, bica.internal_description, bica.print_description, bica.print_order, COALESCE(bica.start_date, bmp.start_date) AS start_date, COALESCE(bica.end_date, bmp.end_date) AS end_date, bica.apply_sales_tax, bica.apply_communication_tax FROM bp_billing_charge bica, bp_master_billing_plan bmp WHERE (bmp.bp_master_billing_plan_id = bica.bp_master_billing_plan_id) ORDER BY bica.print_order;


ALTER TABLE csctoss.bp_billing_charge_vw OWNER TO csctoss_owner;

--
-- Name: VIEW bp_billing_charge_vw; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON VIEW bp_billing_charge_vw IS 'Billing charges with dates inherited from the master billing plan if needed';


--
-- Name: bp_billing_discount_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_billing_discount_type (
    bp_billing_discount_type text NOT NULL,
    description text NOT NULL
);


ALTER TABLE csctoss.bp_billing_discount_type OWNER TO csctoss_owner;

--
-- Name: TABLE bp_billing_discount_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_billing_discount_type IS 'Types of discounts for customer billing';


--
-- Name: bp_billing_entity_preferences; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_billing_entity_preferences (
    billing_entity_id integer NOT NULL,
    currency_id integer NOT NULL,
    bp_billing_calendar_id integer NOT NULL,
    mailing_address_id integer NOT NULL,
    billed_by integer NOT NULL,
    billed_by_logo_file text DEFAULT 'images/ContourReportLogo.jpg'::text NOT NULL,
    language text DEFAULT 'en_US'::text NOT NULL,
    report_file text DEFAULT 'standard_invoice'::text NOT NULL,
    salesperson text,
    payment_terms text DEFAULT 'Net 30 days'::text NOT NULL,
    sales_tax_rate numeric(7,4) DEFAULT 0 NOT NULL,
    communication_tax_rate numeric(7,4) DEFAULT 0 NOT NULL
);


ALTER TABLE csctoss.bp_billing_entity_preferences OWNER TO csctoss_owner;

--
-- Name: TABLE bp_billing_entity_preferences; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_billing_entity_preferences IS 'Store company defaults for billing and reporting engines';


--
-- Name: bp_billing_equipment_assignment; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_billing_equipment_assignment (
    bp_billing_equipment_assignment_id integer DEFAULT nextval('csctoss.bp_billing_equipment_assignme_bp_billing_equipment_assignme_seq'::text) NOT NULL,
    bp_billing_charge_id integer NOT NULL,
    equipment_id integer,
    start_date timestamp with time zone DEFAULT ('now'::text)::date NOT NULL,
    end_date timestamp with time zone,
    note text,
    line_id integer NOT NULL
);


ALTER TABLE csctoss.bp_billing_equipment_assignment OWNER TO csctoss_owner;

--
-- Name: TABLE bp_billing_equipment_assignment; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_billing_equipment_assignment IS 'Intersection table to attach equipment to a billing charge for the billing process';


--
-- Name: bp_billing_equipment_assignme_bp_billing_equipment_assignme_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE bp_billing_equipment_assignme_bp_billing_equipment_assignme_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.bp_billing_equipment_assignme_bp_billing_equipment_assignme_seq OWNER TO csctoss_owner;

--
-- Name: bp_billing_equipment_assignme_bp_billing_equipment_assignme_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE bp_billing_equipment_assignme_bp_billing_equipment_assignme_seq OWNED BY bp_billing_equipment_assignment.bp_billing_equipment_assignment_id;


--
-- Name: bp_billing_period_bp_billing_period_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE bp_billing_period_bp_billing_period_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.bp_billing_period_bp_billing_period_id_seq OWNER TO csctoss_owner;

--
-- Name: bp_billing_period_bp_billing_period_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE bp_billing_period_bp_billing_period_id_seq OWNED BY bp_billing_period.bp_billing_period_id;


--
-- Name: bp_charge_frequency; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_charge_frequency (
    bp_charge_frequency integer NOT NULL,
    description text NOT NULL
);


ALTER TABLE csctoss.bp_charge_frequency OWNER TO csctoss_owner;

--
-- Name: TABLE bp_charge_frequency; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_charge_frequency IS 'Number of periods over which a charge is incurred';


--
-- Name: bp_master_billing_plan_assignment_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW bp_master_billing_plan_assignment_vw AS
    SELECT bich.bp_master_billing_plan_id, mbp.description AS master_billing_plan, mbp.bp_billing_calendar_id, bica.description AS billing_calendar, mbp.billing_entity_id, bent.name AS billing_entity, bich.bp_billing_charge_id, bich.bp_billing_charge_type, bich.internal_description AS charge_internal_description, bich.print_description AS charge_print_description, COALESCE(bich.start_date, mbp.start_date) AS billing_charge_start_date, COALESCE(bich.end_date, mbp.end_date) AS billing_charge_end_date, bbea.equipment_id, equp.equipment_type, bbea.start_date AS equipment_charge_assign_start_date, bbea.end_date AS equipment_charge_assign_end_date, bbea.note FROM bp_master_billing_plan mbp, bp_billing_calendar bica, billing_entity bent, bp_billing_charge bich, bp_billing_equipment_assignment bbea, equipment equp WHERE (((((mbp.bp_billing_calendar_id = bica.bp_billing_calendar_id) AND (mbp.billing_entity_id = bent.billing_entity_id)) AND (mbp.bp_master_billing_plan_id = bich.bp_master_billing_plan_id)) AND (bbea.bp_billing_charge_id = bich.bp_billing_charge_id)) AND (equp.equipment_id = bbea.equipment_id));


ALTER TABLE csctoss.bp_master_billing_plan_assignment_vw OWNER TO csctoss_owner;

--
-- Name: VIEW bp_master_billing_plan_assignment_vw; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON VIEW bp_master_billing_plan_assignment_vw IS 'Master billing plan equipment assignments view with dates';


--
-- Name: bp_master_billing_plan_bp_master_billing_plan_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE bp_master_billing_plan_bp_master_billing_plan_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.bp_master_billing_plan_bp_master_billing_plan_id_seq OWNER TO csctoss_owner;

--
-- Name: bp_master_billing_plan_bp_master_billing_plan_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE bp_master_billing_plan_bp_master_billing_plan_id_seq OWNED BY bp_master_billing_plan.bp_master_billing_plan_id;


--
-- Name: bp_past_due_charge; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_past_due_charge (
    bp_past_due_charge_id integer DEFAULT nextval('csctoss.bp_past_due_charge_bp_past_due_charge_id_seq'::text) NOT NULL,
    bp_master_billing_plan_id integer NOT NULL,
    bp_billing_period_id integer NOT NULL,
    charge_description text NOT NULL,
    amount double precision NOT NULL,
    original_due_date date NOT NULL,
    date_paid date
);


ALTER TABLE csctoss.bp_past_due_charge OWNER TO csctoss_owner;

--
-- Name: TABLE bp_past_due_charge; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_past_due_charge IS 'Hold and track past due amounts for bills';


--
-- Name: bp_past_due_charge_bp_past_due_charge_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE bp_past_due_charge_bp_past_due_charge_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.bp_past_due_charge_bp_past_due_charge_id_seq OWNER TO csctoss_owner;

--
-- Name: bp_past_due_charge_bp_past_due_charge_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE bp_past_due_charge_bp_past_due_charge_id_seq OWNED BY bp_past_due_charge.bp_past_due_charge_id;


--
-- Name: bp_period_billing_summary; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_period_billing_summary (
    bp_period_billing_summary_id integer DEFAULT nextval('csctoss.bp_period_billing_summary_bp_period_billing_summary_id_seq'::text) NOT NULL,
    billing_entity_id integer NOT NULL,
    bp_master_billing_plan_id integer NOT NULL,
    period_id integer NOT NULL,
    corrected boolean DEFAULT false NOT NULL
);


ALTER TABLE csctoss.bp_period_billing_summary OWNER TO csctoss_owner;

--
-- Name: TABLE bp_period_billing_summary; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_period_billing_summary IS 'Top level table for an individual bill output by the billing engine';


--
-- Name: bp_period_billing_summary_bp_period_billing_summary_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE bp_period_billing_summary_bp_period_billing_summary_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.bp_period_billing_summary_bp_period_billing_summary_id_seq OWNER TO csctoss_owner;

--
-- Name: bp_period_billing_summary_bp_period_billing_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE bp_period_billing_summary_bp_period_billing_summary_id_seq OWNED BY bp_period_billing_summary.bp_period_billing_summary_id;


--
-- Name: bp_period_change_summary; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_period_change_summary (
    bp_period_billing_summary_id integer NOT NULL,
    bp_billing_period_id integer NOT NULL,
    change_description text NOT NULL
);


ALTER TABLE csctoss.bp_period_change_summary OWNER TO csctoss_owner;

--
-- Name: TABLE bp_period_change_summary; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_period_change_summary IS 'List of specific changes to a billing plan during a period';


--
-- Name: bp_period_charge_summary; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_period_charge_summary (
    bp_period_charge_summary_id integer DEFAULT nextval('csctoss.bp_period_charge_summary_bp_period_charge_summary_id_seq'::text) NOT NULL,
    bp_period_billing_summary_id integer NOT NULL,
    charge_description text NOT NULL,
    ledger_flag text NOT NULL,
    quantity integer NOT NULL,
    unit_price double precision NOT NULL,
    discount double precision,
    print_order integer,
    line_total double precision NOT NULL,
    CONSTRAINT bp_period_charge_summary_ledger_flag_values CHECK ((((((ledger_flag = 'C'::text) OR (ledger_flag = 'D'::text)) OR (ledger_flag = 'P'::text)) OR (ledger_flag = 'S'::text)) OR (ledger_flag = 'T'::text))),
    CONSTRAINT bp_period_charge_summary_no_negative_discount CHECK (((discount IS NULL) OR (discount >= (0)::double precision))),
    CONSTRAINT bp_period_charge_summary_no_negative_price CHECK ((unit_price >= (0)::double precision)),
    CONSTRAINT bp_period_charge_summary_no_negative_quantity CHECK ((quantity >= 0)),
    CONSTRAINT bp_period_charge_summary_print_order_ck CHECK ((print_order > 0))
);


ALTER TABLE csctoss.bp_period_charge_summary OWNER TO csctoss_owner;

--
-- Name: TABLE bp_period_charge_summary; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_period_charge_summary IS 'Summary (line item) charges for customer bills';


--
-- Name: bp_period_charge_summary_bp_period_charge_summary_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE bp_period_charge_summary_bp_period_charge_summary_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.bp_period_charge_summary_bp_period_charge_summary_id_seq OWNER TO csctoss_owner;

--
-- Name: bp_period_charge_summary_bp_period_charge_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE bp_period_charge_summary_bp_period_charge_summary_id_seq OWNED BY bp_period_charge_summary.bp_period_charge_summary_id;


--
-- Name: bp_period_status_summary; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_period_status_summary (
    bp_period_billing_summary_id integer NOT NULL,
    bp_billing_period_id integer NOT NULL,
    current_allotment bigint NOT NULL,
    current_used bigint NOT NULL,
    allotment_end_date date NOT NULL
);


ALTER TABLE csctoss.bp_period_status_summary OWNER TO csctoss_owner;

--
-- Name: TABLE bp_period_status_summary; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_period_status_summary IS 'Track usage allotments and current usage by billing period';


--
-- Name: bp_period_usage_summary; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_period_usage_summary (
    bp_period_usage_summary_id integer DEFAULT nextval('csctoss.bp_period_usage_summary_bp_period_usage_summary_id_seq'::text) NOT NULL,
    bp_period_billing_summary_id integer NOT NULL,
    equip_id integer NOT NULL,
    billing_entity_address_id integer NOT NULL,
    location_label_used text NOT NULL,
    input_bytes bigint NOT NULL,
    output_bytes bigint NOT NULL,
    CONSTRAINT bp_location_address_constraint_ck CHECK (location_address_constraint(billing_entity_address_id))
);


ALTER TABLE csctoss.bp_period_usage_summary OWNER TO csctoss_owner;

--
-- Name: TABLE bp_period_usage_summary; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_period_usage_summary IS 'Summary of usage by card, with location, for bills';


--
-- Name: bp_period_usage_summary_bp_period_usage_summary_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE bp_period_usage_summary_bp_period_usage_summary_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.bp_period_usage_summary_bp_period_usage_summary_id_seq OWNER TO csctoss_owner;

--
-- Name: bp_period_usage_summary_bp_period_usage_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE bp_period_usage_summary_bp_period_usage_summary_id_seq OWNED BY bp_period_usage_summary.bp_period_usage_summary_id;


--
-- Name: bp_usage_allotment; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE bp_usage_allotment (
    bp_usage_allotment_id integer DEFAULT nextval('csctoss.bp_usage_allotment_bp_usage_allotment_id_seq'::text) NOT NULL,
    bp_billing_charge_usage_id integer NOT NULL,
    allotment integer NOT NULL,
    carrier text NOT NULL,
    applied_time_period text NOT NULL,
    CONSTRAINT bp_usage_allotment_allotment_check CHECK ((allotment > 0)),
    CONSTRAINT bp_usage_allotment_bp_billing_charge_usage_ck CHECK (bp_usage_allotment_bp_billing_charge_usage_ck(bp_billing_charge_usage_id)),
    CONSTRAINT bp_usage_allotment_time_period_check CHECK ((((applied_time_period = 'PERIOD'::text) OR (applied_time_period = 'YEAR'::text)) OR (applied_time_period = 'MASTER BILLING PLAN'::text)))
);


ALTER TABLE csctoss.bp_usage_allotment OWNER TO csctoss_owner;

--
-- Name: TABLE bp_usage_allotment; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE bp_usage_allotment IS 'Track allotment pools for aggregate usage plans';


--
-- Name: bp_usage_allotment_bp_usage_allotment_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE bp_usage_allotment_bp_usage_allotment_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.bp_usage_allotment_bp_usage_allotment_id_seq OWNER TO csctoss_owner;

--
-- Name: bp_usage_allotment_bp_usage_allotment_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE bp_usage_allotment_bp_usage_allotment_id_seq OWNED BY bp_usage_allotment.bp_usage_allotment_id;


--
-- Name: branding_button; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE branding_button (
    billing_entity_id integer NOT NULL,
    button_number smallint NOT NULL,
    product_code text NOT NULL,
    refill_amount numeric(9,2) DEFAULT 0 NOT NULL,
    currency text DEFAULT 'USD'::text NOT NULL,
    button_image text NOT NULL,
    button_alt_image text NOT NULL
);


ALTER TABLE csctoss.branding_button OWNER TO csctoss_owner;

--
-- Name: TABLE branding_button; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE branding_button IS 'Branding button table description here.';


--
-- Name: branding_content; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE branding_content (
    parent_billing_entity_id integer NOT NULL,
    company_name text,
    product_name text,
    copyright text,
    customer_support_phone text,
    refill_center_select_text text,
    business_contact_email text,
    business_contact_phone text,
    business_contact_address_line1 text,
    business_contact_address_line2 text,
    business_contact_address_line3 text,
    business_contact_address_line4 text,
    cal_privacy_address_text text,
    web_failure_contact_text text
);


ALTER TABLE csctoss.branding_content OWNER TO csctoss_owner;

--
-- Name: TABLE branding_content; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE branding_content IS 'Branding content table description here.';


--
-- Name: branding_presentation; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE branding_presentation (
    parent_billing_entity_id integer NOT NULL,
    style_sheet text,
    display_cal_privacy boolean DEFAULT false NOT NULL,
    register_style_sheet text,
    register_company_logo text,
    branding_directory text
);


ALTER TABLE csctoss.branding_presentation OWNER TO csctoss_owner;

--
-- Name: TABLE branding_presentation; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE branding_presentation IS 'Branding presentation table description here.';


--
-- Name: broadcast_message; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE broadcast_message (
    broadcast_message_id integer DEFAULT nextval('csctoss.broadcast_message_broadcast_message_id_seq'::text) NOT NULL,
    subject character varying(128) NOT NULL,
    detail character varying(1024) NOT NULL,
    broadcast_message_level_id integer DEFAULT 1 NOT NULL,
    broadcast_message_type_id integer DEFAULT 1 NOT NULL,
    active_flag boolean DEFAULT true NOT NULL,
    start_date timestamp with time zone DEFAULT now() NOT NULL,
    end_date timestamp with time zone NOT NULL,
    preserve_flag boolean DEFAULT false NOT NULL,
    billing_entity_id integer
);


ALTER TABLE csctoss.broadcast_message OWNER TO csctoss_owner;

--
-- Name: TABLE broadcast_message; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE broadcast_message IS 'Lists broadcast message content, type, level, status, dates governing the message.';


--
-- Name: broadcast_message_broadcast_message_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE broadcast_message_broadcast_message_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.broadcast_message_broadcast_message_id_seq OWNER TO csctoss_owner;

--
-- Name: broadcast_message_broadcast_message_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE broadcast_message_broadcast_message_id_seq OWNED BY broadcast_message.broadcast_message_id;


--
-- Name: broadcast_message_data; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE broadcast_message_data (
    broadcast_id integer DEFAULT nextval('csctoss.broadcast_message_data_broadcast_id_seq'::text) NOT NULL,
    create_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    created_by text NOT NULL,
    message_start_date date DEFAULT ('now'::text)::date NOT NULL,
    message_end_date date DEFAULT (('now'::text)::date + '30 days'::interval) NOT NULL,
    broadcast_message_group_id integer,
    subject character varying(30) NOT NULL,
    broadcast_message text NOT NULL,
    message_priority_id integer NOT NULL
);


ALTER TABLE csctoss.broadcast_message_data OWNER TO csctoss_owner;

--
-- Name: broadcast_message_data_broadcast_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE broadcast_message_data_broadcast_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.broadcast_message_data_broadcast_id_seq OWNER TO csctoss_owner;

--
-- Name: broadcast_message_data_broadcast_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE broadcast_message_data_broadcast_id_seq OWNED BY broadcast_message_data.broadcast_id;


--
-- Name: broadcast_message_group; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE broadcast_message_group (
    broadcast_message_group_id integer NOT NULL,
    broadcast_message_billing_entity_id integer NOT NULL,
    broadcast_id integer
);


ALTER TABLE csctoss.broadcast_message_group OWNER TO csctoss_owner;

--
-- Name: broadcast_message_level; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE broadcast_message_level (
    broadcast_message_level_id integer DEFAULT nextval('csctoss.broadcast_message_level_broadcast_message_level_id_seq'::text) NOT NULL,
    broadcast_message_level text NOT NULL,
    image_file_name text NOT NULL,
    message_font text NOT NULL,
    font_color text NOT NULL
);


ALTER TABLE csctoss.broadcast_message_level OWNER TO csctoss_owner;

--
-- Name: TABLE broadcast_message_level; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE broadcast_message_level IS 'Lookup table defining broadcast message levels and associated properties.';


--
-- Name: broadcast_message_level_broadcast_message_level_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE broadcast_message_level_broadcast_message_level_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.broadcast_message_level_broadcast_message_level_id_seq OWNER TO csctoss_owner;

--
-- Name: broadcast_message_level_broadcast_message_level_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE broadcast_message_level_broadcast_message_level_id_seq OWNED BY broadcast_message_level.broadcast_message_level_id;


--
-- Name: broadcast_message_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE broadcast_message_type (
    broadcast_message_type_id integer DEFAULT nextval('csctoss.broadcast_message_type_broadcast_message_type_id_seq'::text) NOT NULL,
    broadcast_message_type text NOT NULL
);


ALTER TABLE csctoss.broadcast_message_type OWNER TO csctoss_owner;

--
-- Name: TABLE broadcast_message_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE broadcast_message_type IS 'Lookup table defining message types for broadcast messages.';


--
-- Name: broadcast_message_type_broadcast_message_type_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE broadcast_message_type_broadcast_message_type_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.broadcast_message_type_broadcast_message_type_id_seq OWNER TO csctoss_owner;

--
-- Name: broadcast_message_type_broadcast_message_type_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE broadcast_message_type_broadcast_message_type_id_seq OWNED BY broadcast_message_type.broadcast_message_type_id;


--
-- Name: plan; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE plan (
    plan_id integer DEFAULT nextval('csctoss.plan_plan_id_seq'::text) NOT NULL,
    length_days integer NOT NULL,
    plan_type_id integer NOT NULL,
    comment text DEFAULT ''::text NOT NULL,
    create_timestamp timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    product_id integer NOT NULL,
    staff_id integer DEFAULT public.get_change_log_staff_id() NOT NULL,
    line_id integer,
    start_date date DEFAULT ('now'::text)::date NOT NULL,
    end_date date,
    prepaid_unit text,
    prepaid_allowance integer,
    prepaid_balance integer,
    accounting_start_date date,
    sales_order_number text,
    CONSTRAINT plan_prepaid_unit_ck CHECK ((((prepaid_unit = 'MINUTES'::text) OR (prepaid_unit = 'PACKETS'::text)) OR (prepaid_unit = 'KB'::text))),
    CONSTRAINT plan_start_end_date_ck CHECK ((start_date <= end_date))
);


ALTER TABLE csctoss.plan OWNER TO csctoss_owner;

--
-- Name: TABLE plan; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE plan IS 'A plan in the sequence of plans on a line.';


--
-- Name: product; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE product (
    product_id integer NOT NULL,
    product_code text NOT NULL,
    plan_type_id integer NOT NULL,
    length_days integer NOT NULL,
    obsolete boolean DEFAULT false NOT NULL,
    product_desc text NOT NULL,
    prepaid_unit text,
    prepaid_allowance integer,
    default_logical_apn text,
    sales_price numeric(9,2) DEFAULT 0 NOT NULL
);


ALTER TABLE csctoss.product OWNER TO csctoss_owner;

--
-- Name: TABLE product; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE product IS 'A product is a marketing-department construction that may include a plan and/or a card.';


--
-- Name: cancellation_report_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW cancellation_report_vw AS
    SELECT be.billing_entity_id, be.name AS billing_entity_name, line.line_id, (line.start_date)::date AS line_start_date, (line.end_date)::date AS line_end_date, eq.equipment_id, le.start_date AS equipment_start_date, le.end_date AS equipment_end_date, em.model_number1 AS equipment_model, prd.product_code, em.carrier FROM ((((((billing_entity be JOIN line ON ((be.billing_entity_id = line.billing_entity_id))) JOIN plan ON ((line.line_id = plan.line_id))) JOIN product prd ON ((plan.product_id = prd.product_id))) JOIN line_equipment le ON ((line.line_id = le.line_id))) JOIN equipment eq ON ((le.equipment_id = eq.equipment_id))) JOIN equipment_model em ON ((eq.equipment_model_id = em.equipment_model_id))) WHERE (((1 = 1) AND (line.end_date IS NOT NULL)) AND (line.end_date >= (('now'::text)::date - '3 years'::interval)));


ALTER TABLE csctoss.cancellation_report_vw OWNER TO csctoss_owner;

--
-- Name: carrier; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE carrier (
    carrier text NOT NULL,
    name text NOT NULL,
    cdr_description text NOT NULL
);


ALTER TABLE csctoss.carrier OWNER TO csctoss_owner;

--
-- Name: TABLE carrier; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE carrier IS 'Wireless carrier information';


--
-- Name: carrier_api_activity_log; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE carrier_api_activity_log (
    api_activity_log bigint DEFAULT nextval('csctoss.carrier_api_activity_log_api_activity_log_seq'::text) NOT NULL,
    request_timestamp timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    carrier text NOT NULL,
    line_id integer,
    device_identifier text,
    username text,
    result_code boolean NOT NULL,
    result_desc text DEFAULT ''::text,
    api_called text
);


ALTER TABLE csctoss.carrier_api_activity_log OWNER TO csctoss_owner;

--
-- Name: carrier_api_activity_log_api_activity_log_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE carrier_api_activity_log_api_activity_log_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.carrier_api_activity_log_api_activity_log_seq OWNER TO csctoss_owner;

--
-- Name: carrier_api_activity_log_api_activity_log_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE carrier_api_activity_log_api_activity_log_seq OWNED BY carrier_api_activity_log.api_activity_log;


--
-- Name: carrier_domain; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE carrier_domain (
    carrier text NOT NULL,
    domain text NOT NULL,
    unique_identifier_type text NOT NULL
);


ALTER TABLE csctoss.carrier_domain OWNER TO csctoss_owner;

--
-- Name: cc_auth_log; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE cc_auth_log (
    cc_auth_log_id integer DEFAULT nextval('csctoss.cc_auth_log_cc_auth_log_id_seq'::text) NOT NULL,
    phone_number text NOT NULL,
    transaction_id text NOT NULL,
    transaction_time timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    transaction_success boolean NOT NULL,
    reason_text text NOT NULL,
    product_code text NOT NULL,
    return_string text
);


ALTER TABLE csctoss.cc_auth_log OWNER TO csctoss_owner;

--
-- Name: TABLE cc_auth_log; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE cc_auth_log IS 'Log of credit card authorization attempts.';


--
-- Name: cc_auth_log_cc_auth_log_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE cc_auth_log_cc_auth_log_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.cc_auth_log_cc_auth_log_id_seq OWNER TO csctoss_owner;

--
-- Name: cc_auth_log_cc_auth_log_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE cc_auth_log_cc_auth_log_id_seq OWNED BY cc_auth_log.cc_auth_log_id;


--
-- Name: cc_encrypt_key; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE cc_encrypt_key (
    cc_encrypt_key_id integer DEFAULT nextval('csctoss.cc_encrypt_key_cc_encrypt_key_id_seq'::text) NOT NULL,
    encryption_key text NOT NULL,
    pin_code text,
    contract_id integer,
    phone_number text
);


ALTER TABLE csctoss.cc_encrypt_key OWNER TO csctoss_owner;

--
-- Name: TABLE cc_encrypt_key; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE cc_encrypt_key IS 'Store encryption key for b-Access client.';


--
-- Name: cc_encrypt_key_cc_encrypt_key_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE cc_encrypt_key_cc_encrypt_key_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.cc_encrypt_key_cc_encrypt_key_id_seq OWNER TO csctoss_owner;

--
-- Name: cc_encrypt_key_cc_encrypt_key_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE cc_encrypt_key_cc_encrypt_key_id_seq OWNED BY cc_encrypt_key.cc_encrypt_key_id;


--
-- Name: change_log; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE change_log (
    change_log_id integer DEFAULT nextval('csctoss.change_log_change_log_id_seq'::text) NOT NULL,
    change_timestamp timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    db_user text DEFAULT "session_user"() NOT NULL,
    staff_id integer NOT NULL,
    change_type character(1) NOT NULL,
    table_name text NOT NULL,
    primary_key text NOT NULL,
    column_name text,
    previous_value text,
    CONSTRAINT change_log_change_type_check CHECK ((((change_type = 'I'::bpchar) OR (change_type = 'U'::bpchar)) OR (change_type = 'D'::bpchar)))
);


ALTER TABLE csctoss.change_log OWNER TO csctoss_owner;

--
-- Name: TABLE change_log; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE change_log IS 'Used for logging all changes to the database.';


--
-- Name: change_log_change_log_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE change_log_change_log_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.change_log_change_log_id_seq OWNER TO csctoss_owner;

--
-- Name: change_log_change_log_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE change_log_change_log_id_seq OWNED BY change_log.change_log_id;


--
-- Name: config; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE config (
    id integer DEFAULT nextval('csctoss.config_id_seq'::text) NOT NULL,
    name text NOT NULL,
    description text,
    billing_entity_id integer,
    created_date timestamp with time zone NOT NULL,
    file_path text NOT NULL,
    default_status smallint
);


ALTER TABLE csctoss.config OWNER TO csctoss_owner;

--
-- Name: config_equipment; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE config_equipment (
    id integer DEFAULT nextval('csctoss.config_equipment_id_seq'::text) NOT NULL,
    config_id integer NOT NULL,
    equipment_model_id integer NOT NULL
);


ALTER TABLE csctoss.config_equipment OWNER TO csctoss_owner;

--
-- Name: config_equipment_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE config_equipment_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.config_equipment_id_seq OWNER TO csctoss_owner;

--
-- Name: config_equipment_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE config_equipment_id_seq OWNED BY config_equipment.id;


--
-- Name: config_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE config_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.config_id_seq OWNER TO csctoss_owner;

--
-- Name: config_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE config_id_seq OWNED BY config.id;


--
-- Name: contact; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE contact (
    contact_id integer DEFAULT nextval('csctoss.contact_contact_id_seq'::text) NOT NULL,
    billing_entity_id integer NOT NULL,
    contact_type text NOT NULL,
    contact_level text NOT NULL,
    family_name text DEFAULT ''::text NOT NULL,
    given_name text DEFAULT ''::text NOT NULL,
    title text,
    email_address text,
    phone_number text DEFAULT ''::text NOT NULL,
    alternate_phone_number text,
    fax_number text,
    send_product_info boolean DEFAULT false NOT NULL,
    notification_email text,
    notification_phone text
);


ALTER TABLE csctoss.contact OWNER TO csctoss_owner;

--
-- Name: TABLE contact; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE contact IS 'Contacts at a Billing Entity - Accounting, shipping/receiving, etc.';


--
-- Name: contact_address; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE contact_address (
    contact_id integer NOT NULL,
    address_type text NOT NULL,
    address_id integer NOT NULL
);


ALTER TABLE csctoss.contact_address OWNER TO csctoss_owner;

--
-- Name: contact_contact_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE contact_contact_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.contact_contact_id_seq OWNER TO csctoss_owner;

--
-- Name: contact_contact_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE contact_contact_id_seq OWNED BY contact.contact_id;


--
-- Name: contact_level; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE contact_level (
    contact_level text NOT NULL,
    description text NOT NULL
);


ALTER TABLE csctoss.contact_level OWNER TO csctoss_owner;

--
-- Name: TABLE contact_level; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE contact_level IS 'Lookup table defining the levels of contacts for a billing entity.';


--
-- Name: contact_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE contact_type (
    contact_type text NOT NULL,
    description text NOT NULL
);


ALTER TABLE csctoss.contact_type OWNER TO csctoss_owner;

--
-- Name: TABLE contact_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE contact_type IS 'Lookup table defining the types of contacts for a billing entity.';


--
-- Name: csctoss_users_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE csctoss_users_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.csctoss_users_id_seq OWNER TO csctoss_owner;

--
-- Name: currency; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE currency (
    currency_id integer DEFAULT nextval('csctoss.currency_currency_id_seq'::text) NOT NULL,
    name text NOT NULL,
    short_name text NOT NULL,
    "precision" integer DEFAULT 0 NOT NULL
);


ALTER TABLE csctoss.currency OWNER TO csctoss_owner;

--
-- Name: TABLE currency; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE currency IS 'Currency information used in invoice generation';


--
-- Name: currency_currency_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE currency_currency_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.currency_currency_id_seq OWNER TO csctoss_owner;

--
-- Name: currency_currency_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE currency_currency_id_seq OWNED BY currency.currency_id;


SET default_with_oids = true;

--
-- Name: device_monitor; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE device_monitor (
    serial_number text NOT NULL,
    create_timestamp timestamp with time zone DEFAULT now()
);


ALTER TABLE csctoss.device_monitor OWNER TO csctoss_owner;

--
-- Name: device_monitor_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW device_monitor_vw AS
    SELECT be.billing_entity_id, be.name AS billing_entity_name, line.line_id, line.radius_username, (line.start_date)::date AS line_start_date, (line.end_date)::date AS line_end_date, le.equipment_id, le.start_date AS equip_start_date, le.end_date AS equip_end_date, (SELECT unique_identifier.value FROM unique_identifier WHERE ((le.equipment_id = unique_identifier.equipment_id) AND (unique_identifier.unique_identifier_type = 'SERIAL NUMBER'::text))) AS sn, (SELECT unique_identifier.value FROM unique_identifier WHERE ((le.equipment_id = unique_identifier.equipment_id) AND (unique_identifier.unique_identifier_type = 'MDN'::text))) AS mdn, (SELECT unique_identifier.value FROM unique_identifier WHERE ((le.equipment_id = unique_identifier.equipment_id) AND (unique_identifier.unique_identifier_type = 'MIN'::text))) AS min, (SELECT unique_identifier.value FROM unique_identifier WHERE ((le.equipment_id = unique_identifier.equipment_id) AND (unique_identifier.unique_identifier_type = 'ESN HEX'::text))) AS esn_hex, (SELECT unique_identifier.value FROM unique_identifier WHERE ((le.equipment_id = unique_identifier.equipment_id) AND (unique_identifier.unique_identifier_type = 'ESN DEC'::text))) AS esn_dec, em.model_number1 AS equipment_model, em.model_note, em.vendor, loc.id AS location_id, loc."owner" AS location_owner, loc.name AS location_name, loc.address AS location_address, loc.processor AS location_processor, ARRAY(SELECT usergroup.groupname FROM usergroup WHERE ((usergroup.username)::text = line.radius_username)) AS groupname, (SELECT radreply.value FROM radreply WHERE (((radreply.username)::text = line.radius_username) AND ((radreply.attribute)::text = 'Framed-IP-Address'::text))) AS static_ip_address, mrad.total_usage_bytes_data_for_last30days AS last_connected_timestamp_for_last30days FROM ((((((billing_entity be JOIN line ON ((be.billing_entity_id = line.billing_entity_id))) JOIN line_equipment le ON ((line.line_id = le.line_id))) JOIN equipment eq ON ((le.equipment_id = eq.equipment_id))) JOIN equipment_model em ON ((eq.equipment_model_id = em.equipment_model_id))) LEFT JOIN location_labels loc ON ((loc.line_id = line.line_id))) LEFT JOIN public.dblink((SELECT fetch_csctlog_conn.fetch_csctlog_conn FROM fetch_csctlog_conn()), '\012SELECT\012  username,\012  MAX(acctstarttime::timestamp(0)) AS last_connected_timestamp,\012  SUM(acctinputoctets + acctoutputoctets) AS total_usage_data_for_last30days\012FROM csctlog.master_radacct mrad\012WHERE 1 = 1\012AND acctstarttime >= (now() - ''30 days''::INTERVAL)\012GROUP BY username\012'::text) mrad(username text, last_connected_timestamp timestamp with time zone, total_usage_bytes_data_for_last30days bigint) ON ((line.radius_username = mrad.username))) WHERE ((1 = 1) AND (eq.equipment_id IN (SELECT unique_identifier.equipment_id FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'SERIAL NUMBER'::text) AND (unique_identifier.value IN (SELECT device_monitor.serial_number FROM device_monitor))))));


ALTER TABLE csctoss.device_monitor_vw OWNER TO csctoss_owner;

SET default_with_oids = false;

--
-- Name: download_file_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE download_file_type (
    file_type text NOT NULL,
    description text NOT NULL
);


ALTER TABLE csctoss.download_file_type OWNER TO csctoss_owner;

--
-- Name: TABLE download_file_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE download_file_type IS ' Defines file types for download via the Portal.';


--
-- Name: equipment_credential; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment_credential (
    equipment_credential_id integer DEFAULT nextval('csctoss.equipment_credential_equipment_credential_id_seq'::text) NOT NULL,
    equipment_id integer NOT NULL,
    credential_set smallint NOT NULL,
    preferred_set boolean DEFAULT false NOT NULL,
    username text,
    password text,
    last_update_timestamp timestamp with time zone,
    last_update_status text
);


ALTER TABLE csctoss.equipment_credential OWNER TO csctoss_owner;

--
-- Name: TABLE equipment_credential; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE equipment_credential IS 'Stores device credentials for remote login.';


--
-- Name: equipment_credential_equipment_credential_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE equipment_credential_equipment_credential_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.equipment_credential_equipment_credential_id_seq OWNER TO csctoss_owner;

--
-- Name: equipment_credential_equipment_credential_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE equipment_credential_equipment_credential_id_seq OWNED BY equipment_credential.equipment_credential_id;


--
-- Name: equipment_equipment_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE equipment_equipment_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.equipment_equipment_id_seq OWNER TO csctoss_owner;

--
-- Name: equipment_equipment_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE equipment_equipment_id_seq OWNED BY equipment.equipment_id;


--
-- Name: equipment_firmware; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment_firmware (
    equipment_firmware_id integer DEFAULT nextval('csctoss.equipment_firmware_equipment_firmware_id_seq'::text) NOT NULL,
    equipment_model_id integer NOT NULL,
    firmware_version text NOT NULL,
    pass_reset_days integer
);


ALTER TABLE csctoss.equipment_firmware OWNER TO csctoss_owner;

--
-- Name: equipment_firmware_equipment_firmware_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE equipment_firmware_equipment_firmware_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.equipment_firmware_equipment_firmware_id_seq OWNER TO csctoss_owner;

--
-- Name: equipment_firmware_equipment_firmware_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE equipment_firmware_equipment_firmware_id_seq OWNED BY equipment_firmware.equipment_firmware_id;


--
-- Name: equipment_info; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment_info (
    equipment_id integer NOT NULL,
    equipment_info_type text NOT NULL,
    value text NOT NULL
);


ALTER TABLE csctoss.equipment_info OWNER TO csctoss_owner;

--
-- Name: equipment_info_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment_info_type (
    equipment_info_type text NOT NULL,
    description text NOT NULL,
    datatype text NOT NULL,
    CONSTRAINT equipment_info_type_datatype_ck CHECK ((((((datatype = 'TEXT'::text) OR (datatype = 'INTEGER'::text)) OR (datatype = 'NUMERIC'::text)) OR (datatype = 'DATE'::text)) OR (datatype = 'TIMESTAMP'::text)))
);


ALTER TABLE csctoss.equipment_info_type OWNER TO csctoss_owner;

--
-- Name: TABLE equipment_info_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE equipment_info_type IS 'Lookup table defining types of equipment information.';


--
-- Name: equipment_load; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment_load (
    equipment_id integer,
    esn_hex text,
    esn_dec text,
    mdn text,
    min text
);


ALTER TABLE csctoss.equipment_load OWNER TO csctoss_owner;

--
-- Name: equipment_model_credential; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment_model_credential (
    equipment_model_id integer NOT NULL,
    credential_set smallint NOT NULL,
    preferred_set boolean DEFAULT false NOT NULL,
    username text,
    password text,
    derived boolean DEFAULT false NOT NULL
);


ALTER TABLE csctoss.equipment_model_credential OWNER TO csctoss_owner;

--
-- Name: TABLE equipment_model_credential; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE equipment_model_credential IS 'Lookup table associating equipment models with equipment credentials.';


--
-- Name: equipment_model_equipment_model_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE equipment_model_equipment_model_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.equipment_model_equipment_model_id_seq OWNER TO csctoss_owner;

--
-- Name: equipment_model_equipment_model_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE equipment_model_equipment_model_id_seq OWNED BY equipment_model.equipment_model_id;


--
-- Name: equipment_model_status; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment_model_status (
    equipment_model_id integer NOT NULL,
    is_active boolean DEFAULT true NOT NULL
);


ALTER TABLE csctoss.equipment_model_status OWNER TO csctoss_owner;

--
-- Name: TABLE equipment_model_status; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE equipment_model_status IS 'This table represents whether equipment_model is active.';


--
-- Name: equipment_note; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment_note (
    equipment_id integer NOT NULL,
    note_number integer NOT NULL,
    short_description text NOT NULL,
    note_text text NOT NULL,
    date_created date DEFAULT ('now'::text)::date NOT NULL,
    date_modiifed date
);


ALTER TABLE csctoss.equipment_note OWNER TO csctoss_owner;

--
-- Name: TABLE equipment_note; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE equipment_note IS 'Stores any relevent notes for a given piece of equipment.';


--
-- Name: equipment_software; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment_software (
    equipment_id integer NOT NULL,
    software_id integer NOT NULL,
    install_date date DEFAULT ('now'::text)::date NOT NULL,
    retire_date date,
    notes text
);


ALTER TABLE csctoss.equipment_software OWNER TO csctoss_owner;

--
-- Name: TABLE equipment_software; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE equipment_software IS 'Intersection table between equipment and software tracking software installed on a given piece of equipment.';


--
-- Name: equipment_status; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment_status (
    equipment_id integer NOT NULL,
    equipment_status_type text NOT NULL,
    date_created date DEFAULT ('now'::text)::date NOT NULL,
    date_modified date
);


ALTER TABLE csctoss.equipment_status OWNER TO csctoss_owner;

--
-- Name: TABLE equipment_status; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE equipment_status IS 'Intersection table between equipment and equipment_status_type storing the current status of equipment.';


--
-- Name: equipment_status_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment_status_type (
    equipment_status_type text NOT NULL,
    description text
);


ALTER TABLE csctoss.equipment_status_type OWNER TO csctoss_owner;

--
-- Name: TABLE equipment_status_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE equipment_status_type IS 'Lookup table defining the various statuses for a given piece of equipment.';


--
-- Name: equipment_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment_type (
    equipment_type text NOT NULL,
    description text NOT NULL,
    equipment_class text NOT NULL,
    show_usage boolean DEFAULT false NOT NULL,
    preferred_unique_identifier_type text,
    CONSTRAINT equipment_type_equipment_class_ck CHECK (((equipment_class = 'DEVICE'::text) OR (equipment_class = 'SERVICE'::text)))
);


ALTER TABLE csctoss.equipment_type OWNER TO csctoss_owner;

--
-- Name: TABLE equipment_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE equipment_type IS 'Stores all specific, relevent information for a given piece of equipment.';


--
-- Name: username; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE username (
    username character varying(64) NOT NULL,
    billing_entity_id integer NOT NULL,
    primary_service boolean DEFAULT false NOT NULL,
    enabled boolean DEFAULT true NOT NULL,
    start_date date DEFAULT ('now'::text)::date NOT NULL,
    end_date date DEFAULT '2999-12-31'::date NOT NULL,
    date_created date DEFAULT ('now'::text)::date NOT NULL,
    notes text,
    auth_pod boolean DEFAULT false NOT NULL
);


ALTER TABLE csctoss.username OWNER TO csctoss_owner;

--
-- Name: TABLE username; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE username IS 'Defines / stores / tracks all users names in the radius system.';


--
-- Name: equipment_summary_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW equipment_summary_vw AS
    SELECT line.line_id, line.active_flag AS active, line.line_assignment_type, lieq.start_date AS line_assignment_start, lieq.end_date AS line_assignment_end, line.billing_entity_id, CASE WHEN (line.billing_entity_id IS NOT NULL) THEN (SELECT billing_entity.name FROM billing_entity WHERE (billing_entity.billing_entity_id = line.billing_entity_id)) ELSE NULL::text END AS billing_entity, equp.equipment_id, eqmo.carrier, equp.equipment_type, eqmo.model_number1, CASE WHEN (eqty.preferred_unique_identifier_type IS NOT NULL) THEN eqty.preferred_unique_identifier_type ELSE 'N/A'::text END AS primary_unique_id_type, CASE WHEN (eqty.preferred_unique_identifier_type IS NOT NULL) THEN (SELECT uid1.value FROM unique_identifier uid1 WHERE ((uid1.equipment_id = equp.equipment_id) AND (uid1.unique_identifier_type = eqty.preferred_unique_identifier_type))) ELSE 'N/A'::text END AS primary_unique_id, CASE WHEN (eqty.preferred_unique_identifier_type IS NOT NULL) THEN CASE WHEN (eqty.equipment_type = 'CARD'::text) THEN 'ESN DEC'::text WHEN (eqty.equipment_type = 'MODULE'::text) THEN 'ESN DEC'::text WHEN (eqty.equipment_type = 'ROUTER'::text) THEN 'ESN HEX'::text ELSE 'N/A'::text END ELSE 'N/A'::text END AS secondary_unique_id_type, CASE WHEN (eqty.preferred_unique_identifier_type IS NOT NULL) THEN CASE WHEN (eqty.equipment_type = 'CARD'::text) THEN (SELECT uid2.value FROM unique_identifier uid2 WHERE ((uid2.equipment_id = equp.equipment_id) AND (uid2.unique_identifier_type = 'ESN DEC'::text))) WHEN (eqty.equipment_type = 'MODULE'::text) THEN (SELECT uid2.value FROM unique_identifier uid2 WHERE ((uid2.equipment_id = equp.equipment_id) AND (uid2.unique_identifier_type = 'ESN DEC'::text))) WHEN (eqty.equipment_type = 'ROUTER'::text) THEN (SELECT uid2.value FROM unique_identifier uid2 WHERE ((uid2.equipment_id = equp.equipment_id) AND (uid2.unique_identifier_type = 'ESN HEX'::text))) ELSE 'N/A'::text END ELSE 'N/A'::text END AS secondary_unique_id, CASE WHEN (eqty.preferred_unique_identifier_type IS NOT NULL) THEN CASE WHEN (eqty.equipment_type = 'CARD'::text) THEN 'N/A'::text WHEN (eqty.equipment_type = 'MODULE'::text) THEN 'N/A'::text WHEN (eqty.equipment_type = 'ROUTER'::text) THEN 'ESN DEC'::text ELSE 'N/A'::text END ELSE 'N/A'::text END AS tertiary_unique_id_type, CASE WHEN (eqty.preferred_unique_identifier_type IS NOT NULL) THEN CASE WHEN (eqty.equipment_type = 'CARD'::text) THEN 'N/A'::text WHEN (eqty.equipment_type = 'MODULE'::text) THEN 'N/A'::text WHEN (eqty.equipment_type = 'ROUTER'::text) THEN (SELECT uid2.value FROM unique_identifier uid2 WHERE ((uid2.equipment_id = equp.equipment_id) AND (uid2.unique_identifier_type = 'ESN DEC'::text))) ELSE 'N/A'::text END ELSE 'N/A'::text END AS tertiary_unique_id, (SELECT uid1.value FROM unique_identifier uid1 WHERE ((uid1.equipment_id = equp.equipment_id) AND (uid1.unique_identifier_type = 'MIN'::text))) AS min, (SELECT uid1.value FROM unique_identifier uid1 WHERE ((uid1.equipment_id = equp.equipment_id) AND (uid1.unique_identifier_type = 'MDN'::text))) AS mdn, line.radius_username, eqst.equipment_status_type, line.radius_auth_type, line.ip_pool, CASE WHEN (line.radius_username IS NOT NULL) THEN COALESCE((SELECT radreply.value FROM radreply WHERE (((radreply.attribute)::text = 'Framed-IP-Address'::text) AND ((radreply.username)::text = line.radius_username))), ('N/A'::text)::character varying) ELSE 'N/A'::character varying END AS static_ip_address, CASE WHEN ((eqty.preferred_unique_identifier_type IS NOT NULL) AND (line.radius_username IS NOT NULL)) THEN (SELECT usna.billing_entity_id FROM username usna WHERE ((usna.username)::text = line.radius_username)) ELSE NULL::integer END AS radius_billing_entity_id, CASE WHEN ((eqty.preferred_unique_identifier_type IS NOT NULL) AND (line.radius_username IS NOT NULL)) THEN (SELECT bent2.name FROM username usna2, billing_entity bent2 WHERE ((bent2.billing_entity_id = usna2.billing_entity_id) AND ((usna2.username)::text = line.radius_username))) ELSE NULL::text END AS radius_billing_entity, (SELECT (count(*))::integer AS count FROM bp_billing_equipment_assignment bbea WHERE ((bbea.equipment_id = equp.equipment_id) AND ((('now'::text)::date >= (bbea.start_date)::date) AND (('now'::text)::date <= COALESCE(((bbea.end_date)::date)::timestamp without time zone, (('now'::text)::date + '1 day'::interval)))))) AS number_active_charges FROM (((((equipment equp JOIN equipment_type eqty ON ((eqty.equipment_type = equp.equipment_type))) JOIN equipment_model eqmo ON ((eqmo.equipment_model_id = equp.equipment_model_id))) LEFT JOIN equipment_status eqst ON ((eqst.equipment_id = equp.equipment_id))) LEFT JOIN line_equipment lieq ON ((lieq.equipment_id = equp.equipment_id))) LEFT JOIN line ON ((line.line_id = lieq.line_id)));


ALTER TABLE csctoss.equipment_summary_vw OWNER TO csctoss_owner;

--
-- Name: VIEW equipment_summary_vw; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON VIEW equipment_summary_vw IS 'Equipment view with current status';


--
-- Name: equipment_warranty; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment_warranty (
    equipment_id integer NOT NULL,
    warranty_start_date timestamp with time zone,
    warranty_end_date timestamp with time zone
);


ALTER TABLE csctoss.equipment_warranty OWNER TO csctoss_owner;

SET default_with_oids = true;

--
-- Name: equipment_warranty_rule; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE equipment_warranty_rule (
    equipment_model_id integer NOT NULL,
    num_of_months integer NOT NULL
);


ALTER TABLE csctoss.equipment_warranty_rule OWNER TO csctoss_owner;

SET default_with_oids = false;

--
-- Name: firmware; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE firmware (
    id integer DEFAULT nextval('csctoss.firmware_id_seq'::text) NOT NULL,
    name text NOT NULL,
    description text,
    billing_entity_id integer,
    create_date timestamp with time zone NOT NULL,
    file_path text NOT NULL,
    default_status smallint,
    device_version text NOT NULL
);


ALTER TABLE csctoss.firmware OWNER TO csctoss_owner;

--
-- Name: firmware_equipment; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE firmware_equipment (
    id integer DEFAULT nextval('csctoss.firmware_equipment_id_seq'::text) NOT NULL,
    firmware_id integer NOT NULL,
    equipment_model_id integer NOT NULL
);


ALTER TABLE csctoss.firmware_equipment OWNER TO csctoss_owner;

--
-- Name: firmware_equipment_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE firmware_equipment_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.firmware_equipment_id_seq OWNER TO csctoss_owner;

--
-- Name: firmware_equipment_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE firmware_equipment_id_seq OWNED BY firmware_equipment.id;


--
-- Name: firmware_gmu; Type: TABLE; Schema: csctoss; Owner: slony; Tablespace: 
--

CREATE TABLE firmware_gmu (
    firmware_gmu_id integer DEFAULT nextval('csctoss.firmware_gmu_firmware_gmu_id_seq'::text) NOT NULL,
    vendor_name text,
    unique_identifier_type text,
    value text,
    firmware_version text,
    equipment_id integer,
    equipment_model_id integer,
    status text DEFAULT 'LOAD'::text NOT NULL,
    error text
);


ALTER TABLE csctoss.firmware_gmu OWNER TO slony;

--
-- Name: firmware_gmu_firmware_gmu_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: slony
--

CREATE SEQUENCE firmware_gmu_firmware_gmu_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.firmware_gmu_firmware_gmu_id_seq OWNER TO slony;

--
-- Name: firmware_gmu_firmware_gmu_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: slony
--

ALTER SEQUENCE firmware_gmu_firmware_gmu_id_seq OWNED BY firmware_gmu.firmware_gmu_id;


--
-- Name: firmware_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE firmware_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.firmware_id_seq OWNER TO csctoss_owner;

--
-- Name: firmware_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE firmware_id_seq OWNED BY firmware.id;


--
-- Name: firmware_soup; Type: TABLE; Schema: csctoss; Owner: slony; Tablespace: 
--

CREATE TABLE firmware_soup (
    did integer NOT NULL,
    eui text,
    serial text,
    model text,
    description text,
    firmware text,
    equipment_id integer,
    equipment_model_id integer,
    model_number2 text,
    status text DEFAULT 'LOAD'::text NOT NULL,
    error text
);


ALTER TABLE csctoss.firmware_soup OWNER TO slony;

--
-- Name: groupname; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE groupname (
    groupname character varying(64) NOT NULL,
    priority integer NOT NULL,
    short_desc character varying(16),
    long_desc character varying(256),
    start_date date DEFAULT ('now'::text)::date,
    end_date date DEFAULT '2999-12-31'::date
);


ALTER TABLE csctoss.groupname OWNER TO csctoss_owner;

--
-- Name: TABLE groupname; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE groupname IS 'Lookup table defining radius group names.';


--
-- Name: groupname_default; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE groupname_default (
    groupname_default_key_id integer DEFAULT nextval('csctoss.groupname_default_groupname_default_key_id_seq'::text) NOT NULL,
    groupname character varying(64) NOT NULL,
    carrier text NOT NULL,
    billing_entity_id integer NOT NULL
);


ALTER TABLE csctoss.groupname_default OWNER TO csctoss_owner;

--
-- Name: groupname_default_groupname_default_key_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE groupname_default_groupname_default_key_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.groupname_default_groupname_default_key_id_seq OWNER TO csctoss_owner;

--
-- Name: groupname_default_groupname_default_key_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE groupname_default_groupname_default_key_id_seq OWNED BY groupname_default.groupname_default_key_id;


--
-- Name: last_change_log; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE last_change_log (
    last_change_log_id bigint NOT NULL,
    last_submission_id bigint NOT NULL,
    last_change_log_pk smallint NOT NULL
);


ALTER TABLE csctoss.last_change_log OWNER TO csctoss_owner;

--
-- Name: TABLE last_change_log; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE last_change_log IS 'Table to store last_change_log_id processed in updater based replication.';


SET default_with_oids = true;

--
-- Name: line_alert; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE line_alert (
    line_id integer NOT NULL,
    threshold_kb integer NOT NULL,
    threshold_minutes integer NOT NULL
);


ALTER TABLE csctoss.line_alert OWNER TO csctoss_owner;

--
-- Name: line_alert_email; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE line_alert_email (
    line_id integer NOT NULL,
    email_address text NOT NULL
);


ALTER TABLE csctoss.line_alert_email OWNER TO csctoss_owner;

SET default_with_oids = false;

--
-- Name: line_assignment_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE line_assignment_type (
    line_assignment_type text NOT NULL,
    description text NOT NULL
);


ALTER TABLE csctoss.line_assignment_type OWNER TO csctoss_owner;

--
-- Name: TABLE line_assignment_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE line_assignment_type IS 'Lookup table defining the types of line assignments in the system.';


--
-- Name: line_equipment_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW line_equipment_vw AS
    SELECT lieq.line_id, lieq.equipment_id, equp.equipment_type, eqty.equipment_class, eqmo.model_number1, eqmo.model_number2, eqmo.model_description, (SELECT eqst.equipment_status_type FROM equipment_status eqst WHERE ((eqst.equipment_id = equp.equipment_id) AND (eqst.date_created = (SELECT max(eqst2.date_created) AS max FROM equipment_status eqst2 WHERE (eqst2.equipment_id = eqst.equipment_id))))) AS equipment_status, lieq.start_date, lieq.end_date, eqty.preferred_unique_identifier_type, (SELECT unid.value FROM unique_identifier unid WHERE ((unid.equipment_id = equp.equipment_id) AND (unid.unique_identifier_type = eqty.preferred_unique_identifier_type))) AS unique_id FROM (((line_equipment lieq JOIN equipment equp ON ((equp.equipment_id = lieq.equipment_id))) JOIN equipment_model eqmo ON ((eqmo.equipment_model_id = equp.equipment_model_id))) JOIN equipment_type eqty ON ((eqty.equipment_type = equp.equipment_type)));


ALTER TABLE csctoss.line_equipment_vw OWNER TO csctoss_owner;

--
-- Name: VIEW line_equipment_vw; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON VIEW line_equipment_vw IS 'Line_equipment view with related information';


--
-- Name: line_line_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE line_line_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.line_line_id_seq OWNER TO csctoss_owner;

--
-- Name: line_line_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE line_line_id_seq OWNED BY line.line_id;


--
-- Name: line_terminal; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE line_terminal (
    line_id integer NOT NULL,
    terminal_id text,
    atm_processor text
);


ALTER TABLE csctoss.line_terminal OWNER TO csctoss_owner;

--
-- Name: TABLE line_terminal; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE line_terminal IS 'Table to store atm terminal information including terminal id and atm processor.';


--
-- Name: line_usage_day; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE line_usage_day (
    line_id integer NOT NULL,
    timezone text NOT NULL,
    usage_date date NOT NULL,
    time_connected_utc bigint DEFAULT 0,
    acctsessiontime_utc bigint DEFAULT 0,
    acctinputoctets_utc bigint DEFAULT 0,
    acctoutputoctets_utc bigint DEFAULT 0,
    rowcount_utc integer DEFAULT 0,
    time_connected_tz bigint DEFAULT 0,
    acctsessiontime_tz bigint DEFAULT 0,
    acctinputoctets_tz bigint DEFAULT 0,
    acctoutputoctets_tz bigint DEFAULT 0,
    rowcount_tz integer DEFAULT 0
);


ALTER TABLE csctoss.line_usage_day OWNER TO csctoss_owner;

--
-- Name: TABLE line_usage_day; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE line_usage_day IS 'Stub table used for usage calculations.';


SET default_with_oids = true;

--
-- Name: line_usage_day_2012_2014; Type: TABLE; Schema: csctoss; Owner: postgres; Tablespace: 
--

CREATE TABLE line_usage_day_2012_2014 (
    line_id integer,
    timezone text,
    usage_date date,
    time_connected_utc bigint,
    acctsessiontime_utc bigint,
    acctinputoctets_utc bigint,
    acctoutputoctets_utc bigint,
    rowcount_utc integer,
    time_connected_tz bigint,
    acctsessiontime_tz bigint,
    acctinputoctets_tz bigint,
    acctoutputoctets_tz bigint,
    rowcount_tz integer
);


ALTER TABLE csctoss.line_usage_day_2012_2014 OWNER TO postgres;

SET default_with_oids = false;

--
-- Name: line_usage_day_history; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE line_usage_day_history (
    line_id integer NOT NULL,
    timezone text NOT NULL,
    usage_date date NOT NULL,
    time_connected_utc bigint DEFAULT 0,
    acctsessiontime_utc bigint DEFAULT 0,
    acctinputoctets_utc bigint DEFAULT 0,
    acctoutputoctets_utc bigint DEFAULT 0,
    rowcount_utc integer DEFAULT 0,
    time_connected_tz bigint DEFAULT 0,
    acctsessiontime_tz bigint DEFAULT 0,
    acctinputoctets_tz bigint DEFAULT 0,
    acctoutputoctets_tz bigint DEFAULT 0,
    rowcount_tz integer DEFAULT 0
);


ALTER TABLE csctoss.line_usage_day_history OWNER TO csctoss_owner;

--
-- Name: TABLE line_usage_day_history; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE line_usage_day_history IS 'History table used for usage calculations.';


--
-- Name: line_usage_month; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE line_usage_month (
    line_id integer NOT NULL,
    year smallint NOT NULL,
    month smallint NOT NULL,
    timezone text NOT NULL,
    time_connected_utc bigint DEFAULT 0,
    acctsessiontime_utc bigint DEFAULT 0,
    acctinputoctets_utc bigint DEFAULT 0,
    acctoutputoctets_utc bigint DEFAULT 0,
    rowcount_utc integer DEFAULT 0,
    time_connected_tz bigint DEFAULT 0,
    acctsessiontime_tz bigint DEFAULT 0,
    acctinputoctets_tz bigint DEFAULT 0,
    acctoutputoctets_tz bigint DEFAULT 0,
    rowcount_tz integer DEFAULT 0,
    CONSTRAINT line_usage_month_month_ck CHECK ((("month" >= 1) AND ("month" <= 12)))
);


ALTER TABLE csctoss.line_usage_month OWNER TO csctoss_owner;

--
-- Name: TABLE line_usage_month; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE line_usage_month IS 'Accounting usage rollup table providing usage by month for all lines.';


SET default_with_oids = true;

--
-- Name: line_usage_overage_calc; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE line_usage_overage_calc (
    line_id integer NOT NULL,
    timezone text NOT NULL,
    usage_calc_start_timestamp timestamp with time zone NOT NULL,
    usage_calc_end_timestamp timestamp with time zone NOT NULL,
    billing_entity_name text,
    username text,
    product_code text NOT NULL,
    pooled_product boolean NOT NULL,
    alert_threshold_mb integer NOT NULL,
    time_connected_utc bigint DEFAULT 0,
    acctsessiontime_utc bigint DEFAULT 0,
    acctinputoctets_utc bigint DEFAULT 0,
    acctoutputoctets_utc bigint DEFAULT 0,
    rowcount_utc integer DEFAULT 0,
    time_connected_tz bigint DEFAULT 0,
    acctsessiontime_tz bigint DEFAULT 0,
    acctinputoctets_tz bigint DEFAULT 0,
    acctoutputoctets_tz bigint DEFAULT 0,
    rowcount_tz integer DEFAULT 0
);


ALTER TABLE csctoss.line_usage_overage_calc OWNER TO csctoss_owner;

--
-- Name: TABLE line_usage_overage_calc; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE line_usage_overage_calc IS 'Stub table used for usage calculations.';


SET default_with_oids = false;

--
-- Name: lns_lookup; Type: TABLE; Schema: csctoss; Owner: postgres; Tablespace: 
--

CREATE TABLE lns_lookup (
    nasidentifier text NOT NULL,
    description text NOT NULL,
    radclient_ip_address text NOT NULL,
    radclient_port integer NOT NULL,
    radclient_password text NOT NULL
);


ALTER TABLE csctoss.lns_lookup OWNER TO postgres;

--
-- Name: TABLE lns_lookup; Type: COMMENT; Schema: csctoss; Owner: postgres
--

COMMENT ON TABLE lns_lookup IS 'Table for looking up LNS server information used to call Radius executables.';


--
-- Name: location_label_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE location_label_type (
    location_label_type text NOT NULL,
    description text NOT NULL
);


ALTER TABLE csctoss.location_label_type OWNER TO csctoss_owner;

--
-- Name: TABLE location_label_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE location_label_type IS 'Lookup table defining the types of location labels.';


SET default_with_oids = true;

--
-- Name: location_labels_20170509_131000mdt; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE location_labels_20170509_131000mdt (
    line_id integer,
    owner character varying,
    id character varying,
    name character varying,
    address character varying,
    processor character varying,
    fwver character varying,
    uptime integer
);


ALTER TABLE csctoss.location_labels_20170509_131000mdt OWNER TO csctoss_owner;

--
-- Name: location_labels_20170730_201000mdt; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE location_labels_20170730_201000mdt (
    line_id integer,
    owner character varying,
    id character varying,
    name character varying,
    address character varying,
    processor character varying,
    fwver character varying,
    uptime integer
);


ALTER TABLE csctoss.location_labels_20170730_201000mdt OWNER TO csctoss_owner;

--
-- Name: location_labels_atl; Type: TABLE; Schema: csctoss; Owner: postgres; Tablespace: 
--

CREATE TABLE location_labels_atl (
    line_id integer,
    owner character varying,
    id character varying,
    name character varying,
    address character varying,
    processor character varying,
    fwver character varying,
    uptime integer
);


ALTER TABLE csctoss.location_labels_atl OWNER TO postgres;

--
-- Name: location_labels_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW location_labels_vw AS
    SELECT be.billing_entity_id, be.name AS billing_entity_name, ll.line_id, ll."owner", ll.id, ll.name, ll.address, ll.processor, ll.fwver, ll.uptime FROM ((location_labels ll LEFT JOIN line ON ((ll.line_id = line.line_id))) LEFT JOIN billing_entity be ON ((line.billing_entity_id = be.billing_entity_id))) ORDER BY be.billing_entity_id;


ALTER TABLE csctoss.location_labels_vw OWNER TO csctoss_owner;

SET default_with_oids = false;

--
-- Name: login_tracking; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE login_tracking (
    username text NOT NULL,
    billing_entity_id integer NOT NULL,
    login_timestamp timestamp without time zone NOT NULL,
    logout_timestamp timestamp without time zone,
    session_id text,
    role_used text
);


ALTER TABLE csctoss.login_tracking OWNER TO csctoss_owner;

--
-- Name: TABLE login_tracking; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE login_tracking IS 'Basic tracking of logins to the Portal or OSS';


SET default_with_oids = true;

--
-- Name: master_radacct; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE master_radacct (
    master_radacctid bigint DEFAULT nextval('csctoss.master_radacct_master_radacctid_seq'::text) NOT NULL,
    source_hostname character varying(64) NOT NULL,
    radacctid bigint NOT NULL,
    acctsessionid character varying(32) NOT NULL,
    acctuniqueid character varying(32) NOT NULL,
    username character varying(64),
    realm character varying(64),
    nasipaddress inet NOT NULL,
    nasportid character varying(15),
    nasporttype character varying(32),
    acctstarttime timestamp with time zone,
    acctstoptime timestamp with time zone,
    acctsessiontime bigint,
    acctauthentic character varying(32),
    connectinfo_start character varying(50),
    connectinfo_stop character varying(50),
    acctinputoctets bigint,
    acctoutputoctets bigint,
    calledstationid character varying(50),
    callingstationid character varying(50),
    acctterminatecause character varying(32),
    servicetype character varying(32),
    framedprotocol character varying(32),
    framedipaddress inet,
    acctstartdelay bigint,
    acctstopdelay bigint,
    xascendsessionsvrkey character varying(10),
    tunnelclientendpoint inet,
    nasidentifier character varying(32),
    class character varying(128),
    processed_flag boolean DEFAULT false
);


ALTER TABLE csctoss.master_radacct OWNER TO csctoss_owner;

--
-- Name: TABLE master_radacct; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE master_radacct IS 'Comprehensive accounting table for Free RADIUS residing on master CSCTOSS database.';


--
-- Name: master_radacct_master_radacctid_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE master_radacct_master_radacctid_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.master_radacct_master_radacctid_seq OWNER TO csctoss_owner;

--
-- Name: master_radacct_master_radacctid_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE master_radacct_master_radacctid_seq OWNED BY master_radacct.master_radacctid;


--
-- Name: master_radacct_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW master_radacct_vw AS
    SELECT master_radacct.master_radacctid, master_radacct.source_hostname, master_radacct.radacctid, master_radacct.acctsessionid, master_radacct.acctuniqueid, master_radacct.username, master_radacct.realm, host(master_radacct.nasipaddress) AS nasipaddress, master_radacct.nasportid, master_radacct.nasporttype, master_radacct.acctstarttime, master_radacct.acctstoptime, master_radacct.acctsessiontime, master_radacct.acctauthentic, master_radacct.connectinfo_start, master_radacct.connectinfo_stop, master_radacct.acctinputoctets, master_radacct.acctoutputoctets, master_radacct.calledstationid, master_radacct.callingstationid, master_radacct.acctterminatecause, master_radacct.servicetype, master_radacct.framedprotocol, host(master_radacct.framedipaddress) AS framedipaddress, master_radacct.acctstartdelay, master_radacct.acctstopdelay, master_radacct.xascendsessionsvrkey, host(master_radacct.tunnelclientendpoint) AS tunnelclientendpoint, master_radacct.nasidentifier, master_radacct."class", master_radacct.processed_flag FROM master_radacct;


ALTER TABLE csctoss.master_radacct_vw OWNER TO csctoss_owner;

SET default_with_oids = false;

--
-- Name: master_radpostauth; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE master_radpostauth (
    master_radpostauth_id bigint DEFAULT nextval('csctoss.master_radpostauth_master_radpostauth_id_seq'::text) NOT NULL,
    source_hostname character varying(64) NOT NULL,
    id bigint NOT NULL,
    username character varying(64) NOT NULL,
    pass character varying(128),
    reply character varying(32),
    authdate timestamp with time zone DEFAULT '2009-09-01 22:57:40.301448+00'::timestamp with time zone NOT NULL
);


ALTER TABLE csctoss.master_radpostauth OWNER TO csctoss_owner;

--
-- Name: TABLE master_radpostauth; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE master_radpostauth IS 'Comprehensive post authentication table for Free RADIUS residing on master CSCTOSS database.';


--
-- Name: master_radpostauth_master_radpostauth_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE master_radpostauth_master_radpostauth_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.master_radpostauth_master_radpostauth_id_seq OWNER TO csctoss_owner;

--
-- Name: master_radpostauth_master_radpostauth_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE master_radpostauth_master_radpostauth_id_seq OWNED BY master_radpostauth.master_radpostauth_id;


--
-- Name: message_priority; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE message_priority (
    message_priority_id integer DEFAULT nextval('csctoss.message_priority_message_priority_id_seq'::text) NOT NULL,
    message_priority text NOT NULL
);


ALTER TABLE csctoss.message_priority OWNER TO csctoss_owner;

--
-- Name: message_priority_message_priority_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE message_priority_message_priority_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.message_priority_message_priority_id_seq OWNER TO csctoss_owner;

--
-- Name: message_priority_message_priority_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE message_priority_message_priority_id_seq OWNED BY message_priority.message_priority_id;


SET default_with_oids = true;

--
-- Name: mrac_load; Type: TABLE; Schema: csctoss; Owner: slony; Tablespace: 
--

CREATE TABLE mrac_load (
    radacctid bigint,
    source_hostname character varying(64),
    change_type character(1),
    acctsessionid character varying(32),
    acctuniqueid character varying(32),
    username character varying(64),
    realm character varying(64),
    nasipaddress inet,
    nasportid character varying(15),
    nasporttype character varying(32),
    acctstarttime timestamp with time zone,
    acctstoptime timestamp with time zone,
    acctsessiontime bigint,
    acctauthentic character varying(32),
    connectinfo_start character varying(50),
    connectinfo_stop character varying(50),
    acctinputoctets bigint,
    acctoutputoctets bigint,
    calledstationid character varying(50),
    callingstationid character varying(50),
    acctterminatecause character varying(32),
    servicetype character varying(32),
    framedprotocol character varying(32),
    framedipaddress inet,
    acctstartdelay bigint,
    acctstopdelay bigint,
    xascendsessionsvrkey character varying(10),
    tunnelclientendpoint inet,
    nasidentifier character varying(32),
    class character varying(128)
);


ALTER TABLE csctoss.mrac_load OWNER TO slony;

--
-- Name: TABLE mrac_load; Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON TABLE mrac_load IS 'Temporary holding table for radacct data from remote radiusdb databases.';


SET default_with_oids = false;

--
-- Name: mrad_duplicate; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE mrad_duplicate (
    master_radacctid bigint NOT NULL,
    retained_mrad_id bigint,
    duplicate_reason text NOT NULL,
    status text NOT NULL,
    scrub_date date NOT NULL,
    source_hostname character varying(64) NOT NULL,
    radacctid bigint NOT NULL,
    acctsessionid character varying(32) NOT NULL,
    acctuniqueid character varying(32) NOT NULL,
    username character varying(64),
    realm character varying(64),
    nasipaddress inet NOT NULL,
    nasportid character varying(15),
    nasporttype character varying(32),
    acctstarttime timestamp with time zone,
    acctstoptime timestamp with time zone,
    acctsessiontime bigint,
    acctauthentic character varying(32),
    connectinfo_start character varying(50),
    connectinfo_stop character varying(50),
    acctinputoctets bigint,
    acctoutputoctets bigint,
    calledstationid character varying(50),
    callingstationid character varying(50),
    acctterminatecause character varying(32),
    servicetype character varying(32),
    framedprotocol character varying(32),
    framedipaddress inet,
    acctstartdelay bigint,
    acctstopdelay bigint,
    xascendsessionsvrkey character varying(10),
    tunnelclientendpoint inet,
    nasidentifier character varying(32),
    class character varying(128),
    CONSTRAINT mrad_duplicate_duplicate_reason_ck CHECK (((((duplicate_reason = 'SOURCE_HOSTNAME+RADACCTID'::text) OR (duplicate_reason = 'ACCTUNIQUEID'::text)) OR (duplicate_reason = 'USERNAME+ACCTSTARTTIME'::text)) OR (duplicate_reason = 'USERNAME+ACCTSTOPTIME'::text))),
    CONSTRAINT mrad_duplicate_status_ck CHECK (((status = 'SCRUB'::text) OR (status = 'CLOSED'::text)))
);


ALTER TABLE csctoss.mrad_duplicate OWNER TO csctoss_owner;

--
-- Name: TABLE mrad_duplicate; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE mrad_duplicate IS 'Table storing duplicate master_radacct records based upon business rules defining duplicate records.';


--
-- Name: nas; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE nas (
    id integer DEFAULT nextval('csctoss.nas_id_seq'::text) NOT NULL,
    nasname character varying(128) NOT NULL,
    shortname character varying(32) NOT NULL,
    type character varying(30) DEFAULT 'other'::character varying NOT NULL,
    ports integer,
    secret character varying(60) NOT NULL,
    community character varying(50),
    description character varying(200)
);


ALTER TABLE csctoss.nas OWNER TO csctoss_owner;

--
-- Name: TABLE nas; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE nas IS 'Table structure for table nas.';


--
-- Name: nas_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE nas_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.nas_id_seq OWNER TO csctoss_owner;

--
-- Name: nas_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE nas_id_seq OWNED BY nas.id;


--
-- Name: number_of_active_per_carrier_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW number_of_active_per_carrier_vw AS
    SELECT CASE WHEN (l.radius_username ~ '@uscc'::text) THEN 'USCC'::text WHEN (l.radius_username ~ '@tsp'::text) THEN 'SPRINT'::text WHEN (l.radius_username ~ '@cn01'::text) THEN 'SPRINT'::text WHEN (l.radius_username ~ '@vzw'::text) THEN 'VZW'::text ELSE 'Others'::text END AS carrier, count(*) AS num_of_active FROM (line l JOIN line_equipment le ON ((l.line_id = le.line_id))) WHERE ((((1 = 1) AND (le.end_date IS NULL)) AND (l.radius_username !~ '@csctus'::text)) AND (l.radius_username !~ '@contour'::text)) GROUP BY CASE WHEN (l.radius_username ~ '@uscc'::text) THEN 'USCC'::text WHEN (l.radius_username ~ '@tsp'::text) THEN 'SPRINT'::text WHEN (l.radius_username ~ '@cn01'::text) THEN 'SPRINT'::text WHEN (l.radius_username ~ '@vzw'::text) THEN 'VZW'::text ELSE 'Others'::text END;


ALTER TABLE csctoss.number_of_active_per_carrier_vw OWNER TO csctoss_owner;

--
-- Name: soup_config_info; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE soup_config_info (
    config_id integer DEFAULT nextval('csctoss.soup_config_info_config_id_seq'::text) NOT NULL,
    message text NOT NULL,
    equipment_id integer NOT NULL,
    config_name text NOT NULL
);


ALTER TABLE csctoss.soup_config_info OWNER TO csctoss_owner;

--
-- Name: oss_active_line_config_revisions_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW oss_active_line_config_revisions_vw AS
    SELECT be.billing_entity_id, be.name AS billing_entity_name, line.line_id, line.radius_username, (line.start_date)::date AS line_start_date, (line.end_date)::date AS line_end_date, le.equipment_id, le.start_date AS equipment_start_date, le.end_date AS equipment_end_date, sci.config_id, sci.config_name, sci.message FROM (((billing_entity be JOIN line ON ((be.billing_entity_id = line.billing_entity_id))) JOIN line_equipment le ON ((le.line_id = line.line_id))) LEFT JOIN soup_config_info sci ON ((sci.equipment_id = le.equipment_id))) WHERE ((1 = 1) AND (le.end_date IS NULL));


ALTER TABLE csctoss.oss_active_line_config_revisions_vw OWNER TO csctoss_owner;

SET default_with_oids = true;

--
-- Name: oss_jbill_billing_entity_mapping; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE oss_jbill_billing_entity_mapping (
    oss_billing_entity_id integer NOT NULL,
    jbilling_customer_id integer
);


ALTER TABLE csctoss.oss_jbill_billing_entity_mapping OWNER TO csctoss_owner;

--
-- Name: oss_jbill_plan_comparison_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW oss_jbill_plan_comparison_vw AS
    SELECT be.billing_entity_id AS oss_billing_entity_id, be.name AS oss_billing_entity_name, line.line_id, line.radius_username AS oss_radius_username, line.start_date AS line_start_date, line.end_date AS line_end_date, prd.product_code AS oss_product_code, jbill.internal_number AS jbill_product_code, jbill.public_number AS jbill_public_number, jbill.order_internal_number FROM (((((billing_entity be JOIN line ON ((be.billing_entity_id = line.billing_entity_id))) JOIN line_equipment le ON ((line.line_id = le.line_id))) JOIN plan ON ((line.line_id = plan.line_id))) JOIN product prd ON ((prd.product_id = plan.product_id))) LEFT JOIN public.dblink((SELECT fetch_jbilling_conn.fetch_jbilling_conn FROM fetch_jbilling_conn()), '\012SELECT\012  pl.line_id,\012  pl.item_id,\012  item.internal_number,\012  po.public_number,\012  (SELECT internal_number FROM order_line ol\012   JOIN item i ON (ol.item_id = i.id)\012   JOIN item_type_map itm2 ON (itm2.item_id = ol.item_id)\012   WHERE ol.order_id = po.id\012   AND itm2.type_id = 301\012   AND i.internal_number LIKE ''MRC-%'') AS order_internal_number\012FROM purchase_order po\012JOIN prov_line pl ON (po.id = pl.order_id)\012JOIN item ON (pl.item_id = item.id)\012JOIN item_type_map itm ON (item.id = itm.item_id)\012WHERE 1 = 1\012AND itm.type_id = 301\012AND archived is null\012'::text) jbill(line_id integer, item_id integer, internal_number text, public_number text, order_internal_number text) ON ((line.line_id = jbill.line_id))) WHERE ((1 = 1) AND (le.end_date IS NULL)) ORDER BY be.billing_entity_id, line.line_id;


ALTER TABLE csctoss.oss_jbill_plan_comparison_vw OWNER TO csctoss_owner;

--
-- Name: oss_line_summary_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW oss_line_summary_vw AS
    SELECT be.billing_entity_id, be.name AS billing_entity_name, be.parent_billing_entity_id, line.line_id, line.start_date AS line_start_date, line.end_date AS line_end_date, line.radius_username, line.notes AS line_notes, le.equipment_id, le.start_date AS equip_start_date, le.end_date AS equip_end_date, prd.product_code, em.model_number1 AS model_number, (SELECT ARRAY(SELECT usergroup.groupname FROM usergroup WHERE ((usergroup.username)::text = line.radius_username))) AS groupname, (SELECT radreply.value FROM radreply WHERE (((radreply.username)::text = line.radius_username) AND ((radreply.attribute)::text = 'Framed-IP-Address'::text))) AS framed_ip_address, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'SERIAL NUMBER'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS sn, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'MAC ADDRESS'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS mac, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'ESN HEX'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS esn_hex, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'ESN DEC'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS esn_dec, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'MDN'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS mdn, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'MIN'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS min, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'MSISDN'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS msisdn, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'ICCID'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS iccid, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'IMEI'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS imei, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'MEID'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS meid, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'IMSI'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS imsi FROM ((((((billing_entity be JOIN line ON ((be.billing_entity_id = line.billing_entity_id))) JOIN line_equipment le ON ((line.line_id = le.line_id))) LEFT JOIN plan ON ((line.line_id = plan.line_id))) LEFT JOIN product prd ON ((plan.product_id = prd.product_id))) LEFT JOIN equipment eq ON ((le.equipment_id = eq.equipment_id))) LEFT JOIN equipment_model em ON ((eq.equipment_model_id = em.equipment_model_id)));


ALTER TABLE csctoss.oss_line_summary_vw OWNER TO csctoss_owner;

--
-- Name: oss_sync_ip_activity_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW oss_sync_ip_activity_vw AS
    SELECT rec_type.acctstarttime, rec_type.acctstoptime, rec_type.framedipaddress, rec_type."class" FROM public.dblink((SELECT fetch_csctlog_conn.fetch_csctlog_conn FROM fetch_csctlog_conn()), 'select acctstarttime::timestamp, acctstoptime::timestamp, framedipaddress, class\012                          from csctlog.master_radacct\012                         where acctstarttime  > current_timestamp - interval ''26 hours''\012                           and (  acctstarttime > current_timestamp - interval ''2 hours''\012                               or acctstoptime  > current_timestamp - interval ''2 hours''\012                               or acctstoptime is null\012                               )\012                      order by acctstarttime'::text) rec_type(acctstarttime timestamp without time zone, acctstoptime timestamp without time zone, framedipaddress inet, "class" character varying);


ALTER TABLE csctoss.oss_sync_ip_activity_vw OWNER TO csctoss_owner;

--
-- Name: oss_sync_line_mrac_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW oss_sync_line_mrac_vw AS
    SELECT rec_type.master_radacctid, rec_type."class", rec_type.acctstarttime, rec_type.acctstoptime, rec_type.framedipaddress FROM public.dblink((SELECT fetch_csctlog_conn.fetch_csctlog_conn FROM fetch_csctlog_conn()), 'select master_radacctid, class::integer, acctstarttime, acctstoptime, framedipaddress\012                          from csctlog.master_radacct\012                         where master_radacctid in\012                               (select max(master_radacctid)\012                                  from master_radacct\012                                 where class > ''0''\012                                   and class <> ''classtest''\012                                   and connectinfo_start is not null\012                                   and acctstarttime >= current_date-2\012                                   and acctstarttime <= current_date+1\012                              group by class)'::text) rec_type(master_radacctid bigint, "class" integer, acctstarttime timestamp with time zone, acctstoptime timestamp with time zone, framedipaddress inet);


ALTER TABLE csctoss.oss_sync_line_mrac_vw OWNER TO csctoss_owner;

--
-- Name: otaps_monthly_usage_summary; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE otaps_monthly_usage_summary (
    usage_monthly_summary_id integer DEFAULT nextval('csctoss.otaps_monthly_usage_summary_usage_monthly_summary_id_seq'::text) NOT NULL,
    create_timestamp timestamp with time zone NOT NULL,
    record_type integer,
    archived boolean NOT NULL,
    billing_entity_id integer NOT NULL,
    billing_entity_name text NOT NULL,
    jbilling_id integer,
    old_product_code character varying NOT NULL,
    otaps_product_code character varying,
    carrier_product_code character varying,
    carrier character varying,
    line_id integer,
    usage_date character varying NOT NULL,
    base_mb integer,
    num_of_lines_in_pool integer,
    total_threshold integer,
    acctinputoctets numeric,
    acctoutputoctets numeric,
    total_usage numeric(9,2),
    usage_overage numeric(9,2),
    usage_fee_text text,
    usage_source text
);


ALTER TABLE csctoss.otaps_monthly_usage_summary OWNER TO csctoss_owner;

--
-- Name: otaps_monthly_usage_summary_usage_monthly_summary_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE otaps_monthly_usage_summary_usage_monthly_summary_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.otaps_monthly_usage_summary_usage_monthly_summary_id_seq OWNER TO csctoss_owner;

--
-- Name: otaps_monthly_usage_summary_usage_monthly_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE otaps_monthly_usage_summary_usage_monthly_summary_id_seq OWNED BY otaps_monthly_usage_summary.usage_monthly_summary_id;


--
-- Name: otaps_product_code_translation; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE otaps_product_code_translation (
    item_id integer NOT NULL,
    old_product_code text NOT NULL,
    product_code_descr text NOT NULL,
    carrier character varying NOT NULL,
    otaps_product_code text,
    carrier_internal_product_code text,
    carrier_internal_product_code_descr text
);


ALTER TABLE csctoss.otaps_product_code_translation OWNER TO csctoss_owner;

--
-- Name: otaps_service_line_number; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE otaps_service_line_number (
    line_id integer NOT NULL,
    product_id text,
    so_number text,
    so_item_seq_id integer,
    is_active text,
    status_id text,
    customer_id integer,
    date_of_provising date
);


ALTER TABLE csctoss.otaps_service_line_number OWNER TO csctoss_owner;

SET default_with_oids = false;

--
-- Name: parser_log; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE parser_log (
    parser_log_id integer DEFAULT nextval('csctoss.parser_log_parser_log_id_seq'::text) NOT NULL,
    master_radacctid_start bigint NOT NULL,
    master_radacctid_end bigint NOT NULL,
    start_runtime timestamp with time zone,
    end_runtime timestamp with time zone,
    master_radacct_rows_tried integer,
    master_radacct_rows_processed integer
);


ALTER TABLE csctoss.parser_log OWNER TO csctoss_owner;

--
-- Name: TABLE parser_log; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE parser_log IS 'Table to Log parser information';


--
-- Name: parser_log_parser_log_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE parser_log_parser_log_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.parser_log_parser_log_id_seq OWNER TO csctoss_owner;

--
-- Name: parser_log_parser_log_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE parser_log_parser_log_id_seq OWNED BY parser_log.parser_log_id;


--
-- Name: plan_log; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE plan_log (
    plan_log_id integer DEFAULT nextval('csctoss.plan_log_plan_log_id_seq'::text) NOT NULL,
    plan_id integer NOT NULL,
    days_added integer,
    minutes_added integer,
    login_date timestamp with time zone,
    comment text,
    create_timestamp timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL
);


ALTER TABLE csctoss.plan_log OWNER TO csctoss_owner;

--
-- Name: TABLE plan_log; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE plan_log IS 'Table for storing wifi charging';


--
-- Name: plan_log_plan_log_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE plan_log_plan_log_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.plan_log_plan_log_id_seq OWNER TO csctoss_owner;

--
-- Name: plan_log_plan_log_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE plan_log_plan_log_id_seq OWNED BY plan_log.plan_log_id;


--
-- Name: plan_plan_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE plan_plan_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.plan_plan_id_seq OWNER TO csctoss_owner;

--
-- Name: plan_plan_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE plan_plan_id_seq OWNED BY plan.plan_id;


--
-- Name: plan_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE plan_type (
    plan_type_id integer NOT NULL,
    plan_type_desc text NOT NULL
);


ALTER TABLE csctoss.plan_type OWNER TO csctoss_owner;

--
-- Name: TABLE plan_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE plan_type IS 'A description of a collection of services (some of which may be optional) and how they are billed.';


--
-- Name: soup_cellsignal; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE soup_cellsignal (
    esn text NOT NULL,
    esn1 text,
    esn2 text,
    cellsignal text NOT NULL,
    "timestamp" timestamp with time zone NOT NULL
);


ALTER TABLE csctoss.soup_cellsignal OWNER TO csctoss_owner;

--
-- Name: TABLE soup_cellsignal; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE soup_cellsignal IS 'Cell signal data which comes from SOUP server.';


SET default_with_oids = true;

--
-- Name: soup_device_stats_table; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE soup_device_stats_table (
    did bigint,
    serial_number text,
    datetime timestamp without time zone,
    firmware text,
    firmware_time timestamp without time zone,
    log_errors bigint,
    log_warnings bigint,
    pda_errors bigint,
    uptime bigint
);


ALTER TABLE csctoss.soup_device_stats_table OWNER TO csctoss_owner;

--
-- Name: portal_active_lines_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW portal_active_lines_vw AS
    SELECT line.line_id, (line.start_date)::date AS line_start_date, (line.end_date)::date AS line_end_date, line.radius_username, em.model_number1 AS equipment_model_number, em.carrier AS equipment_carrier, em.make AS equipment_maker, em.vendor AS equipment_vendor, prd.product_code, plan."comment" AS sales_order_number, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'ESN HEX'::text) AND (unique_identifier.equipment_id = lieq.equipment_id))) AS esn_hex, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'SERIAL NUMBER'::text) AND (unique_identifier.equipment_id = lieq.equipment_id))) AS serial_number, liloc."owner" AS location_owner, liloc.id AS location_id, liloc.address AS location_address, liloc.name AS location_name, liloc.processor AS location_processor, (SELECT soup_cellsignal.cellsignal FROM soup_cellsignal WHERE ((soup_cellsignal.esn1 = (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'ESN HEX'::text) AND (unique_identifier.equipment_id = lieq.equipment_id)))) OR (soup_cellsignal.esn2 = (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'ESN HEX'::text) AND (unique_identifier.equipment_id = lieq.equipment_id))))) ORDER BY soup_cellsignal."timestamp" DESC LIMIT 1) AS cellsignal, CASE WHEN (line.radius_username IS NOT NULL) THEN (COALESCE((SELECT radreply.value FROM radreply WHERE (((radreply.attribute)::text = 'Framed-IP-Address'::text) AND ((radreply.username)::text = line.radius_username))), ('N/A'::text)::character varying))::text ELSE 'IP Not Avalible'::text END AS static_ip_address, be.name, (SELECT ops_get_connection_status.ops_get_connection_status FROM ops_get_connection_status(line.radius_username)) AS connection_status, COALESCE((SELECT (max(master_radacct.acctstarttime))::text AS max FROM master_radacct WHERE ((master_radacct.username)::text = line.radius_username) GROUP BY master_radacct.username), 'No connections in last 3 months'::text) AS last_connected_timestamp, (SELECT soup_device_stats_table.firmware FROM soup_device_stats_table WHERE (soup_device_stats_table.serial_number = (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'SERIAL NUMBER'::text) AND (unique_identifier.equipment_id = lieq.equipment_id)))) ORDER BY soup_device_stats_table.datetime DESC LIMIT 1) AS firmware_version, (ew.warranty_start_date)::date AS warranty_start_date, (ew.warranty_end_date)::date AS warranty_end_date, CASE WHEN ((ew.warranty_end_date)::date >= ('now'::text)::date) THEN 'In warranty'::text ELSE 'Out of warranty'::text END AS warranty_status, sci.config_name AS soup_config_name, (SELECT CASE WHEN ((SELECT count(*) AS count FROM master_radacct WHERE ((master_radacct.username)::text = line.radius_username)) = 0) THEN 'NO'::text ELSE CASE WHEN ((SELECT count(*) AS count FROM master_radacct mrad WHERE (((((mrad.username)::text = line.radius_username) AND (mrad.acctstarttime >= (('now'::text)::timestamp(6) with time zone - '1 mon'::interval))) AND (mrad.master_radacctid = (SELECT max(mrad2.master_radacctid) AS max FROM master_radacct mrad2 WHERE ((mrad2.username)::text = (mrad.username)::text)))) AND (mrad.acctstoptime IS NULL))) = 1) THEN 'YES'::text ELSE 'NO'::text END END AS "case") AS is_connected, (SELECT ops_get_config_status.ops_get_config_status FROM ops_get_config_status(sci.config_name)) AS config_status, (SELECT ops_get_firmware_status.ops_get_firmware_status FROM ops_get_firmware_status((SELECT soup_device_stats_table.firmware FROM soup_device_stats_table WHERE (soup_device_stats_table.serial_number = (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'SERIAL NUMBER'::text) AND (unique_identifier.equipment_id = lieq.equipment_id)))) ORDER BY soup_device_stats_table.datetime DESC LIMIT 1))) AS firmware_status, be.billing_entity_id, be.parent_billing_entity_id FROM ((((((((((line JOIN billing_entity be ON ((line.billing_entity_id = be.billing_entity_id))) LEFT JOIN plan ON ((line.line_id = plan.line_id))) LEFT JOIN product prd ON ((plan.product_id = prd.product_id))) LEFT JOIN line_equipment lieq ON ((line.line_id = lieq.line_id))) LEFT JOIN equipment eq ON ((lieq.equipment_id = eq.equipment_id))) LEFT JOIN equipment_model em ON ((eq.equipment_model_id = em.equipment_model_id))) LEFT JOIN location_labels liloc ON ((line.line_id = liloc.line_id))) LEFT JOIN usergroup ug ON ((((ug.username)::text = line.radius_username) AND ((ug.groupname)::text = 'userdisconnected'::text)))) LEFT JOIN equipment_warranty ew ON ((eq.equipment_id = ew.equipment_id))) LEFT JOIN soup_config_info sci ON ((sci.equipment_id = eq.equipment_id))) WHERE ((((1 = 1) AND (lieq.end_date IS NULL)) AND (line.end_date IS NULL)) AND (line.radius_username IS NOT NULL));


ALTER TABLE csctoss.portal_active_lines_vw OWNER TO csctoss_owner;

SET default_with_oids = false;

--
-- Name: portal_properties; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE portal_properties (
    property_name text NOT NULL,
    property_value text NOT NULL
);


ALTER TABLE csctoss.portal_properties OWNER TO csctoss_owner;

--
-- Name: TABLE portal_properties; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE portal_properties IS ' Defines Portal application level variables.';


--
-- Name: product_overage_threshold; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE product_overage_threshold (
    product_id integer NOT NULL,
    base_mb integer,
    pooled boolean,
    billing_pattern text,
    alert_threshold_mb integer
);


ALTER TABLE csctoss.product_overage_threshold OWNER TO csctoss_owner;

--
-- Name: TABLE product_overage_threshold; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE product_overage_threshold IS 'Table to report overage lines.';


--
-- Name: product_overage_threshold_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW product_overage_threshold_vw AS
    SELECT prd.product_id, prd.product_code, prd.plan_type_id, prd.length_days, prd.obsolete, prd.product_desc, prd.prepaid_unit, prd.prepaid_allowance, prd.default_logical_apn, prd.sales_price, overage.base_mb, overage.pooled, overage.billing_pattern, overage.alert_threshold_mb FROM (product prd LEFT JOIN product_overage_threshold overage ON ((prd.product_id = overage.product_id))) ORDER BY prd.product_id;


ALTER TABLE csctoss.product_overage_threshold_vw OWNER TO csctoss_owner;

--
-- Name: VIEW product_overage_threshold_vw; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON VIEW product_overage_threshold_vw IS 'Provide overage threshold information with product information.';


--
-- Name: purchase_log; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE purchase_log (
    purchase_log_id integer DEFAULT nextval('csctoss.purchase_log_purchase_log_id_seq'::text) NOT NULL,
    transaction_result text NOT NULL,
    esn text,
    mdn text,
    product_code text,
    sold_by text,
    submission_id integer,
    jci_bmarket_web_api text,
    client_ip_address text,
    company_name text,
    user_name text,
    submission_date timestamp with time zone,
    failure_reasons text,
    CONSTRAINT purchase_log_transaction_result_ck CHECK (((transaction_result = 'SUCCESS'::text) OR (transaction_result = 'FAILURE'::text)))
);


ALTER TABLE csctoss.purchase_log OWNER TO csctoss_owner;

--
-- Name: TABLE purchase_log; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE purchase_log IS 'Table to record purchases.';


--
-- Name: purchase_log_purchase_log_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE purchase_log_purchase_log_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.purchase_log_purchase_log_id_seq OWNER TO csctoss_owner;

--
-- Name: purchase_log_purchase_log_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE purchase_log_purchase_log_id_seq OWNED BY purchase_log.purchase_log_id;


--
-- Name: radcheck; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE radcheck (
    id integer DEFAULT nextval('csctoss.radcheck_id_seq'::text) NOT NULL,
    username character varying(64) DEFAULT ''::character varying NOT NULL,
    attribute character varying(64) DEFAULT ''::character varying NOT NULL,
    op character varying(2) DEFAULT '=='::character varying NOT NULL,
    value character varying(253) DEFAULT ''::character varying NOT NULL
);


ALTER TABLE csctoss.radcheck OWNER TO csctoss_owner;

--
-- Name: TABLE radcheck; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE radcheck IS 'Table structure for table radcheck.';


--
-- Name: radcheck_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE radcheck_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.radcheck_id_seq OWNER TO csctoss_owner;

--
-- Name: radcheck_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE radcheck_id_seq OWNED BY radcheck.id;


--
-- Name: radgroupcheck; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE radgroupcheck (
    id integer DEFAULT nextval('csctoss.radgroupcheck_id_seq'::text) NOT NULL,
    groupname character varying(64) DEFAULT ''::character varying NOT NULL,
    attribute character varying(64) DEFAULT ''::character varying NOT NULL,
    op character varying(2) DEFAULT '=='::character varying NOT NULL,
    value character varying(253) DEFAULT ''::character varying NOT NULL
);


ALTER TABLE csctoss.radgroupcheck OWNER TO csctoss_owner;

--
-- Name: TABLE radgroupcheck; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE radgroupcheck IS 'Table structure for table radgroupcheck.';


--
-- Name: radgroupcheck_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE radgroupcheck_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.radgroupcheck_id_seq OWNER TO csctoss_owner;

--
-- Name: radgroupcheck_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE radgroupcheck_id_seq OWNED BY radgroupcheck.id;


--
-- Name: radgroupreply; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE radgroupreply (
    id integer DEFAULT nextval('csctoss.radgroupreply_id_seq'::text) NOT NULL,
    groupname character varying(64) DEFAULT ''::character varying NOT NULL,
    attribute character varying(64) DEFAULT ''::character varying NOT NULL,
    op character varying(2) DEFAULT '='::character varying NOT NULL,
    value character varying(253) DEFAULT ''::character varying NOT NULL
);


ALTER TABLE csctoss.radgroupreply OWNER TO csctoss_owner;

--
-- Name: TABLE radgroupreply; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE radgroupreply IS 'Table structure for table radgroupreply.';


--
-- Name: radgroupreply_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE radgroupreply_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.radgroupreply_id_seq OWNER TO csctoss_owner;

--
-- Name: radgroupreply_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE radgroupreply_id_seq OWNED BY radgroupreply.id;


--
-- Name: radius_operator; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE radius_operator (
    op_id integer DEFAULT nextval('csctoss.radius_operator_op_id_seq'::text) NOT NULL,
    op character varying(2) NOT NULL
);


ALTER TABLE csctoss.radius_operator OWNER TO csctoss_owner;

--
-- Name: radius_operator_op_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE radius_operator_op_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.radius_operator_op_id_seq OWNER TO csctoss_owner;

--
-- Name: radius_operator_op_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE radius_operator_op_id_seq OWNED BY radius_operator.op_id;


--
-- Name: radius_postauth_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW radius_postauth_vw AS
    SELECT mrpa.master_radpostauth_id, mrpa.username, CASE WHEN ((mrpa.pass)::text = 'Chap-Password'::text) THEN mrpa.pass ELSE '********'::character varying END AS pass, mrpa.reply, mrpa.authdate, mrpa.source_hostname, line.radius_username AS callingstationid, line.line_id FROM ((master_radpostauth mrpa JOIN line ON ((line.radius_username = (mrpa.username)::text))) JOIN billing_entity bent USING (billing_entity_id));


ALTER TABLE csctoss.radius_postauth_vw OWNER TO csctoss_owner;

--
-- Name: VIEW radius_postauth_vw; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON VIEW radius_postauth_vw IS 'Radius Post-Authentication information with password supressed';


--
-- Name: radius_username_change_log_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW radius_username_change_log_vw AS
    SELECT change_log.change_timestamp, change_log.change_type, change_log.table_name, change_log.column_name, change_log.primary_key AS line_id, change_log.previous_value FROM change_log WHERE (((1 = 1) AND (change_log.table_name = '"csctoss"."line"'::text)) AND (change_log.column_name = 'radius_username'::text)) ORDER BY change_log.change_timestamp DESC;


ALTER TABLE csctoss.radius_username_change_log_vw OWNER TO csctoss_owner;

--
-- Name: radreply_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE radreply_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.radreply_id_seq OWNER TO csctoss_owner;

--
-- Name: radreply_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE radreply_id_seq OWNED BY radreply.id;


SET default_with_oids = true;

--
-- Name: rating_engine_beid_trans; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE rating_engine_beid_trans (
    oss_beid integer,
    oss_parent_beid integer,
    jbill_id integer,
    oss_cust_name character varying,
    oss_parent_cust_name character varying,
    jbill_cust_name character varying
);


ALTER TABLE csctoss.rating_engine_beid_trans OWNER TO csctoss_owner;

SET default_with_oids = false;

--
-- Name: receiving_lot; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE receiving_lot (
    receiving_lot_id integer DEFAULT nextval('csctoss.receiving_lot_receiving_lot_id_seq'::text) NOT NULL,
    description text NOT NULL,
    receiving_status text NOT NULL,
    purchase_order_date date NOT NULL,
    master_pack_id text,
    ship_date date,
    received_date date,
    so_number text,
    po_number text,
    total_cost numeric,
    item_count integer DEFAULT 0 NOT NULL,
    vendor text,
    CONSTRAINT receiving_lot_receiving_status_ck CHECK (((receiving_status = 'OPEN'::text) OR (receiving_status = 'CLOSED'::text)))
);


ALTER TABLE csctoss.receiving_lot OWNER TO csctoss_owner;

--
-- Name: TABLE receiving_lot; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE receiving_lot IS 'Lists and tracks pertinent information for equipment shipments from vendors and received by CSCT.';


--
-- Name: receiving_lot_receiving_lot_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE receiving_lot_receiving_lot_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.receiving_lot_receiving_lot_id_seq OWNER TO csctoss_owner;

--
-- Name: receiving_lot_receiving_lot_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE receiving_lot_receiving_lot_id_seq OWNED BY receiving_lot.receiving_lot_id;


--
-- Name: replication_failure; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE replication_failure (
    replication_failure_id integer DEFAULT nextval('csctoss.replication_failure_replication_failure_id_seq'::text) NOT NULL,
    hostname text NOT NULL,
    ip_address text NOT NULL,
    failed_table text NOT NULL,
    failed_primary_key text NOT NULL,
    failed_action character(1) NOT NULL,
    sql_statement text DEFAULT ''::text NOT NULL,
    status text DEFAULT 'FAILED'::text NOT NULL,
    date_created date DEFAULT ('now'::text)::date NOT NULL,
    date_reconciled date,
    CONSTRAINT replication_failure_failed_action_ck CHECK ((((failed_action = 'I'::bpchar) OR (failed_action = 'U'::bpchar)) OR (failed_action = 'D'::bpchar))),
    CONSTRAINT replication_failure_status_ck CHECK (((status = 'FAILED'::text) OR (status = 'RECONCILED'::text)))
);


ALTER TABLE csctoss.replication_failure OWNER TO csctoss_owner;

--
-- Name: TABLE replication_failure; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE replication_failure IS 'Table to track replication failures for reconciliation.';


--
-- Name: replication_failure_replication_failure_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE replication_failure_replication_failure_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.replication_failure_replication_failure_id_seq OWNER TO csctoss_owner;

--
-- Name: replication_failure_replication_failure_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE replication_failure_replication_failure_id_seq OWNED BY replication_failure.replication_failure_id;


--
-- Name: report; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE report (
    report_id integer DEFAULT nextval('csctoss.report_report_id_seq'::text) NOT NULL,
    report_name text NOT NULL,
    reporting_page character varying(128) NOT NULL,
    file_name character varying(128) NOT NULL,
    output_type text NOT NULL,
    input_screen_name text NOT NULL,
    output_file_name character varying(128) NOT NULL,
    status text NOT NULL,
    security_role text,
    description text NOT NULL,
    category text,
    billing_entity_id integer,
    CONSTRAINT report_output_type_ck CHECK (((((output_type = 'PDF'::text) OR (output_type = 'CSV'::text)) OR (output_type = 'XLS'::text)) OR (output_type = 'XML'::text)))
);


ALTER TABLE csctoss.report OWNER TO csctoss_owner;

--
-- Name: TABLE report; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE report IS 'Table to manage reporting structure.';


--
-- Name: report_report_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE report_report_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.report_report_id_seq OWNER TO csctoss_owner;

--
-- Name: report_report_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE report_report_id_seq OWNED BY report.report_id;


--
-- Name: rma_form; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE rma_form (
    id integer DEFAULT nextval('csctoss.rma_form_id_seq'::text) NOT NULL,
    name text NOT NULL,
    username text NOT NULL,
    phone_number text,
    reason_id integer NOT NULL,
    description text NOT NULL,
    create_date timestamp with time zone NOT NULL,
    address1 text NOT NULL,
    address2 text,
    city text NOT NULL,
    state character varying(2) NOT NULL,
    zipcode text NOT NULL,
    old_esn_hex text NOT NULL,
    email text NOT NULL,
    agreement_id integer NOT NULL,
    new_esn_hex text,
    shipping_tracking text,
    return_tracking text,
    status text NOT NULL,
    freshdesk_id integer
);


ALTER TABLE csctoss.rma_form OWNER TO csctoss_owner;

--
-- Name: rma_form_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE rma_form_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.rma_form_id_seq OWNER TO csctoss_owner;

--
-- Name: rma_form_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE rma_form_id_seq OWNED BY rma_form.id;


--
-- Name: sales_order; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE sales_order (
    sales_order_number text NOT NULL,
    date_created date DEFAULT ('now'::text)::date
);


ALTER TABLE csctoss.sales_order OWNER TO csctoss_owner;

--
-- Name: secured_line_info_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW secured_line_info_vw AS
    SELECT be.billing_entity_id, be.name AS billing_entity_name, line.line_id, line.radius_username, (line.start_date)::date AS line_start_date, (line.end_date)::date AS line_end_date, le.equipment_id, le.start_date AS equip_start_date, le.end_date AS equip_end_date, (SELECT rr.value FROM radreply rr WHERE (((rr.username)::text = line.radius_username) AND ((rr.attribute)::text = 'Framed-IP-Address'::text))) AS static_ip_address, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'SERIAL NUMBER'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS sn, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'ESN HEX'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS esn_hex, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'ESN DEC'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS esn_dec, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'MDN'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS mdn, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'MIN'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS min, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'MAC ADDRESS'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS mac, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'MSISDN'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS msisdn, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'ICCID'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS iccid, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'MEID'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS meid, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'IMEI'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS imei, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'IMSI'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS imsi, (SELECT unique_identifier.value FROM unique_identifier WHERE ((unique_identifier.unique_identifier_type = 'MSID'::text) AND (unique_identifier.equipment_id = le.equipment_id))) AS msid FROM ((billing_entity be JOIN line ON ((be.billing_entity_id = line.billing_entity_id))) JOIN line_equipment le ON ((line.line_id = le.line_id))) WHERE ((1 = 1) AND (be.billing_entity_id = 748));


ALTER TABLE csctoss.secured_line_info_vw OWNER TO csctoss_owner;

--
-- Name: security_roles; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE security_roles (
    security_role text NOT NULL,
    role_level integer NOT NULL,
    role_type text NOT NULL,
    CONSTRAINT role_type_value_ck CHECK (((role_type = 'OSS'::text) OR (role_type = 'PORTAL'::text)))
);


ALTER TABLE csctoss.security_roles OWNER TO csctoss_owner;

--
-- Name: TABLE security_roles; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE security_roles IS 'Portal and OSS Security roles for user masquerading';


--
-- Name: session_history_last30days_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW session_history_last30days_vw AS
    SELECT be.name AS billing_entity_name, line.radius_username AS username, mrad.acctterminatecause, sum(mrad.num_of_conn) AS num_of_conn FROM ((billing_entity be JOIN line ON ((be.billing_entity_id = line.billing_entity_id))) JOIN public.dblink((SELECT fetch_csctlog_conn.fetch_csctlog_conn FROM fetch_csctlog_conn()), '\012SELECT\012  username, acctterminatecause, COUNT(*) AS num_of_conn\012FROM csctlog.master_radacct\012WHERE 1 = 1\012AND acctstarttime >= (current_timestamp - ''30 days''::interval)\012GROUP BY username, acctterminatecause\012'::text) mrad(username text, acctterminatecause text, num_of_conn bigint) ON ((line.radius_username = mrad.username))) GROUP BY be.name, line.radius_username, mrad.acctterminatecause ORDER BY be.name, line.radius_username, mrad.acctterminatecause;


ALTER TABLE csctoss.session_history_last30days_vw OWNER TO csctoss_owner;

--
-- Name: shipment; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE shipment (
    shipment_id integer DEFAULT nextval('csctoss.shipment_shipment_id_seq'::text) NOT NULL,
    sender_billing_entity_id integer NOT NULL,
    receiver_billing_entity_id integer NOT NULL,
    date_sent date DEFAULT ('now'::text)::date NOT NULL,
    receiver_address_id integer NOT NULL,
    shipment_carrier text,
    shipment_method text,
    expected_delivery_date date,
    actual_received_date date,
    tracking_information text,
    special_instructions text,
    item_count integer,
    sales_order_number text,
    CONSTRAINT shipment_check_dates_ck CHECK (shipment_check_dates(date_sent, expected_delivery_date, actual_received_date))
);


ALTER TABLE csctoss.shipment OWNER TO csctoss_owner;

--
-- Name: TABLE shipment; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE shipment IS 'Table for listing and tracking customer shipment information.';


--
-- Name: shipment_equipment; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE shipment_equipment (
    shipment_id integer NOT NULL,
    equipment_id integer NOT NULL,
    end_date date,
    notes text,
    CONSTRAINT shipment_equipment_end_date_ck CHECK (shipment_equipment_end_date(shipment_id, equipment_id, end_date))
);


ALTER TABLE csctoss.shipment_equipment OWNER TO csctoss_owner;

--
-- Name: TABLE shipment_equipment; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE shipment_equipment IS 'Intersection table associating equipment with a shipment.';


--
-- Name: shipment_shipment_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE shipment_shipment_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.shipment_shipment_id_seq OWNER TO csctoss_owner;

--
-- Name: shipment_shipment_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE shipment_shipment_id_seq OWNED BY shipment.shipment_id;


--
-- Name: software; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE software (
    software_id integer DEFAULT nextval('csctoss.software_software_id_seq'::text) NOT NULL,
    software_name text,
    software_description text,
    software_version text,
    software_vendor text
);


ALTER TABLE csctoss.software OWNER TO csctoss_owner;

--
-- Name: TABLE software; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE software IS 'Table defining all software for the csctoss system as it pertains to equipment. Used with intersection table equipment_software.';


--
-- Name: software_software_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE software_software_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.software_software_id_seq OWNER TO csctoss_owner;

--
-- Name: software_software_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE software_software_id_seq OWNED BY software.software_id;


SET default_with_oids = true;

--
-- Name: soup_alerts_table; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE soup_alerts_table (
    did bigint,
    serial_number text,
    server_timestamp timestamp without time zone,
    local_timestamp timestamp without time zone,
    service text,
    returncode bigint,
    output text
);


ALTER TABLE csctoss.soup_alerts_table OWNER TO csctoss_owner;

SET default_with_oids = false;

--
-- Name: soup_config; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE soup_config (
    soup_config_id integer DEFAULT nextval('csctoss.soup_config_soup_config_id_seq'::text) NOT NULL,
    name text NOT NULL,
    equipment_model_id integer
);


ALTER TABLE csctoss.soup_config OWNER TO csctoss_owner;

--
-- Name: soup_config_info_config_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE soup_config_info_config_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.soup_config_info_config_id_seq OWNER TO csctoss_owner;

--
-- Name: soup_config_info_config_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE soup_config_info_config_id_seq OWNED BY soup_config_info.config_id;


--
-- Name: soup_config_soup_config_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE soup_config_soup_config_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.soup_config_soup_config_id_seq OWNER TO csctoss_owner;

--
-- Name: soup_config_soup_config_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE soup_config_soup_config_id_seq OWNED BY soup_config.soup_config_id;


--
-- Name: soup_device; Type: TABLE; Schema: csctoss; Owner: slony; Tablespace: 
--

CREATE TABLE soup_device (
    did integer NOT NULL,
    create_date text,
    "timestamp" text,
    eui character(12),
    model character varying(16),
    serial_number character varying(64),
    part_number character varying(64),
    description character varying(255),
    location character varying(255)
);


ALTER TABLE csctoss.soup_device OWNER TO slony;

SET default_with_oids = true;

--
-- Name: soup_device_table; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE soup_device_table (
    did bigint,
    datetime timestamp without time zone,
    eui text,
    model text,
    serial_number text,
    part_number text,
    description text,
    location text,
    lastip text
);


ALTER TABLE csctoss.soup_device_table OWNER TO csctoss_owner;

SET default_with_oids = false;

--
-- Name: soup_dirnames; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE soup_dirnames (
    soup_dirnames_id integer DEFAULT nextval('csctoss.soup_dirnames_soup_dirnames_id_seq'::text) NOT NULL,
    dirname text,
    billing_entity_id integer NOT NULL,
    soup_config_id integer NOT NULL
);


ALTER TABLE csctoss.soup_dirnames OWNER TO csctoss_owner;

--
-- Name: soup_dirnames_soup_dirnames_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE soup_dirnames_soup_dirnames_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.soup_dirnames_soup_dirnames_id_seq OWNER TO csctoss_owner;

--
-- Name: soup_dirnames_soup_dirnames_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE soup_dirnames_soup_dirnames_id_seq OWNED BY soup_dirnames.soup_dirnames_id;


--
-- Name: soup_group_info; Type: TABLE; Schema: csctoss; Owner: slony; Tablespace: 
--

CREATE TABLE soup_group_info (
    gid integer,
    aid smallint,
    name text
);


ALTER TABLE csctoss.soup_group_info OWNER TO slony;

--
-- Name: soup_update_from_oss; Type: TABLE; Schema: csctoss; Owner: slony; Tablespace: 
--

CREATE TABLE soup_update_from_oss (
    d_did integer,
    d_eui text,
    d_serial_number text,
    d_description text,
    gd_gid integer,
    gi_name text,
    oss_equipment_id integer,
    oss_line_id integer,
    oss_billing_entity_id integer,
    oss_billing_entity_name text,
    status text DEFAULT 'LOAD'::text NOT NULL
);


ALTER TABLE csctoss.soup_update_from_oss OWNER TO slony;

--
-- Name: sprint_assignment; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE sprint_assignment (
    sprint_assignment_id integer DEFAULT nextval('csctoss.sprint_assignment_sprint_assignment_id_seq'::text) NOT NULL,
    username text DEFAULT 'UNKNOWN'::text NOT NULL,
    billing_entity_id integer DEFAULT 0 NOT NULL,
    billing_entity_name text DEFAULT 'UNKNOWN'::text NOT NULL,
    equipment_id integer DEFAULT 0 NOT NULL,
    mdn text DEFAULT 'UNKNOWN'::text NOT NULL,
    ser text DEFAULT 'UNKNOWN'::text NOT NULL,
    readiness text DEFAULT 'UNKNOWN'::text NOT NULL,
    evaluator_name text DEFAULT 'UNKNOWN'::text NOT NULL,
    system text DEFAULT 'UNKNOWN'::text NOT NULL
);


ALTER TABLE csctoss.sprint_assignment OWNER TO csctoss_owner;

--
-- Name: sprint_assignment_sprint_assignment_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE sprint_assignment_sprint_assignment_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.sprint_assignment_sprint_assignment_id_seq OWNER TO csctoss_owner;

--
-- Name: sprint_assignment_sprint_assignment_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE sprint_assignment_sprint_assignment_id_seq OWNED BY sprint_assignment.sprint_assignment_id;


--
-- Name: sprint_csa; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE sprint_csa (
    id bigint DEFAULT nextval('csctoss.sprint_csa_id_seq'::text) NOT NULL,
    name text NOT NULL
);


ALTER TABLE csctoss.sprint_csa OWNER TO csctoss_owner;

--
-- Name: TABLE sprint_csa; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE sprint_csa IS 'This is for Sprint CSA.';


--
-- Name: sprint_csa_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE sprint_csa_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.sprint_csa_id_seq OWNER TO csctoss_owner;

--
-- Name: sprint_csa_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE sprint_csa_id_seq OWNED BY sprint_csa.id;


--
-- Name: sprint_master_radacct; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE sprint_master_radacct (
    sprint_master_radacctid bigint DEFAULT nextval('csctoss.sprint_master_radacct_sprint_master_radacctid_seq'::text) NOT NULL,
    source_hostname character varying(64) NOT NULL,
    acctstatustype character varying(20) NOT NULL,
    radacctid bigint NOT NULL,
    acctsessionid character varying(32) NOT NULL,
    acctuniqueid character varying(32) NOT NULL,
    username character varying(64),
    realm character varying(64),
    nasipaddress inet NOT NULL,
    nasportid character varying(15),
    nasporttype character varying(32),
    acctstarttime timestamp with time zone,
    acctstoptime timestamp with time zone,
    acctsessiontime bigint,
    acctauthentic character varying(32),
    connectinfo_start character varying(50),
    connectinfo_stop character varying(50),
    acctinputoctets bigint,
    acctoutputoctets bigint,
    calledstationid character varying(50),
    callingstationid character varying(50),
    acctterminatecause character varying(32),
    servicetype character varying(32),
    framedprotocol character varying(32),
    framedipaddress inet,
    acctstartdelay bigint,
    acctstopdelay bigint,
    xascendsessionsvrkey character varying(10),
    tunnelclientendpoint inet,
    nasidentifier character varying(32),
    class character varying(128),
    _3gpp2homeagentipaddress inet,
    _3gpp2pcfipaddress inet,
    _3gpp2bsid character(50),
    _3gpp2userid character varying(15),
    _3gpp2serviceoption character varying(15),
    _3gpp2iptechnology character varying(15),
    _3gpp2airlinkrecordtype character varying(15),
    _3gpp2attr41 character varying(128),
    _3gpp2airlinksequencenumber character varying(15),
    _3gpp2numberactivetransitions character varying(15),
    _3gpp2receivedhdlcoctets character varying(15),
    _3gpp2correlationid character varying(32),
    _3gpp2esn character varying(32),
    _3gpp2foreignagentaddress inet,
    _3gpp2forwardfchmuxoption character varying(15),
    _3gpp2reversefchmuxoption character varying(15),
    _3gpp2forwardtraffictype character varying(15),
    _3gpp2reversetraffictype character varying(15),
    _3gpp2forwardfchrc character varying(15),
    _3gpp2reversefchrc character varying(15),
    _3gpp2lastuseractivitytime character varying(128)
);


ALTER TABLE csctoss.sprint_master_radacct OWNER TO csctoss_owner;

--
-- Name: TABLE sprint_master_radacct; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE sprint_master_radacct IS 'Comprehensive accounting table for SPRINT Accounting Data residing on master csctoss database.';


--
-- Name: sprint_master_radacct_sprint_master_radacctid_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE sprint_master_radacct_sprint_master_radacctid_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.sprint_master_radacct_sprint_master_radacctid_seq OWNER TO csctoss_owner;

--
-- Name: sprint_master_radacct_sprint_master_radacctid_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE sprint_master_radacct_sprint_master_radacctid_seq OWNED BY sprint_master_radacct.sprint_master_radacctid;


--
-- Name: sprint_msl; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE sprint_msl (
    mdn text NOT NULL,
    esn text NOT NULL,
    msl text NOT NULL,
    created_timestamp timestamp with time zone
);


ALTER TABLE csctoss.sprint_msl OWNER TO csctoss_owner;

--
-- Name: TABLE sprint_msl; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE sprint_msl IS 'This is for Sprint MSL.';


--
-- Name: staff; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE staff (
    staff_id integer NOT NULL,
    staff_login_name text NOT NULL,
    staff_password_md5 text,
    login_enabled boolean DEFAULT false NOT NULL
);


ALTER TABLE csctoss.staff OWNER TO csctoss_owner;

--
-- Name: TABLE staff; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE staff IS 'Staff members and others who use/update this database.';


--
-- Name: staff_access; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE staff_access (
    staff_id integer NOT NULL,
    level_name text NOT NULL
);


ALTER TABLE csctoss.staff_access OWNER TO csctoss_owner;

--
-- Name: TABLE staff_access; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE staff_access IS 'Staff/Access level mapping.';


--
-- Name: state_code; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE state_code (
    state_code character(2) NOT NULL,
    state_province_name text NOT NULL,
    country_code character(2) NOT NULL
);


ALTER TABLE csctoss.state_code OWNER TO csctoss_owner;

--
-- Name: TABLE state_code; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE state_code IS 'US states and territories as well as Canadian provinces.';


--
-- Name: static_ip_carrier_def; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE static_ip_carrier_def (
    carrier_def_id integer NOT NULL,
    carrier text NOT NULL
);


ALTER TABLE csctoss.static_ip_carrier_def OWNER TO csctoss_owner;

--
-- Name: TABLE static_ip_carrier_def; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE static_ip_carrier_def IS 'Table for storing the carrier names with respective ids for static ip range.';


--
-- Name: static_ip_pool; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE static_ip_pool (
    id integer DEFAULT nextval('csctoss.static_ip_pool_id_seq'::text) NOT NULL,
    static_ip text NOT NULL,
    groupname character varying(64) DEFAULT ''::character varying NOT NULL,
    is_assigned boolean DEFAULT false NOT NULL,
    line_id integer,
    carrier_id integer NOT NULL,
    billing_entity_id integer
);


ALTER TABLE csctoss.static_ip_pool OWNER TO csctoss_owner;

--
-- Name: TABLE static_ip_pool; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE static_ip_pool IS 'Table for storing the static ip pool to be assigned to the lines.';


--
-- Name: static_ip_reservation; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE static_ip_reservation (
    reservation_id integer DEFAULT nextval('csctoss.static_ip_reservation_reservation_id_seq'::text) NOT NULL,
    static_ip_id integer NOT NULL,
    reservation_billing_entity_id integer NOT NULL,
    reservation_timestamp timestamp without time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL
);


ALTER TABLE csctoss.static_ip_reservation OWNER TO csctoss_owner;

--
-- Name: static_ip_active_reservations_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW static_ip_active_reservations_vw AS
    SELECT sip.id, sip.static_ip, sip.groupname, sip.is_assigned, sip.line_id, sip.carrier_id, sip.billing_entity_id, sir.reservation_id, sir.static_ip_id, sir.reservation_billing_entity_id, sir.reservation_timestamp, sic.carrier_def_id, sic.carrier FROM ((static_ip_pool sip JOIN static_ip_reservation sir ON ((sir.static_ip_id = sip.id))) JOIN static_ip_carrier_def sic ON ((sic.carrier_def_id = sip.carrier_id))) WHERE ((sir.reservation_timestamp > (('now'::text)::timestamp(6) with time zone - ((SELECT app_config.config_value FROM app_config WHERE (app_config.config_key = 'db.ip.reservation.interval'::text) LIMIT 1))::interval)) AND (sip.is_assigned IS FALSE));


ALTER TABLE csctoss.static_ip_active_reservations_vw OWNER TO csctoss_owner;

--
-- Name: static_ip_pool_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE static_ip_pool_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.static_ip_pool_id_seq OWNER TO csctoss_owner;

--
-- Name: static_ip_pool_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE static_ip_pool_id_seq OWNED BY static_ip_pool.id;


--
-- Name: static_ip_reservation_reservation_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE static_ip_reservation_reservation_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.static_ip_reservation_reservation_id_seq OWNER TO csctoss_owner;

--
-- Name: static_ip_reservation_reservation_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE static_ip_reservation_reservation_id_seq OWNED BY static_ip_reservation.reservation_id;


--
-- Name: static_ips_assigned_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW static_ips_assigned_vw AS
    SELECT sip.id, sip.static_ip, sip.groupname, sip.is_assigned, sip.line_id, sip.carrier_id, sip.billing_entity_id, sic.carrier_def_id, sic.carrier, sir.reservation_id, sir.reservation_billing_entity_id, sir.reservation_timestamp FROM ((static_ip_pool sip JOIN static_ip_carrier_def sic ON ((sic.carrier_def_id = sip.carrier_id))) LEFT JOIN static_ip_reservation sir ON ((sir.static_ip_id = sip.id))) WHERE (sip.is_assigned IS TRUE);


ALTER TABLE csctoss.static_ips_assigned_vw OWNER TO csctoss_owner;

--
-- Name: static_ips_available_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW static_ips_available_vw AS
    SELECT sip.id, sip.static_ip, sip.groupname, sip.is_assigned, sip.line_id, sip.carrier_id, sip.billing_entity_id, sic.carrier_def_id, sic.carrier, sir.reservation_id, sir.reservation_billing_entity_id, sir.reservation_timestamp FROM ((static_ip_pool sip JOIN static_ip_carrier_def sic ON ((sic.carrier_def_id = sip.carrier_id))) LEFT JOIN static_ip_reservation sir ON ((sir.static_ip_id = sip.id))) WHERE ((sip.is_assigned IS FALSE) AND (sir.reservation_id IS NULL));


ALTER TABLE csctoss.static_ips_available_vw OWNER TO csctoss_owner;

--
-- Name: static_ips_vw; Type: VIEW; Schema: csctoss; Owner: csctoss_owner
--

CREATE VIEW static_ips_vw AS
    SELECT sip.id, sip.static_ip, sip.groupname, sip.is_assigned, sip.line_id, sip.carrier_id, sip.billing_entity_id, sic.carrier_def_id, sic.carrier, sir.reservation_id, sir.reservation_billing_entity_id, sir.reservation_timestamp FROM ((static_ip_pool sip JOIN static_ip_carrier_def sic ON ((sic.carrier_def_id = sip.carrier_id))) LEFT JOIN static_ip_reservation sir ON ((sir.static_ip_id = sip.id)));


ALTER TABLE csctoss.static_ips_vw OWNER TO csctoss_owner;

--
-- Name: system_parameter; Type: TABLE; Schema: csctoss; Owner: slony; Tablespace: 
--

CREATE TABLE system_parameter (
    hostname text NOT NULL,
    ip_address text NOT NULL,
    repl_port text NOT NULL,
    repl_target_db text NOT NULL,
    repl_target_username text NOT NULL,
    repl_target_password text NOT NULL,
    repl_flag boolean DEFAULT false NOT NULL,
    radacct_flag boolean DEFAULT false NOT NULL,
    radpostauth_flag boolean DEFAULT false NOT NULL,
    sprint_flag boolean DEFAULT false NOT NULL
);


ALTER TABLE csctoss.system_parameter OWNER TO slony;

--
-- Name: TABLE system_parameter; Type: COMMENT; Schema: csctoss; Owner: slony
--

COMMENT ON TABLE system_parameter IS 'Used for dynamically populating radius servers from radius db master.';


SET default_with_oids = true;

--
-- Name: temp_contour_usage; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE temp_contour_usage (
    rlm_nme text,
    nai text,
    dev_msid_id text,
    presumed_mdn text,
    oss_billing_entity_name text,
    oss_line_id integer,
    oss_mdn text,
    oss_min text,
    oss_serial_number text
);


ALTER TABLE csctoss.temp_contour_usage OWNER TO csctoss_owner;

SET default_with_oids = false;

--
-- Name: throw_away_minutes; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE throw_away_minutes (
    throw_away_min_id integer DEFAULT nextval('csctoss.throw_away_minutes_throw_away_min_id_seq'::text) NOT NULL,
    line_id integer NOT NULL,
    plan_id integer NOT NULL,
    throw_away_min integer,
    create_timestamp timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL
);


ALTER TABLE csctoss.throw_away_minutes OWNER TO csctoss_owner;

--
-- Name: TABLE throw_away_minutes; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE throw_away_minutes IS 'Table to store minutes that could not be charged to a plan';


--
-- Name: throw_away_minutes_throw_away_min_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE throw_away_minutes_throw_away_min_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.throw_away_minutes_throw_away_min_id_seq OWNER TO csctoss_owner;

--
-- Name: throw_away_minutes_throw_away_min_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE throw_away_minutes_throw_away_min_id_seq OWNED BY throw_away_minutes.throw_away_min_id;


--
-- Name: timezone; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE timezone (
    timezone text NOT NULL,
    offset_from_utc text NOT NULL,
    description text NOT NULL
);


ALTER TABLE csctoss.timezone OWNER TO csctoss_owner;

--
-- Name: TABLE timezone; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE timezone IS 'Referential table for valid timezones in the billing_entity table.';


--
-- Name: unique_identifier_history; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE unique_identifier_history (
    unique_identifier_history_id integer DEFAULT nextval('csctoss.unique_identifier_history_unique_identifier_history_id_seq'::text) NOT NULL,
    create_timestamp timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    insert_or_update_or_delete character(1) NOT NULL,
    equipment_id integer NOT NULL,
    unique_identifier_type text NOT NULL,
    value text NOT NULL,
    notes text,
    date_created date DEFAULT ('now'::text)::date NOT NULL,
    date_modified date
);


ALTER TABLE csctoss.unique_identifier_history OWNER TO csctoss_owner;

--
-- Name: TABLE unique_identifier_history; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE unique_identifier_history IS 'This is a history table for csctoss.unique_identifier table.';


--
-- Name: unique_identifier_history_unique_identifier_history_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE unique_identifier_history_unique_identifier_history_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.unique_identifier_history_unique_identifier_history_id_seq OWNER TO csctoss_owner;

--
-- Name: unique_identifier_history_unique_identifier_history_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE unique_identifier_history_unique_identifier_history_id_seq OWNED BY unique_identifier_history.unique_identifier_history_id;


--
-- Name: unique_identifier_type; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE unique_identifier_type (
    unique_identifier_type text NOT NULL,
    description text NOT NULL,
    change_eligible_flag boolean DEFAULT true NOT NULL
);


ALTER TABLE csctoss.unique_identifier_type OWNER TO csctoss_owner;

--
-- Name: TABLE unique_identifier_type; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE unique_identifier_type IS 'Lookup table defining the types of equipment unique identifiers.';


--
-- Name: usage_calc; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE usage_calc (
    class character varying(128),
    acctstarttime timestamp with time zone,
    acctstoptime timestamp with time zone,
    acctsessiontime bigint,
    acctinputoctets bigint,
    acctoutputoctets bigint
);


ALTER TABLE csctoss.usage_calc OWNER TO csctoss_owner;

--
-- Name: TABLE usage_calc; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE usage_calc IS 'Stub table used for usage calculations.';


SET default_with_oids = true;

--
-- Name: usage_overage_calc; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE usage_overage_calc (
    class character varying(128),
    acctstarttime timestamp with time zone,
    acctstoptime timestamp with time zone,
    acctsessiontime bigint,
    acctinputoctets bigint,
    acctoutputoctets bigint
);


ALTER TABLE csctoss.usage_overage_calc OWNER TO csctoss_owner;

--
-- Name: TABLE usage_overage_calc; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE usage_overage_calc IS 'Stub table used for usage overage calculations.';


SET default_with_oids = false;

--
-- Name: usergroup_error_log; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE usergroup_error_log (
    usergroup_error_log_id integer DEFAULT nextval('csctoss.usergroup_error_log_usergroup_error_log_id_seq'::text) NOT NULL,
    line_id integer NOT NULL,
    plan_id integer NOT NULL,
    username character varying(64) DEFAULT ''::character varying NOT NULL,
    error_message text,
    create_timestamp timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL
);


ALTER TABLE csctoss.usergroup_error_log OWNER TO csctoss_owner;

--
-- Name: TABLE usergroup_error_log; Type: COMMENT; Schema: csctoss; Owner: csctoss_owner
--

COMMENT ON TABLE usergroup_error_log IS 'Table to log usergroup record that did not match either service or expired group';


--
-- Name: usergroup_error_log_usergroup_error_log_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE usergroup_error_log_usergroup_error_log_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.usergroup_error_log_usergroup_error_log_id_seq OWNER TO csctoss_owner;

--
-- Name: usergroup_error_log_usergroup_error_log_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE usergroup_error_log_usergroup_error_log_id_seq OWNED BY usergroup_error_log.usergroup_error_log_id;


--
-- Name: usergroup_id_seq; Type: SEQUENCE; Schema: csctoss; Owner: csctoss_owner
--

CREATE SEQUENCE usergroup_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE csctoss.usergroup_id_seq OWNER TO csctoss_owner;

--
-- Name: usergroup_id_seq; Type: SEQUENCE OWNED BY; Schema: csctoss; Owner: csctoss_owner
--

ALTER SEQUENCE usergroup_id_seq OWNED BY usergroup.id;


--
-- Name: userlevelpermissions; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE userlevelpermissions (
    userlevelid integer NOT NULL,
    tablename character varying(255) NOT NULL,
    permission integer NOT NULL
);


ALTER TABLE csctoss.userlevelpermissions OWNER TO csctoss_owner;

--
-- Name: userlevels; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE userlevels (
    userlevelid integer NOT NULL,
    userlevelname character varying(255) NOT NULL
);


ALTER TABLE csctoss.userlevels OWNER TO csctoss_owner;

SET default_with_oids = true;

--
-- Name: v_count; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE v_count (
    count bigint
);


ALTER TABLE csctoss.v_count OWNER TO csctoss_owner;

--
-- Name: v_new_sn; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE v_new_sn (
    value text
);


ALTER TABLE csctoss.v_new_sn OWNER TO csctoss_owner;

--
-- Name: v_old_ip; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE v_old_ip (
    value character varying(253)
);


ALTER TABLE csctoss.v_old_ip OWNER TO csctoss_owner;

--
-- Name: var_equipment_id; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE var_equipment_id (
    equipment_id integer
);


ALTER TABLE csctoss.var_equipment_id OWNER TO csctoss_owner;

--
-- Name: var_username; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE var_username (
    username character varying(64)
);


ALTER TABLE csctoss.var_username OWNER TO csctoss_owner;

--
-- Name: webui_users; Type: TABLE; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE TABLE webui_users (
    id integer DEFAULT nextval('csctoss_users_id_seq'::text) NOT NULL,
    username character varying(200) NOT NULL,
    password character varying(40),
    comments text,
    signature text,
    emailaddress character varying(120),
    freeformcontactinfo text,
    organization character varying(200),
    realname character varying(120),
    nickname character varying(16),
    lang character varying(16),
    emailencoding character varying(16),
    webencoding character varying(16),
    externalcontactinfoid character varying(100),
    contactinfosystem character varying(30),
    externalauthid character varying(100),
    authsystem character varying(30),
    gecos character varying(16),
    homephone character varying(30),
    workphone character varying(30),
    mobilephone character varying(30),
    pagerphone character varying(30),
    address1 character varying(200),
    address2 character varying(200),
    city character varying(100),
    state character varying(100),
    zip character varying(16),
    country character varying(50),
    timezone character varying(50),
    pgpkey text,
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone,
    lastupdatedby integer DEFAULT 0 NOT NULL,
    lastupdated timestamp without time zone,
    userlevelid integer DEFAULT 0,
    enabled boolean DEFAULT true
);


ALTER TABLE csctoss.webui_users OWNER TO csctoss_owner;

SET search_path = invoice, pg_catalog;

SET default_with_oids = false;

--
-- Name: app_config; Type: TABLE; Schema: invoice; Owner: invoice_owner; Tablespace: 
--

CREATE TABLE app_config (
    app_config_id integer DEFAULT nextval('invoice.app_config_app_config_id_seq'::text) NOT NULL,
    config_key text NOT NULL,
    config_value text NOT NULL
);


ALTER TABLE invoice.app_config OWNER TO invoice_owner;

--
-- Name: app_config_app_config_id_seq; Type: SEQUENCE; Schema: invoice; Owner: invoice_owner
--

CREATE SEQUENCE app_config_app_config_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invoice.app_config_app_config_id_seq OWNER TO invoice_owner;

--
-- Name: app_config_app_config_id_seq; Type: SEQUENCE OWNED BY; Schema: invoice; Owner: invoice_owner
--

ALTER SEQUENCE app_config_app_config_id_seq OWNED BY app_config.app_config_id;


--
-- Name: billing_entity; Type: TABLE; Schema: invoice; Owner: invoice_owner; Tablespace: 
--

CREATE TABLE billing_entity (
    billing_entity_id integer DEFAULT nextval('invoice.billing_entity_billing_entity_id_seq'::text) NOT NULL,
    parent_billing_entity_id integer,
    name text NOT NULL,
    phone_number1 text DEFAULT ''::text NOT NULL,
    phone_number2 text,
    fax_number1 text,
    fax_number2 text,
    url text,
    preferred_timezone text DEFAULT 'EDT'::text NOT NULL,
    billing_entity_type text DEFAULT 'UNKNOWN'::text NOT NULL,
    opt_in_flag boolean DEFAULT false NOT NULL
);


ALTER TABLE invoice.billing_entity OWNER TO invoice_owner;

--
-- Name: billing_entity_billing_entity_id_seq; Type: SEQUENCE; Schema: invoice; Owner: invoice_owner
--

CREATE SEQUENCE billing_entity_billing_entity_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invoice.billing_entity_billing_entity_id_seq OWNER TO invoice_owner;

--
-- Name: billing_entity_billing_entity_id_seq; Type: SEQUENCE OWNED BY; Schema: invoice; Owner: invoice_owner
--

ALTER SEQUENCE billing_entity_billing_entity_id_seq OWNED BY billing_entity.billing_entity_id;


--
-- Name: file_system; Type: TABLE; Schema: invoice; Owner: invoice_owner; Tablespace: 
--

CREATE TABLE file_system (
    document_id integer DEFAULT nextval('invoice.file_system_document_id_seq'::text) NOT NULL,
    document_date date NOT NULL,
    billing_entity_id integer NOT NULL,
    filename text NOT NULL,
    filepath text NOT NULL,
    extension text NOT NULL,
    filetype text NOT NULL
);


ALTER TABLE invoice.file_system OWNER TO invoice_owner;

--
-- Name: file_system_document_id_seq; Type: SEQUENCE; Schema: invoice; Owner: invoice_owner
--

CREATE SEQUENCE file_system_document_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invoice.file_system_document_id_seq OWNER TO invoice_owner;

--
-- Name: file_system_document_id_seq; Type: SEQUENCE OWNED BY; Schema: invoice; Owner: invoice_owner
--

ALTER SEQUENCE file_system_document_id_seq OWNED BY file_system.document_id;


SET search_path = oss_sync, pg_catalog;

SET default_with_oids = true;

--
-- Name: alert_definition; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE alert_definition (
    alert_type_id integer NOT NULL,
    username text NOT NULL,
    enabled boolean DEFAULT true NOT NULL,
    check_interval_minutes integer DEFAULT 0 NOT NULL,
    bytes_ignore_threshold integer DEFAULT 0 NOT NULL,
    time_ignore_threshold text,
    time_notification_interval text,
    time_reconnect_interval text,
    nagios_server text,
    nagios_failure_text text,
    nagios_success_text text,
    nagios_unknown_text text,
    max_notifications_per_alert integer,
    max_incidents_per_day integer DEFAULT 1 NOT NULL,
    alert_subject text NOT NULL,
    alert_text text
);


ALTER TABLE oss_sync.alert_definition OWNER TO alert_writer;

SET default_with_oids = false;

--
-- Name: be_vrf; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE be_vrf (
    be_id integer NOT NULL,
    vrf character varying,
    use_static_ip boolean,
    carrier character varying
);


ALTER TABLE oss_sync.be_vrf OWNER TO alert_writer;

--
-- Name: equipment; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE equipment (
    equipment_id integer,
    equipment_model_id integer,
    esn_hex text,
    serial_number text
);


ALTER TABLE oss_sync.equipment OWNER TO alert_writer;

--
-- Name: line; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE line (
    line_id integer,
    esn_hex character varying,
    product_id integer,
    start_date timestamp with time zone,
    end_date timestamp with time zone,
    active_flag boolean,
    radius_username text,
    billing_entity_id integer,
    parent_billing_entity_id integer
);


ALTER TABLE oss_sync.line OWNER TO alert_writer;

--
-- Name: line_equipment; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE line_equipment (
    line_id integer,
    equipment_id integer
);


ALTER TABLE oss_sync.line_equipment OWNER TO alert_writer;

--
-- Name: line_guid; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE line_guid (
    line_id integer NOT NULL,
    guid character varying
);


ALTER TABLE oss_sync.line_guid OWNER TO alert_writer;

SET default_with_oids = true;

--
-- Name: mrad; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE mrad (
    line_id integer,
    start_time timestamp without time zone,
    stop_time timestamp without time zone,
    ipaddr inet,
    vrf character varying,
    static_ip inet,
    user_disconnected boolean,
    disconnected boolean
);


ALTER TABLE oss_sync.mrad OWNER TO alert_writer;

SET default_with_oids = false;

--
-- Name: processor; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE processor (
    name character varying NOT NULL,
    nickname character varying
);


ALTER TABLE oss_sync.processor OWNER TO alert_writer;

--
-- Name: shipment; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE shipment (
    shipment_id integer,
    special_instructions text,
    receiver_billing_entity_id integer,
    tracking_information text,
    date_sent date,
    manual boolean,
    sales_order_number text
);


ALTER TABLE oss_sync.shipment OWNER TO alert_writer;

--
-- Name: shipment_equipment; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE shipment_equipment (
    shipment_id integer,
    equipment_id integer,
    manual boolean
);


ALTER TABLE oss_sync.shipment_equipment OWNER TO alert_writer;

--
-- Name: shipment_line; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE shipment_line (
    shipment_id integer,
    line_id integer,
    manual boolean
);


ALTER TABLE oss_sync.shipment_line OWNER TO alert_writer;

--
-- Name: snesn; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE snesn (
    sn character varying NOT NULL,
    esn_hex character varying NOT NULL
);


ALTER TABLE oss_sync.snesn OWNER TO alert_writer;

--
-- Name: snmac; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE snmac (
    mac character varying,
    sn character varying
);


ALTER TABLE oss_sync.snmac OWNER TO alert_writer;

--
-- Name: static_ip; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE static_ip (
    ip inet NOT NULL,
    billing_entity_id integer NOT NULL,
    carrier character varying
);


ALTER TABLE oss_sync.static_ip OWNER TO alert_writer;

--
-- Name: systech; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE systech (
    equipment_id integer NOT NULL,
    esn_hex character varying,
    sn character varying,
    mac character varying
);


ALTER TABLE oss_sync.systech OWNER TO alert_writer;

--
-- Name: usage; Type: TABLE; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

CREATE TABLE usage (
    line_id integer,
    usage_date date,
    tot_bytes integer,
    number_of_records integer,
    time_connected integer
);


ALTER TABLE oss_sync.usage OWNER TO alert_writer;

SET search_path = rt3, pg_catalog;

SET default_with_oids = true;

--
-- Name: acl; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE acl (
    id integer DEFAULT nextval('acl_id_seq'::text) NOT NULL,
    principaltype character varying(25) NOT NULL,
    principalid integer NOT NULL,
    rightname character varying(25) NOT NULL,
    objecttype character varying(25) NOT NULL,
    objectid integer DEFAULT 0 NOT NULL,
    delegatedby integer DEFAULT 0 NOT NULL,
    delegatedfrom integer DEFAULT 0 NOT NULL
);


ALTER TABLE rt3.acl OWNER TO rt_user;

--
-- Name: acl_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE acl_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.acl_id_seq OWNER TO rt_user;

--
-- Name: attachments; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE attachments (
    id integer DEFAULT nextval('attachments_id_seq'::text) NOT NULL,
    transactionid integer NOT NULL,
    parent integer DEFAULT 0 NOT NULL,
    messageid character varying(160),
    subject character varying(255),
    filename character varying(255),
    contenttype character varying(80),
    contentencoding character varying(80),
    content text,
    headers text,
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone
);


ALTER TABLE rt3.attachments OWNER TO rt_user;

--
-- Name: attachments_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE attachments_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.attachments_id_seq OWNER TO rt_user;

--
-- Name: attributes; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE attributes (
    id integer DEFAULT nextval('attributes_id_seq'::text) NOT NULL,
    name character varying(255) NOT NULL,
    description character varying(255),
    content text,
    contenttype character varying(16),
    objecttype character varying(64),
    objectid integer,
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone,
    lastupdatedby integer DEFAULT 0 NOT NULL,
    lastupdated timestamp without time zone
);


ALTER TABLE rt3.attributes OWNER TO rt_user;

--
-- Name: attributes_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE attributes_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.attributes_id_seq OWNER TO rt_user;

--
-- Name: cachedgroupmembers; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE cachedgroupmembers (
    id integer DEFAULT nextval('cachedgroupmembers_id_seq'::text) NOT NULL,
    groupid integer,
    memberid integer,
    via integer,
    immediateparentid integer,
    disabled integer DEFAULT 0 NOT NULL
);


ALTER TABLE rt3.cachedgroupmembers OWNER TO rt_user;

--
-- Name: cachedgroupmembers_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE cachedgroupmembers_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.cachedgroupmembers_id_seq OWNER TO rt_user;

--
-- Name: customfields; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE customfields (
    id integer DEFAULT nextval('customfields_id_seq'::text) NOT NULL,
    name character varying(200),
    type character varying(200),
    maxvalues integer DEFAULT 0 NOT NULL,
    repeated integer DEFAULT 0 NOT NULL,
    pattern character varying(255),
    lookuptype character varying(255) NOT NULL,
    description character varying(255),
    sortorder integer DEFAULT 0 NOT NULL,
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone,
    lastupdatedby integer DEFAULT 0 NOT NULL,
    lastupdated timestamp without time zone,
    disabled integer DEFAULT 0 NOT NULL
);


ALTER TABLE rt3.customfields OWNER TO rt_user;

--
-- Name: customfields_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE customfields_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.customfields_id_seq OWNER TO rt_user;

--
-- Name: customfieldvalues; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE customfieldvalues (
    id integer DEFAULT nextval('customfieldvalues_id_seq'::text) NOT NULL,
    customfield integer NOT NULL,
    name character varying(200),
    description character varying(255),
    sortorder integer DEFAULT 0 NOT NULL,
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone,
    lastupdatedby integer DEFAULT 0 NOT NULL,
    lastupdated timestamp without time zone
);


ALTER TABLE rt3.customfieldvalues OWNER TO rt_user;

--
-- Name: customfieldvalues_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE customfieldvalues_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.customfieldvalues_id_seq OWNER TO rt_user;

--
-- Name: groupmembers; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE groupmembers (
    id integer DEFAULT nextval('groupmembers_id_seq'::text) NOT NULL,
    groupid integer DEFAULT 0 NOT NULL,
    memberid integer DEFAULT 0 NOT NULL
);


ALTER TABLE rt3.groupmembers OWNER TO rt_user;

--
-- Name: groupmembers_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE groupmembers_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.groupmembers_id_seq OWNER TO rt_user;

--
-- Name: groups; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE groups (
    id integer DEFAULT nextval('groups_id_seq'::text) NOT NULL,
    name character varying(200),
    description character varying(255),
    domain character varying(64),
    type character varying(64),
    instance integer
);


ALTER TABLE rt3.groups OWNER TO rt_user;

--
-- Name: groups_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE groups_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.groups_id_seq OWNER TO rt_user;

--
-- Name: links; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE links (
    id integer DEFAULT nextval('links_id_seq'::text) NOT NULL,
    base character varying(240),
    target character varying(240),
    type character varying(20) NOT NULL,
    localtarget integer DEFAULT 0 NOT NULL,
    localbase integer DEFAULT 0 NOT NULL,
    lastupdatedby integer DEFAULT 0 NOT NULL,
    lastupdated timestamp without time zone,
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone
);


ALTER TABLE rt3.links OWNER TO rt_user;

--
-- Name: links_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE links_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.links_id_seq OWNER TO rt_user;

--
-- Name: objectcustomfields; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE objectcustomfields (
    id integer DEFAULT nextval('objectcustomfields_id_s'::text) NOT NULL,
    customfield integer NOT NULL,
    objectid integer NOT NULL,
    sortorder integer DEFAULT 0 NOT NULL,
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone,
    lastupdatedby integer DEFAULT 0 NOT NULL,
    lastupdated timestamp without time zone
);


ALTER TABLE rt3.objectcustomfields OWNER TO rt_user;

--
-- Name: objectcustomfields_id_s; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE objectcustomfields_id_s
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.objectcustomfields_id_s OWNER TO rt_user;

--
-- Name: objectcustomfieldvalues; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE objectcustomfieldvalues (
    id integer DEFAULT nextval('objectcustomfieldvalues_id_s'::text) NOT NULL,
    customfield integer NOT NULL,
    objecttype character varying(255),
    objectid integer NOT NULL,
    sortorder integer DEFAULT 0 NOT NULL,
    content character varying(255),
    largecontent text,
    contenttype character varying(80),
    contentencoding character varying(80),
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone,
    lastupdatedby integer DEFAULT 0 NOT NULL,
    lastupdated timestamp without time zone,
    disabled integer DEFAULT 0 NOT NULL
);


ALTER TABLE rt3.objectcustomfieldvalues OWNER TO rt_user;

--
-- Name: objectcustomfieldvalues_id_s; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE objectcustomfieldvalues_id_s
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.objectcustomfieldvalues_id_s OWNER TO rt_user;

--
-- Name: principals; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE principals (
    id integer DEFAULT nextval('principals_id_seq'::text) NOT NULL,
    principaltype character varying(16) NOT NULL,
    objectid integer,
    disabled integer DEFAULT 0 NOT NULL
);


ALTER TABLE rt3.principals OWNER TO rt_user;

--
-- Name: principals_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE principals_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.principals_id_seq OWNER TO rt_user;

--
-- Name: queues; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE queues (
    id integer DEFAULT nextval('queues_id_seq'::text) NOT NULL,
    name character varying(200) NOT NULL,
    description character varying(255),
    correspondaddress character varying(120),
    commentaddress character varying(120),
    initialpriority integer DEFAULT 0 NOT NULL,
    finalpriority integer DEFAULT 0 NOT NULL,
    defaultduein integer DEFAULT 0 NOT NULL,
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone,
    lastupdatedby integer DEFAULT 0 NOT NULL,
    lastupdated timestamp without time zone,
    disabled integer DEFAULT 0 NOT NULL
);


ALTER TABLE rt3.queues OWNER TO rt_user;

--
-- Name: queues_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE queues_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.queues_id_seq OWNER TO rt_user;

--
-- Name: tickets; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE tickets (
    id integer DEFAULT nextval('tickets_id_seq'::text) NOT NULL,
    effectiveid integer DEFAULT 0 NOT NULL,
    queue integer DEFAULT 0 NOT NULL,
    type character varying(16),
    issuestatement integer DEFAULT 0 NOT NULL,
    resolution integer DEFAULT 0 NOT NULL,
    owner integer DEFAULT 0 NOT NULL,
    subject character varying(200) DEFAULT '[no subject]'::character varying,
    initialpriority integer DEFAULT 0 NOT NULL,
    finalpriority integer DEFAULT 0 NOT NULL,
    priority integer DEFAULT 0 NOT NULL,
    timeestimated integer DEFAULT 0 NOT NULL,
    timeworked integer DEFAULT 0 NOT NULL,
    status character varying(10),
    timeleft integer DEFAULT 0 NOT NULL,
    told timestamp without time zone,
    starts timestamp without time zone,
    started timestamp without time zone,
    due timestamp without time zone,
    resolved timestamp without time zone,
    lastupdatedby integer DEFAULT 0 NOT NULL,
    lastupdated timestamp without time zone,
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone,
    disabled integer DEFAULT 0 NOT NULL
);


ALTER TABLE rt3.tickets OWNER TO rt_user;

--
-- Name: users; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE users (
    id integer DEFAULT nextval('users_id_seq'::text) NOT NULL,
    name character varying(200) NOT NULL,
    password character varying(40),
    comments text,
    signature text,
    emailaddress character varying(120),
    freeformcontactinfo text,
    organization character varying(200),
    realname character varying(120),
    nickname character varying(16),
    lang character varying(16),
    emailencoding character varying(16),
    webencoding character varying(16),
    externalcontactinfoid character varying(100),
    contactinfosystem character varying(30),
    externalauthid character varying(100),
    authsystem character varying(30),
    gecos character varying(16),
    homephone character varying(30),
    workphone character varying(30),
    mobilephone character varying(30),
    pagerphone character varying(30),
    address1 character varying(200),
    address2 character varying(200),
    city character varying(100),
    state character varying(100),
    zip character varying(16),
    country character varying(50),
    timezone character varying(50),
    pgpkey text,
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone,
    lastupdatedby integer DEFAULT 0 NOT NULL,
    lastupdated timestamp without time zone
);


ALTER TABLE rt3.users OWNER TO rt_user;

--
-- Name: rt_rma_queue_last6mo_vw; Type: VIEW; Schema: rt3; Owner: rt_user
--

CREATE VIEW rt_rma_queue_last6mo_vw AS
    SELECT btrim((q.name)::text) AS queue_name, q.description AS queue_description, t.id AS ticket_id, (t.created)::date AS ticket_created, t.subject, u.name AS ticket_creator, t.status AS ticket_status, (SELECT o.content FROM objectcustomfieldvalues o WHERE ((o.objectid = t.id) AND (o.customfield = 3)) LIMIT 1) AS company, (SELECT o.content FROM objectcustomfieldvalues o WHERE ((o.objectid = t.id) AND (o.customfield = 6)) LIMIT 1) AS ticket_resolution, (SELECT o.content FROM objectcustomfieldvalues o WHERE ((o.objectid = t.id) AND (o.customfield = 7)) LIMIT 1) AS equipment_make, (SELECT o.content FROM objectcustomfieldvalues o WHERE ((o.objectid = t.id) AND (o.customfield = 8)) LIMIT 1) AS equipment_model, (SELECT o.content FROM objectcustomfieldvalues o WHERE ((o.objectid = t.id) AND (o.customfield = 9)) LIMIT 1) AS carrier, (SELECT o.content FROM objectcustomfieldvalues o WHERE ((o.objectid = t.id) AND (o.customfield = 40)) LIMIT 1) AS status_led, (SELECT o.content FROM objectcustomfieldvalues o WHERE ((o.objectid = t.id) AND (o.customfield = 41)) LIMIT 1) AS cell_on_led, (SELECT o.content FROM objectcustomfieldvalues o WHERE ((o.objectid = t.id) AND (o.customfield = 42)) LIMIT 1) AS signal_leds, (SELECT o.content FROM objectcustomfieldvalues o WHERE ((o.objectid = t.id) AND (o.customfield = 43)) LIMIT 1) AS atm_pos_terminal_led, (SELECT o.content FROM objectcustomfieldvalues o WHERE ((o.objectid = t.id) AND (o.customfield = 44)) LIMIT 1) AS ethernet_led FROM ((queues q JOIN tickets t ON ((q.id = t.queue))) JOIN users u ON ((u.id = t.creator))) WHERE (((((1 = 1) AND (btrim((q.name)::text) = 'RMA Customer'::text)) AND (q.disabled = 0)) AND (t.disabled = 0)) AND ((t.created)::date >= (('now'::text)::date - '6 mons'::interval))) ORDER BY t.id DESC;


ALTER TABLE rt3.rt_rma_queue_last6mo_vw OWNER TO rt_user;

--
-- Name: scripactions; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE scripactions (
    id integer DEFAULT nextval('scripactions_id_seq'::text) NOT NULL,
    name character varying(200),
    description character varying(255),
    execmodule character varying(60),
    argument character varying(255),
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone,
    lastupdatedby integer DEFAULT 0 NOT NULL,
    lastupdated timestamp without time zone
);


ALTER TABLE rt3.scripactions OWNER TO rt_user;

--
-- Name: scripactions_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE scripactions_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.scripactions_id_seq OWNER TO rt_user;

--
-- Name: scripconditions; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE scripconditions (
    id integer DEFAULT nextval('scripconditions_id_seq'::text) NOT NULL,
    name character varying(200),
    description character varying(255),
    execmodule character varying(60),
    argument character varying(255),
    applicabletranstypes character varying(60),
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone,
    lastupdatedby integer DEFAULT 0 NOT NULL,
    lastupdated timestamp without time zone
);


ALTER TABLE rt3.scripconditions OWNER TO rt_user;

--
-- Name: scripconditions_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE scripconditions_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.scripconditions_id_seq OWNER TO rt_user;

--
-- Name: scrips; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE scrips (
    id integer DEFAULT nextval('scrips_id_seq'::text) NOT NULL,
    description character varying(255),
    scripcondition integer DEFAULT 0 NOT NULL,
    scripaction integer DEFAULT 0 NOT NULL,
    conditionrules text,
    actionrules text,
    customisapplicablecode text,
    custompreparecode text,
    customcommitcode text,
    stage character varying(32),
    queue integer DEFAULT 0 NOT NULL,
    template integer DEFAULT 0 NOT NULL,
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone,
    lastupdatedby integer DEFAULT 0 NOT NULL,
    lastupdated timestamp without time zone
);


ALTER TABLE rt3.scrips OWNER TO rt_user;

--
-- Name: scrips_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE scrips_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.scrips_id_seq OWNER TO rt_user;

--
-- Name: sessions; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE sessions (
    id character(32) NOT NULL,
    a_session bytea,
    lastupdated timestamp without time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL
);


ALTER TABLE rt3.sessions OWNER TO rt_user;

--
-- Name: templates; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE templates (
    id integer DEFAULT nextval('templates_id_seq'::text) NOT NULL,
    queue integer DEFAULT 0 NOT NULL,
    name character varying(200) NOT NULL,
    description character varying(255),
    type character varying(16),
    language character varying(16),
    translationof integer DEFAULT 0 NOT NULL,
    content text,
    lastupdated timestamp without time zone,
    lastupdatedby integer DEFAULT 0 NOT NULL,
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone
);


ALTER TABLE rt3.templates OWNER TO rt_user;

--
-- Name: templates_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE templates_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.templates_id_seq OWNER TO rt_user;

--
-- Name: tickets_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE tickets_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.tickets_id_seq OWNER TO rt_user;

--
-- Name: transactions; Type: TABLE; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE TABLE transactions (
    id integer DEFAULT nextval('transactions_id_seq'::text) NOT NULL,
    objecttype character varying(255) NOT NULL,
    objectid integer DEFAULT 0 NOT NULL,
    timetaken integer DEFAULT 0 NOT NULL,
    type character varying(20),
    field character varying(40),
    oldvalue character varying(255),
    newvalue character varying(255),
    referencetype character varying(255),
    oldreference integer,
    newreference integer,
    data character varying(255),
    creator integer DEFAULT 0 NOT NULL,
    created timestamp without time zone
);


ALTER TABLE rt3.transactions OWNER TO rt_user;

--
-- Name: transactions_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE transactions_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.transactions_id_seq OWNER TO rt_user;

--
-- Name: users_id_seq; Type: SEQUENCE; Schema: rt3; Owner: rt_user
--

CREATE SEQUENCE users_id_seq
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rt3.users_id_seq OWNER TO rt_user;

SET search_path = carrier, pg_catalog;

--
-- Name: app_config_pkey; Type: CONSTRAINT; Schema: carrier; Owner: carrier_owner; Tablespace: 
--

ALTER TABLE ONLY app_config
    ADD CONSTRAINT app_config_pkey PRIMARY KEY (app_config_id);


--
-- Name: app_config_uk1; Type: CONSTRAINT; Schema: carrier; Owner: carrier_owner; Tablespace: 
--

ALTER TABLE ONLY app_config
    ADD CONSTRAINT app_config_uk1 UNIQUE (application, environment, config_key);


--
-- Name: carrier_api_activity_log_pkey; Type: CONSTRAINT; Schema: carrier; Owner: carrier_owner; Tablespace: 
--

ALTER TABLE ONLY api_activity_log
    ADD CONSTRAINT carrier_api_activity_log_pkey PRIMARY KEY (api_activity_log);


--
-- Name: request_carrier_pkey; Type: CONSTRAINT; Schema: carrier; Owner: carrier_owner; Tablespace: 
--

ALTER TABLE ONLY request_carrier
    ADD CONSTRAINT request_carrier_pkey PRIMARY KEY (request_carrier_id);


--
-- Name: request_pkey; Type: CONSTRAINT; Schema: carrier; Owner: carrier_owner; Tablespace: 
--

ALTER TABLE ONLY request
    ADD CONSTRAINT request_pkey PRIMARY KEY (request_id);


--
-- Name: request_status_pkey; Type: CONSTRAINT; Schema: carrier; Owner: carrier_owner; Tablespace: 
--

ALTER TABLE ONLY request_status
    ADD CONSTRAINT request_status_pkey PRIMARY KEY (request_status_id);


--
-- Name: request_type_pkey; Type: CONSTRAINT; Schema: carrier; Owner: carrier_owner; Tablespace: 
--

ALTER TABLE ONLY request_type
    ADD CONSTRAINT request_type_pkey PRIMARY KEY (request_type_id);


SET search_path = csctoss, pg_catalog;

--
-- Name: address_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY address
    ADD CONSTRAINT address_pkey PRIMARY KEY (address_id);


--
-- Name: address_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY address_type
    ADD CONSTRAINT address_type_pkey PRIMARY KEY (address_type);


--
-- Name: agreement_table_pk; Type: CONSTRAINT; Schema: csctoss; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY agreement_table
    ADD CONSTRAINT agreement_table_pk PRIMARY KEY (id);


--
-- Name: alert_activity_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY alert_activity
    ADD CONSTRAINT alert_activity_pkey PRIMARY KEY (alert_activity_id);


--
-- Name: alert_definition_alert_type_id_username_uk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY alert_definition
    ADD CONSTRAINT alert_definition_alert_type_id_username_uk UNIQUE (alert_type_id, username);


--
-- Name: alert_definition_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY alert_definition
    ADD CONSTRAINT alert_definition_pkey PRIMARY KEY (alert_definition_id);


--
-- Name: alert_definition_snmp_ip_address_uk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY alert_definition_snmp
    ADD CONSTRAINT alert_definition_snmp_ip_address_uk UNIQUE (hostname_or_ip);


--
-- Name: alert_definition_snmp_pk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY alert_definition_snmp
    ADD CONSTRAINT alert_definition_snmp_pk PRIMARY KEY (alert_definition_id);


--
-- Name: alert_defintion_contact_pk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY alert_definition_contact
    ADD CONSTRAINT alert_defintion_contact_pk PRIMARY KEY (alert_definition_id, contact_id);


--
-- Name: alert_priority_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY alert_priority
    ADD CONSTRAINT alert_priority_pkey PRIMARY KEY (alert_priority_id);


--
-- Name: alert_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY alert_type
    ADD CONSTRAINT alert_type_pkey PRIMARY KEY (alert_type_id);


--
-- Name: alert_usage_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY alert_usage_type
    ADD CONSTRAINT alert_usage_type_pkey PRIMARY KEY (alert_type_id);


--
-- Name: alerts_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY alerts
    ADD CONSTRAINT alerts_pkey PRIMARY KEY (alert_id);


--
-- Name: api_device_login_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY api_device_login
    ADD CONSTRAINT api_device_login_pkey PRIMARY KEY (device_login_id);


--
-- Name: api_device_parser_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY api_device_parser
    ADD CONSTRAINT api_device_parser_pkey PRIMARY KEY (device_id, parser_id);


--
-- Name: api_key_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY api_key
    ADD CONSTRAINT api_key_pkey PRIMARY KEY (api_key_id);


--
-- Name: api_parser_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY api_parser
    ADD CONSTRAINT api_parser_pkey PRIMARY KEY (parser_id);


--
-- Name: api_request_log_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY api_request_log
    ADD CONSTRAINT api_request_log_pkey PRIMARY KEY (api_request_id);


--
-- Name: api_supported_device_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY api_supported_device
    ADD CONSTRAINT api_supported_device_pkey PRIMARY KEY (device_id);


--
-- Name: app_config_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY app_config
    ADD CONSTRAINT app_config_pkey PRIMARY KEY (app_config_id);


--
-- Name: app_config_uk1; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY app_config
    ADD CONSTRAINT app_config_uk1 UNIQUE (application, environment, config_key);


--
-- Name: atm_processor_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY atm_processor
    ADD CONSTRAINT atm_processor_pkey PRIMARY KEY (atm_processor);


--
-- Name: attribute_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY attribute
    ADD CONSTRAINT attribute_pkey PRIMARY KEY (attribute);


--
-- Name: attribute_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY attribute_type
    ADD CONSTRAINT attribute_type_pkey PRIMARY KEY (attribute_type);


--
-- Name: bent_llab_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY billing_entity_location_label
    ADD CONSTRAINT bent_llab_pkey PRIMARY KEY (billing_entity_address_id, location_label_type);


--
-- Name: bent_prod_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY billing_entity_product
    ADD CONSTRAINT bent_prod_pkey PRIMARY KEY (billing_entity_id, product_id);


--
-- Name: billing_entity_address_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY billing_entity_address
    ADD CONSTRAINT billing_entity_address_pkey PRIMARY KEY (billing_entity_id, address_type);


--
-- Name: billing_entity_address_uk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY billing_entity_address
    ADD CONSTRAINT billing_entity_address_uk UNIQUE (address_type, address_id);


--
-- Name: billing_entity_download_file_name_uk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY billing_entity_download
    ADD CONSTRAINT billing_entity_download_file_name_uk UNIQUE (file_name);


--
-- Name: billing_entity_download_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY billing_entity_download
    ADD CONSTRAINT billing_entity_download_pkey PRIMARY KEY (billing_entity_id, file_name);


--
-- Name: billing_entity_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY billing_entity
    ADD CONSTRAINT billing_entity_pkey PRIMARY KEY (billing_entity_id);


--
-- Name: billing_entity_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY billing_entity_type
    ADD CONSTRAINT billing_entity_type_pkey PRIMARY KEY (billing_entity_type);


--
-- Name: bp_aggregate_usage_plan_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_aggregate_usage_plan
    ADD CONSTRAINT bp_aggregate_usage_plan_pkey PRIMARY KEY (bp_aggregate_usage_plan_id);


--
-- Name: bp_aggregate_usage_plan_tier_unique; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_aggregate_usage_plan
    ADD CONSTRAINT bp_aggregate_usage_plan_tier_unique UNIQUE (bp_billing_charge_usage_id, tier_number);


--
-- Name: bp_allotment_adjustment_history_pk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_allotment_adjustment_history
    ADD CONSTRAINT bp_allotment_adjustment_history_pk PRIMARY KEY (bp_usage_allotment_id, change_date, previous_allotment);


--
-- Name: bp_billing_calendar_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_billing_calendar
    ADD CONSTRAINT bp_billing_calendar_pkey PRIMARY KEY (bp_billing_calendar_id);


--
-- Name: bp_billing_charge_discount_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_billing_charge_discount
    ADD CONSTRAINT bp_billing_charge_discount_pkey PRIMARY KEY (bp_billing_charge_discount_id);


--
-- Name: bp_billing_charge_onetime_bp_billing_charge_id_uk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_billing_charge_onetime
    ADD CONSTRAINT bp_billing_charge_onetime_bp_billing_charge_id_uk UNIQUE (bp_billing_charge_id);


--
-- Name: bp_billing_charge_onetime_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_billing_charge_onetime
    ADD CONSTRAINT bp_billing_charge_onetime_pkey PRIMARY KEY (bp_billing_charge_onetime_id);


--
-- Name: bp_billing_charge_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_billing_charge
    ADD CONSTRAINT bp_billing_charge_pkey PRIMARY KEY (bp_billing_charge_id);


--
-- Name: bp_billing_charge_static_bp_billing_charge_id_uk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_billing_charge_static
    ADD CONSTRAINT bp_billing_charge_static_bp_billing_charge_id_uk UNIQUE (bp_billing_charge_id);


--
-- Name: bp_billing_charge_static_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_billing_charge_static
    ADD CONSTRAINT bp_billing_charge_static_pkey PRIMARY KEY (bp_billing_charge_static_id);


--
-- Name: bp_billing_charge_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_billing_charge_type
    ADD CONSTRAINT bp_billing_charge_type_pkey PRIMARY KEY (bp_billing_charge_type);


--
-- Name: bp_billing_charge_unit_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_billing_charge_unit
    ADD CONSTRAINT bp_billing_charge_unit_pkey PRIMARY KEY (bp_billing_charge_unit);


--
-- Name: bp_billing_charge_usage_bp_billing_charge_id_uk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_billing_charge_usage
    ADD CONSTRAINT bp_billing_charge_usage_bp_billing_charge_id_uk UNIQUE (bp_billing_charge_id);


--
-- Name: bp_billing_charge_usage_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_billing_charge_usage
    ADD CONSTRAINT bp_billing_charge_usage_pkey PRIMARY KEY (bp_billing_charge_usage_id);


--
-- Name: bp_billing_discount_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_billing_discount_type
    ADD CONSTRAINT bp_billing_discount_type_pkey PRIMARY KEY (bp_billing_discount_type);


--
-- Name: bp_billing_entity_preferences_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_billing_entity_preferences
    ADD CONSTRAINT bp_billing_entity_preferences_pkey PRIMARY KEY (billing_entity_id);


--
-- Name: bp_billing_equipment_assignment_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_billing_equipment_assignment
    ADD CONSTRAINT bp_billing_equipment_assignment_pkey PRIMARY KEY (bp_billing_equipment_assignment_id);


--
-- Name: bp_billing_period_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_billing_period
    ADD CONSTRAINT bp_billing_period_pkey PRIMARY KEY (bp_billing_period_id);


--
-- Name: bp_charge_frequency_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_charge_frequency
    ADD CONSTRAINT bp_charge_frequency_pkey PRIMARY KEY (bp_charge_frequency);


--
-- Name: bp_master_billing_plan_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_master_billing_plan
    ADD CONSTRAINT bp_master_billing_plan_pkey PRIMARY KEY (bp_master_billing_plan_id);


--
-- Name: bp_past_due_charge_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_past_due_charge
    ADD CONSTRAINT bp_past_due_charge_pkey PRIMARY KEY (bp_past_due_charge_id);


--
-- Name: bp_period_billing_summary_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_period_billing_summary
    ADD CONSTRAINT bp_period_billing_summary_pkey PRIMARY KEY (bp_period_billing_summary_id);


--
-- Name: bp_period_change_summary_pk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_period_change_summary
    ADD CONSTRAINT bp_period_change_summary_pk PRIMARY KEY (bp_period_billing_summary_id, bp_billing_period_id);


--
-- Name: bp_period_charge_summary_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_period_charge_summary
    ADD CONSTRAINT bp_period_charge_summary_pkey PRIMARY KEY (bp_period_charge_summary_id);


--
-- Name: bp_period_status_summary_pk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_period_status_summary
    ADD CONSTRAINT bp_period_status_summary_pk PRIMARY KEY (bp_period_billing_summary_id, bp_billing_period_id);


--
-- Name: bp_period_usage_summary_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_period_usage_summary
    ADD CONSTRAINT bp_period_usage_summary_pkey PRIMARY KEY (bp_period_usage_summary_id);


--
-- Name: bp_usage_allotment_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY bp_usage_allotment
    ADD CONSTRAINT bp_usage_allotment_pkey PRIMARY KEY (bp_usage_allotment_id);


--
-- Name: branding_button_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY branding_button
    ADD CONSTRAINT branding_button_pkey PRIMARY KEY (billing_entity_id, button_number);


--
-- Name: branding_content_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY branding_content
    ADD CONSTRAINT branding_content_pkey PRIMARY KEY (parent_billing_entity_id);


--
-- Name: branding_presentation_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY branding_presentation
    ADD CONSTRAINT branding_presentation_pkey PRIMARY KEY (parent_billing_entity_id);


--
-- Name: broadcast_message_data_pk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY broadcast_message_data
    ADD CONSTRAINT broadcast_message_data_pk PRIMARY KEY (broadcast_id);


--
-- Name: broadcast_message_data_uk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY broadcast_message_data
    ADD CONSTRAINT broadcast_message_data_uk UNIQUE (broadcast_message_group_id);


--
-- Name: broadcast_message_group_pk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY broadcast_message_group
    ADD CONSTRAINT broadcast_message_group_pk PRIMARY KEY (broadcast_message_group_id, broadcast_message_billing_entity_id);


--
-- Name: broadcast_message_level_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY broadcast_message_level
    ADD CONSTRAINT broadcast_message_level_pkey PRIMARY KEY (broadcast_message_level_id);


--
-- Name: broadcast_message_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY broadcast_message
    ADD CONSTRAINT broadcast_message_pkey PRIMARY KEY (broadcast_message_id);


--
-- Name: broadcast_message_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY broadcast_message_type
    ADD CONSTRAINT broadcast_message_type_pkey PRIMARY KEY (broadcast_message_type_id);


--
-- Name: carrier_api_activity_log_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY carrier_api_activity_log
    ADD CONSTRAINT carrier_api_activity_log_pkey PRIMARY KEY (api_activity_log);


--
-- Name: carrier_domain_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY carrier_domain
    ADD CONSTRAINT carrier_domain_pkey PRIMARY KEY (carrier, domain);


--
-- Name: carrier_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY carrier
    ADD CONSTRAINT carrier_pkey PRIMARY KEY (carrier);


--
-- Name: cc_auth_log_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY cc_auth_log
    ADD CONSTRAINT cc_auth_log_pkey PRIMARY KEY (cc_auth_log_id);


--
-- Name: cc_encrypt_key_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY cc_encrypt_key
    ADD CONSTRAINT cc_encrypt_key_pkey PRIMARY KEY (cc_encrypt_key_id);


--
-- Name: change_log_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY change_log
    ADD CONSTRAINT change_log_pkey PRIMARY KEY (change_log_id);


--
-- Name: config_equipment_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY config_equipment
    ADD CONSTRAINT config_equipment_pkey PRIMARY KEY (id);


--
-- Name: config_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_pkey PRIMARY KEY (id);


--
-- Name: contact_address_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY contact_address
    ADD CONSTRAINT contact_address_pkey PRIMARY KEY (contact_id, address_type);


--
-- Name: contact_level_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY contact_level
    ADD CONSTRAINT contact_level_pkey PRIMARY KEY (contact_level);


--
-- Name: contact_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY contact
    ADD CONSTRAINT contact_pkey PRIMARY KEY (contact_id);


--
-- Name: contact_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY contact_type
    ADD CONSTRAINT contact_type_pkey PRIMARY KEY (contact_type);


--
-- Name: contact_uk1; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY contact
    ADD CONSTRAINT contact_uk1 UNIQUE (billing_entity_id, contact_type, contact_level);


--
-- Name: currency_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY currency
    ADD CONSTRAINT currency_pkey PRIMARY KEY (currency_id);


--
-- Name: device_monitor_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY device_monitor
    ADD CONSTRAINT device_monitor_pkey PRIMARY KEY (serial_number);


--
-- Name: download_file_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY download_file_type
    ADD CONSTRAINT download_file_type_pkey PRIMARY KEY (file_type);


--
-- Name: equipment_credential_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment_credential
    ADD CONSTRAINT equipment_credential_pkey PRIMARY KEY (equipment_credential_id);


--
-- Name: equipment_credential_uk1; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment_credential
    ADD CONSTRAINT equipment_credential_uk1 UNIQUE (equipment_id, credential_set);


--
-- Name: equipment_firmware_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment_firmware
    ADD CONSTRAINT equipment_firmware_pkey PRIMARY KEY (equipment_firmware_id);


--
-- Name: equipment_info_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment_info
    ADD CONSTRAINT equipment_info_pkey PRIMARY KEY (equipment_id, equipment_info_type);


--
-- Name: equipment_info_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment_info_type
    ADD CONSTRAINT equipment_info_type_pkey PRIMARY KEY (equipment_info_type);


--
-- Name: equipment_model_credential_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment_model_credential
    ADD CONSTRAINT equipment_model_credential_pkey PRIMARY KEY (equipment_model_id, credential_set);


--
-- Name: equipment_model_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment_model
    ADD CONSTRAINT equipment_model_pkey PRIMARY KEY (equipment_model_id);


--
-- Name: equipment_model_status_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment_model_status
    ADD CONSTRAINT equipment_model_status_pkey PRIMARY KEY (equipment_model_id);


--
-- Name: equipment_note_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment_note
    ADD CONSTRAINT equipment_note_pkey PRIMARY KEY (equipment_id, note_number);


--
-- Name: equipment_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment
    ADD CONSTRAINT equipment_pkey PRIMARY KEY (equipment_id);


--
-- Name: equipment_software_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment_software
    ADD CONSTRAINT equipment_software_pkey PRIMARY KEY (equipment_id, software_id);


--
-- Name: equipment_status_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment_status
    ADD CONSTRAINT equipment_status_pkey PRIMARY KEY (equipment_id);


--
-- Name: equipment_status_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment_status_type
    ADD CONSTRAINT equipment_status_type_pkey PRIMARY KEY (equipment_status_type);


--
-- Name: equipment_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment_type
    ADD CONSTRAINT equipment_type_pkey PRIMARY KEY (equipment_type);


--
-- Name: equipment_warranty_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment_warranty
    ADD CONSTRAINT equipment_warranty_pkey PRIMARY KEY (equipment_id);


--
-- Name: equipment_warranty_rule_pk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY equipment_warranty_rule
    ADD CONSTRAINT equipment_warranty_rule_pk PRIMARY KEY (equipment_model_id);


--
-- Name: firmware_equipment_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY firmware_equipment
    ADD CONSTRAINT firmware_equipment_pkey PRIMARY KEY (id);


--
-- Name: firmware_gmu_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: slony; Tablespace: 
--

ALTER TABLE ONLY firmware_gmu
    ADD CONSTRAINT firmware_gmu_pkey PRIMARY KEY (firmware_gmu_id);


--
-- Name: firmware_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY firmware
    ADD CONSTRAINT firmware_pkey PRIMARY KEY (id);


--
-- Name: firmware_soup_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: slony; Tablespace: 
--

ALTER TABLE ONLY firmware_soup
    ADD CONSTRAINT firmware_soup_pkey PRIMARY KEY (did);


--
-- Name: groupname_default_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY groupname_default
    ADD CONSTRAINT groupname_default_pkey PRIMARY KEY (groupname_default_key_id);


--
-- Name: groupname_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY groupname
    ADD CONSTRAINT groupname_pkey PRIMARY KEY (groupname);


--
-- Name: last_change_log_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY last_change_log
    ADD CONSTRAINT last_change_log_pkey PRIMARY KEY (last_change_log_pk);


--
-- Name: line_alert_email_line_id_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY line_alert_email
    ADD CONSTRAINT line_alert_email_line_id_pkey PRIMARY KEY (line_id, email_address);


--
-- Name: line_alert_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY line_alert
    ADD CONSTRAINT line_alert_pkey PRIMARY KEY (line_id);


--
-- Name: line_assignment_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY line_assignment_type
    ADD CONSTRAINT line_assignment_type_pkey PRIMARY KEY (line_assignment_type);


--
-- Name: line_equipment_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY line_equipment
    ADD CONSTRAINT line_equipment_pkey PRIMARY KEY (line_id, equipment_id);


--
-- Name: line_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY line
    ADD CONSTRAINT line_pkey PRIMARY KEY (line_id);


--
-- Name: line_terminal_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY line_terminal
    ADD CONSTRAINT line_terminal_pkey PRIMARY KEY (line_id);


--
-- Name: line_usage_be_carrier_pk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY otaps_monthly_usage_summary
    ADD CONSTRAINT line_usage_be_carrier_pk PRIMARY KEY (usage_monthly_summary_id);


--
-- Name: line_usage_day_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY line_usage_day
    ADD CONSTRAINT line_usage_day_pkey PRIMARY KEY (line_id, usage_date);


--
-- Name: line_usage_day_pkey1; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY line_usage_day_history
    ADD CONSTRAINT line_usage_day_pkey1 PRIMARY KEY (line_id, usage_date);


--
-- Name: line_usage_month_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY line_usage_month
    ADD CONSTRAINT line_usage_month_pkey PRIMARY KEY (line_id, year, month);


--
-- Name: line_usage_overage_calc_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY line_usage_overage_calc
    ADD CONSTRAINT line_usage_overage_calc_pkey PRIMARY KEY (line_id, usage_calc_start_timestamp);


--
-- Name: lns_lookup_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY lns_lookup
    ADD CONSTRAINT lns_lookup_pkey PRIMARY KEY (nasidentifier);


--
-- Name: location_label_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY location_label_type
    ADD CONSTRAINT location_label_type_pkey PRIMARY KEY (location_label_type);


--
-- Name: location_labels_pk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY location_labels
    ADD CONSTRAINT location_labels_pk PRIMARY KEY (line_id);


--
-- Name: login_tracking_pk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY login_tracking
    ADD CONSTRAINT login_tracking_pk PRIMARY KEY (username, billing_entity_id, login_timestamp);


--
-- Name: master_radacct_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY master_radacct
    ADD CONSTRAINT master_radacct_pkey PRIMARY KEY (master_radacctid);


--
-- Name: master_radpostauth_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY master_radpostauth
    ADD CONSTRAINT master_radpostauth_pkey PRIMARY KEY (master_radpostauth_id);


--
-- Name: message_priority_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY message_priority
    ADD CONSTRAINT message_priority_pkey PRIMARY KEY (message_priority_id);


--
-- Name: mrad_duplicate_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY mrad_duplicate
    ADD CONSTRAINT mrad_duplicate_pkey PRIMARY KEY (master_radacctid);


--
-- Name: nas_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY nas
    ADD CONSTRAINT nas_pkey PRIMARY KEY (id);


--
-- Name: op_id_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY radius_operator
    ADD CONSTRAINT op_id_pkey PRIMARY KEY (op_id);


--
-- Name: op_unique; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY radius_operator
    ADD CONSTRAINT op_unique UNIQUE (op);


--
-- Name: oss_jbill_billing_entity_mapping_jbilling_customer_id_key; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY oss_jbill_billing_entity_mapping
    ADD CONSTRAINT oss_jbill_billing_entity_mapping_jbilling_customer_id_key UNIQUE (jbilling_customer_id);


--
-- Name: oss_jbill_billing_entity_mapping_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY oss_jbill_billing_entity_mapping
    ADD CONSTRAINT oss_jbill_billing_entity_mapping_pkey PRIMARY KEY (oss_billing_entity_id);


--
-- Name: otaps_product_code_translation_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY otaps_product_code_translation
    ADD CONSTRAINT otaps_product_code_translation_pkey PRIMARY KEY (old_product_code, carrier);


--
-- Name: otaps_service_line_number_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY otaps_service_line_number
    ADD CONSTRAINT otaps_service_line_number_pkey PRIMARY KEY (line_id);


--
-- Name: parser_log_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY parser_log
    ADD CONSTRAINT parser_log_pkey PRIMARY KEY (parser_log_id);


--
-- Name: plan_log_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY plan_log
    ADD CONSTRAINT plan_log_pkey PRIMARY KEY (plan_log_id);


--
-- Name: plan_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY plan
    ADD CONSTRAINT plan_pkey PRIMARY KEY (plan_id);


--
-- Name: plan_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY plan_type
    ADD CONSTRAINT plan_type_pkey PRIMARY KEY (plan_type_id);


--
-- Name: portal_properties_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY portal_properties
    ADD CONSTRAINT portal_properties_pkey PRIMARY KEY (property_name);


--
-- Name: product_overage_threshold_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY product_overage_threshold
    ADD CONSTRAINT product_overage_threshold_pkey PRIMARY KEY (product_id);


--
-- Name: product_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY product
    ADD CONSTRAINT product_pkey PRIMARY KEY (product_id);


--
-- Name: product_product_code_key; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY product
    ADD CONSTRAINT product_product_code_key UNIQUE (product_code);


--
-- Name: purchase_log_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY purchase_log
    ADD CONSTRAINT purchase_log_pkey PRIMARY KEY (purchase_log_id);


--
-- Name: radcheck_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY radcheck
    ADD CONSTRAINT radcheck_pkey PRIMARY KEY (id);


--
-- Name: radcheck_uk1; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY radcheck
    ADD CONSTRAINT radcheck_uk1 UNIQUE (username, attribute, op, value);


--
-- Name: radgroupcheck_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY radgroupcheck
    ADD CONSTRAINT radgroupcheck_pkey PRIMARY KEY (id);


--
-- Name: radgroupcheck_uk1; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY radgroupcheck
    ADD CONSTRAINT radgroupcheck_uk1 UNIQUE (groupname, attribute, op, value);


--
-- Name: radgroupreply_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY radgroupreply
    ADD CONSTRAINT radgroupreply_pkey PRIMARY KEY (id);


--
-- Name: radgroupreply_uk1; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY radgroupreply
    ADD CONSTRAINT radgroupreply_uk1 UNIQUE (groupname, attribute, op, value);


--
-- Name: radreply_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY radreply
    ADD CONSTRAINT radreply_pkey PRIMARY KEY (id);


--
-- Name: radreply_uk1; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY radreply
    ADD CONSTRAINT radreply_uk1 UNIQUE (username, attribute, op, value);


--
-- Name: receiving_lot_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY receiving_lot
    ADD CONSTRAINT receiving_lot_pkey PRIMARY KEY (receiving_lot_id);


--
-- Name: replication_failure_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY replication_failure
    ADD CONSTRAINT replication_failure_pkey PRIMARY KEY (replication_failure_id);


--
-- Name: report_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY report
    ADD CONSTRAINT report_pkey PRIMARY KEY (report_id);


--
-- Name: rma_form_pk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY rma_form
    ADD CONSTRAINT rma_form_pk PRIMARY KEY (id);


--
-- Name: role_level_type_unq; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY security_roles
    ADD CONSTRAINT role_level_type_unq UNIQUE (role_level, role_type);


--
-- Name: sales_order_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY sales_order
    ADD CONSTRAINT sales_order_pkey PRIMARY KEY (sales_order_number);


--
-- Name: security_roles_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY security_roles
    ADD CONSTRAINT security_roles_pkey PRIMARY KEY (security_role);


--
-- Name: shipment_equipment_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY shipment_equipment
    ADD CONSTRAINT shipment_equipment_pkey PRIMARY KEY (shipment_id, equipment_id);


--
-- Name: shipment_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY shipment
    ADD CONSTRAINT shipment_pkey PRIMARY KEY (shipment_id);


--
-- Name: software_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY software
    ADD CONSTRAINT software_pkey PRIMARY KEY (software_id);


--
-- Name: soup_config_info_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY soup_config_info
    ADD CONSTRAINT soup_config_info_pkey PRIMARY KEY (config_id);


--
-- Name: soup_config_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY soup_config
    ADD CONSTRAINT soup_config_pkey PRIMARY KEY (soup_config_id);


--
-- Name: soup_device_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: slony; Tablespace: 
--

ALTER TABLE ONLY soup_device
    ADD CONSTRAINT soup_device_pkey PRIMARY KEY (did);


--
-- Name: soup_dirnames_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY soup_dirnames
    ADD CONSTRAINT soup_dirnames_pkey PRIMARY KEY (soup_dirnames_id);


--
-- Name: sprint_assignment_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY sprint_assignment
    ADD CONSTRAINT sprint_assignment_pkey PRIMARY KEY (sprint_assignment_id);


--
-- Name: sprint_csa_name_key; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY sprint_csa
    ADD CONSTRAINT sprint_csa_name_key UNIQUE (name);


--
-- Name: sprint_csa_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY sprint_csa
    ADD CONSTRAINT sprint_csa_pkey PRIMARY KEY (id);


--
-- Name: sprint_master_radacct_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY sprint_master_radacct
    ADD CONSTRAINT sprint_master_radacct_pkey PRIMARY KEY (sprint_master_radacctid);


--
-- Name: sprint_msl_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY sprint_msl
    ADD CONSTRAINT sprint_msl_pkey PRIMARY KEY (mdn, esn);


--
-- Name: staff_access_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY staff_access
    ADD CONSTRAINT staff_access_pkey PRIMARY KEY (staff_id, level_name);


--
-- Name: staff_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY staff
    ADD CONSTRAINT staff_pkey PRIMARY KEY (staff_id);


--
-- Name: staff_staff_login_name_key; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY staff
    ADD CONSTRAINT staff_staff_login_name_key UNIQUE (staff_login_name);


--
-- Name: state_code_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY state_code
    ADD CONSTRAINT state_code_pkey PRIMARY KEY (state_code);


--
-- Name: static_ip_carrier_def_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY static_ip_carrier_def
    ADD CONSTRAINT static_ip_carrier_def_pkey PRIMARY KEY (carrier_def_id);


--
-- Name: static_ip_pool_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY static_ip_pool
    ADD CONSTRAINT static_ip_pool_pkey PRIMARY KEY (id);


--
-- Name: static_ip_pool_static_ip_uk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY static_ip_pool
    ADD CONSTRAINT static_ip_pool_static_ip_uk UNIQUE (id, static_ip, groupname);


--
-- Name: static_ip_pool_static_ip_ukey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY static_ip_pool
    ADD CONSTRAINT static_ip_pool_static_ip_ukey UNIQUE (static_ip);


--
-- Name: system_parameter_ip_address_uk; Type: CONSTRAINT; Schema: csctoss; Owner: slony; Tablespace: 
--

ALTER TABLE ONLY system_parameter
    ADD CONSTRAINT system_parameter_ip_address_uk UNIQUE (ip_address);


--
-- Name: system_parameter_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: slony; Tablespace: 
--

ALTER TABLE ONLY system_parameter
    ADD CONSTRAINT system_parameter_pkey PRIMARY KEY (hostname);


--
-- Name: throw_away_minutes_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY throw_away_minutes
    ADD CONSTRAINT throw_away_minutes_pkey PRIMARY KEY (throw_away_min_id);


--
-- Name: timezone_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY timezone
    ADD CONSTRAINT timezone_pkey PRIMARY KEY (timezone);


--
-- Name: unique_identifier_history_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY unique_identifier_history
    ADD CONSTRAINT unique_identifier_history_pkey PRIMARY KEY (unique_identifier_history_id);


--
-- Name: unique_identifier_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY unique_identifier
    ADD CONSTRAINT unique_identifier_pkey PRIMARY KEY (equipment_id, unique_identifier_type);


--
-- Name: unique_identifier_type_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY unique_identifier_type
    ADD CONSTRAINT unique_identifier_type_pkey PRIMARY KEY (unique_identifier_type);


--
-- Name: unique_identifier_type_value_uk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY unique_identifier
    ADD CONSTRAINT unique_identifier_type_value_uk UNIQUE (unique_identifier_type, value);


--
-- Name: usergroup_error_log_id_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY usergroup_error_log
    ADD CONSTRAINT usergroup_error_log_id_pkey PRIMARY KEY (usergroup_error_log_id);


--
-- Name: usergroup_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY usergroup
    ADD CONSTRAINT usergroup_pkey PRIMARY KEY (id);


--
-- Name: usergroup_username_priority_uk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY usergroup
    ADD CONSTRAINT usergroup_username_priority_uk UNIQUE (username, priority);


--
-- Name: userlevels_id_pk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY userlevels
    ADD CONSTRAINT userlevels_id_pk PRIMARY KEY (userlevelid);


--
-- Name: username_pkey; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY username
    ADD CONSTRAINT username_pkey PRIMARY KEY (username);


--
-- Name: webui_users_id_pk; Type: CONSTRAINT; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

ALTER TABLE ONLY webui_users
    ADD CONSTRAINT webui_users_id_pk PRIMARY KEY (id);


SET search_path = invoice, pg_catalog;

--
-- Name: app_config_config_key_key; Type: CONSTRAINT; Schema: invoice; Owner: invoice_owner; Tablespace: 
--

ALTER TABLE ONLY app_config
    ADD CONSTRAINT app_config_config_key_key UNIQUE (config_key);


--
-- Name: app_config_pkey; Type: CONSTRAINT; Schema: invoice; Owner: invoice_owner; Tablespace: 
--

ALTER TABLE ONLY app_config
    ADD CONSTRAINT app_config_pkey PRIMARY KEY (app_config_id);


--
-- Name: billing_entity_pkey; Type: CONSTRAINT; Schema: invoice; Owner: invoice_owner; Tablespace: 
--

ALTER TABLE ONLY billing_entity
    ADD CONSTRAINT billing_entity_pkey PRIMARY KEY (billing_entity_id);


--
-- Name: file_system_pkey; Type: CONSTRAINT; Schema: invoice; Owner: invoice_owner; Tablespace: 
--

ALTER TABLE ONLY file_system
    ADD CONSTRAINT file_system_pkey PRIMARY KEY (document_id);


SET search_path = oss_sync, pg_catalog;

--
-- Name: be_vrf_pk; Type: CONSTRAINT; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

ALTER TABLE ONLY be_vrf
    ADD CONSTRAINT be_vrf_pk PRIMARY KEY (be_id);


--
-- Name: line_guid_pk; Type: CONSTRAINT; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

ALTER TABLE ONLY line_guid
    ADD CONSTRAINT line_guid_pk PRIMARY KEY (line_id);


--
-- Name: processor_pk; Type: CONSTRAINT; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

ALTER TABLE ONLY processor
    ADD CONSTRAINT processor_pk PRIMARY KEY (name);


--
-- Name: snesn_pk; Type: CONSTRAINT; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

ALTER TABLE ONLY snesn
    ADD CONSTRAINT snesn_pk PRIMARY KEY (sn, esn_hex);


--
-- Name: snmac_pk; Type: CONSTRAINT; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

ALTER TABLE ONLY systech
    ADD CONSTRAINT snmac_pk PRIMARY KEY (equipment_id);


--
-- Name: static_ip_pk; Type: CONSTRAINT; Schema: oss_sync; Owner: alert_writer; Tablespace: 
--

ALTER TABLE ONLY static_ip
    ADD CONSTRAINT static_ip_pk PRIMARY KEY (ip, billing_entity_id);


SET search_path = rt3, pg_catalog;

--
-- Name: acl_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY acl
    ADD CONSTRAINT acl_pkey PRIMARY KEY (id);


--
-- Name: attachments_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY attachments
    ADD CONSTRAINT attachments_pkey PRIMARY KEY (id);


--
-- Name: attributes_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY attributes
    ADD CONSTRAINT attributes_pkey PRIMARY KEY (id);


--
-- Name: cachedgroupmembers_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY cachedgroupmembers
    ADD CONSTRAINT cachedgroupmembers_pkey PRIMARY KEY (id);


--
-- Name: customfields_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY customfields
    ADD CONSTRAINT customfields_pkey PRIMARY KEY (id);


--
-- Name: customfieldvalues_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY customfieldvalues
    ADD CONSTRAINT customfieldvalues_pkey PRIMARY KEY (id);


--
-- Name: groupmembers_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY groupmembers
    ADD CONSTRAINT groupmembers_pkey PRIMARY KEY (id);


--
-- Name: groups_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY groups
    ADD CONSTRAINT groups_pkey PRIMARY KEY (id);


--
-- Name: links_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY links
    ADD CONSTRAINT links_pkey PRIMARY KEY (id);


--
-- Name: objectcustomfields_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY objectcustomfields
    ADD CONSTRAINT objectcustomfields_pkey PRIMARY KEY (id);


--
-- Name: objectcustomfieldvalues_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY objectcustomfieldvalues
    ADD CONSTRAINT objectcustomfieldvalues_pkey PRIMARY KEY (id);


--
-- Name: principals_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY principals
    ADD CONSTRAINT principals_pkey PRIMARY KEY (id);


--
-- Name: queues_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY queues
    ADD CONSTRAINT queues_pkey PRIMARY KEY (id);


--
-- Name: scripactions_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY scripactions
    ADD CONSTRAINT scripactions_pkey PRIMARY KEY (id);


--
-- Name: scripconditions_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY scripconditions
    ADD CONSTRAINT scripconditions_pkey PRIMARY KEY (id);


--
-- Name: scrips_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY scrips
    ADD CONSTRAINT scrips_pkey PRIMARY KEY (id);


--
-- Name: sessions_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY sessions
    ADD CONSTRAINT sessions_pkey PRIMARY KEY (id);


--
-- Name: templates_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY templates
    ADD CONSTRAINT templates_pkey PRIMARY KEY (id);


--
-- Name: tickets_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY tickets
    ADD CONSTRAINT tickets_pkey PRIMARY KEY (id);


--
-- Name: transactions_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY transactions
    ADD CONSTRAINT transactions_pkey PRIMARY KEY (id);


--
-- Name: users_pkey; Type: CONSTRAINT; Schema: rt3; Owner: rt_user; Tablespace: 
--

ALTER TABLE ONLY users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


SET search_path = csctoss, pg_catalog;

--
-- Name: billing_entity_name_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX billing_entity_name_idx ON billing_entity USING btree (name);


--
-- Name: billing_entity_name_uk; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE UNIQUE INDEX billing_entity_name_uk ON billing_entity USING btree (name) WHERE (billing_entity_type <> 'CONSUMER'::text);


--
-- Name: line_billing_entity_id_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX line_billing_entity_id_idx ON line USING btree (billing_entity_id);


--
-- Name: line_current_plan_id_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX line_current_plan_id_idx ON line USING btree (current_plan_id);


--
-- Name: line_line_id_varchar_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX line_line_id_varchar_idx ON line USING btree (((line_id)::character varying));


--
-- Name: line_usage_day_history_line_id_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX line_usage_day_history_line_id_idx ON line_usage_day_history USING btree (line_id);


--
-- Name: line_usage_day_history_usage_date_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX line_usage_day_history_usage_date_idx ON line_usage_day_history USING btree (usage_date);


--
-- Name: line_usage_day_line_id_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX line_usage_day_line_id_idx ON line_usage_day USING btree (line_id);


--
-- Name: line_usage_day_usage_date_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX line_usage_day_usage_date_idx ON line_usage_day USING btree (usage_date);


--
-- Name: line_usage_month_line_id_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX line_usage_month_line_id_idx ON line_usage_month USING btree (line_id);


--
-- Name: line_usage_month_year_month_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX line_usage_month_year_month_idx ON line_usage_month USING btree ("year", "month");


--
-- Name: line_usage_overage_calc_line_id_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX line_usage_overage_calc_line_id_idx ON line_usage_overage_calc USING btree (line_id);


--
-- Name: line_usage_overage_calc_usage_calc_end_timestamp_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX line_usage_overage_calc_usage_calc_end_timestamp_idx ON line_usage_overage_calc USING btree (usage_calc_end_timestamp);


--
-- Name: line_usage_overage_calc_usage_calc_start_timestamp_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX line_usage_overage_calc_usage_calc_start_timestamp_idx ON line_usage_overage_calc USING btree (usage_calc_start_timestamp);


--
-- Name: master_radpostauth_username_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX master_radpostauth_username_idx ON master_radpostauth USING btree (username);


--
-- Name: mrad_acct_stop_date_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX mrad_acct_stop_date_idx ON master_radacct USING btree (date_trunc('day'::text, timezone('UTC'::text, acctstoptime))) WHERE (acctstoptime IS NOT NULL);


--
-- Name: mrad_acctuniqueid_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX mrad_acctuniqueid_idx ON master_radacct USING btree (acctuniqueid);


--
-- Name: mrad_class_acctstoptime_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX mrad_class_acctstoptime_idx ON master_radacct USING btree ("class", acctstoptime);


--
-- Name: mrad_source_hostname_radacctid_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX mrad_source_hostname_radacctid_idx ON master_radacct USING btree (source_hostname, radacctid);


--
-- Name: mrad_username_acctstarttime_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX mrad_username_acctstarttime_idx ON master_radacct USING btree (username, acctstarttime);


--
-- Name: mrad_username_acctstoptime_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX mrad_username_acctstoptime_idx ON master_radacct USING btree (username, acctstoptime);


--
-- Name: nas_nasname; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX nas_nasname ON nas USING btree (nasname);


--
-- Name: nas_nasname_shortname_uk; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE UNIQUE INDEX nas_nasname_shortname_uk ON nas USING btree (nasname, shortname);


--
-- Name: otaps_service_line_number_customer_id_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX otaps_service_line_number_customer_id_idx ON otaps_service_line_number USING btree (customer_id);


--
-- Name: otaps_service_line_number_line_id_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX otaps_service_line_number_line_id_idx ON otaps_service_line_number USING btree (line_id);


--
-- Name: plan_plan_type_id_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX plan_plan_type_id_idx ON plan USING btree (plan_type_id);


--
-- Name: radcheck_username; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX radcheck_username ON radcheck USING btree (username, attribute);


--
-- Name: radgroupcheck_groupname; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX radgroupcheck_groupname ON radgroupcheck USING btree (groupname, attribute);


--
-- Name: radgroupreply_groupname; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX radgroupreply_groupname ON radgroupreply USING btree (groupname, attribute);


--
-- Name: radreply_username; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX radreply_username ON radreply USING btree (username, attribute);


--
-- Name: smrac_acctstarttime_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX smrac_acctstarttime_idx ON sprint_master_radacct USING btree (acctstarttime);


--
-- Name: smrac_acctstoptime_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX smrac_acctstoptime_idx ON sprint_master_radacct USING btree (acctstoptime);


--
-- Name: smrac_username_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX smrac_username_idx ON sprint_master_radacct USING btree (username);


--
-- Name: soup_cellsignal_esn1_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX soup_cellsignal_esn1_idx ON soup_cellsignal USING btree (esn1);


--
-- Name: soup_cellsignal_esn2_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX soup_cellsignal_esn2_idx ON soup_cellsignal USING btree (esn2);


--
-- Name: soup_cellsignal_esn_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX soup_cellsignal_esn_idx ON soup_cellsignal USING btree (esn);


--
-- Name: soup_cellsignal_timestamp_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX soup_cellsignal_timestamp_idx ON soup_cellsignal USING btree ("timestamp");


--
-- Name: soup_config_info_equipment_id_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX soup_config_info_equipment_id_idx ON soup_config_info USING btree (equipment_id);


--
-- Name: soup_device_stats_table_serial_number_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX soup_device_stats_table_serial_number_idx ON soup_device_stats_table USING btree (serial_number);


--
-- Name: soup_device_table_eui_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX soup_device_table_eui_idx ON soup_device_table USING btree (eui);


--
-- Name: soup_device_table_serial_number_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX soup_device_table_serial_number_idx ON soup_device_table USING btree (serial_number);


--
-- Name: unique_identifier_value_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX unique_identifier_value_idx ON unique_identifier USING btree (value);


--
-- Name: usage_calc_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX usage_calc_idx ON usage_calc USING btree ("class", acctstoptime);


--
-- Name: usage_overage_calc_idx; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX usage_overage_calc_idx ON usage_overage_calc USING btree ("class", acctstoptime);


--
-- Name: usergroup_username; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE INDEX usergroup_username ON usergroup USING btree (username);


--
-- Name: usergroup_username_groupname_priority_uk; Type: INDEX; Schema: csctoss; Owner: csctoss_owner; Tablespace: 
--

CREATE UNIQUE INDEX usergroup_username_groupname_priority_uk ON usergroup USING btree (username, groupname, priority);


SET search_path = rt3, pg_catalog;

--
-- Name: acl1; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX acl1 ON acl USING btree (rightname, objecttype, objectid, principaltype, principalid);


--
-- Name: attachments1; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX attachments1 ON attachments USING btree (parent);


--
-- Name: attachments2; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX attachments2 ON attachments USING btree (transactionid);


--
-- Name: attachments3; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX attachments3 ON attachments USING btree (parent, transactionid);


--
-- Name: attributes1; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX attributes1 ON attributes USING btree (name);


--
-- Name: attributes2; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX attributes2 ON attributes USING btree (objecttype, objectid);


--
-- Name: cachedgroupmembers2; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX cachedgroupmembers2 ON cachedgroupmembers USING btree (memberid);


--
-- Name: cachedgroupmembers3; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX cachedgroupmembers3 ON cachedgroupmembers USING btree (groupid);


--
-- Name: customfieldvalues1; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX customfieldvalues1 ON customfieldvalues USING btree (customfield);


--
-- Name: disgroumem; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX disgroumem ON cachedgroupmembers USING btree (groupid, memberid, disabled);


--
-- Name: groups1; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE UNIQUE INDEX groups1 ON groups USING btree ("domain", instance, "type", id, name);


--
-- Name: groups2; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX groups2 ON groups USING btree ("type", instance, "domain");


--
-- Name: links1; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE UNIQUE INDEX links1 ON links USING btree (base, target, "type");


--
-- Name: links4; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX links4 ON links USING btree ("type", localbase);


--
-- Name: objectcustomfieldvalues1; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX objectcustomfieldvalues1 ON objectcustomfieldvalues USING btree (customfield, objecttype, objectid, content);


--
-- Name: objectcustomfieldvalues2; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX objectcustomfieldvalues2 ON objectcustomfieldvalues USING btree (customfield, objecttype, objectid);


--
-- Name: principals2; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX principals2 ON principals USING btree (objectid);


--
-- Name: queues1; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE UNIQUE INDEX queues1 ON queues USING btree (name);


--
-- Name: tickets1; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX tickets1 ON tickets USING btree (queue, status);


--
-- Name: tickets2; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX tickets2 ON tickets USING btree ("owner");


--
-- Name: tickets3; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX tickets3 ON tickets USING btree (effectiveid);


--
-- Name: tickets4; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX tickets4 ON tickets USING btree (id, status);


--
-- Name: tickets5; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX tickets5 ON tickets USING btree (id, effectiveid);


--
-- Name: transactions1; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX transactions1 ON transactions USING btree (objecttype, objectid);


--
-- Name: users1; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE UNIQUE INDEX users1 ON users USING btree (name);


--
-- Name: users2; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX users2 ON users USING btree (name);


--
-- Name: users3; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX users3 ON users USING btree (id, emailaddress);


--
-- Name: users4; Type: INDEX; Schema: rt3; Owner: rt_user; Tablespace: 
--

CREATE INDEX users4 ON users USING btree (emailaddress);


SET search_path = csctoss, pg_catalog;

--
-- Name: address_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER address_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON address
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: address_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER address_type_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON address_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: alert_definition_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER alert_definition_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON alert_definition
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: alert_definition_contact_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER alert_definition_contact_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON alert_definition_contact
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: alert_definition_snmp_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER alert_definition_snmp_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON alert_definition_snmp
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: alert_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER alert_type_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON alert_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: api_device_login_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER api_device_login_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON api_device_login
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: api_device_parser_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER api_device_parser_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON api_device_parser
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: api_key_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER api_key_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON api_key
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: api_parser_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER api_parser_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON api_parser
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: api_supported_device_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER api_supported_device_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON api_supported_device
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: app_config_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER app_config_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON app_config
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: atm_processor_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER atm_processor_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON atm_processor
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: attribute_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER attribute_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON attribute
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: attribute_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER attribute_type_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON attribute_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: billing_entity_address_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER billing_entity_address_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON billing_entity_address
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: billing_entity_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER billing_entity_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON billing_entity
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: billing_entity_download_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER billing_entity_download_changelog
    BEFORE INSERT OR UPDATE ON billing_entity_download
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: billing_entity_location_label_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER billing_entity_location_label_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON billing_entity_location_label
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: billing_entity_product_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER billing_entity_product_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON billing_entity_product
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: billing_entity_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER billing_entity_type_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON billing_entity_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_aggregate_usage_plan_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_aggregate_usage_plan_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_aggregate_usage_plan
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_allotment_adjustment_history_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_allotment_adjustment_history_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_allotment_adjustment_history
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_billing_calendar_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_calendar_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_billing_calendar
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_billing_charge_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_charge_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_billing_charge
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_billing_charge_discount_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_charge_discount_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_billing_charge_discount
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_billing_charge_onetime_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_charge_onetime_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_billing_charge_onetime
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_billing_charge_pre_update_delete_trig; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_charge_pre_update_delete_trig
    BEFORE DELETE OR UPDATE ON bp_billing_charge
    FOR EACH ROW
    EXECUTE PROCEDURE bp_billing_charge_pre_update_delete();


--
-- Name: bp_billing_charge_static_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_charge_static_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_billing_charge_static
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_billing_charge_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_charge_type_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_billing_charge_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_billing_charge_unit_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_charge_unit_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_billing_charge_unit
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_billing_charge_usage_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_charge_usage_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_billing_charge_usage
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_billing_charge_usage_pre_insert_update_trig; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_charge_usage_pre_insert_update_trig
    BEFORE INSERT OR UPDATE ON bp_billing_charge_usage
    FOR EACH ROW
    EXECUTE PROCEDURE bp_billing_charge_usage_pre_insert_update();


--
-- Name: bp_billing_discount_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_discount_type_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_billing_discount_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_billing_entity_preferences_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_entity_preferences_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_billing_entity_preferences
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_billing_equipment_assignment_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_equipment_assignment_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_billing_equipment_assignment
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_billing_equipment_assignment_pre_insert_trig; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_equipment_assignment_pre_insert_trig
    BEFORE INSERT ON bp_billing_equipment_assignment
    FOR EACH ROW
    EXECUTE PROCEDURE bp_billing_equipment_assignment_pre_insert();


--
-- Name: bp_billing_equipment_assignment_pre_update_trig; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_equipment_assignment_pre_update_trig
    BEFORE UPDATE ON bp_billing_equipment_assignment
    FOR EACH ROW
    EXECUTE PROCEDURE bp_billing_equipment_assignment_pre_update();


--
-- Name: bp_billing_period_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_period_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_billing_period
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_billing_period_pre_insert_update_trig; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_billing_period_pre_insert_update_trig
    BEFORE INSERT OR UPDATE ON bp_billing_period
    FOR EACH ROW
    EXECUTE PROCEDURE bp_billing_period_pre_insert_update();


--
-- Name: bp_charge_frequency_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_charge_frequency_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_charge_frequency
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_master_billing_plan_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_master_billing_plan_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_master_billing_plan
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_past_due_charge_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_past_due_charge_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_past_due_charge
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_period_billing_summary_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_period_billing_summary_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_period_billing_summary
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_period_change_summary_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_period_change_summary_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_period_change_summary
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_period_charge_summary_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_period_charge_summary_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_period_charge_summary
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_period_status_summary_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_period_status_summary_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_period_status_summary
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_period_usage_summary_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_period_usage_summary_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_period_usage_summary
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: bp_usage_allotment_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER bp_usage_allotment_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON bp_usage_allotment
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: branding_button_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER branding_button_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON branding_button
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: branding_content_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER branding_content_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON branding_content
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: branding_presentation_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER branding_presentation_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON branding_presentation
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: broadcast_message_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER broadcast_message_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON broadcast_message
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: broadcast_message_level_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER broadcast_message_level_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON broadcast_message_level
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: broadcast_message_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER broadcast_message_type_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON broadcast_message_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: carrier_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER carrier_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON carrier
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: carrier_domain_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER carrier_domain_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON carrier_domain
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: cc_auth_log_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER cc_auth_log_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON cc_auth_log
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: cc_encrypt_key_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER cc_encrypt_key_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON cc_encrypt_key
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: contact_address_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER contact_address_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON contact_address
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: contact_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER contact_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON contact
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: contact_level_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER contact_level_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON contact_level
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: contact_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER contact_type_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON contact_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: currency_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER currency_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON currency
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: download_file_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER download_file_type_changelog
    BEFORE INSERT OR UPDATE ON download_file_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: emod_credential_pre_insert_update_trig; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER emod_credential_pre_insert_update_trig
    BEFORE INSERT OR UPDATE ON equipment_model_credential
    FOR EACH ROW
    EXECUTE PROCEDURE emod_credential_pre_insert_update();


--
-- Name: equipment_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER equipment_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON equipment
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: equipment_credential_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER equipment_credential_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON equipment_credential
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: equipment_credential_pre_insert_update_trig; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER equipment_credential_pre_insert_update_trig
    BEFORE INSERT OR UPDATE ON equipment_credential
    FOR EACH ROW
    EXECUTE PROCEDURE equipment_credential_pre_insert_update();


--
-- Name: equipment_firmware_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER equipment_firmware_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON equipment_firmware
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: equipment_info_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER equipment_info_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON equipment_info
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: equipment_info_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER equipment_info_type_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON equipment_info_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: equipment_model_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER equipment_model_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON equipment_model
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: equipment_model_credential_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER equipment_model_credential_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON equipment_model_credential
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: equipment_note_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER equipment_note_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON equipment_note
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: equipment_software_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER equipment_software_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON equipment_software
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: equipment_status_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER equipment_status_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON equipment_status
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: equipment_status_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER equipment_status_type_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON equipment_status_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: equipment_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER equipment_type_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON equipment_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: equipment_warranty_rule_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER equipment_warranty_rule_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON equipment_warranty_rule
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: groupname_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER groupname_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON groupname
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: line_assignment_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER line_assignment_type_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON line_assignment_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: line_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER line_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON line
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: line_equipment_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER line_equipment_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON line_equipment
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: line_equipment_pre_insert_trig; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER line_equipment_pre_insert_trig
    BEFORE INSERT ON line_equipment
    FOR EACH ROW
    EXECUTE PROCEDURE line_equipment_pre_insert();


--
-- Name: line_equipment_pre_update_trig; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER line_equipment_pre_update_trig
    BEFORE UPDATE ON line_equipment
    FOR EACH ROW
    EXECUTE PROCEDURE line_equipment_pre_update();


--
-- Name: line_pre_delete_trig; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER line_pre_delete_trig
    BEFORE DELETE ON line
    FOR EACH ROW
    EXECUTE PROCEDURE line_pre_delete();


--
-- Name: line_pre_insert_trig; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER line_pre_insert_trig
    BEFORE INSERT ON line
    FOR EACH ROW
    EXECUTE PROCEDURE line_pre_insert();


--
-- Name: line_terminal_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER line_terminal_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON line_terminal
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: lns_lookup_changelog; Type: TRIGGER; Schema: csctoss; Owner: postgres
--

CREATE TRIGGER lns_lookup_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON lns_lookup
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: location_label_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER location_label_type_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON location_label_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: nas_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER nas_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON nas
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: plan_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER plan_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON plan
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: plan_log_pre_update; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER plan_log_pre_update
    BEFORE UPDATE ON plan
    FOR EACH ROW
    EXECUTE PROCEDURE plan_log_pre_update();


--
-- Name: plan_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER plan_type_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON plan_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: portal_properties_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER portal_properties_changelog
    BEFORE INSERT OR UPDATE ON portal_properties
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: product_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER product_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON product
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: radcheck_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER radcheck_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON radcheck
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: radgroupcheck_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER radgroupcheck_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON radgroupcheck
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: radgroupreply_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER radgroupreply_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON radgroupreply
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: radreply_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER radreply_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON radreply
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: radreply_pre_insert_update_trig; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER radreply_pre_insert_update_trig
    BEFORE INSERT OR UPDATE ON radreply
    FOR EACH ROW
    EXECUTE PROCEDURE radreply_pre_insert_update();


--
-- Name: receiving_lot_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER receiving_lot_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON receiving_lot
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: report_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER report_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON report
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: sales_order_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER sales_order_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON sales_order
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: security_roles_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER security_roles_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON security_roles
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: shipment_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER shipment_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON shipment
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: shipment_equipment_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER shipment_equipment_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON shipment_equipment
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: software_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER software_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON software
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: staff_access_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER staff_access_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON staff_access
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: staff_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER staff_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON staff
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: state_code_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER state_code_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON state_code
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: system_parameter_changelog; Type: TRIGGER; Schema: csctoss; Owner: slony
--

CREATE TRIGGER system_parameter_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON system_parameter
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: timezone_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER timezone_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON timezone
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: unique_identifier_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER unique_identifier_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON unique_identifier
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: unique_identifier_type_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER unique_identifier_type_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON unique_identifier_type
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: usergroup_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER usergroup_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON usergroup
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


--
-- Name: username_changelog; Type: TRIGGER; Schema: csctoss; Owner: csctoss_owner
--

CREATE TRIGGER username_changelog
    BEFORE INSERT OR DELETE OR UPDATE ON username
    FOR EACH ROW
    EXECUTE PROCEDURE public.change_log('change_log', ',');


SET search_path = carrier, pg_catalog;

--
-- Name: carrier_request_carrier_fk; Type: FK CONSTRAINT; Schema: carrier; Owner: carrier_owner
--

ALTER TABLE ONLY request
    ADD CONSTRAINT carrier_request_carrier_fk FOREIGN KEY (request_carrier_id) REFERENCES request_carrier(request_carrier_id);


--
-- Name: carrier_request_status_fk; Type: FK CONSTRAINT; Schema: carrier; Owner: carrier_owner
--

ALTER TABLE ONLY request
    ADD CONSTRAINT carrier_request_status_fk FOREIGN KEY (request_status_id) REFERENCES request_status(request_status_id);


--
-- Name: carrier_request_type_fk; Type: FK CONSTRAINT; Schema: carrier; Owner: carrier_owner
--

ALTER TABLE ONLY request
    ADD CONSTRAINT carrier_request_type_fk FOREIGN KEY (request_type_id) REFERENCES request_type(request_type_id);


SET search_path = csctoss, pg_catalog;

--
-- Name: address_state_code_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY address
    ADD CONSTRAINT address_state_code_fk FOREIGN KEY (state_code) REFERENCES state_code(state_code);


--
-- Name: alert_activity_alert_definition_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY alert_activity
    ADD CONSTRAINT alert_activity_alert_definition_id_fk FOREIGN KEY (alert_definition_id) REFERENCES alert_definition(alert_definition_id);


--
-- Name: alert_definition_alert_type_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY alert_definition
    ADD CONSTRAINT alert_definition_alert_type_id_fk FOREIGN KEY (alert_type_id) REFERENCES alert_type(alert_type_id);


--
-- Name: alert_definition_contact_alert_defintion_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY alert_definition_contact
    ADD CONSTRAINT alert_definition_contact_alert_defintion_id_fk FOREIGN KEY (alert_definition_id) REFERENCES alert_definition(alert_definition_id);


--
-- Name: alert_definition_contact_contact_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY alert_definition_contact
    ADD CONSTRAINT alert_definition_contact_contact_id_fk FOREIGN KEY (contact_id) REFERENCES contact(contact_id);


--
-- Name: alert_defintion_snmp_alert_definition_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY alert_definition_snmp
    ADD CONSTRAINT alert_defintion_snmp_alert_definition_id_fk FOREIGN KEY (alert_definition_id) REFERENCES alert_definition(alert_definition_id);


--
-- Name: alert_defintion_username_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY alert_definition
    ADD CONSTRAINT alert_defintion_username_fk FOREIGN KEY (username) REFERENCES username(username);


--
-- Name: alerts_alert_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY alerts
    ADD CONSTRAINT alerts_alert_type_fk FOREIGN KEY (alert_type_id) REFERENCES alert_type(alert_type_id);


--
-- Name: alerts_line_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY alerts
    ADD CONSTRAINT alerts_line_fk FOREIGN KEY (line_id) REFERENCES line(line_id);


--
-- Name: alerts_priority_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY alerts
    ADD CONSTRAINT alerts_priority_fk FOREIGN KEY (priority_id) REFERENCES alert_priority(alert_priority_id);


--
-- Name: api_device_parser_device_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY api_device_parser
    ADD CONSTRAINT api_device_parser_device_id_fk FOREIGN KEY (device_id) REFERENCES api_supported_device(device_id);


--
-- Name: api_device_parser_parser_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY api_device_parser
    ADD CONSTRAINT api_device_parser_parser_id_fk FOREIGN KEY (parser_id) REFERENCES api_parser(parser_id);


--
-- Name: api_key_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY api_key
    ADD CONSTRAINT api_key_billing_entity_id_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: api_supported_device_device_login_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY api_supported_device
    ADD CONSTRAINT api_supported_device_device_login_id_fk FOREIGN KEY (device_login_id) REFERENCES api_device_login(device_login_id);


--
-- Name: api_supported_device_equipment_firmware_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY api_supported_device
    ADD CONSTRAINT api_supported_device_equipment_firmware_id_fk FOREIGN KEY (equipment_firmware_id) REFERENCES equipment_firmware(equipment_firmware_id);


--
-- Name: attribute_attribute_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY attribute
    ADD CONSTRAINT attribute_attribute_type_fk FOREIGN KEY (attribute_type) REFERENCES attribute_type(attribute_type);


--
-- Name: bent_llab_location_label_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY billing_entity_location_label
    ADD CONSTRAINT bent_llab_location_label_type_fk FOREIGN KEY (location_label_type) REFERENCES location_label_type(location_label_type);


--
-- Name: bent_prod_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY billing_entity_product
    ADD CONSTRAINT bent_prod_billing_entity_id_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: bent_prod_expired_groupname_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY billing_entity_product
    ADD CONSTRAINT bent_prod_expired_groupname_fk FOREIGN KEY (expired_groupname) REFERENCES groupname(groupname);


--
-- Name: bent_prod_product_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY billing_entity_product
    ADD CONSTRAINT bent_prod_product_id_fk FOREIGN KEY (product_id) REFERENCES product(product_id);


--
-- Name: bent_prod_service_groupname_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY billing_entity_product
    ADD CONSTRAINT bent_prod_service_groupname_fk FOREIGN KEY (service_groupname) REFERENCES groupname(groupname);


--
-- Name: billing_entity_address_address_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY billing_entity_address
    ADD CONSTRAINT billing_entity_address_address_id_fk FOREIGN KEY (address_id) REFERENCES address(address_id);


--
-- Name: billing_entity_address_address_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY billing_entity_address
    ADD CONSTRAINT billing_entity_address_address_type_fk FOREIGN KEY (address_type) REFERENCES address_type(address_type);


--
-- Name: billing_entity_address_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY billing_entity_address
    ADD CONSTRAINT billing_entity_address_billing_entity_id_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: billing_entity_download_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY billing_entity_download
    ADD CONSTRAINT billing_entity_download_billing_entity_id_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: billing_entity_download_file_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY billing_entity_download
    ADD CONSTRAINT billing_entity_download_file_type_fk FOREIGN KEY (file_type) REFERENCES download_file_type(file_type);


--
-- Name: billing_entity_fusio_billing_entity_id_fkey; Type: FK CONSTRAINT; Schema: csctoss; Owner: postgres
--

ALTER TABLE ONLY billing_entity_fusio
    ADD CONSTRAINT billing_entity_fusio_billing_entity_id_fkey FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: billing_entity_parent_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY billing_entity
    ADD CONSTRAINT billing_entity_parent_billing_entity_id_fk FOREIGN KEY (parent_billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: billing_entity_preferred_timezone_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY billing_entity
    ADD CONSTRAINT billing_entity_preferred_timezone_fk FOREIGN KEY (preferred_timezone) REFERENCES timezone(timezone);


--
-- Name: billing_entity_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY billing_entity
    ADD CONSTRAINT billing_entity_type_fk FOREIGN KEY (billing_entity_type) REFERENCES billing_entity_type(billing_entity_type);


--
-- Name: bp_aggregate_usage_plan_billing_charge_usage_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_aggregate_usage_plan
    ADD CONSTRAINT bp_aggregate_usage_plan_billing_charge_usage_id_fk FOREIGN KEY (bp_billing_charge_usage_id) REFERENCES bp_billing_charge_usage(bp_billing_charge_usage_id);


--
-- Name: bp_aggregate_usage_plan_discount_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_aggregate_usage_plan
    ADD CONSTRAINT bp_aggregate_usage_plan_discount_type_fk FOREIGN KEY (bp_billing_discount_type) REFERENCES bp_billing_discount_type(bp_billing_discount_type);


--
-- Name: bp_allotment_adjustment_history_usage_allotment_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_allotment_adjustment_history
    ADD CONSTRAINT bp_allotment_adjustment_history_usage_allotment_fk FOREIGN KEY (bp_usage_allotment_id) REFERENCES bp_usage_allotment(bp_usage_allotment_id);


--
-- Name: bp_billing_calendar_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_period
    ADD CONSTRAINT bp_billing_calendar_id_fk FOREIGN KEY (bp_billing_calendar_id) REFERENCES bp_billing_calendar(bp_billing_calendar_id);


--
-- Name: bp_billing_charge_charge_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_charge
    ADD CONSTRAINT bp_billing_charge_charge_type_fk FOREIGN KEY (bp_billing_charge_type) REFERENCES bp_billing_charge_type(bp_billing_charge_type);


--
-- Name: bp_billing_charge_discount_charge_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_charge_discount
    ADD CONSTRAINT bp_billing_charge_discount_charge_id_fk FOREIGN KEY (bp_billing_charge_id) REFERENCES bp_billing_charge(bp_billing_charge_id);


--
-- Name: bp_billing_charge_discount_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_charge_discount
    ADD CONSTRAINT bp_billing_charge_discount_type_fk FOREIGN KEY (bp_billing_discount_type) REFERENCES bp_billing_discount_type(bp_billing_discount_type);


--
-- Name: bp_billing_charge_master_billing_plan_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_charge
    ADD CONSTRAINT bp_billing_charge_master_billing_plan_id_fk FOREIGN KEY (bp_master_billing_plan_id) REFERENCES bp_master_billing_plan(bp_master_billing_plan_id);


--
-- Name: bp_billing_charge_onetime_charge_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_charge_onetime
    ADD CONSTRAINT bp_billing_charge_onetime_charge_id_fk FOREIGN KEY (bp_billing_charge_id) REFERENCES bp_billing_charge(bp_billing_charge_id);


--
-- Name: bp_billing_charge_static_charge_frequency_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_charge_static
    ADD CONSTRAINT bp_billing_charge_static_charge_frequency_fk FOREIGN KEY (bp_charge_frequency) REFERENCES bp_charge_frequency(bp_charge_frequency);


--
-- Name: bp_billing_charge_static_charge_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_charge_static
    ADD CONSTRAINT bp_billing_charge_static_charge_id_fk FOREIGN KEY (bp_billing_charge_id) REFERENCES bp_billing_charge(bp_billing_charge_id);


--
-- Name: bp_billing_charge_summary_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_period_charge_summary
    ADD CONSTRAINT bp_billing_charge_summary_id_fk FOREIGN KEY (bp_period_billing_summary_id) REFERENCES bp_period_billing_summary(bp_period_billing_summary_id);


--
-- Name: bp_billing_charge_summary_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_period_change_summary
    ADD CONSTRAINT bp_billing_charge_summary_id_fk FOREIGN KEY (bp_period_billing_summary_id) REFERENCES bp_period_billing_summary(bp_period_billing_summary_id);


--
-- Name: bp_billing_charge_summary_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_period_usage_summary
    ADD CONSTRAINT bp_billing_charge_summary_id_fk FOREIGN KEY (bp_period_billing_summary_id) REFERENCES bp_period_billing_summary(bp_period_billing_summary_id);


--
-- Name: bp_billing_charge_summary_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_period_status_summary
    ADD CONSTRAINT bp_billing_charge_summary_id_fk FOREIGN KEY (bp_period_billing_summary_id) REFERENCES bp_period_billing_summary(bp_period_billing_summary_id);


--
-- Name: bp_billing_charge_usage_billing_charge_unit_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_charge_usage
    ADD CONSTRAINT bp_billing_charge_usage_billing_charge_unit_fk FOREIGN KEY (bp_billing_charge_unit) REFERENCES bp_billing_charge_unit(bp_billing_charge_unit);


--
-- Name: bp_billing_charge_usage_carrier; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_charge_usage
    ADD CONSTRAINT bp_billing_charge_usage_carrier FOREIGN KEY (carrier) REFERENCES carrier(carrier);


--
-- Name: bp_billing_charge_usage_charge_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_charge_usage
    ADD CONSTRAINT bp_billing_charge_usage_charge_id_fk FOREIGN KEY (bp_billing_charge_id) REFERENCES bp_billing_charge(bp_billing_charge_id);


--
-- Name: bp_billing_entity_preferences_billed_by_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_entity_preferences
    ADD CONSTRAINT bp_billing_entity_preferences_billed_by_fk FOREIGN KEY (billed_by) REFERENCES billing_entity(billing_entity_id);


--
-- Name: bp_billing_entity_preferences_billing_calendar_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_entity_preferences
    ADD CONSTRAINT bp_billing_entity_preferences_billing_calendar_id_fk FOREIGN KEY (bp_billing_calendar_id) REFERENCES bp_billing_calendar(bp_billing_calendar_id);


--
-- Name: bp_billing_entity_preferences_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_entity_preferences
    ADD CONSTRAINT bp_billing_entity_preferences_billing_entity_id_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: bp_billing_entity_preferences_currency_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_entity_preferences
    ADD CONSTRAINT bp_billing_entity_preferences_currency_id_fk FOREIGN KEY (currency_id) REFERENCES currency(currency_id);


--
-- Name: bp_billing_entity_preferences_mailing_address_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_entity_preferences
    ADD CONSTRAINT bp_billing_entity_preferences_mailing_address_id_fk FOREIGN KEY (mailing_address_id) REFERENCES address(address_id);


--
-- Name: bp_billing_equipment_assignment_billing_charge_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_equipment_assignment
    ADD CONSTRAINT bp_billing_equipment_assignment_billing_charge_fk FOREIGN KEY (bp_billing_charge_id) REFERENCES bp_billing_charge(bp_billing_charge_id);


--
-- Name: bp_billing_equipment_assignment_equipment_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_equipment_assignment
    ADD CONSTRAINT bp_billing_equipment_assignment_equipment_fk FOREIGN KEY (equipment_id) REFERENCES equipment(equipment_id);


--
-- Name: bp_billing_equipment_assignment_line_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_billing_equipment_assignment
    ADD CONSTRAINT bp_billing_equipment_assignment_line_id_fk FOREIGN KEY (line_id) REFERENCES line(line_id);


--
-- Name: bp_billing_period_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_period_change_summary
    ADD CONSTRAINT bp_billing_period_id_fk FOREIGN KEY (bp_billing_period_id) REFERENCES bp_billing_period(bp_billing_period_id);


--
-- Name: bp_billing_period_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_period_status_summary
    ADD CONSTRAINT bp_billing_period_id_fk FOREIGN KEY (bp_billing_period_id) REFERENCES bp_billing_period(bp_billing_period_id);


--
-- Name: bp_billing_summary_billing_entity_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_period_billing_summary
    ADD CONSTRAINT bp_billing_summary_billing_entity_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: bp_master_billing_plan_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_master_billing_plan
    ADD CONSTRAINT bp_master_billing_plan_billing_entity_id_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: bp_master_billing_plan_bp_billing_calendar_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_master_billing_plan
    ADD CONSTRAINT bp_master_billing_plan_bp_billing_calendar_id_fk FOREIGN KEY (bp_billing_calendar_id) REFERENCES bp_billing_calendar(bp_billing_calendar_id);


--
-- Name: bp_master_billing_plan_currency_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_master_billing_plan
    ADD CONSTRAINT bp_master_billing_plan_currency_id_fk FOREIGN KEY (currency_id) REFERENCES currency(currency_id);


--
-- Name: bp_past_due_charge_billing_period_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_past_due_charge
    ADD CONSTRAINT bp_past_due_charge_billing_period_fk FOREIGN KEY (bp_billing_period_id) REFERENCES bp_billing_period(bp_billing_period_id);


--
-- Name: bp_past_due_charge_master_billing_plan_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_past_due_charge
    ADD CONSTRAINT bp_past_due_charge_master_billing_plan_fk FOREIGN KEY (bp_master_billing_plan_id) REFERENCES bp_master_billing_plan(bp_master_billing_plan_id);


--
-- Name: bp_period_billing_summary_master_billing_plan_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_period_billing_summary
    ADD CONSTRAINT bp_period_billing_summary_master_billing_plan_fk FOREIGN KEY (bp_master_billing_plan_id) REFERENCES bp_master_billing_plan(bp_master_billing_plan_id);


--
-- Name: bp_usage_allotment_carrier_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_usage_allotment
    ADD CONSTRAINT bp_usage_allotment_carrier_fk FOREIGN KEY (carrier) REFERENCES carrier(carrier);


--
-- Name: bp_usage_allotment_usage_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY bp_usage_allotment
    ADD CONSTRAINT bp_usage_allotment_usage_fk FOREIGN KEY (bp_billing_charge_usage_id) REFERENCES bp_billing_charge_usage(bp_billing_charge_usage_id);


--
-- Name: branding_button_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY branding_button
    ADD CONSTRAINT branding_button_billing_entity_id_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: branding_button_product_code_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY branding_button
    ADD CONSTRAINT branding_button_product_code_fk FOREIGN KEY (product_code) REFERENCES product(product_code);


--
-- Name: branding_content_parent_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY branding_content
    ADD CONSTRAINT branding_content_parent_billing_entity_id_fk FOREIGN KEY (parent_billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: branding_presentation_parent_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY branding_presentation
    ADD CONSTRAINT branding_presentation_parent_billing_entity_id_fk FOREIGN KEY (parent_billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: broadcast_group_test_fk2; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY broadcast_message_group
    ADD CONSTRAINT broadcast_group_test_fk2 FOREIGN KEY (broadcast_id) REFERENCES broadcast_message_data(broadcast_id);


--
-- Name: broadcast_message_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY broadcast_message
    ADD CONSTRAINT broadcast_message_billing_entity_id_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: broadcast_message_data_fkey; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY broadcast_message_data
    ADD CONSTRAINT broadcast_message_data_fkey FOREIGN KEY (message_priority_id) REFERENCES message_priority(message_priority_id);


--
-- Name: broadcast_message_group_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY broadcast_message_group
    ADD CONSTRAINT broadcast_message_group_fk FOREIGN KEY (broadcast_message_billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: broadcast_message_message_level_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY broadcast_message
    ADD CONSTRAINT broadcast_message_message_level_id_fk FOREIGN KEY (broadcast_message_level_id) REFERENCES broadcast_message_level(broadcast_message_level_id);


--
-- Name: broadcast_message_message_type_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY broadcast_message
    ADD CONSTRAINT broadcast_message_message_type_id_fk FOREIGN KEY (broadcast_message_type_id) REFERENCES broadcast_message_type(broadcast_message_type_id);


--
-- Name: carrier_domain_carrier_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY carrier_domain
    ADD CONSTRAINT carrier_domain_carrier_fk FOREIGN KEY (carrier) REFERENCES carrier(carrier);


--
-- Name: carrier_domain_uniq_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY carrier_domain
    ADD CONSTRAINT carrier_domain_uniq_type_fk FOREIGN KEY (unique_identifier_type) REFERENCES unique_identifier_type(unique_identifier_type);


--
-- Name: change_log_staff_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY change_log
    ADD CONSTRAINT change_log_staff_id_fk FOREIGN KEY (staff_id) REFERENCES staff(staff_id);


--
-- Name: config_equipment_ibfk_1; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY config_equipment
    ADD CONSTRAINT config_equipment_ibfk_1 FOREIGN KEY (config_id) REFERENCES config(id) ON DELETE CASCADE;


--
-- Name: config_equipment_ibfk_1; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY firmware_equipment
    ADD CONSTRAINT config_equipment_ibfk_1 FOREIGN KEY (firmware_id) REFERENCES firmware(id) ON DELETE CASCADE;


--
-- Name: config_equipment_ibfk_2; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY config_equipment
    ADD CONSTRAINT config_equipment_ibfk_2 FOREIGN KEY (equipment_model_id) REFERENCES equipment_model(equipment_model_id) ON DELETE CASCADE;


--
-- Name: config_equipment_ibfk_2; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY firmware_equipment
    ADD CONSTRAINT config_equipment_ibfk_2 FOREIGN KEY (equipment_model_id) REFERENCES equipment_model(equipment_model_id) ON DELETE CASCADE;


--
-- Name: contact_address_address_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY contact_address
    ADD CONSTRAINT contact_address_address_id_fk FOREIGN KEY (address_id) REFERENCES address(address_id);


--
-- Name: contact_address_address_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY contact_address
    ADD CONSTRAINT contact_address_address_type_fk FOREIGN KEY (address_type) REFERENCES address_type(address_type);


--
-- Name: contact_address_contact_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY contact_address
    ADD CONSTRAINT contact_address_contact_id_fk FOREIGN KEY (contact_id) REFERENCES contact(contact_id);


--
-- Name: contact_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY contact
    ADD CONSTRAINT contact_billing_entity_id_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: contact_contact_level_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY contact
    ADD CONSTRAINT contact_contact_level_fk FOREIGN KEY (contact_level) REFERENCES contact_level(contact_level);


--
-- Name: contact_contact_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY contact
    ADD CONSTRAINT contact_contact_type_fk FOREIGN KEY (contact_type) REFERENCES contact_type(contact_type);


--
-- Name: embedded_equipment_model_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment_model
    ADD CONSTRAINT embedded_equipment_model_id_fk FOREIGN KEY (embedded_equipment_model_id) REFERENCES equipment_model(equipment_model_id);


--
-- Name: equipment_credential_equipment_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment_credential
    ADD CONSTRAINT equipment_credential_equipment_id_fk FOREIGN KEY (equipment_id) REFERENCES equipment(equipment_id);


--
-- Name: equipment_equipment_firmware_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment
    ADD CONSTRAINT equipment_equipment_firmware_id_fk FOREIGN KEY (equipment_firmware_id) REFERENCES equipment_firmware(equipment_firmware_id);


--
-- Name: equipment_equipment_model_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment
    ADD CONSTRAINT equipment_equipment_model_id_fk FOREIGN KEY (equipment_model_id) REFERENCES equipment_model(equipment_model_id);


--
-- Name: equipment_equipment_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment
    ADD CONSTRAINT equipment_equipment_type_fk FOREIGN KEY (equipment_type) REFERENCES equipment_type(equipment_type);


--
-- Name: equipment_firmware_equipment_model_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment_firmware
    ADD CONSTRAINT equipment_firmware_equipment_model_id_fk FOREIGN KEY (equipment_model_id) REFERENCES equipment_model(equipment_model_id);


--
-- Name: equipment_id; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY soup_config_info
    ADD CONSTRAINT equipment_id FOREIGN KEY (equipment_id) REFERENCES equipment(equipment_id) MATCH FULL;


--
-- Name: equipment_info_equipment_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment_info
    ADD CONSTRAINT equipment_info_equipment_id_fk FOREIGN KEY (equipment_id) REFERENCES equipment(equipment_id);


--
-- Name: equipment_info_equipment_info_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment_info
    ADD CONSTRAINT equipment_info_equipment_info_type_fk FOREIGN KEY (equipment_info_type) REFERENCES equipment_info_type(equipment_info_type);


--
-- Name: equipment_model_carrier_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment_model
    ADD CONSTRAINT equipment_model_carrier_fk FOREIGN KEY (carrier) REFERENCES carrier(carrier);


--
-- Name: equipment_model_credential_equipment_model_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment_model_credential
    ADD CONSTRAINT equipment_model_credential_equipment_model_id_fk FOREIGN KEY (equipment_model_id) REFERENCES equipment_model(equipment_model_id);


--
-- Name: equipment_note_equipment_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment_note
    ADD CONSTRAINT equipment_note_equipment_id_fk FOREIGN KEY (equipment_id) REFERENCES equipment(equipment_id);


--
-- Name: equipment_receiving_lot_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment
    ADD CONSTRAINT equipment_receiving_lot_id_fk FOREIGN KEY (receiving_lot_id) REFERENCES receiving_lot(receiving_lot_id);


--
-- Name: equipment_software_equipment_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment_software
    ADD CONSTRAINT equipment_software_equipment_id_fk FOREIGN KEY (equipment_id) REFERENCES equipment(equipment_id);


--
-- Name: equipment_software_software_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment_software
    ADD CONSTRAINT equipment_software_software_id_fk FOREIGN KEY (software_id) REFERENCES software(software_id);


--
-- Name: equipment_status_equipment_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment_status
    ADD CONSTRAINT equipment_status_equipment_id_fk FOREIGN KEY (equipment_id) REFERENCES equipment(equipment_id);


--
-- Name: equipment_status_equipment_status_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment_status
    ADD CONSTRAINT equipment_status_equipment_status_type_fk FOREIGN KEY (equipment_status_type) REFERENCES equipment_status_type(equipment_status_type);


--
-- Name: equipment_type_preferred_unique_identifier_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment_type
    ADD CONSTRAINT equipment_type_preferred_unique_identifier_type_fk FOREIGN KEY (preferred_unique_identifier_type) REFERENCES unique_identifier_type(unique_identifier_type);


--
-- Name: equipment_warranty_equipment_id_fkey; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment_warranty
    ADD CONSTRAINT equipment_warranty_equipment_id_fkey FOREIGN KEY (equipment_id) REFERENCES equipment(equipment_id);


--
-- Name: equipment_warranty_rule_equipment_model_id_fkey; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY equipment_warranty_rule
    ADD CONSTRAINT equipment_warranty_rule_equipment_model_id_fkey FOREIGN KEY (equipment_model_id) REFERENCES equipment_model(equipment_model_id);


--
-- Name: groupname_default_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY groupname_default
    ADD CONSTRAINT groupname_default_billing_entity_id_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: groupname_default_carrier_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY groupname_default
    ADD CONSTRAINT groupname_default_carrier_fk FOREIGN KEY (carrier) REFERENCES carrier(carrier);


--
-- Name: groupname_default_groupname_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY groupname_default
    ADD CONSTRAINT groupname_default_groupname_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: line_alert_email_line_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line_alert_email
    ADD CONSTRAINT line_alert_email_line_id_fk FOREIGN KEY (line_id) REFERENCES line(line_id);


--
-- Name: line_alert_line_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line_alert
    ADD CONSTRAINT line_alert_line_id_fk FOREIGN KEY (line_id) REFERENCES line(line_id);


--
-- Name: line_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line
    ADD CONSTRAINT line_billing_entity_id_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: line_contact_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line
    ADD CONSTRAINT line_contact_id_fk FOREIGN KEY (contact_id) REFERENCES contact(contact_id);


--
-- Name: line_current_plan_id; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line
    ADD CONSTRAINT line_current_plan_id FOREIGN KEY (current_plan_id) REFERENCES plan(plan_id);


--
-- Name: line_equipment_equipment_id; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line_equipment
    ADD CONSTRAINT line_equipment_equipment_id FOREIGN KEY (equipment_id) REFERENCES equipment(equipment_id);


--
-- Name: line_equipment_line_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line_equipment
    ADD CONSTRAINT line_equipment_line_id_fk FOREIGN KEY (line_id) REFERENCES line(line_id);


--
-- Name: line_line_assignment_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line
    ADD CONSTRAINT line_line_assignment_type_fk FOREIGN KEY (line_assignment_type) REFERENCES line_assignment_type(line_assignment_type);


--
-- Name: line_previous_line_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line
    ADD CONSTRAINT line_previous_line_id_fk FOREIGN KEY (previous_line_id) REFERENCES line(line_id);


--
-- Name: line_radius_username_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line
    ADD CONSTRAINT line_radius_username_fk FOREIGN KEY (radius_username) REFERENCES username(username) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: line_terminal_atm_processor_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line_terminal
    ADD CONSTRAINT line_terminal_atm_processor_fk FOREIGN KEY (atm_processor) REFERENCES atm_processor(atm_processor);


--
-- Name: line_terminal_line_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line_terminal
    ADD CONSTRAINT line_terminal_line_id_fk FOREIGN KEY (line_id) REFERENCES line(line_id);


--
-- Name: line_usage_day_line_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line_usage_day
    ADD CONSTRAINT line_usage_day_line_id_fk FOREIGN KEY (line_id) REFERENCES line(line_id);


--
-- Name: line_usage_day_line_id_fk1; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line_usage_day_history
    ADD CONSTRAINT line_usage_day_line_id_fk1 FOREIGN KEY (line_id) REFERENCES line(line_id);


--
-- Name: line_usage_day_timezone_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line_usage_day
    ADD CONSTRAINT line_usage_day_timezone_fk FOREIGN KEY (timezone) REFERENCES timezone(timezone);


--
-- Name: line_usage_day_timezone_fk1; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line_usage_day_history
    ADD CONSTRAINT line_usage_day_timezone_fk1 FOREIGN KEY (timezone) REFERENCES timezone(timezone);


--
-- Name: line_usage_month_line_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line_usage_month
    ADD CONSTRAINT line_usage_month_line_id_fk FOREIGN KEY (line_id) REFERENCES line(line_id);


--
-- Name: line_usage_month_timezone_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line_usage_month
    ADD CONSTRAINT line_usage_month_timezone_fk FOREIGN KEY (timezone) REFERENCES timezone(timezone);


--
-- Name: line_usage_overage_calc_timezone_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY line_usage_overage_calc
    ADD CONSTRAINT line_usage_overage_calc_timezone_fk FOREIGN KEY (timezone) REFERENCES timezone(timezone);


--
-- Name: login_tracking_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY login_tracking
    ADD CONSTRAINT login_tracking_billing_entity_id_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: oss_jbill_billing_entity_mapping_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY oss_jbill_billing_entity_mapping
    ADD CONSTRAINT oss_jbill_billing_entity_mapping_billing_entity_id_fk FOREIGN KEY (oss_billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: plan_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY plan_log
    ADD CONSTRAINT plan_id_fk FOREIGN KEY (plan_id) REFERENCES plan(plan_id);


--
-- Name: plan_line_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY plan
    ADD CONSTRAINT plan_line_id_fk FOREIGN KEY (line_id) REFERENCES line(line_id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: plan_plan_type_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY plan
    ADD CONSTRAINT plan_plan_type_id_fk FOREIGN KEY (plan_type_id) REFERENCES plan_type(plan_type_id);


--
-- Name: plan_product_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY plan
    ADD CONSTRAINT plan_product_id_fk FOREIGN KEY (product_id) REFERENCES product(product_id);


--
-- Name: plan_staff_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY plan
    ADD CONSTRAINT plan_staff_id_fk FOREIGN KEY (staff_id) REFERENCES staff(staff_id);


--
-- Name: product_overage_threshold_product_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY product_overage_threshold
    ADD CONSTRAINT product_overage_threshold_product_id_fk FOREIGN KEY (product_id) REFERENCES product(product_id);


--
-- Name: product_plan_type_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY product
    ADD CONSTRAINT product_plan_type_id_fk FOREIGN KEY (plan_type_id) REFERENCES plan_type(plan_type_id);


--
-- Name: radcheck_attribute_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY radcheck
    ADD CONSTRAINT radcheck_attribute_fk FOREIGN KEY (attribute) REFERENCES attribute(attribute);


--
-- Name: radcheck_operator_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY radcheck
    ADD CONSTRAINT radcheck_operator_fk FOREIGN KEY (op) REFERENCES radius_operator(op);


--
-- Name: radcheck_username_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY radcheck
    ADD CONSTRAINT radcheck_username_fk FOREIGN KEY (username) REFERENCES username(username) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: radgroupcheck_attribute_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY radgroupcheck
    ADD CONSTRAINT radgroupcheck_attribute_fk FOREIGN KEY (attribute) REFERENCES attribute(attribute);


--
-- Name: radgroupcheck_groupname_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY radgroupcheck
    ADD CONSTRAINT radgroupcheck_groupname_fk FOREIGN KEY (groupname) REFERENCES groupname(groupname);


--
-- Name: radgroupcheck_operator_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY radgroupcheck
    ADD CONSTRAINT radgroupcheck_operator_fk FOREIGN KEY (op) REFERENCES radius_operator(op);


--
-- Name: radgroupreply_attribute_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY radgroupreply
    ADD CONSTRAINT radgroupreply_attribute_fk FOREIGN KEY (attribute) REFERENCES attribute(attribute);


--
-- Name: radgroupreply_groupname_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY radgroupreply
    ADD CONSTRAINT radgroupreply_groupname_fk FOREIGN KEY (groupname) REFERENCES groupname(groupname);


--
-- Name: radgroupreply_operator; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY radgroupreply
    ADD CONSTRAINT radgroupreply_operator FOREIGN KEY (op) REFERENCES radius_operator(op);


--
-- Name: radreply_attribute_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY radreply
    ADD CONSTRAINT radreply_attribute_fk FOREIGN KEY (attribute) REFERENCES attribute(attribute);


--
-- Name: radreply_operator_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY radreply
    ADD CONSTRAINT radreply_operator_fk FOREIGN KEY (op) REFERENCES radius_operator(op);


--
-- Name: radreply_username_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY radreply
    ADD CONSTRAINT radreply_username_fk FOREIGN KEY (username) REFERENCES username(username) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: replication_failure_hostname_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY replication_failure
    ADD CONSTRAINT replication_failure_hostname_fk FOREIGN KEY (hostname) REFERENCES system_parameter(hostname);


--
-- Name: replication_failure_ip_address_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY replication_failure
    ADD CONSTRAINT replication_failure_ip_address_fk FOREIGN KEY (ip_address) REFERENCES system_parameter(ip_address);


--
-- Name: report_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY report
    ADD CONSTRAINT report_billing_entity_id_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: reservation_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY static_ip_reservation
    ADD CONSTRAINT reservation_billing_entity_id_fk FOREIGN KEY (reservation_billing_entity_id) REFERENCES billing_entity(billing_entity_id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_static_ip_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY static_ip_reservation
    ADD CONSTRAINT reservation_static_ip_id_fk FOREIGN KEY (static_ip_id) REFERENCES static_ip_pool(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: sales_order_number_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY plan
    ADD CONSTRAINT sales_order_number_fk FOREIGN KEY (sales_order_number) REFERENCES sales_order(sales_order_number);


--
-- Name: shipment_equipment_equipment_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY shipment_equipment
    ADD CONSTRAINT shipment_equipment_equipment_id_fk FOREIGN KEY (equipment_id) REFERENCES equipment(equipment_id);


--
-- Name: shipment_equipment_shipment_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY shipment_equipment
    ADD CONSTRAINT shipment_equipment_shipment_id_fk FOREIGN KEY (shipment_id) REFERENCES shipment(shipment_id);


--
-- Name: shipment_receiver_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY shipment
    ADD CONSTRAINT shipment_receiver_billing_entity_id_fk FOREIGN KEY (receiver_billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: shipment_sender_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY shipment
    ADD CONSTRAINT shipment_sender_billing_entity_id_fk FOREIGN KEY (sender_billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: soup_config_equipment_model_id_fkey; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY soup_config
    ADD CONSTRAINT soup_config_equipment_model_id_fkey FOREIGN KEY (equipment_model_id) REFERENCES equipment_model(equipment_model_id);


--
-- Name: soup_dirnames_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY soup_dirnames
    ADD CONSTRAINT soup_dirnames_billing_entity_id_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: soup_dirnames_soup_config_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY soup_dirnames
    ADD CONSTRAINT soup_dirnames_soup_config_id_fk FOREIGN KEY (soup_config_id) REFERENCES soup_config(soup_config_id);


--
-- Name: staff_access_staff_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY staff_access
    ADD CONSTRAINT staff_access_staff_id_fk FOREIGN KEY (staff_id) REFERENCES staff(staff_id);


--
-- Name: static_ip_carrier_def_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY static_ip_carrier_def
    ADD CONSTRAINT static_ip_carrier_def_fk FOREIGN KEY (carrier) REFERENCES carrier(carrier) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: static_ip_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY static_ip_pool
    ADD CONSTRAINT static_ip_fk FOREIGN KEY (carrier_id) REFERENCES static_ip_carrier_def(carrier_def_id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: unique_identifier_equipment_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY unique_identifier
    ADD CONSTRAINT unique_identifier_equipment_id_fk FOREIGN KEY (equipment_id) REFERENCES equipment(equipment_id);


--
-- Name: unique_identifier_unique_identifier_type_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY unique_identifier
    ADD CONSTRAINT unique_identifier_unique_identifier_type_fk FOREIGN KEY (unique_identifier_type) REFERENCES unique_identifier_type(unique_identifier_type);


--
-- Name: usergroup_groupname_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY usergroup
    ADD CONSTRAINT usergroup_groupname_fk FOREIGN KEY (groupname) REFERENCES groupname(groupname);


--
-- Name: usergroup_username_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY usergroup
    ADD CONSTRAINT usergroup_username_fk FOREIGN KEY (username) REFERENCES username(username) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: username_billing_entity_id_fk; Type: FK CONSTRAINT; Schema: csctoss; Owner: csctoss_owner
--

ALTER TABLE ONLY username
    ADD CONSTRAINT username_billing_entity_id_fk FOREIGN KEY (billing_entity_id) REFERENCES billing_entity(billing_entity_id);


--
-- Name: csctoss; Type: ACL; Schema: -; Owner: csctoss_owner
--

REVOKE ALL ON SCHEMA csctoss FROM PUBLIC;
REVOKE ALL ON SCHEMA csctoss FROM csctoss_owner;
GRANT ALL ON SCHEMA csctoss TO csctoss_owner;
GRANT USAGE ON SCHEMA csctoss TO PUBLIC;


--
-- Name: invoice; Type: ACL; Schema: -; Owner: invoice_owner
--

REVOKE ALL ON SCHEMA invoice FROM PUBLIC;
REVOKE ALL ON SCHEMA invoice FROM invoice_owner;
GRANT ALL ON SCHEMA invoice TO invoice_owner;
GRANT ALL ON SCHEMA invoice TO PUBLIC;


--
-- Name: oss_sync; Type: ACL; Schema: -; Owner: alert_writer
--

REVOKE ALL ON SCHEMA oss_sync FROM PUBLIC;
REVOKE ALL ON SCHEMA oss_sync FROM alert_writer;
GRANT ALL ON SCHEMA oss_sync TO alert_writer;
GRANT USAGE ON SCHEMA oss_sync TO PUBLIC;
GRANT USAGE ON SCHEMA oss_sync TO csctoss_reader;


--
-- Name: public; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM postgres;
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO PUBLIC;
GRANT USAGE ON SCHEMA public TO csctoss_owner;


--
-- Name: rt3; Type: ACL; Schema: -; Owner: rt_user
--

REVOKE ALL ON SCHEMA rt3 FROM PUBLIC;
REVOKE ALL ON SCHEMA rt3 FROM rt_user;
GRANT ALL ON SCHEMA rt3 TO rt_user;
GRANT USAGE ON SCHEMA rt3 TO PUBLIC;


--
-- Name: api_bent_owned(integer, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION api_bent_owned(integer, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION api_bent_owned(integer, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION api_bent_owned(integer, text) TO csctoss_owner;
GRANT ALL ON FUNCTION api_bent_owned(integer, text) TO radius_writer;
GRANT ALL ON FUNCTION api_bent_owned(integer, text) TO PUBLIC;


--
-- Name: api_get_ip_for_unique_id(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION api_get_ip_for_unique_id(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION api_get_ip_for_unique_id(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION api_get_ip_for_unique_id(text) TO csctoss_owner;
GRANT ALL ON FUNCTION api_get_ip_for_unique_id(text) TO radius_writer;


--
-- Name: api_get_mac_for_unique_id(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION api_get_mac_for_unique_id(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION api_get_mac_for_unique_id(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION api_get_mac_for_unique_id(text) TO csctoss_owner;
GRANT ALL ON FUNCTION api_get_mac_for_unique_id(text) TO radius_writer;


--
-- Name: api_get_radius_username_for_unique_id(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION api_get_radius_username_for_unique_id(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION api_get_radius_username_for_unique_id(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION api_get_radius_username_for_unique_id(text) TO csctoss_owner;
GRANT ALL ON FUNCTION api_get_radius_username_for_unique_id(text) TO radius_writer;
GRANT ALL ON FUNCTION api_get_radius_username_for_unique_id(text) TO PUBLIC;


--
-- Name: api_get_sn_for_unique_id(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION api_get_sn_for_unique_id(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION api_get_sn_for_unique_id(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION api_get_sn_for_unique_id(text) TO csctoss_owner;
GRANT ALL ON FUNCTION api_get_sn_for_unique_id(text) TO PUBLIC;


--
-- Name: api_radius_attribute_reset(integer, integer, integer); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION api_radius_attribute_reset(integer, integer, integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION api_radius_attribute_reset(integer, integer, integer) FROM csctoss_owner;
GRANT ALL ON FUNCTION api_radius_attribute_reset(integer, integer, integer) TO csctoss_owner;
GRANT ALL ON FUNCTION api_radius_attribute_reset(integer, integer, integer) TO radius_writer;
GRANT ALL ON FUNCTION api_radius_attribute_reset(integer, integer, integer) TO PUBLIC;


--
-- Name: api_translate_unique_id(text, text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION api_translate_unique_id(text, text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION api_translate_unique_id(text, text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION api_translate_unique_id(text, text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION api_translate_unique_id(text, text, text) TO radius_writer;
GRANT ALL ON FUNCTION api_translate_unique_id(text, text, text) TO csctoss_reader;
GRANT ALL ON FUNCTION api_translate_unique_id(text, text, text) TO PUBLIC;


--
-- Name: attribute_type_updater(text, character); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION attribute_type_updater(text, character) FROM PUBLIC;
REVOKE ALL ON FUNCTION attribute_type_updater(text, character) FROM slony;
GRANT ALL ON FUNCTION attribute_type_updater(text, character) TO slony;


--
-- Name: attribute_updater(text, character); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION attribute_updater(text, character) FROM PUBLIC;
REVOKE ALL ON FUNCTION attribute_updater(text, character) FROM slony;
GRANT ALL ON FUNCTION attribute_updater(text, character) TO slony;


--
-- Name: billing_entity_structure(); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION billing_entity_structure() FROM PUBLIC;
REVOKE ALL ON FUNCTION billing_entity_structure() FROM csctoss_owner;
GRANT ALL ON FUNCTION billing_entity_structure() TO csctoss_owner;


--
-- Name: bp_check_charge_frequency(date, date, integer, integer, integer); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION bp_check_charge_frequency(date, date, integer, integer, integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION bp_check_charge_frequency(date, date, integer, integer, integer) FROM csctoss_owner;
GRANT ALL ON FUNCTION bp_check_charge_frequency(date, date, integer, integer, integer) TO csctoss_owner;
GRANT ALL ON FUNCTION bp_check_charge_frequency(date, date, integer, integer, integer) TO PUBLIC;


--
-- Name: calc_charged_minutes(interval); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION calc_charged_minutes(interval) FROM PUBLIC;
REVOKE ALL ON FUNCTION calc_charged_minutes(interval) FROM csctoss_owner;
GRANT ALL ON FUNCTION calc_charged_minutes(interval) TO csctoss_owner;
GRANT ALL ON FUNCTION calc_charged_minutes(interval) TO PUBLIC;


--
-- Name: calc_charged_minutes(bigint); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION calc_charged_minutes(bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION calc_charged_minutes(bigint) FROM csctoss_owner;
GRANT ALL ON FUNCTION calc_charged_minutes(bigint) TO csctoss_owner;
GRANT ALL ON FUNCTION calc_charged_minutes(bigint) TO PUBLIC;


--
-- Name: calculate_uptime_percent(text, date, date); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION calculate_uptime_percent(text, date, date) FROM PUBLIC;
REVOKE ALL ON FUNCTION calculate_uptime_percent(text, date, date) FROM csctoss_owner;
GRANT ALL ON FUNCTION calculate_uptime_percent(text, date, date) TO csctoss_owner;
GRANT ALL ON FUNCTION calculate_uptime_percent(text, date, date) TO radius_writer;
GRANT ALL ON FUNCTION calculate_uptime_percent(text, date, date) TO csctoss_reader;
GRANT ALL ON FUNCTION calculate_uptime_percent(text, date, date) TO PUBLIC;


--
-- Name: cancellation_info_and_perform_bulk(text, text[], integer); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION cancellation_info_and_perform_bulk(text, text[], integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION cancellation_info_and_perform_bulk(text, text[], integer) FROM csctoss_owner;
GRANT ALL ON FUNCTION cancellation_info_and_perform_bulk(text, text[], integer) TO csctoss_owner;
GRANT ALL ON FUNCTION cancellation_info_and_perform_bulk(text, text[], integer) TO PUBLIC;
GRANT ALL ON FUNCTION cancellation_info_and_perform_bulk(text, text[], integer) TO csctoss_writer;


--
-- Name: date_range_overlap(date, date, date, date); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION date_range_overlap(date, date, date, date) FROM PUBLIC;
REVOKE ALL ON FUNCTION date_range_overlap(date, date, date, date) FROM csctoss_owner;
GRANT ALL ON FUNCTION date_range_overlap(date, date, date, date) TO csctoss_owner;
GRANT ALL ON FUNCTION date_range_overlap(date, date, date, date) TO PUBLIC;


--
-- Name: delete_broadcast_message(integer); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION delete_broadcast_message(integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION delete_broadcast_message(integer) FROM csctoss_owner;
GRANT ALL ON FUNCTION delete_broadcast_message(integer) TO csctoss_owner;
GRANT ALL ON FUNCTION delete_broadcast_message(integer) TO csctoss_test;
GRANT ALL ON FUNCTION delete_broadcast_message(integer) TO csctoss_reader;
GRANT ALL ON FUNCTION delete_broadcast_message(integer) TO PUBLIC;


--
-- Name: equipment_credential_populate(); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION equipment_credential_populate() FROM PUBLIC;
REVOKE ALL ON FUNCTION equipment_credential_populate() FROM csctoss_owner;
GRANT ALL ON FUNCTION equipment_credential_populate() TO csctoss_owner;


--
-- Name: expand_be_children(refcursor, integer, integer, integer); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION expand_be_children(refcursor, integer, integer, integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION expand_be_children(refcursor, integer, integer, integer) FROM csctoss_owner;
GRANT ALL ON FUNCTION expand_be_children(refcursor, integer, integer, integer) TO csctoss_owner;


--
-- Name: fetch_csctlog_conn(); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION fetch_csctlog_conn() FROM PUBLIC;
REVOKE ALL ON FUNCTION fetch_csctlog_conn() FROM slony;
GRANT ALL ON FUNCTION fetch_csctlog_conn() TO slony;
GRANT ALL ON FUNCTION fetch_csctlog_conn() TO csctoss_owner;
GRANT ALL ON FUNCTION fetch_csctlog_conn() TO radius_writer;
GRANT ALL ON FUNCTION fetch_csctlog_conn() TO alert_writer;
GRANT ALL ON FUNCTION fetch_csctlog_conn() TO csctoss_reader;


--
-- Name: fetch_csctmon_conn(); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION fetch_csctmon_conn() FROM PUBLIC;
REVOKE ALL ON FUNCTION fetch_csctmon_conn() FROM csctoss_owner;
GRANT ALL ON FUNCTION fetch_csctmon_conn() TO csctoss_owner;
GRANT ALL ON FUNCTION fetch_csctmon_conn() TO PUBLIC;
GRANT ALL ON FUNCTION fetch_csctmon_conn() TO postgres;


--
-- Name: fetch_csctoss_conn(); Type: ACL; Schema: csctoss; Owner: postgres
--

REVOKE ALL ON FUNCTION fetch_csctoss_conn() FROM PUBLIC;
REVOKE ALL ON FUNCTION fetch_csctoss_conn() FROM postgres;
GRANT ALL ON FUNCTION fetch_csctoss_conn() TO postgres;
GRANT ALL ON FUNCTION fetch_csctoss_conn() TO PUBLIC;


--
-- Name: fetch_ip_for_line_id(integer); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION fetch_ip_for_line_id(integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION fetch_ip_for_line_id(integer) FROM csctoss_owner;
GRANT ALL ON FUNCTION fetch_ip_for_line_id(integer) TO csctoss_owner;
GRANT ALL ON FUNCTION fetch_ip_for_line_id(integer) TO PUBLIC;


--
-- Name: fetch_jbilling_conn(); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION fetch_jbilling_conn() FROM PUBLIC;
REVOKE ALL ON FUNCTION fetch_jbilling_conn() FROM slony;
GRANT ALL ON FUNCTION fetch_jbilling_conn() TO slony;
GRANT ALL ON FUNCTION fetch_jbilling_conn() TO PUBLIC;
GRANT ALL ON FUNCTION fetch_jbilling_conn() TO csctoss_owner;
GRANT ALL ON FUNCTION fetch_jbilling_conn() TO radius_writer;
GRANT ALL ON FUNCTION fetch_jbilling_conn() TO alert_writer;
GRANT ALL ON FUNCTION fetch_jbilling_conn() TO csctoss_reader;


--
-- Name: fetch_max_ip_address(text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION fetch_max_ip_address(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION fetch_max_ip_address(text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION fetch_max_ip_address(text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION fetch_max_ip_address(text, text) TO radius_writer;
GRANT ALL ON FUNCTION fetch_max_ip_address(text, text) TO csctoss_reader;
GRANT ALL ON FUNCTION fetch_max_ip_address(text, text) TO PUBLIC;


--
-- Name: fetch_mrac_by_date_range(integer, date, date); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION fetch_mrac_by_date_range(integer, date, date) FROM PUBLIC;
REVOKE ALL ON FUNCTION fetch_mrac_by_date_range(integer, date, date) FROM csctoss_owner;
GRANT ALL ON FUNCTION fetch_mrac_by_date_range(integer, date, date) TO csctoss_owner;
GRANT ALL ON FUNCTION fetch_mrac_by_date_range(integer, date, date) TO radius_writer;
GRANT ALL ON FUNCTION fetch_mrac_by_date_range(integer, date, date) TO csctoss_reader;
GRANT ALL ON FUNCTION fetch_mrac_by_date_range(integer, date, date) TO PUBLIC;


--
-- Name: fetch_mrpa_by_date_range(integer, date, date); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION fetch_mrpa_by_date_range(integer, date, date) FROM PUBLIC;
REVOKE ALL ON FUNCTION fetch_mrpa_by_date_range(integer, date, date) FROM csctoss_owner;
GRANT ALL ON FUNCTION fetch_mrpa_by_date_range(integer, date, date) TO csctoss_owner;
GRANT ALL ON FUNCTION fetch_mrpa_by_date_range(integer, date, date) TO radius_writer;
GRANT ALL ON FUNCTION fetch_mrpa_by_date_range(integer, date, date) TO csctoss_reader;
GRANT ALL ON FUNCTION fetch_mrpa_by_date_range(integer, date, date) TO PUBLIC;


--
-- Name: fetch_portal_conn(); Type: ACL; Schema: csctoss; Owner: postgres
--

REVOKE ALL ON FUNCTION fetch_portal_conn() FROM PUBLIC;
REVOKE ALL ON FUNCTION fetch_portal_conn() FROM postgres;
GRANT ALL ON FUNCTION fetch_portal_conn() TO postgres;
GRANT ALL ON FUNCTION fetch_portal_conn() TO PUBLIC;


--
-- Name: firmware_gmu_loader(); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION firmware_gmu_loader() FROM PUBLIC;
REVOKE ALL ON FUNCTION firmware_gmu_loader() FROM csctoss_owner;
GRANT ALL ON FUNCTION firmware_gmu_loader() TO csctoss_owner;
GRANT ALL ON FUNCTION firmware_gmu_loader() TO PUBLIC;


--
-- Name: firmware_soup_loader(); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION firmware_soup_loader() FROM PUBLIC;
REVOKE ALL ON FUNCTION firmware_soup_loader() FROM csctoss_owner;
GRANT ALL ON FUNCTION firmware_soup_loader() TO csctoss_owner;
GRANT ALL ON FUNCTION firmware_soup_loader() TO PUBLIC;


--
-- Name: fix_class_value_vzw(); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION fix_class_value_vzw() FROM PUBLIC;
REVOKE ALL ON FUNCTION fix_class_value_vzw() FROM csctoss_owner;
GRANT ALL ON FUNCTION fix_class_value_vzw() TO csctoss_owner;
GRANT ALL ON FUNCTION fix_class_value_vzw() TO PUBLIC;


--
-- Name: free_ips_in_range(text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION free_ips_in_range(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION free_ips_in_range(text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION free_ips_in_range(text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION free_ips_in_range(text, text) TO radius_writer;
GRANT ALL ON FUNCTION free_ips_in_range(text, text) TO csctoss_reader;


--
-- Name: get_branding_billing_entity_id_by_radius_username(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION get_branding_billing_entity_id_by_radius_username(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION get_branding_billing_entity_id_by_radius_username(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION get_branding_billing_entity_id_by_radius_username(text) TO csctoss_owner;
GRANT ALL ON FUNCTION get_branding_billing_entity_id_by_radius_username(text) TO csctoss_reader;
GRANT ALL ON FUNCTION get_branding_billing_entity_id_by_radius_username(text) TO PUBLIC;


--
-- Name: get_encrypt_key(integer, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION get_encrypt_key(integer, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION get_encrypt_key(integer, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION get_encrypt_key(integer, text) TO csctoss_owner;
GRANT ALL ON FUNCTION get_encrypt_key(integer, text) TO csctoss_reader;
GRANT ALL ON FUNCTION get_encrypt_key(integer, text) TO radius_writer;
GRANT ALL ON FUNCTION get_encrypt_key(integer, text) TO PUBLIC;


--
-- Name: get_encrypt_key(text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION get_encrypt_key(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION get_encrypt_key(text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION get_encrypt_key(text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION get_encrypt_key(text, text) TO csctoss_reader;
GRANT ALL ON FUNCTION get_encrypt_key(text, text) TO radius_writer;
GRANT ALL ON FUNCTION get_encrypt_key(text, text) TO PUBLIC;


--
-- Name: get_equipment_line_unique_identifier(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION get_equipment_line_unique_identifier(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION get_equipment_line_unique_identifier(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION get_equipment_line_unique_identifier(text) TO csctoss_owner;
GRANT ALL ON FUNCTION get_equipment_line_unique_identifier(text) TO PUBLIC;
GRANT ALL ON FUNCTION get_equipment_line_unique_identifier(text) TO csctoss_test;
GRANT ALL ON FUNCTION get_equipment_line_unique_identifier(text) TO csctoss_reader;


--
-- Name: get_line_radius_all(integer); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION get_line_radius_all(integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION get_line_radius_all(integer) FROM csctoss_owner;
GRANT ALL ON FUNCTION get_line_radius_all(integer) TO csctoss_owner;
GRANT ALL ON FUNCTION get_line_radius_all(integer) TO csctoss_reader;
GRANT ALL ON FUNCTION get_line_radius_all(integer) TO radius_writer;
GRANT ALL ON FUNCTION get_line_radius_all(integer) TO PUBLIC;


--
-- Name: get_line_radius_info(integer); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION get_line_radius_info(integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION get_line_radius_info(integer) FROM csctoss_owner;
GRANT ALL ON FUNCTION get_line_radius_info(integer) TO csctoss_owner;
GRANT ALL ON FUNCTION get_line_radius_info(integer) TO csctoss_reader;
GRANT ALL ON FUNCTION get_line_radius_info(integer) TO radius_writer;
GRANT ALL ON FUNCTION get_line_radius_info(integer) TO PUBLIC;


--
-- Name: get_list_static_ip(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION get_list_static_ip(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION get_list_static_ip(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION get_list_static_ip(text) TO csctoss_owner;


--
-- Name: get_parent_branding(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION get_parent_branding(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION get_parent_branding(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION get_parent_branding(text) TO csctoss_owner;
GRANT ALL ON FUNCTION get_parent_branding(text) TO csctoss_reader;
GRANT ALL ON FUNCTION get_parent_branding(text) TO PUBLIC;


--
-- Name: get_plan_acct_dates(date); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION get_plan_acct_dates(date) FROM PUBLIC;
REVOKE ALL ON FUNCTION get_plan_acct_dates(date) FROM csctoss_owner;
GRANT ALL ON FUNCTION get_plan_acct_dates(date) TO csctoss_owner;
GRANT ALL ON FUNCTION get_plan_acct_dates(date) TO radius_writer;
GRANT ALL ON FUNCTION get_plan_acct_dates(date) TO csctoss_reader;


--
-- Name: get_radgroupcheck_values(text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION get_radgroupcheck_values(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION get_radgroupcheck_values(text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION get_radgroupcheck_values(text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION get_radgroupcheck_values(text, text) TO csctoss_reader;
GRANT ALL ON FUNCTION get_radgroupcheck_values(text, text) TO radius_writer;
GRANT ALL ON FUNCTION get_radgroupcheck_values(text, text) TO PUBLIC;


--
-- Name: get_radgroupreply_values(text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION get_radgroupreply_values(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION get_radgroupreply_values(text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION get_radgroupreply_values(text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION get_radgroupreply_values(text, text) TO csctoss_reader;
GRANT ALL ON FUNCTION get_radgroupreply_values(text, text) TO radius_writer;
GRANT ALL ON FUNCTION get_radgroupreply_values(text, text) TO PUBLIC;


--
-- Name: groupname_updater(text, character); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION groupname_updater(text, character) FROM PUBLIC;
REVOKE ALL ON FUNCTION groupname_updater(text, character) FROM slony;
GRANT ALL ON FUNCTION groupname_updater(text, character) TO slony;


--
-- Name: is_user_registered(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION is_user_registered(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION is_user_registered(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION is_user_registered(text) TO csctoss_owner;
GRANT ALL ON FUNCTION is_user_registered(text) TO csctoss_reader;
GRANT ALL ON FUNCTION is_user_registered(text) TO get_limit_reader;


--
-- Name: line_class_updater(); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION line_class_updater() FROM PUBLIC;
REVOKE ALL ON FUNCTION line_class_updater() FROM csctoss_owner;
GRANT ALL ON FUNCTION line_class_updater() TO csctoss_owner;


--
-- Name: line_usage_daily_detail(integer, date); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION line_usage_daily_detail(integer, date) FROM PUBLIC;
REVOKE ALL ON FUNCTION line_usage_daily_detail(integer, date) FROM csctoss_owner;
GRANT ALL ON FUNCTION line_usage_daily_detail(integer, date) TO csctoss_owner;
GRANT ALL ON FUNCTION line_usage_daily_detail(integer, date) TO csctoss_reader;
GRANT ALL ON FUNCTION line_usage_daily_detail(integer, date) TO radius_writer;


--
-- Name: line_usage_day_calc(date, integer); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION line_usage_day_calc(date, integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION line_usage_day_calc(date, integer) FROM csctoss_owner;
GRANT ALL ON FUNCTION line_usage_day_calc(date, integer) TO csctoss_owner;


--
-- Name: line_usage_month_calc(integer, integer); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION line_usage_month_calc(integer, integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION line_usage_month_calc(integer, integer) FROM csctoss_owner;
GRANT ALL ON FUNCTION line_usage_month_calc(integer, integer) TO csctoss_owner;


--
-- Name: mrac_loader(); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION mrac_loader() FROM PUBLIC;
REVOKE ALL ON FUNCTION mrac_loader() FROM slony;
GRANT ALL ON FUNCTION mrac_loader() TO slony;


--
-- Name: mrad_duplicate_scrub(date, date); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION mrad_duplicate_scrub(date, date) FROM PUBLIC;
REVOKE ALL ON FUNCTION mrad_duplicate_scrub(date, date) FROM csctoss_owner;
GRANT ALL ON FUNCTION mrad_duplicate_scrub(date, date) TO csctoss_owner;


--
-- Name: mrpa_loader(); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION mrpa_loader() FROM PUBLIC;
REVOKE ALL ON FUNCTION mrpa_loader() FROM slony;
GRANT ALL ON FUNCTION mrpa_loader() TO slony;


--
-- Name: nas_updater(text, character); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION nas_updater(text, character) FROM PUBLIC;
REVOKE ALL ON FUNCTION nas_updater(text, character) FROM slony;
GRANT ALL ON FUNCTION nas_updater(text, character) TO slony;


--
-- Name: normalize_epoch(bigint, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION normalize_epoch(bigint, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION normalize_epoch(bigint, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION normalize_epoch(bigint, text) TO csctoss_owner;
GRANT ALL ON FUNCTION normalize_epoch(bigint, text) TO PUBLIC;


--
-- Name: ops_api_expire(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION ops_api_expire(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION ops_api_expire(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION ops_api_expire(text) TO csctoss_owner;
GRANT ALL ON FUNCTION ops_api_expire(text) TO csctoss_test;
GRANT ALL ON FUNCTION ops_api_expire(text) TO csctoss_reader;
GRANT ALL ON FUNCTION ops_api_expire(text) TO PUBLIC;


--
-- Name: ops_api_expire(text, boolean); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION ops_api_expire(text, boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION ops_api_expire(text, boolean) FROM csctoss_owner;
GRANT ALL ON FUNCTION ops_api_expire(text, boolean) TO csctoss_owner;
GRANT ALL ON FUNCTION ops_api_expire(text, boolean) TO csctoss_test;
GRANT ALL ON FUNCTION ops_api_expire(text, boolean) TO csctoss_reader;
GRANT ALL ON FUNCTION ops_api_expire(text, boolean) TO PUBLIC;


--
-- Name: ops_api_expire_ex(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION ops_api_expire_ex(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION ops_api_expire_ex(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION ops_api_expire_ex(text) TO csctoss_owner;
GRANT ALL ON FUNCTION ops_api_expire_ex(text) TO csctoss_test;
GRANT ALL ON FUNCTION ops_api_expire_ex(text) TO csctoss_reader;
GRANT ALL ON FUNCTION ops_api_expire_ex(text) TO PUBLIC;


--
-- Name: ops_api_line_plan_product_info(text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION ops_api_line_plan_product_info(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION ops_api_line_plan_product_info(text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION ops_api_line_plan_product_info(text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION ops_api_line_plan_product_info(text, text) TO postgres;
GRANT ALL ON FUNCTION ops_api_line_plan_product_info(text, text) TO csctoss_test;
GRANT ALL ON FUNCTION ops_api_line_plan_product_info(text, text) TO csctoss_reader;
GRANT ALL ON FUNCTION ops_api_line_plan_product_info(text, text) TO PUBLIC;


--
-- Name: ops_api_modify(text, text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION ops_api_modify(text, text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION ops_api_modify(text, text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION ops_api_modify(text, text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION ops_api_modify(text, text, text) TO csctoss_test;
GRANT ALL ON FUNCTION ops_api_modify(text, text, text) TO csctoss_reader;
GRANT ALL ON FUNCTION ops_api_modify(text, text, text) TO PUBLIC;


--
-- Name: ops_api_restore(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION ops_api_restore(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION ops_api_restore(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION ops_api_restore(text) TO csctoss_owner;
GRANT ALL ON FUNCTION ops_api_restore(text) TO csctoss_test;
GRANT ALL ON FUNCTION ops_api_restore(text) TO csctoss_reader;
GRANT ALL ON FUNCTION ops_api_restore(text) TO PUBLIC;


--
-- Name: ops_api_restore_ex(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION ops_api_restore_ex(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION ops_api_restore_ex(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION ops_api_restore_ex(text) TO csctoss_owner;
GRANT ALL ON FUNCTION ops_api_restore_ex(text) TO PUBLIC;
GRANT ALL ON FUNCTION ops_api_restore_ex(text) TO csctoss_test;
GRANT ALL ON FUNCTION ops_api_restore_ex(text) TO csctoss_reader;


--
-- Name: ops_api_rma(text, text, text, integer, boolean, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION ops_api_rma(text, text, text, integer, boolean, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION ops_api_rma(text, text, text, integer, boolean, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION ops_api_rma(text, text, text, integer, boolean, text) TO csctoss_owner;
GRANT ALL ON FUNCTION ops_api_rma(text, text, text, integer, boolean, text) TO postgres;
GRANT ALL ON FUNCTION ops_api_rma(text, text, text, integer, boolean, text) TO PUBLIC;


--
-- Name: ops_api_suspend(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION ops_api_suspend(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION ops_api_suspend(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION ops_api_suspend(text) TO csctoss_owner;
GRANT ALL ON FUNCTION ops_api_suspend(text) TO csctoss_test;
GRANT ALL ON FUNCTION ops_api_suspend(text) TO csctoss_reader;
GRANT ALL ON FUNCTION ops_api_suspend(text) TO PUBLIC;


--
-- Name: ops_api_suspend_ex(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION ops_api_suspend_ex(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION ops_api_suspend_ex(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION ops_api_suspend_ex(text) TO csctoss_owner;
GRANT ALL ON FUNCTION ops_api_suspend_ex(text) TO PUBLIC;
GRANT ALL ON FUNCTION ops_api_suspend_ex(text) TO csctoss_test;
GRANT ALL ON FUNCTION ops_api_suspend_ex(text) TO csctoss_reader;


--
-- Name: ops_api_unique_ids_radius_info(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION ops_api_unique_ids_radius_info(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION ops_api_unique_ids_radius_info(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION ops_api_unique_ids_radius_info(text) TO csctoss_owner;
GRANT ALL ON FUNCTION ops_api_unique_ids_radius_info(text) TO csctoss_test;
GRANT ALL ON FUNCTION ops_api_unique_ids_radius_info(text) TO csctoss_reader;
GRANT ALL ON FUNCTION ops_api_unique_ids_radius_info(text) TO PUBLIC;


--
-- Name: ops_api_user_restore(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION ops_api_user_restore(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION ops_api_user_restore(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION ops_api_user_restore(text) TO csctoss_owner;
GRANT ALL ON FUNCTION ops_api_user_restore(text) TO csctoss_test;
GRANT ALL ON FUNCTION ops_api_user_restore(text) TO csctoss_reader;
GRANT ALL ON FUNCTION ops_api_user_restore(text) TO PUBLIC;


--
-- Name: ops_api_user_restore(text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION ops_api_user_restore(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION ops_api_user_restore(text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION ops_api_user_restore(text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION ops_api_user_restore(text, text) TO csctoss_test;
GRANT ALL ON FUNCTION ops_api_user_restore(text, text) TO csctoss_reader;
GRANT ALL ON FUNCTION ops_api_user_restore(text, text) TO PUBLIC;


--
-- Name: ops_api_user_suspend(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION ops_api_user_suspend(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION ops_api_user_suspend(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION ops_api_user_suspend(text) TO csctoss_owner;
GRANT ALL ON FUNCTION ops_api_user_suspend(text) TO csctoss_test;
GRANT ALL ON FUNCTION ops_api_user_suspend(text) TO csctoss_reader;
GRANT ALL ON FUNCTION ops_api_user_suspend(text) TO PUBLIC;


--
-- Name: ops_api_user_suspend(text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION ops_api_user_suspend(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION ops_api_user_suspend(text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION ops_api_user_suspend(text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION ops_api_user_suspend(text, text) TO csctoss_test;
GRANT ALL ON FUNCTION ops_api_user_suspend(text, text) TO csctoss_reader;
GRANT ALL ON FUNCTION ops_api_user_suspend(text, text) TO PUBLIC;


--
-- Name: oss_sync_ip_activity_fetch(); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION oss_sync_ip_activity_fetch() FROM PUBLIC;
REVOKE ALL ON FUNCTION oss_sync_ip_activity_fetch() FROM csctoss_owner;
GRANT ALL ON FUNCTION oss_sync_ip_activity_fetch() TO csctoss_owner;
GRANT ALL ON FUNCTION oss_sync_ip_activity_fetch() TO radius_writer;
GRANT ALL ON FUNCTION oss_sync_ip_activity_fetch() TO alert_writer;
GRANT ALL ON FUNCTION oss_sync_ip_activity_fetch() TO csctoss_reader;
GRANT ALL ON FUNCTION oss_sync_ip_activity_fetch() TO PUBLIC;


--
-- Name: oss_sync_line_mrac_fetch(); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION oss_sync_line_mrac_fetch() FROM PUBLIC;
REVOKE ALL ON FUNCTION oss_sync_line_mrac_fetch() FROM csctoss_owner;
GRANT ALL ON FUNCTION oss_sync_line_mrac_fetch() TO csctoss_owner;
GRANT ALL ON FUNCTION oss_sync_line_mrac_fetch() TO radius_writer;
GRANT ALL ON FUNCTION oss_sync_line_mrac_fetch() TO alert_writer;
GRANT ALL ON FUNCTION oss_sync_line_mrac_fetch() TO csctoss_reader;
GRANT ALL ON FUNCTION oss_sync_line_mrac_fetch() TO PUBLIC;


--
-- Name: plan_log_pre_update(); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION plan_log_pre_update() FROM PUBLIC;
REVOKE ALL ON FUNCTION plan_log_pre_update() FROM csctoss_owner;
GRANT ALL ON FUNCTION plan_log_pre_update() TO csctoss_owner;
GRANT ALL ON FUNCTION plan_log_pre_update() TO csctoss_reader;
GRANT ALL ON FUNCTION plan_log_pre_update() TO radius_writer;
GRANT ALL ON FUNCTION plan_log_pre_update() TO PUBLIC;


--
-- Name: radcheck_updater(text, character); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION radcheck_updater(text, character) FROM PUBLIC;
REVOKE ALL ON FUNCTION radcheck_updater(text, character) FROM slony;
GRANT ALL ON FUNCTION radcheck_updater(text, character) TO slony;


--
-- Name: radgroupcheck_updater(text, character); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION radgroupcheck_updater(text, character) FROM PUBLIC;
REVOKE ALL ON FUNCTION radgroupcheck_updater(text, character) FROM slony;
GRANT ALL ON FUNCTION radgroupcheck_updater(text, character) TO slony;


--
-- Name: radgroupreply_updater(text, character); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION radgroupreply_updater(text, character) FROM PUBLIC;
REVOKE ALL ON FUNCTION radgroupreply_updater(text, character) FROM slony;
GRANT ALL ON FUNCTION radgroupreply_updater(text, character) TO slony;


--
-- Name: radius_updater(); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION radius_updater() FROM PUBLIC;
REVOKE ALL ON FUNCTION radius_updater() FROM slony;
GRANT ALL ON FUNCTION radius_updater() TO slony;


--
-- Name: radius_updater(integer); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION radius_updater(integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION radius_updater(integer) FROM slony;
GRANT ALL ON FUNCTION radius_updater(integer) TO slony;


--
-- Name: radreply_pre_insert_update(); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION radreply_pre_insert_update() FROM PUBLIC;
REVOKE ALL ON FUNCTION radreply_pre_insert_update() FROM csctoss_owner;
GRANT ALL ON FUNCTION radreply_pre_insert_update() TO csctoss_owner;


--
-- Name: radreply_updater(text, character); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION radreply_updater(text, character) FROM PUBLIC;
REVOKE ALL ON FUNCTION radreply_updater(text, character) FROM slony;
GRANT ALL ON FUNCTION radreply_updater(text, character) TO slony;


--
-- Name: register_prepaid_user_ui(text, text, boolean, text, text, text, text, text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION register_prepaid_user_ui(text, text, boolean, text, text, text, text, text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION register_prepaid_user_ui(text, text, boolean, text, text, text, text, text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION register_prepaid_user_ui(text, text, boolean, text, text, text, text, text, text) TO csctoss_owner;


--
-- Name: replication_failure_insert(text, text, text, text, text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION replication_failure_insert(text, text, text, text, text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION replication_failure_insert(text, text, text, text, text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION replication_failure_insert(text, text, text, text, text, text) TO csctoss_owner;


--
-- Name: rma_device_info(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION rma_device_info(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION rma_device_info(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION rma_device_info(text) TO csctoss_owner;
GRANT ALL ON FUNCTION rma_device_info(text) TO csctoss_test;
GRANT ALL ON FUNCTION rma_device_info(text) TO csctoss_reader;
GRANT ALL ON FUNCTION rma_device_info(text) TO PUBLIC;


--
-- Name: rt_field_updater(integer, integer, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION rt_field_updater(ticketid integer, fieldid integer, value text) FROM PUBLIC;
REVOKE ALL ON FUNCTION rt_field_updater(ticketid integer, fieldid integer, value text) FROM csctoss_owner;
GRANT ALL ON FUNCTION rt_field_updater(ticketid integer, fieldid integer, value text) TO csctoss_owner;
GRANT ALL ON FUNCTION rt_field_updater(ticketid integer, fieldid integer, value text) TO postgres;
GRANT ALL ON FUNCTION rt_field_updater(ticketid integer, fieldid integer, value text) TO PUBLIC;


--
-- Name: rt_oss_rma(text, text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION rt_oss_rma(text, text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION rt_oss_rma(text, text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION rt_oss_rma(text, text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION rt_oss_rma(text, text, text) TO postgres;
GRANT ALL ON FUNCTION rt_oss_rma(text, text, text) TO PUBLIC;


--
-- Name: rt_oss_rma(text, text, text, boolean); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION rt_oss_rma(text, text, text, boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION rt_oss_rma(text, text, text, boolean) FROM csctoss_owner;
GRANT ALL ON FUNCTION rt_oss_rma(text, text, text, boolean) TO csctoss_owner;
GRANT ALL ON FUNCTION rt_oss_rma(text, text, text, boolean) TO postgres;
GRANT ALL ON FUNCTION rt_oss_rma(text, text, text, boolean) TO PUBLIC;


--
-- Name: rt_oss_rma_oss_only(text, text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION rt_oss_rma_oss_only(text, text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION rt_oss_rma_oss_only(text, text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION rt_oss_rma_oss_only(text, text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION rt_oss_rma_oss_only(text, text, text) TO PUBLIC;
GRANT ALL ON FUNCTION rt_oss_rma_oss_only(text, text, text) TO postgres;


--
-- Name: rt_processing(); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION rt_processing() FROM PUBLIC;
REVOKE ALL ON FUNCTION rt_processing() FROM csctoss_owner;
GRANT ALL ON FUNCTION rt_processing() TO csctoss_owner;
GRANT ALL ON FUNCTION rt_processing() TO postgres;
GRANT ALL ON FUNCTION rt_processing() TO PUBLIC;


--
-- Name: set_encrypt_key(integer, text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION set_encrypt_key(integer, text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION set_encrypt_key(integer, text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION set_encrypt_key(integer, text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION set_encrypt_key(integer, text, text) TO csctoss_reader;
GRANT ALL ON FUNCTION set_encrypt_key(integer, text, text) TO radius_writer;
GRANT ALL ON FUNCTION set_encrypt_key(integer, text, text) TO PUBLIC;


--
-- Name: set_encrypt_key(text, text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION set_encrypt_key(text, text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION set_encrypt_key(text, text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION set_encrypt_key(text, text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION set_encrypt_key(text, text, text) TO csctoss_reader;
GRANT ALL ON FUNCTION set_encrypt_key(text, text, text) TO radius_writer;
GRANT ALL ON FUNCTION set_encrypt_key(text, text, text) TO PUBLIC;


--
-- Name: set_plan_acct_start_date(); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION set_plan_acct_start_date() FROM PUBLIC;
REVOKE ALL ON FUNCTION set_plan_acct_start_date() FROM csctoss_owner;
GRANT ALL ON FUNCTION set_plan_acct_start_date() TO csctoss_owner;


--
-- Name: smrac_loader(); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION smrac_loader() FROM PUBLIC;
REVOKE ALL ON FUNCTION smrac_loader() FROM slony;
GRANT ALL ON FUNCTION smrac_loader() TO slony;


--
-- Name: soup_sn_derive_bent(); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION soup_sn_derive_bent() FROM PUBLIC;
REVOKE ALL ON FUNCTION soup_sn_derive_bent() FROM slony;
GRANT ALL ON FUNCTION soup_sn_derive_bent() TO slony;


--
-- Name: soup_update_from_oss(); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION soup_update_from_oss() FROM PUBLIC;
REVOKE ALL ON FUNCTION soup_update_from_oss() FROM slony;
GRANT ALL ON FUNCTION soup_update_from_oss() TO slony;
GRANT ALL ON FUNCTION soup_update_from_oss() TO PUBLIC;


--
-- Name: sprint_roaming_by_date_range(date, date); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION sprint_roaming_by_date_range(date, date) FROM PUBLIC;
REVOKE ALL ON FUNCTION sprint_roaming_by_date_range(date, date) FROM csctoss_owner;
GRANT ALL ON FUNCTION sprint_roaming_by_date_range(date, date) TO csctoss_owner;
GRANT ALL ON FUNCTION sprint_roaming_by_date_range(date, date) TO radius_writer;
GRANT ALL ON FUNCTION sprint_roaming_by_date_range(date, date) TO csctoss_reader;
GRANT ALL ON FUNCTION sprint_roaming_by_date_range(date, date) TO PUBLIC;


--
-- Name: sprint_time_left(text); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION sprint_time_left(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION sprint_time_left(text) FROM slony;
GRANT ALL ON FUNCTION sprint_time_left(text) TO slony;
GRANT ALL ON FUNCTION sprint_time_left(text) TO csctoss_owner;
GRANT ALL ON FUNCTION sprint_time_left(text) TO radius_writer;
GRANT ALL ON FUNCTION sprint_time_left(text) TO alert_writer;
GRANT ALL ON FUNCTION sprint_time_left(text) TO csctoss_reader;


--
-- Name: test_ops_api_line_plan_product_info(text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION test_ops_api_line_plan_product_info(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION test_ops_api_line_plan_product_info(text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION test_ops_api_line_plan_product_info(text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION test_ops_api_line_plan_product_info(text, text) TO postgres;
GRANT ALL ON FUNCTION test_ops_api_line_plan_product_info(text, text) TO csctoss_test;
GRANT ALL ON FUNCTION test_ops_api_line_plan_product_info(text, text) TO csctoss_reader;
GRANT ALL ON FUNCTION test_ops_api_line_plan_product_info(text, text) TO PUBLIC;


--
-- Name: unique_id(integer, text); Type: ACL; Schema: csctoss; Owner: postgres
--

REVOKE ALL ON FUNCTION unique_id(integer, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION unique_id(integer, text) FROM postgres;
GRANT ALL ON FUNCTION unique_id(integer, text) TO postgres;
GRANT ALL ON FUNCTION unique_id(integer, text) TO PUBLIC;


--
-- Name: universal_get_limit_wrapper(text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION universal_get_limit_wrapper(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION universal_get_limit_wrapper(text) FROM csctoss_owner;
GRANT ALL ON FUNCTION universal_get_limit_wrapper(text) TO csctoss_owner;
GRANT ALL ON FUNCTION universal_get_limit_wrapper(text) TO csctoss_reader;
GRANT ALL ON FUNCTION universal_get_limit_wrapper(text) TO get_limit_reader;


--
-- Name: update_unique_identifier_value(integer, text, text, text); Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON FUNCTION update_unique_identifier_value(integer, text, text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION update_unique_identifier_value(integer, text, text, text) FROM csctoss_owner;
GRANT ALL ON FUNCTION update_unique_identifier_value(integer, text, text, text) TO csctoss_owner;
GRANT ALL ON FUNCTION update_unique_identifier_value(integer, text, text, text) TO PUBLIC;


--
-- Name: usergroup_updater(text, character); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION usergroup_updater(text, character) FROM PUBLIC;
REVOKE ALL ON FUNCTION usergroup_updater(text, character) FROM slony;
GRANT ALL ON FUNCTION usergroup_updater(text, character) TO slony;


--
-- Name: username_updater(text, character); Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON FUNCTION username_updater(text, character) FROM PUBLIC;
REVOKE ALL ON FUNCTION username_updater(text, character) FROM slony;
GRANT ALL ON FUNCTION username_updater(text, character) TO slony;


SET search_path = public, pg_catalog;

--
-- Name: dblink_connect_u(text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION dblink_connect_u(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION dblink_connect_u(text) FROM postgres;
GRANT ALL ON FUNCTION dblink_connect_u(text) TO postgres;


--
-- Name: dblink_connect_u(text, text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION dblink_connect_u(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION dblink_connect_u(text, text) FROM postgres;
GRANT ALL ON FUNCTION dblink_connect_u(text, text) TO postgres;


--
-- Name: instr(character varying, character varying); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION instr(character varying, character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION instr(character varying, character varying) FROM postgres;
GRANT ALL ON FUNCTION instr(character varying, character varying) TO postgres;
GRANT ALL ON FUNCTION instr(character varying, character varying) TO PUBLIC;


--
-- Name: instr(character varying, character varying, character varying); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION instr(character varying, character varying, character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION instr(character varying, character varying, character varying) FROM postgres;
GRANT ALL ON FUNCTION instr(character varying, character varying, character varying) TO postgres;
GRANT ALL ON FUNCTION instr(character varying, character varying, character varying) TO PUBLIC;


--
-- Name: instr(character varying, character varying, integer, integer); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION instr(character varying, character varying, integer, integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION instr(character varying, character varying, integer, integer) FROM postgres;
GRANT ALL ON FUNCTION instr(character varying, character varying, integer, integer) TO postgres;
GRANT ALL ON FUNCTION instr(character varying, character varying, integer, integer) TO PUBLIC;


--
-- Name: packet_of_disconnect(text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION packet_of_disconnect(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION packet_of_disconnect(text) FROM postgres;
GRANT ALL ON FUNCTION packet_of_disconnect(text) TO postgres;
GRANT ALL ON FUNCTION packet_of_disconnect(text) TO slony;
GRANT ALL ON FUNCTION packet_of_disconnect(text) TO csctoss_owner;


--
-- Name: plsh_pod(text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION plsh_pod(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION plsh_pod(text) FROM postgres;
GRANT ALL ON FUNCTION plsh_pod(text) TO postgres;
GRANT ALL ON FUNCTION plsh_pod(text) TO slony;


--
-- Name: plsh_pod(text, text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION plsh_pod(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION plsh_pod(text, text) FROM postgres;
GRANT ALL ON FUNCTION plsh_pod(text, text) TO postgres;
GRANT ALL ON FUNCTION plsh_pod(text, text) TO slony;


--
-- Name: plsh_radclient_pod(text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION plsh_radclient_pod(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION plsh_radclient_pod(text) FROM postgres;
GRANT ALL ON FUNCTION plsh_radclient_pod(text) TO postgres;
GRANT ALL ON FUNCTION plsh_radclient_pod(text) TO csctoss_owner;


--
-- Name: plsh_send_email(text, text, text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION plsh_send_email(text, text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION plsh_send_email(text, text, text) FROM postgres;
GRANT ALL ON FUNCTION plsh_send_email(text, text, text) TO postgres;
GRANT ALL ON FUNCTION plsh_send_email(text, text, text) TO csctoss_owner;


--
-- Name: plsh_send_nsca(text, text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION plsh_send_nsca(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION plsh_send_nsca(text, text) FROM postgres;
GRANT ALL ON FUNCTION plsh_send_nsca(text, text) TO postgres;
GRANT ALL ON FUNCTION plsh_send_nsca(text, text) TO csctoss_owner;


--
-- Name: replchk_attribute(text); Type: ACL; Schema: public; Owner: slony
--

REVOKE ALL ON FUNCTION replchk_attribute(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION replchk_attribute(text) FROM slony;
GRANT ALL ON FUNCTION replchk_attribute(text) TO slony;
GRANT ALL ON FUNCTION replchk_attribute(text) TO csctoss_owner;
GRANT ALL ON FUNCTION replchk_attribute(text) TO postgres;


--
-- Name: replchk_attribute_type(text); Type: ACL; Schema: public; Owner: slony
--

REVOKE ALL ON FUNCTION replchk_attribute_type(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION replchk_attribute_type(text) FROM slony;
GRANT ALL ON FUNCTION replchk_attribute_type(text) TO slony;
GRANT ALL ON FUNCTION replchk_attribute_type(text) TO csctoss_owner;
GRANT ALL ON FUNCTION replchk_attribute_type(text) TO postgres;


--
-- Name: replchk_groupname(text); Type: ACL; Schema: public; Owner: slony
--

REVOKE ALL ON FUNCTION replchk_groupname(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION replchk_groupname(text) FROM slony;
GRANT ALL ON FUNCTION replchk_groupname(text) TO slony;
GRANT ALL ON FUNCTION replchk_groupname(text) TO csctoss_owner;
GRANT ALL ON FUNCTION replchk_groupname(text) TO postgres;


--
-- Name: replchk_nas(text); Type: ACL; Schema: public; Owner: slony
--

REVOKE ALL ON FUNCTION replchk_nas(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION replchk_nas(text) FROM slony;
GRANT ALL ON FUNCTION replchk_nas(text) TO slony;
GRANT ALL ON FUNCTION replchk_nas(text) TO csctoss_owner;
GRANT ALL ON FUNCTION replchk_nas(text) TO postgres;


--
-- Name: replchk_radcheck(text); Type: ACL; Schema: public; Owner: slony
--

REVOKE ALL ON FUNCTION replchk_radcheck(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION replchk_radcheck(text) FROM slony;
GRANT ALL ON FUNCTION replchk_radcheck(text) TO slony;
GRANT ALL ON FUNCTION replchk_radcheck(text) TO csctoss_owner;
GRANT ALL ON FUNCTION replchk_radcheck(text) TO postgres;


--
-- Name: replchk_radgroupcheck(text); Type: ACL; Schema: public; Owner: slony
--

REVOKE ALL ON FUNCTION replchk_radgroupcheck(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION replchk_radgroupcheck(text) FROM slony;
GRANT ALL ON FUNCTION replchk_radgroupcheck(text) TO slony;
GRANT ALL ON FUNCTION replchk_radgroupcheck(text) TO csctoss_owner;
GRANT ALL ON FUNCTION replchk_radgroupcheck(text) TO postgres;


--
-- Name: replchk_radgroupreply(text); Type: ACL; Schema: public; Owner: slony
--

REVOKE ALL ON FUNCTION replchk_radgroupreply(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION replchk_radgroupreply(text) FROM slony;
GRANT ALL ON FUNCTION replchk_radgroupreply(text) TO slony;
GRANT ALL ON FUNCTION replchk_radgroupreply(text) TO csctoss_owner;
GRANT ALL ON FUNCTION replchk_radgroupreply(text) TO postgres;


--
-- Name: replchk_radreply(text); Type: ACL; Schema: public; Owner: slony
--

REVOKE ALL ON FUNCTION replchk_radreply(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION replchk_radreply(text) FROM slony;
GRANT ALL ON FUNCTION replchk_radreply(text) TO slony;
GRANT ALL ON FUNCTION replchk_radreply(text) TO csctoss_owner;
GRANT ALL ON FUNCTION replchk_radreply(text) TO postgres;


--
-- Name: replchk_usergroup(text); Type: ACL; Schema: public; Owner: slony
--

REVOKE ALL ON FUNCTION replchk_usergroup(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION replchk_usergroup(text) FROM slony;
GRANT ALL ON FUNCTION replchk_usergroup(text) TO slony;
GRANT ALL ON FUNCTION replchk_usergroup(text) TO csctoss_owner;
GRANT ALL ON FUNCTION replchk_usergroup(text) TO postgres;


--
-- Name: replchk_username(text); Type: ACL; Schema: public; Owner: slony
--

REVOKE ALL ON FUNCTION replchk_username(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION replchk_username(text) FROM slony;
GRANT ALL ON FUNCTION replchk_username(text) TO slony;
GRANT ALL ON FUNCTION replchk_username(text) TO csctoss_owner;
GRANT ALL ON FUNCTION replchk_username(text) TO postgres;


--
-- Name: sprint_pod_expired(); Type: ACL; Schema: public; Owner: slony
--

REVOKE ALL ON FUNCTION sprint_pod_expired() FROM PUBLIC;
REVOKE ALL ON FUNCTION sprint_pod_expired() FROM slony;
GRANT ALL ON FUNCTION sprint_pod_expired() TO slony;
GRANT ALL ON FUNCTION sprint_pod_expired() TO postgres;


SET search_path = carrier, pg_catalog;

--
-- Name: api_activity_log; Type: ACL; Schema: carrier; Owner: carrier_owner
--

REVOKE ALL ON TABLE api_activity_log FROM PUBLIC;
REVOKE ALL ON TABLE api_activity_log FROM carrier_owner;
GRANT ALL ON TABLE api_activity_log TO carrier_owner;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE api_activity_log TO radius_writer;
GRANT SELECT ON TABLE api_activity_log TO csctoss_reader;
GRANT ALL ON TABLE api_activity_log TO csctoss_owner;


--
-- Name: app_config; Type: ACL; Schema: carrier; Owner: carrier_owner
--

REVOKE ALL ON TABLE app_config FROM PUBLIC;
REVOKE ALL ON TABLE app_config FROM carrier_owner;
GRANT ALL ON TABLE app_config TO carrier_owner;
GRANT SELECT ON TABLE app_config TO csctoss_reader;
GRANT ALL ON TABLE app_config TO csctoss_owner;


--
-- Name: request; Type: ACL; Schema: carrier; Owner: carrier_owner
--

REVOKE ALL ON TABLE request FROM PUBLIC;
REVOKE ALL ON TABLE request FROM carrier_owner;
GRANT ALL ON TABLE request TO carrier_owner;
GRANT SELECT ON TABLE request TO csctoss_reader;
GRANT ALL ON TABLE request TO csctoss_owner;


--
-- Name: request_carrier; Type: ACL; Schema: carrier; Owner: carrier_owner
--

REVOKE ALL ON TABLE request_carrier FROM PUBLIC;
REVOKE ALL ON TABLE request_carrier FROM carrier_owner;
GRANT ALL ON TABLE request_carrier TO carrier_owner;
GRANT SELECT ON TABLE request_carrier TO csctoss_reader;
GRANT ALL ON TABLE request_carrier TO csctoss_owner;


--
-- Name: request_status; Type: ACL; Schema: carrier; Owner: carrier_owner
--

REVOKE ALL ON TABLE request_status FROM PUBLIC;
REVOKE ALL ON TABLE request_status FROM carrier_owner;
GRANT ALL ON TABLE request_status TO carrier_owner;
GRANT SELECT ON TABLE request_status TO csctoss_reader;
GRANT ALL ON TABLE request_status TO csctoss_owner;


--
-- Name: request_type; Type: ACL; Schema: carrier; Owner: carrier_owner
--

REVOKE ALL ON TABLE request_type FROM PUBLIC;
REVOKE ALL ON TABLE request_type FROM carrier_owner;
GRANT ALL ON TABLE request_type TO carrier_owner;
GRANT SELECT ON TABLE request_type TO csctoss_reader;
GRANT ALL ON TABLE request_type TO csctoss_owner;


SET search_path = csctoss, pg_catalog;

--
-- Name: billing_entity; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE billing_entity FROM PUBLIC;
REVOKE ALL ON TABLE billing_entity FROM csctoss_owner;
GRANT ALL ON TABLE billing_entity TO csctoss_owner;
GRANT SELECT ON TABLE billing_entity TO csctoss_reader;
GRANT SELECT,INSERT,UPDATE ON TABLE billing_entity TO radius_writer;
GRANT SELECT ON TABLE billing_entity TO get_limit_reader;


--
-- Name: equipment; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE equipment FROM PUBLIC;
REVOKE ALL ON TABLE equipment FROM csctoss_owner;
GRANT ALL ON TABLE equipment TO csctoss_owner;
GRANT SELECT ON TABLE equipment TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE equipment TO radius_writer;
GRANT SELECT ON TABLE equipment TO password_reset;


--
-- Name: equipment_model; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE equipment_model FROM PUBLIC;
REVOKE ALL ON TABLE equipment_model FROM csctoss_owner;
GRANT ALL ON TABLE equipment_model TO csctoss_owner;
GRANT SELECT ON TABLE equipment_model TO csctoss_reader;
GRANT ALL ON TABLE equipment_model TO radius_writer;
GRANT SELECT ON TABLE equipment_model TO password_reset;


--
-- Name: line; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE line FROM PUBLIC;
REVOKE ALL ON TABLE line FROM csctoss_owner;
GRANT ALL ON TABLE line TO csctoss_owner;
GRANT SELECT ON TABLE line TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE line TO radius_writer;
GRANT SELECT ON TABLE line TO get_limit_reader;
GRANT SELECT ON TABLE line TO password_reset;


--
-- Name: line_equipment; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE line_equipment FROM PUBLIC;
REVOKE ALL ON TABLE line_equipment FROM csctoss_owner;
GRANT ALL ON TABLE line_equipment TO csctoss_owner;
GRANT SELECT ON TABLE line_equipment TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE line_equipment TO radius_writer;
GRANT SELECT ON TABLE line_equipment TO password_reset;


--
-- Name: radreply; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE radreply FROM PUBLIC;
REVOKE ALL ON TABLE radreply FROM csctoss_owner;
GRANT ALL ON TABLE radreply TO csctoss_owner;
GRANT SELECT ON TABLE radreply TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE radreply TO radius_writer;
GRANT SELECT ON TABLE radreply TO get_limit_reader;
GRANT SELECT ON TABLE radreply TO slony;
GRANT SELECT ON TABLE radreply TO password_reset;


--
-- Name: unique_identifier; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE unique_identifier FROM PUBLIC;
REVOKE ALL ON TABLE unique_identifier FROM csctoss_owner;
GRANT ALL ON TABLE unique_identifier TO csctoss_owner;
GRANT SELECT ON TABLE unique_identifier TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE unique_identifier TO radius_writer;
GRANT ALL ON TABLE unique_identifier TO postgres;
GRANT SELECT ON TABLE unique_identifier TO password_reset;


--
-- Name: usergroup; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE usergroup FROM PUBLIC;
REVOKE ALL ON TABLE usergroup FROM csctoss_owner;
GRANT ALL ON TABLE usergroup TO csctoss_owner;
GRANT SELECT ON TABLE usergroup TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE usergroup TO radius_writer;
GRANT SELECT ON TABLE usergroup TO slony;


--
-- Name: address; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE address FROM PUBLIC;
REVOKE ALL ON TABLE address FROM csctoss_owner;
GRANT ALL ON TABLE address TO csctoss_owner;
GRANT SELECT ON TABLE address TO csctoss_reader;
GRANT SELECT,INSERT,UPDATE ON TABLE address TO radius_writer;


--
-- Name: address_address_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE address_address_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE address_address_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE address_address_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE address_address_id_seq TO radius_writer;


--
-- Name: address_type; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE address_type FROM PUBLIC;
REVOKE ALL ON TABLE address_type FROM csctoss_owner;
GRANT ALL ON TABLE address_type TO csctoss_owner;
GRANT SELECT ON TABLE address_type TO csctoss_reader;
GRANT SELECT ON TABLE address_type TO radius_writer;


--
-- Name: alert_activity; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE alert_activity FROM PUBLIC;
REVOKE ALL ON TABLE alert_activity FROM csctoss_owner;
GRANT ALL ON TABLE alert_activity TO csctoss_owner;
GRANT SELECT ON TABLE alert_activity TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE alert_activity TO radius_writer;
GRANT SELECT ON TABLE alert_activity TO alert_writer;


--
-- Name: alert_activity_alert_activity_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE alert_activity_alert_activity_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE alert_activity_alert_activity_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE alert_activity_alert_activity_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE alert_activity_alert_activity_id_seq TO radius_writer;


--
-- Name: alert_definition; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE alert_definition FROM PUBLIC;
REVOKE ALL ON TABLE alert_definition FROM csctoss_owner;
GRANT ALL ON TABLE alert_definition TO csctoss_owner;
GRANT SELECT ON TABLE alert_definition TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE alert_definition TO radius_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE alert_definition TO alert_writer;


--
-- Name: alert_definition_alert_definition_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE alert_definition_alert_definition_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE alert_definition_alert_definition_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE alert_definition_alert_definition_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE alert_definition_alert_definition_id_seq TO radius_writer;
GRANT SELECT,UPDATE ON SEQUENCE alert_definition_alert_definition_id_seq TO alert_writer;


--
-- Name: alert_definition_contact; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE alert_definition_contact FROM PUBLIC;
REVOKE ALL ON TABLE alert_definition_contact FROM csctoss_owner;
GRANT ALL ON TABLE alert_definition_contact TO csctoss_owner;
GRANT SELECT ON TABLE alert_definition_contact TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE alert_definition_contact TO radius_writer;
GRANT SELECT ON TABLE alert_definition_contact TO alert_writer;


--
-- Name: alert_definition_snmp; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE alert_definition_snmp FROM PUBLIC;
REVOKE ALL ON TABLE alert_definition_snmp FROM csctoss_owner;
GRANT ALL ON TABLE alert_definition_snmp TO csctoss_owner;
GRANT SELECT ON TABLE alert_definition_snmp TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE alert_definition_snmp TO radius_writer;
GRANT SELECT ON TABLE alert_definition_snmp TO alert_writer;


--
-- Name: alert_type; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE alert_type FROM PUBLIC;
REVOKE ALL ON TABLE alert_type FROM csctoss_owner;
GRANT ALL ON TABLE alert_type TO csctoss_owner;
GRANT SELECT ON TABLE alert_type TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE alert_type TO radius_writer;
GRANT SELECT ON TABLE alert_type TO alert_writer;


--
-- Name: alert_type_alert_type_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE alert_type_alert_type_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE alert_type_alert_type_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE alert_type_alert_type_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE alert_type_alert_type_id_seq TO radius_writer;


--
-- Name: atm_processor; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE atm_processor FROM PUBLIC;
REVOKE ALL ON TABLE atm_processor FROM csctoss_owner;
GRANT ALL ON TABLE atm_processor TO csctoss_owner;
GRANT SELECT ON TABLE atm_processor TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE atm_processor TO radius_writer;


--
-- Name: attribute; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE attribute FROM PUBLIC;
REVOKE ALL ON TABLE attribute FROM csctoss_owner;
GRANT ALL ON TABLE attribute TO csctoss_owner;
GRANT SELECT ON TABLE attribute TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE attribute TO radius_writer;
GRANT SELECT ON TABLE attribute TO slony;


--
-- Name: attribute_type; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE attribute_type FROM PUBLIC;
REVOKE ALL ON TABLE attribute_type FROM csctoss_owner;
GRANT ALL ON TABLE attribute_type TO csctoss_owner;
GRANT SELECT ON TABLE attribute_type TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE attribute_type TO radius_writer;
GRANT SELECT ON TABLE attribute_type TO slony;


--
-- Name: billing_entity_address; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE billing_entity_address FROM PUBLIC;
REVOKE ALL ON TABLE billing_entity_address FROM csctoss_owner;
GRANT ALL ON TABLE billing_entity_address TO csctoss_owner;
GRANT SELECT ON TABLE billing_entity_address TO csctoss_reader;
GRANT SELECT,INSERT,UPDATE ON TABLE billing_entity_address TO radius_writer;
GRANT SELECT ON TABLE billing_entity_address TO get_limit_reader;


--
-- Name: billing_entity_billing_entity_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE billing_entity_billing_entity_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE billing_entity_billing_entity_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE billing_entity_billing_entity_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE billing_entity_billing_entity_id_seq TO radius_writer;


--
-- Name: billing_entity_download; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE billing_entity_download FROM PUBLIC;
REVOKE ALL ON TABLE billing_entity_download FROM csctoss_owner;
GRANT ALL ON TABLE billing_entity_download TO csctoss_owner;
GRANT SELECT ON TABLE billing_entity_download TO csctoss_reader;
GRANT SELECT ON TABLE billing_entity_download TO radius_writer;


--
-- Name: billing_entity_location_label; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE billing_entity_location_label FROM PUBLIC;
REVOKE ALL ON TABLE billing_entity_location_label FROM csctoss_owner;
GRANT ALL ON TABLE billing_entity_location_label TO csctoss_owner;
GRANT SELECT ON TABLE billing_entity_location_label TO csctoss_reader;
GRANT SELECT,INSERT,UPDATE ON TABLE billing_entity_location_label TO radius_writer;


--
-- Name: bp_aggregate_usage_plan; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_aggregate_usage_plan FROM PUBLIC;
REVOKE ALL ON TABLE bp_aggregate_usage_plan FROM csctoss_owner;
GRANT ALL ON TABLE bp_aggregate_usage_plan TO csctoss_owner;
GRANT SELECT ON TABLE bp_aggregate_usage_plan TO csctoss_reader;
GRANT SELECT ON TABLE bp_aggregate_usage_plan TO radius_writer;


--
-- Name: bp_allotment_adjustment_history; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_allotment_adjustment_history FROM PUBLIC;
REVOKE ALL ON TABLE bp_allotment_adjustment_history FROM csctoss_owner;
GRANT ALL ON TABLE bp_allotment_adjustment_history TO csctoss_owner;
GRANT SELECT ON TABLE bp_allotment_adjustment_history TO csctoss_reader;
GRANT SELECT ON TABLE bp_allotment_adjustment_history TO radius_writer;


--
-- Name: bp_billing_calendar; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_billing_calendar FROM PUBLIC;
REVOKE ALL ON TABLE bp_billing_calendar FROM csctoss_owner;
GRANT ALL ON TABLE bp_billing_calendar TO csctoss_owner;
GRANT SELECT ON TABLE bp_billing_calendar TO csctoss_reader;
GRANT SELECT ON TABLE bp_billing_calendar TO radius_writer;


--
-- Name: bp_billing_period; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_billing_period FROM PUBLIC;
REVOKE ALL ON TABLE bp_billing_period FROM csctoss_owner;
GRANT ALL ON TABLE bp_billing_period TO csctoss_owner;
GRANT SELECT ON TABLE bp_billing_period TO csctoss_reader;
GRANT SELECT ON TABLE bp_billing_period TO radius_writer;


--
-- Name: bp_billing_charge; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_billing_charge FROM PUBLIC;
REVOKE ALL ON TABLE bp_billing_charge FROM csctoss_owner;
GRANT ALL ON TABLE bp_billing_charge TO csctoss_owner;
GRANT SELECT ON TABLE bp_billing_charge TO csctoss_reader;
GRANT SELECT ON TABLE bp_billing_charge TO radius_writer;


--
-- Name: bp_billing_charge_discount; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_billing_charge_discount FROM PUBLIC;
REVOKE ALL ON TABLE bp_billing_charge_discount FROM csctoss_owner;
GRANT ALL ON TABLE bp_billing_charge_discount TO csctoss_owner;
GRANT SELECT ON TABLE bp_billing_charge_discount TO csctoss_reader;
GRANT SELECT ON TABLE bp_billing_charge_discount TO radius_writer;


--
-- Name: bp_billing_charge_onetime; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_billing_charge_onetime FROM PUBLIC;
REVOKE ALL ON TABLE bp_billing_charge_onetime FROM csctoss_owner;
GRANT ALL ON TABLE bp_billing_charge_onetime TO csctoss_owner;
GRANT SELECT ON TABLE bp_billing_charge_onetime TO csctoss_reader;
GRANT SELECT ON TABLE bp_billing_charge_onetime TO radius_writer;


--
-- Name: bp_billing_charge_static; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_billing_charge_static FROM PUBLIC;
REVOKE ALL ON TABLE bp_billing_charge_static FROM csctoss_owner;
GRANT ALL ON TABLE bp_billing_charge_static TO csctoss_owner;
GRANT SELECT ON TABLE bp_billing_charge_static TO csctoss_reader;
GRANT SELECT ON TABLE bp_billing_charge_static TO radius_writer;


--
-- Name: bp_billing_charge_type; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_billing_charge_type FROM PUBLIC;
REVOKE ALL ON TABLE bp_billing_charge_type FROM csctoss_owner;
GRANT ALL ON TABLE bp_billing_charge_type TO csctoss_owner;
GRANT SELECT ON TABLE bp_billing_charge_type TO csctoss_reader;
GRANT SELECT ON TABLE bp_billing_charge_type TO radius_writer;


--
-- Name: bp_billing_charge_unit; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_billing_charge_unit FROM PUBLIC;
REVOKE ALL ON TABLE bp_billing_charge_unit FROM csctoss_owner;
GRANT ALL ON TABLE bp_billing_charge_unit TO csctoss_owner;
GRANT SELECT ON TABLE bp_billing_charge_unit TO csctoss_reader;
GRANT SELECT ON TABLE bp_billing_charge_unit TO radius_writer;


--
-- Name: bp_billing_charge_usage; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_billing_charge_usage FROM PUBLIC;
REVOKE ALL ON TABLE bp_billing_charge_usage FROM csctoss_owner;
GRANT ALL ON TABLE bp_billing_charge_usage TO csctoss_owner;
GRANT SELECT ON TABLE bp_billing_charge_usage TO csctoss_reader;
GRANT SELECT ON TABLE bp_billing_charge_usage TO radius_writer;


--
-- Name: bp_master_billing_plan; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_master_billing_plan FROM PUBLIC;
REVOKE ALL ON TABLE bp_master_billing_plan FROM csctoss_owner;
GRANT ALL ON TABLE bp_master_billing_plan TO csctoss_owner;
GRANT SELECT ON TABLE bp_master_billing_plan TO csctoss_reader;
GRANT SELECT ON TABLE bp_master_billing_plan TO radius_writer;


--
-- Name: bp_billing_discount_type; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_billing_discount_type FROM PUBLIC;
REVOKE ALL ON TABLE bp_billing_discount_type FROM csctoss_owner;
GRANT ALL ON TABLE bp_billing_discount_type TO csctoss_owner;
GRANT SELECT ON TABLE bp_billing_discount_type TO csctoss_reader;
GRANT SELECT ON TABLE bp_billing_discount_type TO radius_writer;


--
-- Name: bp_billing_entity_preferences; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_billing_entity_preferences FROM PUBLIC;
REVOKE ALL ON TABLE bp_billing_entity_preferences FROM csctoss_owner;
GRANT ALL ON TABLE bp_billing_entity_preferences TO csctoss_owner;
GRANT SELECT ON TABLE bp_billing_entity_preferences TO csctoss_reader;
GRANT SELECT ON TABLE bp_billing_entity_preferences TO radius_writer;


--
-- Name: bp_billing_equipment_assignment; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_billing_equipment_assignment FROM PUBLIC;
REVOKE ALL ON TABLE bp_billing_equipment_assignment FROM csctoss_owner;
GRANT ALL ON TABLE bp_billing_equipment_assignment TO csctoss_owner;
GRANT SELECT ON TABLE bp_billing_equipment_assignment TO csctoss_reader;
GRANT SELECT ON TABLE bp_billing_equipment_assignment TO radius_writer;


--
-- Name: bp_charge_frequency; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_charge_frequency FROM PUBLIC;
REVOKE ALL ON TABLE bp_charge_frequency FROM csctoss_owner;
GRANT ALL ON TABLE bp_charge_frequency TO csctoss_owner;
GRANT SELECT ON TABLE bp_charge_frequency TO csctoss_reader;
GRANT SELECT ON TABLE bp_charge_frequency TO radius_writer;


--
-- Name: bp_past_due_charge; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_past_due_charge FROM PUBLIC;
REVOKE ALL ON TABLE bp_past_due_charge FROM csctoss_owner;
GRANT ALL ON TABLE bp_past_due_charge TO csctoss_owner;
GRANT SELECT ON TABLE bp_past_due_charge TO csctoss_reader;
GRANT SELECT ON TABLE bp_past_due_charge TO radius_writer;


--
-- Name: bp_period_billing_summary; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_period_billing_summary FROM PUBLIC;
REVOKE ALL ON TABLE bp_period_billing_summary FROM csctoss_owner;
GRANT ALL ON TABLE bp_period_billing_summary TO csctoss_owner;
GRANT SELECT ON TABLE bp_period_billing_summary TO csctoss_reader;
GRANT SELECT ON TABLE bp_period_billing_summary TO radius_writer;


--
-- Name: bp_period_change_summary; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_period_change_summary FROM PUBLIC;
REVOKE ALL ON TABLE bp_period_change_summary FROM csctoss_owner;
GRANT ALL ON TABLE bp_period_change_summary TO csctoss_owner;
GRANT SELECT ON TABLE bp_period_change_summary TO csctoss_reader;
GRANT SELECT ON TABLE bp_period_change_summary TO radius_writer;


--
-- Name: bp_period_charge_summary; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_period_charge_summary FROM PUBLIC;
REVOKE ALL ON TABLE bp_period_charge_summary FROM csctoss_owner;
GRANT ALL ON TABLE bp_period_charge_summary TO csctoss_owner;
GRANT SELECT ON TABLE bp_period_charge_summary TO csctoss_reader;
GRANT SELECT ON TABLE bp_period_charge_summary TO radius_writer;


--
-- Name: bp_period_status_summary; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_period_status_summary FROM PUBLIC;
REVOKE ALL ON TABLE bp_period_status_summary FROM csctoss_owner;
GRANT ALL ON TABLE bp_period_status_summary TO csctoss_owner;
GRANT SELECT ON TABLE bp_period_status_summary TO csctoss_reader;
GRANT SELECT ON TABLE bp_period_status_summary TO radius_writer;


--
-- Name: bp_period_usage_summary; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_period_usage_summary FROM PUBLIC;
REVOKE ALL ON TABLE bp_period_usage_summary FROM csctoss_owner;
GRANT ALL ON TABLE bp_period_usage_summary TO csctoss_owner;
GRANT SELECT ON TABLE bp_period_usage_summary TO csctoss_reader;
GRANT SELECT ON TABLE bp_period_usage_summary TO radius_writer;


--
-- Name: bp_usage_allotment; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE bp_usage_allotment FROM PUBLIC;
REVOKE ALL ON TABLE bp_usage_allotment FROM csctoss_owner;
GRANT ALL ON TABLE bp_usage_allotment TO csctoss_owner;
GRANT SELECT ON TABLE bp_usage_allotment TO csctoss_reader;
GRANT SELECT ON TABLE bp_usage_allotment TO radius_writer;


--
-- Name: broadcast_message; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE broadcast_message FROM PUBLIC;
REVOKE ALL ON TABLE broadcast_message FROM csctoss_owner;
GRANT ALL ON TABLE broadcast_message TO csctoss_owner;
GRANT SELECT ON TABLE broadcast_message TO csctoss_reader;
GRANT SELECT ON TABLE broadcast_message TO radius_writer;


--
-- Name: broadcast_message_level; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE broadcast_message_level FROM PUBLIC;
REVOKE ALL ON TABLE broadcast_message_level FROM csctoss_owner;
GRANT ALL ON TABLE broadcast_message_level TO csctoss_owner;
GRANT SELECT ON TABLE broadcast_message_level TO csctoss_reader;
GRANT SELECT ON TABLE broadcast_message_level TO radius_writer;


--
-- Name: broadcast_message_type; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE broadcast_message_type FROM PUBLIC;
REVOKE ALL ON TABLE broadcast_message_type FROM csctoss_owner;
GRANT ALL ON TABLE broadcast_message_type TO csctoss_owner;
GRANT SELECT ON TABLE broadcast_message_type TO csctoss_reader;
GRANT SELECT ON TABLE broadcast_message_type TO radius_writer;


--
-- Name: plan; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE plan FROM PUBLIC;
REVOKE ALL ON TABLE plan FROM csctoss_owner;
GRANT ALL ON TABLE plan TO csctoss_owner;
GRANT SELECT ON TABLE plan TO csctoss_reader;
GRANT SELECT,INSERT,UPDATE ON TABLE plan TO radius_writer;
GRANT SELECT ON TABLE plan TO get_limit_reader;


--
-- Name: product; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE product FROM PUBLIC;
REVOKE ALL ON TABLE product FROM csctoss_owner;
GRANT ALL ON TABLE product TO csctoss_owner;
GRANT SELECT ON TABLE product TO csctoss_reader;
GRANT SELECT ON TABLE product TO radius_writer;
GRANT SELECT ON TABLE product TO get_limit_reader;


--
-- Name: carrier; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE carrier FROM PUBLIC;
REVOKE ALL ON TABLE carrier FROM csctoss_owner;
GRANT ALL ON TABLE carrier TO csctoss_owner;
GRANT SELECT ON TABLE carrier TO csctoss_reader;
GRANT SELECT ON TABLE carrier TO radius_writer;


--
-- Name: carrier_api_activity_log; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE carrier_api_activity_log FROM PUBLIC;
REVOKE ALL ON TABLE carrier_api_activity_log FROM csctoss_owner;
GRANT ALL ON TABLE carrier_api_activity_log TO csctoss_owner;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE carrier_api_activity_log TO radius_writer;


--
-- Name: change_log; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE change_log FROM PUBLIC;
REVOKE ALL ON TABLE change_log FROM csctoss_owner;
GRANT ALL ON TABLE change_log TO csctoss_owner;
GRANT SELECT ON TABLE change_log TO csctoss_reader;
GRANT SELECT ON TABLE change_log TO radius_writer;


--
-- Name: contact; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE contact FROM PUBLIC;
REVOKE ALL ON TABLE contact FROM csctoss_owner;
GRANT ALL ON TABLE contact TO csctoss_owner;
GRANT SELECT ON TABLE contact TO csctoss_reader;
GRANT SELECT ON TABLE contact TO radius_writer;


--
-- Name: contact_address; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE contact_address FROM PUBLIC;
REVOKE ALL ON TABLE contact_address FROM csctoss_owner;
GRANT ALL ON TABLE contact_address TO csctoss_owner;
GRANT SELECT ON TABLE contact_address TO csctoss_reader;
GRANT SELECT ON TABLE contact_address TO radius_writer;


--
-- Name: contact_level; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE contact_level FROM PUBLIC;
REVOKE ALL ON TABLE contact_level FROM csctoss_owner;
GRANT ALL ON TABLE contact_level TO csctoss_owner;
GRANT SELECT ON TABLE contact_level TO csctoss_reader;
GRANT SELECT ON TABLE contact_level TO radius_writer;


--
-- Name: contact_type; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE contact_type FROM PUBLIC;
REVOKE ALL ON TABLE contact_type FROM csctoss_owner;
GRANT ALL ON TABLE contact_type TO csctoss_owner;
GRANT SELECT ON TABLE contact_type TO csctoss_reader;
GRANT SELECT ON TABLE contact_type TO radius_writer;


--
-- Name: currency; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE currency FROM PUBLIC;
REVOKE ALL ON TABLE currency FROM csctoss_owner;
GRANT ALL ON TABLE currency TO csctoss_owner;
GRANT SELECT ON TABLE currency TO csctoss_reader;
GRANT SELECT ON TABLE currency TO radius_writer;


--
-- Name: download_file_type; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE download_file_type FROM PUBLIC;
REVOKE ALL ON TABLE download_file_type FROM csctoss_owner;
GRANT ALL ON TABLE download_file_type TO csctoss_owner;
GRANT SELECT ON TABLE download_file_type TO csctoss_reader;
GRANT SELECT ON TABLE download_file_type TO radius_writer;


--
-- Name: equipment_credential; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE equipment_credential FROM PUBLIC;
REVOKE ALL ON TABLE equipment_credential FROM csctoss_owner;
GRANT ALL ON TABLE equipment_credential TO csctoss_owner;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE equipment_credential TO password_reset;


--
-- Name: equipment_equipment_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE equipment_equipment_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE equipment_equipment_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE equipment_equipment_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE equipment_equipment_id_seq TO radius_writer;


--
-- Name: equipment_info; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE equipment_info FROM PUBLIC;
REVOKE ALL ON TABLE equipment_info FROM csctoss_owner;
GRANT ALL ON TABLE equipment_info TO csctoss_owner;
GRANT SELECT ON TABLE equipment_info TO csctoss_reader;
GRANT SELECT ON TABLE equipment_info TO radius_writer;


--
-- Name: equipment_info_type; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE equipment_info_type FROM PUBLIC;
REVOKE ALL ON TABLE equipment_info_type FROM csctoss_owner;
GRANT ALL ON TABLE equipment_info_type TO csctoss_owner;
GRANT SELECT ON TABLE equipment_info_type TO csctoss_reader;
GRANT SELECT ON TABLE equipment_info_type TO radius_writer;


--
-- Name: equipment_load; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE equipment_load FROM PUBLIC;
REVOKE ALL ON TABLE equipment_load FROM csctoss_owner;
GRANT ALL ON TABLE equipment_load TO csctoss_owner;
GRANT ALL ON TABLE equipment_load TO radius_writer;


--
-- Name: equipment_model_equipment_model_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE equipment_model_equipment_model_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE equipment_model_equipment_model_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE equipment_model_equipment_model_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE equipment_model_equipment_model_id_seq TO radius_writer;


--
-- Name: equipment_model_status; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE equipment_model_status FROM PUBLIC;
REVOKE ALL ON TABLE equipment_model_status FROM csctoss_owner;
GRANT ALL ON TABLE equipment_model_status TO csctoss_owner;
GRANT SELECT ON TABLE equipment_model_status TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE equipment_model_status TO radius_writer;


--
-- Name: equipment_note; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE equipment_note FROM PUBLIC;
REVOKE ALL ON TABLE equipment_note FROM csctoss_owner;
GRANT ALL ON TABLE equipment_note TO csctoss_owner;
GRANT SELECT ON TABLE equipment_note TO csctoss_reader;
GRANT SELECT ON TABLE equipment_note TO radius_writer;


--
-- Name: equipment_software; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE equipment_software FROM PUBLIC;
REVOKE ALL ON TABLE equipment_software FROM csctoss_owner;
GRANT ALL ON TABLE equipment_software TO csctoss_owner;
GRANT SELECT ON TABLE equipment_software TO csctoss_reader;
GRANT SELECT ON TABLE equipment_software TO radius_writer;


--
-- Name: equipment_status; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE equipment_status FROM PUBLIC;
REVOKE ALL ON TABLE equipment_status FROM csctoss_owner;
GRANT ALL ON TABLE equipment_status TO csctoss_owner;
GRANT SELECT ON TABLE equipment_status TO csctoss_reader;
GRANT SELECT,INSERT,UPDATE ON TABLE equipment_status TO radius_writer;


--
-- Name: equipment_status_type; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE equipment_status_type FROM PUBLIC;
REVOKE ALL ON TABLE equipment_status_type FROM csctoss_owner;
GRANT ALL ON TABLE equipment_status_type TO csctoss_owner;
GRANT SELECT ON TABLE equipment_status_type TO csctoss_reader;
GRANT SELECT ON TABLE equipment_status_type TO radius_writer;


--
-- Name: equipment_type; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE equipment_type FROM PUBLIC;
REVOKE ALL ON TABLE equipment_type FROM csctoss_owner;
GRANT ALL ON TABLE equipment_type TO csctoss_owner;
GRANT SELECT ON TABLE equipment_type TO csctoss_reader;
GRANT SELECT ON TABLE equipment_type TO radius_writer;


--
-- Name: username; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE username FROM PUBLIC;
REVOKE ALL ON TABLE username FROM csctoss_owner;
GRANT ALL ON TABLE username TO csctoss_owner;
GRANT SELECT ON TABLE username TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE username TO radius_writer;
GRANT SELECT ON TABLE username TO slony;


--
-- Name: equipment_summary_vw; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE equipment_summary_vw FROM PUBLIC;
REVOKE ALL ON TABLE equipment_summary_vw FROM csctoss_owner;
GRANT ALL ON TABLE equipment_summary_vw TO csctoss_owner;
GRANT SELECT ON TABLE equipment_summary_vw TO csctoss_reader;
GRANT SELECT ON TABLE equipment_summary_vw TO radius_writer;


--
-- Name: firmware_gmu; Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON TABLE firmware_gmu FROM PUBLIC;
REVOKE ALL ON TABLE firmware_gmu FROM slony;
GRANT ALL ON TABLE firmware_gmu TO slony;
GRANT ALL ON TABLE firmware_gmu TO csctoss_owner;


--
-- Name: firmware_soup; Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON TABLE firmware_soup FROM PUBLIC;
REVOKE ALL ON TABLE firmware_soup FROM slony;
GRANT ALL ON TABLE firmware_soup TO slony;
GRANT ALL ON TABLE firmware_soup TO csctoss_owner;


--
-- Name: groupname; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE groupname FROM PUBLIC;
REVOKE ALL ON TABLE groupname FROM csctoss_owner;
GRANT ALL ON TABLE groupname TO csctoss_owner;
GRANT SELECT ON TABLE groupname TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE groupname TO radius_writer;
GRANT SELECT ON TABLE groupname TO slony;


--
-- Name: groupname_default; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE groupname_default FROM PUBLIC;
REVOKE ALL ON TABLE groupname_default FROM csctoss_owner;
GRANT ALL ON TABLE groupname_default TO csctoss_owner;
GRANT SELECT ON TABLE groupname_default TO csctoss_reader;


--
-- Name: line_alert; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE line_alert FROM PUBLIC;
REVOKE ALL ON TABLE line_alert FROM csctoss_owner;
GRANT ALL ON TABLE line_alert TO csctoss_owner;
GRANT SELECT ON TABLE line_alert TO PUBLIC;
GRANT SELECT ON TABLE line_alert TO csctoss_reader;


--
-- Name: line_alert_email; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE line_alert_email FROM PUBLIC;
REVOKE ALL ON TABLE line_alert_email FROM csctoss_owner;
GRANT ALL ON TABLE line_alert_email TO csctoss_owner;
GRANT SELECT ON TABLE line_alert_email TO PUBLIC;
GRANT SELECT ON TABLE line_alert_email TO csctoss_reader;


--
-- Name: line_assignment_type; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE line_assignment_type FROM PUBLIC;
REVOKE ALL ON TABLE line_assignment_type FROM csctoss_owner;
GRANT ALL ON TABLE line_assignment_type TO csctoss_owner;
GRANT SELECT ON TABLE line_assignment_type TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE line_assignment_type TO radius_writer;


--
-- Name: line_equipment_vw; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE line_equipment_vw FROM PUBLIC;
REVOKE ALL ON TABLE line_equipment_vw FROM csctoss_owner;
GRANT ALL ON TABLE line_equipment_vw TO csctoss_owner;
GRANT SELECT ON TABLE line_equipment_vw TO csctoss_reader;
GRANT SELECT ON TABLE line_equipment_vw TO radius_writer;


--
-- Name: line_line_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE line_line_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE line_line_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE line_line_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE line_line_id_seq TO radius_writer;


--
-- Name: line_terminal; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE line_terminal FROM PUBLIC;
REVOKE ALL ON TABLE line_terminal FROM csctoss_owner;
GRANT ALL ON TABLE line_terminal TO csctoss_owner;
GRANT SELECT ON TABLE line_terminal TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE line_terminal TO radius_writer;


--
-- Name: line_usage_day; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE line_usage_day FROM PUBLIC;
REVOKE ALL ON TABLE line_usage_day FROM csctoss_owner;
GRANT ALL ON TABLE line_usage_day TO csctoss_owner;
GRANT SELECT ON TABLE line_usage_day TO csctoss_reader;
GRANT SELECT ON TABLE line_usage_day TO alert_writer;
GRANT SELECT ON TABLE line_usage_day TO radius_writer;


--
-- Name: line_usage_day_history; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE line_usage_day_history FROM PUBLIC;
REVOKE ALL ON TABLE line_usage_day_history FROM csctoss_owner;
GRANT ALL ON TABLE line_usage_day_history TO csctoss_owner;
GRANT SELECT ON TABLE line_usage_day_history TO csctoss_reader;
GRANT SELECT ON TABLE line_usage_day_history TO alert_writer;
GRANT SELECT ON TABLE line_usage_day_history TO radius_writer;


--
-- Name: line_usage_month; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE line_usage_month FROM PUBLIC;
REVOKE ALL ON TABLE line_usage_month FROM csctoss_owner;
GRANT ALL ON TABLE line_usage_month TO csctoss_owner;
GRANT SELECT ON TABLE line_usage_month TO csctoss_reader;
GRANT SELECT ON TABLE line_usage_month TO alert_writer;
GRANT SELECT ON TABLE line_usage_month TO radius_writer;


--
-- Name: line_usage_overage_calc; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE line_usage_overage_calc FROM PUBLIC;
REVOKE ALL ON TABLE line_usage_overage_calc FROM csctoss_owner;
GRANT ALL ON TABLE line_usage_overage_calc TO csctoss_owner;
GRANT SELECT ON TABLE line_usage_overage_calc TO csctoss_reader;
GRANT SELECT ON TABLE line_usage_overage_calc TO alert_writer;
GRANT SELECT ON TABLE line_usage_overage_calc TO radius_writer;


--
-- Name: lns_lookup; Type: ACL; Schema: csctoss; Owner: postgres
--

REVOKE ALL ON TABLE lns_lookup FROM PUBLIC;
REVOKE ALL ON TABLE lns_lookup FROM postgres;
GRANT ALL ON TABLE lns_lookup TO postgres;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE lns_lookup TO csctoss_owner;
GRANT SELECT ON TABLE lns_lookup TO csctoss_reader;


--
-- Name: location_label_type; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE location_label_type FROM PUBLIC;
REVOKE ALL ON TABLE location_label_type FROM csctoss_owner;
GRANT ALL ON TABLE location_label_type TO csctoss_owner;
GRANT SELECT ON TABLE location_label_type TO csctoss_reader;
GRANT SELECT ON TABLE location_label_type TO radius_writer;


--
-- Name: login_tracking; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE login_tracking FROM PUBLIC;
REVOKE ALL ON TABLE login_tracking FROM csctoss_owner;
GRANT ALL ON TABLE login_tracking TO csctoss_owner;
GRANT SELECT ON TABLE login_tracking TO radius_writer;
GRANT SELECT ON TABLE login_tracking TO csctoss_reader;


--
-- Name: master_radacct; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE master_radacct FROM PUBLIC;
REVOKE ALL ON TABLE master_radacct FROM csctoss_owner;
GRANT ALL ON TABLE master_radacct TO csctoss_owner;
GRANT SELECT ON TABLE master_radacct TO csctoss_reader;
GRANT SELECT ON TABLE master_radacct TO radius_writer;


--
-- Name: master_radpostauth; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE master_radpostauth FROM PUBLIC;
REVOKE ALL ON TABLE master_radpostauth FROM csctoss_owner;
GRANT ALL ON TABLE master_radpostauth TO csctoss_owner;
GRANT SELECT ON TABLE master_radpostauth TO csctoss_reader;
GRANT SELECT ON TABLE master_radpostauth TO radius_writer;


--
-- Name: mrac_load; Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON TABLE mrac_load FROM PUBLIC;
REVOKE ALL ON TABLE mrac_load FROM slony;
GRANT ALL ON TABLE mrac_load TO slony;


--
-- Name: mrad_duplicate; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE mrad_duplicate FROM PUBLIC;
REVOKE ALL ON TABLE mrad_duplicate FROM csctoss_owner;
GRANT ALL ON TABLE mrad_duplicate TO csctoss_owner;
GRANT SELECT ON TABLE mrad_duplicate TO csctoss_reader;
GRANT SELECT ON TABLE mrad_duplicate TO alert_writer;
GRANT SELECT ON TABLE mrad_duplicate TO radius_writer;


--
-- Name: nas; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE nas FROM PUBLIC;
REVOKE ALL ON TABLE nas FROM csctoss_owner;
GRANT ALL ON TABLE nas TO csctoss_owner;
GRANT SELECT ON TABLE nas TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE nas TO radius_writer;
GRANT SELECT ON TABLE nas TO slony;


--
-- Name: nas_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE nas_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE nas_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE nas_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE nas_id_seq TO radius_writer;


--
-- Name: oss_sync_ip_activity_vw; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE oss_sync_ip_activity_vw FROM PUBLIC;
REVOKE ALL ON TABLE oss_sync_ip_activity_vw FROM csctoss_owner;
GRANT ALL ON TABLE oss_sync_ip_activity_vw TO csctoss_owner;
GRANT SELECT ON TABLE oss_sync_ip_activity_vw TO radius_writer;
GRANT SELECT ON TABLE oss_sync_ip_activity_vw TO alert_writer;
GRANT SELECT ON TABLE oss_sync_ip_activity_vw TO csctoss_reader;


--
-- Name: oss_sync_line_mrac_vw; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE oss_sync_line_mrac_vw FROM PUBLIC;
REVOKE ALL ON TABLE oss_sync_line_mrac_vw FROM csctoss_owner;
GRANT ALL ON TABLE oss_sync_line_mrac_vw TO csctoss_owner;
GRANT SELECT ON TABLE oss_sync_line_mrac_vw TO radius_writer;
GRANT SELECT ON TABLE oss_sync_line_mrac_vw TO alert_writer;
GRANT SELECT ON TABLE oss_sync_line_mrac_vw TO csctoss_reader;


--
-- Name: parser_log; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE parser_log FROM PUBLIC;
REVOKE ALL ON TABLE parser_log FROM csctoss_owner;
GRANT ALL ON TABLE parser_log TO csctoss_owner;
GRANT SELECT ON TABLE parser_log TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE parser_log TO radius_writer;
GRANT SELECT ON TABLE parser_log TO alert_writer;


--
-- Name: plan_log; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE plan_log FROM PUBLIC;
REVOKE ALL ON TABLE plan_log FROM csctoss_owner;
GRANT ALL ON TABLE plan_log TO csctoss_owner;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE plan_log TO radius_writer;


--
-- Name: plan_plan_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE plan_plan_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE plan_plan_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE plan_plan_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE plan_plan_id_seq TO radius_writer;


--
-- Name: plan_type; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE plan_type FROM PUBLIC;
REVOKE ALL ON TABLE plan_type FROM csctoss_owner;
GRANT ALL ON TABLE plan_type TO csctoss_owner;
GRANT SELECT ON TABLE plan_type TO csctoss_reader;
GRANT SELECT ON TABLE plan_type TO radius_writer;


--
-- Name: soup_cellsignal; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE soup_cellsignal FROM PUBLIC;
REVOKE ALL ON TABLE soup_cellsignal FROM csctoss_owner;
GRANT ALL ON TABLE soup_cellsignal TO csctoss_owner;
GRANT SELECT ON TABLE soup_cellsignal TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE soup_cellsignal TO radius_writer;


--
-- Name: portal_properties; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE portal_properties FROM PUBLIC;
REVOKE ALL ON TABLE portal_properties FROM csctoss_owner;
GRANT ALL ON TABLE portal_properties TO csctoss_owner;
GRANT SELECT ON TABLE portal_properties TO csctoss_reader;
GRANT SELECT ON TABLE portal_properties TO radius_writer;


--
-- Name: product_overage_threshold; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE product_overage_threshold FROM PUBLIC;
REVOKE ALL ON TABLE product_overage_threshold FROM csctoss_owner;
GRANT ALL ON TABLE product_overage_threshold TO csctoss_owner;
GRANT SELECT ON TABLE product_overage_threshold TO csctoss_reader;


--
-- Name: product_overage_threshold_vw; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE product_overage_threshold_vw FROM PUBLIC;
REVOKE ALL ON TABLE product_overage_threshold_vw FROM csctoss_owner;
GRANT ALL ON TABLE product_overage_threshold_vw TO csctoss_owner;
GRANT SELECT ON TABLE product_overage_threshold_vw TO csctoss_reader;


--
-- Name: purchase_log; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE purchase_log FROM PUBLIC;
REVOKE ALL ON TABLE purchase_log FROM csctoss_owner;
GRANT ALL ON TABLE purchase_log TO csctoss_owner;
GRANT SELECT ON TABLE purchase_log TO csctoss_reader;


--
-- Name: radcheck; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE radcheck FROM PUBLIC;
REVOKE ALL ON TABLE radcheck FROM csctoss_owner;
GRANT ALL ON TABLE radcheck TO csctoss_owner;
GRANT SELECT ON TABLE radcheck TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE radcheck TO radius_writer;
GRANT SELECT ON TABLE radcheck TO slony;


--
-- Name: radcheck_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE radcheck_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE radcheck_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE radcheck_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE radcheck_id_seq TO radius_writer;


--
-- Name: radgroupcheck; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE radgroupcheck FROM PUBLIC;
REVOKE ALL ON TABLE radgroupcheck FROM csctoss_owner;
GRANT ALL ON TABLE radgroupcheck TO csctoss_owner;
GRANT SELECT ON TABLE radgroupcheck TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE radgroupcheck TO radius_writer;
GRANT SELECT ON TABLE radgroupcheck TO slony;


--
-- Name: radgroupcheck_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE radgroupcheck_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE radgroupcheck_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE radgroupcheck_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE radgroupcheck_id_seq TO radius_writer;


--
-- Name: radgroupreply; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE radgroupreply FROM PUBLIC;
REVOKE ALL ON TABLE radgroupreply FROM csctoss_owner;
GRANT ALL ON TABLE radgroupreply TO csctoss_owner;
GRANT SELECT ON TABLE radgroupreply TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE radgroupreply TO radius_writer;
GRANT SELECT ON TABLE radgroupreply TO slony;


--
-- Name: radgroupreply_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE radgroupreply_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE radgroupreply_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE radgroupreply_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE radgroupreply_id_seq TO radius_writer;


--
-- Name: radius_postauth_vw; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE radius_postauth_vw FROM PUBLIC;
REVOKE ALL ON TABLE radius_postauth_vw FROM csctoss_owner;
GRANT ALL ON TABLE radius_postauth_vw TO csctoss_owner;
GRANT SELECT ON TABLE radius_postauth_vw TO csctoss_reader;
GRANT SELECT ON TABLE radius_postauth_vw TO radius_writer;


--
-- Name: radreply_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE radreply_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE radreply_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE radreply_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE radreply_id_seq TO radius_writer;


--
-- Name: receiving_lot; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE receiving_lot FROM PUBLIC;
REVOKE ALL ON TABLE receiving_lot FROM csctoss_owner;
GRANT ALL ON TABLE receiving_lot TO csctoss_owner;
GRANT SELECT ON TABLE receiving_lot TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE receiving_lot TO radius_writer;


--
-- Name: receiving_lot_receiving_lot_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE receiving_lot_receiving_lot_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE receiving_lot_receiving_lot_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE receiving_lot_receiving_lot_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE receiving_lot_receiving_lot_id_seq TO radius_writer;


--
-- Name: replication_failure; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE replication_failure FROM PUBLIC;
REVOKE ALL ON TABLE replication_failure FROM csctoss_owner;
GRANT ALL ON TABLE replication_failure TO csctoss_owner;
GRANT SELECT ON TABLE replication_failure TO csctoss_reader;
GRANT SELECT ON TABLE replication_failure TO radius_writer;


--
-- Name: report; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE report FROM PUBLIC;
REVOKE ALL ON TABLE report FROM csctoss_owner;
GRANT ALL ON TABLE report TO csctoss_owner;
GRANT SELECT ON TABLE report TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE report TO radius_writer;


--
-- Name: security_roles; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE security_roles FROM PUBLIC;
REVOKE ALL ON TABLE security_roles FROM csctoss_owner;
GRANT ALL ON TABLE security_roles TO csctoss_owner;
GRANT SELECT,INSERT,UPDATE ON TABLE security_roles TO radius_writer;
GRANT SELECT ON TABLE security_roles TO csctoss_reader;


--
-- Name: shipment; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE shipment FROM PUBLIC;
REVOKE ALL ON TABLE shipment FROM csctoss_owner;
GRANT ALL ON TABLE shipment TO csctoss_owner;
GRANT SELECT ON TABLE shipment TO csctoss_reader;
GRANT SELECT,INSERT,UPDATE ON TABLE shipment TO radius_writer;


--
-- Name: shipment_equipment; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE shipment_equipment FROM PUBLIC;
REVOKE ALL ON TABLE shipment_equipment FROM csctoss_owner;
GRANT ALL ON TABLE shipment_equipment TO csctoss_owner;
GRANT SELECT ON TABLE shipment_equipment TO csctoss_reader;
GRANT SELECT,INSERT,UPDATE ON TABLE shipment_equipment TO radius_writer;


--
-- Name: shipment_shipment_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE shipment_shipment_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE shipment_shipment_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE shipment_shipment_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE shipment_shipment_id_seq TO radius_writer;


--
-- Name: software; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE software FROM PUBLIC;
REVOKE ALL ON TABLE software FROM csctoss_owner;
GRANT ALL ON TABLE software TO csctoss_owner;
GRANT SELECT ON TABLE software TO csctoss_reader;
GRANT SELECT ON TABLE software TO radius_writer;


--
-- Name: soup_config; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE soup_config FROM PUBLIC;
REVOKE ALL ON TABLE soup_config FROM csctoss_owner;
GRANT ALL ON TABLE soup_config TO csctoss_owner;
GRANT SELECT ON TABLE soup_config TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE soup_config TO radius_writer;


--
-- Name: soup_device; Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON TABLE soup_device FROM PUBLIC;
REVOKE ALL ON TABLE soup_device FROM slony;
GRANT ALL ON TABLE soup_device TO slony;
GRANT SELECT ON TABLE soup_device TO csctoss_owner;
GRANT SELECT ON TABLE soup_device TO csctoss_reader;


--
-- Name: soup_dirnames; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE soup_dirnames FROM PUBLIC;
REVOKE ALL ON TABLE soup_dirnames FROM csctoss_owner;
GRANT ALL ON TABLE soup_dirnames TO csctoss_owner;
GRANT SELECT ON TABLE soup_dirnames TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE soup_dirnames TO radius_writer;


--
-- Name: soup_group_info; Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON TABLE soup_group_info FROM PUBLIC;
REVOKE ALL ON TABLE soup_group_info FROM slony;
GRANT ALL ON TABLE soup_group_info TO slony;
GRANT ALL ON TABLE soup_group_info TO csctoss_owner;
GRANT SELECT ON TABLE soup_group_info TO csctoss_reader;


--
-- Name: soup_update_from_oss; Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON TABLE soup_update_from_oss FROM PUBLIC;
REVOKE ALL ON TABLE soup_update_from_oss FROM slony;
GRANT ALL ON TABLE soup_update_from_oss TO slony;
GRANT ALL ON TABLE soup_update_from_oss TO csctoss_owner;
GRANT SELECT ON TABLE soup_update_from_oss TO csctoss_reader;


--
-- Name: sprint_assignment; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE sprint_assignment FROM PUBLIC;
REVOKE ALL ON TABLE sprint_assignment FROM csctoss_owner;
GRANT ALL ON TABLE sprint_assignment TO csctoss_owner;
GRANT SELECT ON TABLE sprint_assignment TO slony;
GRANT SELECT ON TABLE sprint_assignment TO radius_writer;
GRANT SELECT ON TABLE sprint_assignment TO csctoss_reader;


--
-- Name: sprint_csa; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE sprint_csa FROM PUBLIC;
REVOKE ALL ON TABLE sprint_csa FROM csctoss_owner;
GRANT ALL ON TABLE sprint_csa TO csctoss_owner;
GRANT SELECT ON TABLE sprint_csa TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE sprint_csa TO radius_writer;


--
-- Name: sprint_msl; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE sprint_msl FROM PUBLIC;
REVOKE ALL ON TABLE sprint_msl FROM csctoss_owner;
GRANT ALL ON TABLE sprint_msl TO csctoss_owner;
GRANT SELECT ON TABLE sprint_msl TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE sprint_msl TO radius_writer;


--
-- Name: staff; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE staff FROM PUBLIC;
REVOKE ALL ON TABLE staff FROM csctoss_owner;
GRANT ALL ON TABLE staff TO csctoss_owner;
GRANT SELECT ON TABLE staff TO csctoss_reader;
GRANT SELECT ON TABLE staff TO radius_writer;
GRANT SELECT ON TABLE staff TO csctoss_writer;


--
-- Name: staff_access; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE staff_access FROM PUBLIC;
REVOKE ALL ON TABLE staff_access FROM csctoss_owner;
GRANT ALL ON TABLE staff_access TO csctoss_owner;
GRANT SELECT ON TABLE staff_access TO csctoss_reader;
GRANT SELECT ON TABLE staff_access TO radius_writer;


--
-- Name: state_code; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE state_code FROM PUBLIC;
REVOKE ALL ON TABLE state_code FROM csctoss_owner;
GRANT ALL ON TABLE state_code TO csctoss_owner;
GRANT SELECT ON TABLE state_code TO csctoss_reader;
GRANT SELECT ON TABLE state_code TO radius_writer;


--
-- Name: static_ip_carrier_def; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE static_ip_carrier_def FROM PUBLIC;
REVOKE ALL ON TABLE static_ip_carrier_def FROM csctoss_owner;
GRANT ALL ON TABLE static_ip_carrier_def TO csctoss_owner;
GRANT SELECT ON TABLE static_ip_carrier_def TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE static_ip_carrier_def TO radius_writer;


--
-- Name: static_ip_pool; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE static_ip_pool FROM PUBLIC;
REVOKE ALL ON TABLE static_ip_pool FROM csctoss_owner;
GRANT ALL ON TABLE static_ip_pool TO csctoss_owner;
GRANT SELECT ON TABLE static_ip_pool TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE static_ip_pool TO radius_writer;


--
-- Name: static_ip_reservation; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE static_ip_reservation FROM PUBLIC;
REVOKE ALL ON TABLE static_ip_reservation FROM csctoss_owner;
GRANT ALL ON TABLE static_ip_reservation TO csctoss_owner;
GRANT SELECT ON TABLE static_ip_reservation TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE static_ip_reservation TO radius_writer;


--
-- Name: static_ip_active_reservations_vw; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE static_ip_active_reservations_vw FROM PUBLIC;
REVOKE ALL ON TABLE static_ip_active_reservations_vw FROM csctoss_owner;
GRANT ALL ON TABLE static_ip_active_reservations_vw TO csctoss_owner;


--
-- Name: system_parameter; Type: ACL; Schema: csctoss; Owner: slony
--

REVOKE ALL ON TABLE system_parameter FROM PUBLIC;
REVOKE ALL ON TABLE system_parameter FROM slony;
GRANT ALL ON TABLE system_parameter TO slony;
GRANT SELECT,REFERENCES ON TABLE system_parameter TO csctoss_owner;
GRANT SELECT ON TABLE system_parameter TO csctoss_reader;


--
-- Name: throw_away_minutes; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE throw_away_minutes FROM PUBLIC;
REVOKE ALL ON TABLE throw_away_minutes FROM csctoss_owner;
GRANT ALL ON TABLE throw_away_minutes TO csctoss_owner;
GRANT SELECT ON TABLE throw_away_minutes TO csctoss_reader;
GRANT SELECT ON TABLE throw_away_minutes TO radius_writer;


--
-- Name: timezone; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE timezone FROM PUBLIC;
REVOKE ALL ON TABLE timezone FROM csctoss_owner;
GRANT ALL ON TABLE timezone TO csctoss_owner;
GRANT SELECT ON TABLE timezone TO csctoss_reader;
GRANT SELECT ON TABLE timezone TO radius_writer;


--
-- Name: unique_identifier_history; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE unique_identifier_history FROM PUBLIC;
REVOKE ALL ON TABLE unique_identifier_history FROM csctoss_owner;
GRANT ALL ON TABLE unique_identifier_history TO csctoss_owner;
GRANT SELECT ON TABLE unique_identifier_history TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE unique_identifier_history TO radius_writer;
GRANT ALL ON TABLE unique_identifier_history TO postgres;


--
-- Name: unique_identifier_type; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE unique_identifier_type FROM PUBLIC;
REVOKE ALL ON TABLE unique_identifier_type FROM csctoss_owner;
GRANT ALL ON TABLE unique_identifier_type TO csctoss_owner;
GRANT SELECT ON TABLE unique_identifier_type TO csctoss_reader;
GRANT SELECT ON TABLE unique_identifier_type TO radius_writer;


--
-- Name: usage_overage_calc; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE usage_overage_calc FROM PUBLIC;
REVOKE ALL ON TABLE usage_overage_calc FROM csctoss_owner;
GRANT ALL ON TABLE usage_overage_calc TO csctoss_owner;
GRANT SELECT ON TABLE usage_overage_calc TO csctoss_reader;


--
-- Name: usergroup_error_log; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON TABLE usergroup_error_log FROM PUBLIC;
REVOKE ALL ON TABLE usergroup_error_log FROM csctoss_owner;
GRANT ALL ON TABLE usergroup_error_log TO csctoss_owner;
GRANT SELECT ON TABLE usergroup_error_log TO csctoss_reader;
GRANT SELECT ON TABLE usergroup_error_log TO radius_writer;


--
-- Name: usergroup_id_seq; Type: ACL; Schema: csctoss; Owner: csctoss_owner
--

REVOKE ALL ON SEQUENCE usergroup_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE usergroup_id_seq FROM csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE usergroup_id_seq TO csctoss_owner;
GRANT SELECT,UPDATE ON SEQUENCE usergroup_id_seq TO radius_writer;


SET search_path = invoice, pg_catalog;

--
-- Name: app_config; Type: ACL; Schema: invoice; Owner: invoice_owner
--

REVOKE ALL ON TABLE app_config FROM PUBLIC;
REVOKE ALL ON TABLE app_config FROM invoice_owner;
GRANT ALL ON TABLE app_config TO invoice_owner;
GRANT SELECT ON TABLE app_config TO csctoss_reader;


--
-- Name: billing_entity; Type: ACL; Schema: invoice; Owner: invoice_owner
--

REVOKE ALL ON TABLE billing_entity FROM PUBLIC;
REVOKE ALL ON TABLE billing_entity FROM invoice_owner;
GRANT ALL ON TABLE billing_entity TO invoice_owner;
GRANT SELECT ON TABLE billing_entity TO csctoss_reader;


--
-- Name: file_system; Type: ACL; Schema: invoice; Owner: invoice_owner
--

REVOKE ALL ON TABLE file_system FROM PUBLIC;
REVOKE ALL ON TABLE file_system FROM invoice_owner;
GRANT ALL ON TABLE file_system TO invoice_owner;
GRANT SELECT ON TABLE file_system TO csctoss_reader;


SET search_path = oss_sync, pg_catalog;

--
-- Name: be_vrf; Type: ACL; Schema: oss_sync; Owner: alert_writer
--

REVOKE ALL ON TABLE be_vrf FROM PUBLIC;
REVOKE ALL ON TABLE be_vrf FROM alert_writer;
GRANT ALL ON TABLE be_vrf TO alert_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE be_vrf TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE be_vrf TO radius_writer;


--
-- Name: equipment; Type: ACL; Schema: oss_sync; Owner: alert_writer
--

REVOKE ALL ON TABLE equipment FROM PUBLIC;
REVOKE ALL ON TABLE equipment FROM alert_writer;
GRANT ALL ON TABLE equipment TO alert_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE equipment TO csctoss_reader;


--
-- Name: line; Type: ACL; Schema: oss_sync; Owner: alert_writer
--

REVOKE ALL ON TABLE line FROM PUBLIC;
REVOKE ALL ON TABLE line FROM alert_writer;
GRANT ALL ON TABLE line TO alert_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE line TO csctoss_reader;


--
-- Name: line_equipment; Type: ACL; Schema: oss_sync; Owner: alert_writer
--

REVOKE ALL ON TABLE line_equipment FROM PUBLIC;
REVOKE ALL ON TABLE line_equipment FROM alert_writer;
GRANT ALL ON TABLE line_equipment TO alert_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE line_equipment TO csctoss_reader;


--
-- Name: line_guid; Type: ACL; Schema: oss_sync; Owner: alert_writer
--

REVOKE ALL ON TABLE line_guid FROM PUBLIC;
REVOKE ALL ON TABLE line_guid FROM alert_writer;
GRANT ALL ON TABLE line_guid TO alert_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE line_guid TO csctoss_reader;


--
-- Name: mrad; Type: ACL; Schema: oss_sync; Owner: alert_writer
--

REVOKE ALL ON TABLE mrad FROM PUBLIC;
REVOKE ALL ON TABLE mrad FROM alert_writer;
GRANT ALL ON TABLE mrad TO alert_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE mrad TO csctoss_reader;


--
-- Name: processor; Type: ACL; Schema: oss_sync; Owner: alert_writer
--

REVOKE ALL ON TABLE processor FROM PUBLIC;
REVOKE ALL ON TABLE processor FROM alert_writer;
GRANT ALL ON TABLE processor TO alert_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE processor TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE processor TO radius_writer;


--
-- Name: shipment; Type: ACL; Schema: oss_sync; Owner: alert_writer
--

REVOKE ALL ON TABLE shipment FROM PUBLIC;
REVOKE ALL ON TABLE shipment FROM alert_writer;
GRANT ALL ON TABLE shipment TO alert_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE shipment TO csctoss_reader;


--
-- Name: shipment_equipment; Type: ACL; Schema: oss_sync; Owner: alert_writer
--

REVOKE ALL ON TABLE shipment_equipment FROM PUBLIC;
REVOKE ALL ON TABLE shipment_equipment FROM alert_writer;
GRANT ALL ON TABLE shipment_equipment TO alert_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE shipment_equipment TO csctoss_reader;


--
-- Name: shipment_line; Type: ACL; Schema: oss_sync; Owner: alert_writer
--

REVOKE ALL ON TABLE shipment_line FROM PUBLIC;
REVOKE ALL ON TABLE shipment_line FROM alert_writer;
GRANT ALL ON TABLE shipment_line TO alert_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE shipment_line TO csctoss_reader;


--
-- Name: snesn; Type: ACL; Schema: oss_sync; Owner: alert_writer
--

REVOKE ALL ON TABLE snesn FROM PUBLIC;
REVOKE ALL ON TABLE snesn FROM alert_writer;
GRANT ALL ON TABLE snesn TO alert_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE snesn TO radius_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE snesn TO csctoss_reader;


--
-- Name: snmac; Type: ACL; Schema: oss_sync; Owner: alert_writer
--

REVOKE ALL ON TABLE snmac FROM PUBLIC;
REVOKE ALL ON TABLE snmac FROM alert_writer;
GRANT ALL ON TABLE snmac TO alert_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE snmac TO radius_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE snmac TO csctoss_reader;


--
-- Name: static_ip; Type: ACL; Schema: oss_sync; Owner: alert_writer
--

REVOKE ALL ON TABLE static_ip FROM PUBLIC;
REVOKE ALL ON TABLE static_ip FROM alert_writer;
GRANT ALL ON TABLE static_ip TO alert_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE static_ip TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE static_ip TO radius_writer;


--
-- Name: systech; Type: ACL; Schema: oss_sync; Owner: alert_writer
--

REVOKE ALL ON TABLE systech FROM PUBLIC;
REVOKE ALL ON TABLE systech FROM alert_writer;
GRANT ALL ON TABLE systech TO alert_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE systech TO csctoss_reader;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE systech TO radius_writer;


--
-- Name: usage; Type: ACL; Schema: oss_sync; Owner: alert_writer
--

REVOKE ALL ON TABLE usage FROM PUBLIC;
REVOKE ALL ON TABLE usage FROM alert_writer;
GRANT ALL ON TABLE usage TO alert_writer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE usage TO csctoss_reader;


--
-- PostgreSQL database dump complete
--

